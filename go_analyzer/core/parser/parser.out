Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> package_declaration import global_statement_list
Rule 2     package_declaration -> PACKAGE IDENTIFIER
Rule 3     import -> simple_import
Rule 4     import -> import simple_import
Rule 5     import -> empty
Rule 6     simple_import -> IMPORT STRING
Rule 7     empty -> <empty>
Rule 8     global_statement_list -> global_statement
Rule 9     global_statement_list -> global_statement_list global_statement
Rule 10    global_statement -> global_var_dec
Rule 11    global_statement -> global_const_dec
Rule 12    global_statement -> function_declaration
Rule 13    global_statement -> method_declaration
Rule 14    global_statement -> type_declaration
Rule 15    global_var_dec -> VAR IDENTIFIER type
Rule 16    global_var_dec -> VAR IDENTIFIER type ASSIGN expression
Rule 17    global_var_dec -> VAR IDENTIFIER ASSIGN expression
Rule 18    global_const_dec -> CONST IDENTIFIER type ASSIGN expression
Rule 19    global_const_dec -> CONST IDENTIFIER ASSIGN expression
Rule 20    local_var_dec -> VAR IDENTIFIER type
Rule 21    local_var_dec -> VAR IDENTIFIER type ASSIGN expression
Rule 22    local_var_dec -> VAR IDENTIFIER ASSIGN expression
Rule 23    local_const_dec -> CONST IDENTIFIER type ASSIGN expression
Rule 24    local_const_dec -> CONST IDENTIFIER ASSIGN expression
Rule 25    assignment_compound -> IDENTIFIER operator_assign expression
Rule 26    operator_assign -> PLUS_ASSIGN
Rule 27    operator_assign -> MINUS_ASSIGN
Rule 28    operator_assign -> MULT_ASSIGN
Rule 29    operator_assign -> DIV_ASSIGN
Rule 30    operator_assign -> MOD_ASSIGN
Rule 31    operator_assign -> AND_ASSIGN
Rule 32    operator_assign -> OR_ASSIGN
Rule 33    operator_assign -> XOR_ASSIGN
Rule 34    operator_assign -> LSHIFT_ASSIGN
Rule 35    operator_assign -> RSHIFT_ASSIGN
Rule 36    expression -> expression binary_operator expression
Rule 37    binary_operator -> PLUS
Rule 38    binary_operator -> MINUS
Rule 39    binary_operator -> TIMES
Rule 40    binary_operator -> DIVIDE
Rule 41    binary_operator -> MODULE
Rule 42    binary_operator -> EQ
Rule 43    binary_operator -> NEQ
Rule 44    binary_operator -> LT
Rule 45    binary_operator -> LE
Rule 46    binary_operator -> GT
Rule 47    binary_operator -> GE
Rule 48    binary_operator -> LAND
Rule 49    binary_operator -> LOR
Rule 50    binary_operator -> AND
Rule 51    binary_operator -> OR
Rule 52    binary_operator -> XOR
Rule 53    binary_operator -> AND_NOT
Rule 54    binary_operator -> LSHIFT
Rule 55    binary_operator -> RSHIFT
Rule 56    simple_assignment -> IDENTIFIER ASSIGN expression
Rule 57    type -> primitive_type
Rule 58    type -> slice_type
Rule 59    type -> array_type
Rule 60    type -> map_type
Rule 61    primitive_type -> INT_TYPE
Rule 62    primitive_type -> FLOAT64_TYPE
Rule 63    primitive_type -> STRING_TYPE
Rule 64    primitive_type -> BOOL_TYPE
Rule 65    slice_type -> LBRACKET RBRACKET primitive_type
Rule 66    expression -> slice_type LBRACE expression_list RBRACE
Rule 67    expression -> slice_type LBRACE RBRACE
Rule 68    expression_list -> expression
Rule 69    expression_list -> expression_list COMMA expression
Rule 70    expression -> LPAREN expression RPAREN
Rule 71    expression -> INT
Rule 72    expression -> FLOAT64
Rule 73    expression -> IDENTIFIER
Rule 74    expression -> STRING
Rule 75    expression -> TRUE
Rule 76    expression -> FALSE
Rule 77    short_assignment -> IDENTIFIER SHORT_ASSIGN expression
Rule 78    local_statement -> local_var_dec
Rule 79    local_statement -> local_const_dec
Rule 80    local_statement -> short_assignment
Rule 81    local_statement -> simple_assignment
Rule 82    local_statement -> assignment_compound
Rule 83    local_statement -> expression
Rule 84    local_statement -> for_statement
Rule 85    local_statement -> if_statement
Rule 86    local_statement -> switch_statement
Rule 87    local_statement -> return_statement
Rule 88    local_statement -> BREAK
Rule 89    local_statement -> CONTINUE
Rule 90    block -> LBRACE local_statement_list RBRACE
Rule 91    block -> LBRACE RBRACE
Rule 92    local_statement_list -> local_statement
Rule 93    local_statement_list -> local_statement_list local_statement
Rule 94    for_statement -> for_classic
Rule 95    for_statement -> for_condition
Rule 96    for_statement -> for_infinite
Rule 97    for_classic -> FOR for_init SEMICOLON for_cond SEMICOLON for_post block
Rule 98    for_condition -> FOR expression block
Rule 99    for_infinite -> FOR block
Rule 100   for_init -> simple_assignment
Rule 101   for_init -> short_assignment
Rule 102   for_init -> local_var_dec
Rule 103   for_init -> empty
Rule 104   for_cond -> expression
Rule 105   for_cond -> empty
Rule 106   for_post -> simple_assignment
Rule 107   for_post -> assignment_compound
Rule 108   for_post -> expression
Rule 109   for_post -> empty
Rule 110   return_list -> expression
Rule 111   return_list -> return_list COMMA expression
Rule 112   function_declaration -> FUNC IDENTIFIER LPAREN parameter_list RPAREN return_type block
Rule 113   parameter_list -> parameter_list COMMA parameter
Rule 114   parameter_list -> parameter
Rule 115   parameter_list -> empty
Rule 116   parameter -> IDENTIFIER type
Rule 117   parameter -> IDENTIFIER ELLIPSIS primitive_type
Rule 118   return_type -> type
Rule 119   return_type -> LPAREN type_list RPAREN
Rule 120   return_type -> empty
Rule 121   type_list -> type
Rule 122   type_list -> type_list COMMA type
Rule 123   return_statement -> RETURN
Rule 124   return_statement -> RETURN return_list
Rule 125   expression -> LNOT expression
Rule 126   expression -> IDENTIFIER PLUSPLUS
Rule 127   expression -> IDENTIFIER MINUSMINUS
Rule 128   if_statement -> IF expression block
Rule 129   if_statement -> IF expression block ELSE block
Rule 130   if_statement -> IF expression block ELSE if_statement
Rule 131   if_statement -> IF if_assignment SEMICOLON expression block
Rule 132   if_statement -> IF if_assignment SEMICOLON expression block ELSE block
Rule 133   if_statement -> IF if_assignment SEMICOLON expression block ELSE if_statement
Rule 134   if_assignment -> simple_assignment
Rule 135   if_assignment -> short_assignment
Rule 136   if_assignment -> local_var_dec
Rule 137   map_type -> MAP LBRACKET primitive_type RBRACKET primitive_type
Rule 138   expression -> map_type LBRACE expression_map_list RBRACE
Rule 139   expression -> map_type LBRACE RBRACE
Rule 140   expression_map_list -> key_value
Rule 141   expression_map_list -> expression_map_list COMMA key_value
Rule 142   key_value -> expression COLON expression
Rule 143   field_list -> field_declaration
Rule 144   field_list -> field_list field_declaration
Rule 145   field_declaration -> IDENTIFIER type
Rule 146   method_declaration -> FUNC LPAREN receiver RPAREN IDENTIFIER LPAREN parameter_list RPAREN return_type block
Rule 147   receiver -> IDENTIFIER IDENTIFIER
Rule 148   receiver -> IDENTIFIER TIMES IDENTIFIER
Rule 149   receiver -> IDENTIFIER TIMES type
Rule 150   type_declaration -> TYPE IDENTIFIER type_alias
Rule 151   type_alias -> struct_type
Rule 152   type_alias -> type
Rule 153   type_alias -> IDENTIFIER
Rule 154   struct_type -> STRUCT LBRACE RBRACE
Rule 155   struct_type -> STRUCT LBRACE field_list RBRACE
Rule 156   keyed_element_list -> keyed_element
Rule 157   keyed_element_list -> keyed_element_list COMMA keyed_element
Rule 158   keyed_element -> IDENTIFIER COLON expression
Rule 159   keyed_element -> INT COLON expression
Rule 160   keyed_element -> expression
Rule 161   expression -> type_name LBRACE keyed_element_list RBRACE
Rule 162   expression -> type_name LBRACE RBRACE
Rule 163   type_name -> IDENTIFIER
Rule 164   type_name -> slice_type
Rule 165   type_name -> array_type
Rule 166   type_name -> map_type
Rule 167   switch_statement -> SWITCH switch_expr LBRACE case_clause_list RBRACE
Rule 168   switch_statement -> SWITCH switch_expr LBRACE RBRACE
Rule 169   switch_statement -> SWITCH LBRACE case_clause_list RBRACE
Rule 170   switch_statement -> SWITCH LBRACE RBRACE
Rule 171   switch_statement -> SWITCH switch_assignment SEMICOLON switch_expr LBRACE case_clause_list RBRACE
Rule 172   switch_statement -> SWITCH switch_assignment SEMICOLON switch_expr LBRACE RBRACE
Rule 173   switch_statement -> SWITCH switch_assignment SEMICOLON LBRACE case_clause_list RBRACE
Rule 174   switch_statement -> SWITCH switch_assignment SEMICOLON LBRACE RBRACE
Rule 175   switch_expr -> primary_expression
Rule 176   primary_expression -> IDENTIFIER
Rule 177   primary_expression -> INT
Rule 178   primary_expression -> FLOAT64
Rule 179   primary_expression -> STRING
Rule 180   primary_expression -> TRUE
Rule 181   primary_expression -> FALSE
Rule 182   primary_expression -> LPAREN expression RPAREN
Rule 183   primary_expression -> IDENTIFIER LPAREN argument_list RPAREN
Rule 184   primary_expression -> primary_expression DOT IDENTIFIER
Rule 185   primary_expression -> primary_expression LBRACKET expression RBRACKET
Rule 186   case_clause_list -> case_clause
Rule 187   case_clause_list -> case_clause_list case_clause
Rule 188   switch_assignment -> simple_assignment
Rule 189   switch_assignment -> short_assignment
Rule 190   switch_assignment -> local_var_dec
Rule 191   case_clause -> CASE case_expression_list COLON case_body
Rule 192   case_clause -> DEFAULT COLON case_body
Rule 193   case_expression_list -> expression
Rule 194   case_expression_list -> case_expression_list COMMA expression
Rule 195   case_body -> local_statement_list
Rule 196   case_body -> empty
Rule 197   array_type -> LBRACKET INT RBRACKET primitive_type
Rule 198   expression -> array_type LBRACE expression_list RBRACE
Rule 199   expression -> array_type LBRACE RBRACE
Rule 200   expression -> expression DOT IDENTIFIER
Rule 201   expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN
Rule 202   expression -> expression LBRACKET expression RBRACKET
Rule 203   expression -> IDENTIFIER LPAREN argument_list RPAREN
Rule 204   argument_list -> expression_list
Rule 205   argument_list -> empty

Terminals, with rules where they appear

AND                  : 50
AND_ASSIGN           : 31
AND_NOT              : 53
ASSIGN               : 16 17 18 19 21 22 23 24 56
BOOL_TYPE            : 64
BREAK                : 88
CASE                 : 191
COLON                : 142 158 159 191 192
COMMA                : 69 111 113 122 141 157 194
CONST                : 18 19 23 24
CONTINUE             : 89
DEFAULT              : 192
DIVIDE               : 40
DIV_ASSIGN           : 29
DOT                  : 184 200 201
ELLIPSIS             : 117
ELSE                 : 129 130 132 133
EQ                   : 42
FALSE                : 76 181
FLOAT64              : 72 178
FLOAT64_TYPE         : 62
FOR                  : 97 98 99
FUNC                 : 112 146
GE                   : 47
GT                   : 46
IDENTIFIER           : 2 15 16 17 18 19 20 21 22 23 24 25 56 73 77 112 116 117 126 127 145 146 147 147 148 148 149 150 153 158 163 176 183 184 200 201 203
IF                   : 128 129 130 131 132 133
IMPORT               : 6
INT                  : 71 159 177 197
INT_TYPE             : 61
LAND                 : 48
LBRACE               : 66 67 90 91 138 139 154 155 161 162 167 168 169 170 171 172 173 174 198 199
LBRACKET             : 65 137 185 197 202
LE                   : 45
LNOT                 : 125
LOR                  : 49
LPAREN               : 70 112 119 146 146 182 183 201 203
LSHIFT               : 54
LSHIFT_ASSIGN        : 34
LT                   : 44
MAP                  : 137
MINUS                : 38
MINUSMINUS           : 127
MINUS_ASSIGN         : 27
MODULE               : 41
MOD_ASSIGN           : 30
MULT_ASSIGN          : 28
NEQ                  : 43
OR                   : 51
OR_ASSIGN            : 32
PACKAGE              : 2
PLUS                 : 37
PLUSPLUS             : 126
PLUS_ASSIGN          : 26
RBRACE               : 66 67 90 91 138 139 154 155 161 162 167 168 169 170 171 172 173 174 198 199
RBRACKET             : 65 137 185 197 202
RETURN               : 123 124
RPAREN               : 70 112 119 146 146 182 183 201 203
RSHIFT               : 55
RSHIFT_ASSIGN        : 35
SEMICOLON            : 97 97 131 132 133 171 172 173 174
SHORT_ASSIGN         : 77
STRING               : 6 74 179
STRING_TYPE          : 63
STRUCT               : 154 155
SWITCH               : 167 168 169 170 171 172 173 174
TIMES                : 39 148 149
TRUE                 : 75 180
TYPE                 : 150
VAR                  : 15 16 17 20 21 22
XOR                  : 52
XOR_ASSIGN           : 33
error                : 

Nonterminals, with rules where they appear

argument_list        : 183 201 203
array_type           : 59 165 198 199
assignment_compound  : 82 107
binary_operator      : 36
block                : 97 98 99 112 128 129 129 130 131 132 132 133 146
case_body            : 191 192
case_clause          : 186 187
case_clause_list     : 167 169 171 173 187
case_expression_list : 191 194
empty                : 5 103 105 109 115 120 196 205
expression           : 16 17 18 19 21 22 23 24 25 36 36 56 68 69 70 77 83 98 104 108 110 111 125 128 129 130 131 132 133 142 142 158 159 160 182 185 193 194 200 201 202 202
expression_list      : 66 69 198 204
expression_map_list  : 138 141
field_declaration    : 143 144
field_list           : 144 155
for_classic          : 94
for_cond             : 97
for_condition        : 95
for_infinite         : 96
for_init             : 97
for_post             : 97
for_statement        : 84
function_declaration : 12
global_const_dec     : 11
global_statement     : 8 9
global_statement_list : 1 9
global_var_dec       : 10
if_assignment        : 131 132 133
if_statement         : 85 130 133
import               : 1 4
key_value            : 140 141
keyed_element        : 156 157
keyed_element_list   : 157 161
local_const_dec      : 79
local_statement      : 92 93
local_statement_list : 90 93 195
local_var_dec        : 78 102 136 190
map_type             : 60 138 139 166
method_declaration   : 13
operator_assign      : 25
package_declaration  : 1
parameter            : 113 114
parameter_list       : 112 113 146
primary_expression   : 175 184 185
primitive_type       : 57 65 117 137 137 197
program              : 0
receiver             : 146
return_list          : 111 124
return_statement     : 87
return_type          : 112 146
short_assignment     : 80 101 135 189
simple_assignment    : 81 100 106 134 188
simple_import        : 3 4
slice_type           : 58 66 67 164
struct_type          : 151
switch_assignment    : 171 172 173 174
switch_expr          : 167 168 171 172
switch_statement     : 86
type                 : 15 16 18 20 21 23 116 118 121 122 145 149 152
type_alias           : 150
type_declaration     : 14
type_list            : 119 122
type_name            : 161 162

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . package_declaration import global_statement_list
    (2) package_declaration -> . PACKAGE IDENTIFIER

    PACKAGE         shift and go to state 3

    program                        shift and go to state 1
    package_declaration            shift and go to state 2

state 1

    (0) S' -> program .



state 2

    (1) program -> package_declaration . import global_statement_list
    (3) import -> . simple_import
    (4) import -> . import simple_import
    (5) import -> . empty
    (6) simple_import -> . IMPORT STRING
    (7) empty -> .

  ! shift/reduce conflict for IMPORT resolved as shift
    IMPORT          shift and go to state 7
    VAR             reduce using rule 7 (empty -> .)
    CONST           reduce using rule 7 (empty -> .)
    FUNC            reduce using rule 7 (empty -> .)
    TYPE            reduce using rule 7 (empty -> .)

  ! IMPORT          [ reduce using rule 7 (empty -> .) ]

    import                         shift and go to state 4
    simple_import                  shift and go to state 5
    empty                          shift and go to state 6

state 3

    (2) package_declaration -> PACKAGE . IDENTIFIER

    IDENTIFIER      shift and go to state 8


state 4

    (1) program -> package_declaration import . global_statement_list
    (4) import -> import . simple_import
    (8) global_statement_list -> . global_statement
    (9) global_statement_list -> . global_statement_list global_statement
    (6) simple_import -> . IMPORT STRING
    (10) global_statement -> . global_var_dec
    (11) global_statement -> . global_const_dec
    (12) global_statement -> . function_declaration
    (13) global_statement -> . method_declaration
    (14) global_statement -> . type_declaration
    (15) global_var_dec -> . VAR IDENTIFIER type
    (16) global_var_dec -> . VAR IDENTIFIER type ASSIGN expression
    (17) global_var_dec -> . VAR IDENTIFIER ASSIGN expression
    (18) global_const_dec -> . CONST IDENTIFIER type ASSIGN expression
    (19) global_const_dec -> . CONST IDENTIFIER ASSIGN expression
    (112) function_declaration -> . FUNC IDENTIFIER LPAREN parameter_list RPAREN return_type block
    (146) method_declaration -> . FUNC LPAREN receiver RPAREN IDENTIFIER LPAREN parameter_list RPAREN return_type block
    (150) type_declaration -> . TYPE IDENTIFIER type_alias

    IMPORT          shift and go to state 7
    VAR             shift and go to state 17
    CONST           shift and go to state 18
    FUNC            shift and go to state 19
    TYPE            shift and go to state 20

    global_statement_list          shift and go to state 9
    simple_import                  shift and go to state 10
    global_statement               shift and go to state 11
    global_var_dec                 shift and go to state 12
    global_const_dec               shift and go to state 13
    function_declaration           shift and go to state 14
    method_declaration             shift and go to state 15
    type_declaration               shift and go to state 16

state 5

    (3) import -> simple_import .

    IMPORT          reduce using rule 3 (import -> simple_import .)
    VAR             reduce using rule 3 (import -> simple_import .)
    CONST           reduce using rule 3 (import -> simple_import .)
    FUNC            reduce using rule 3 (import -> simple_import .)
    TYPE            reduce using rule 3 (import -> simple_import .)


state 6

    (5) import -> empty .

    IMPORT          reduce using rule 5 (import -> empty .)
    VAR             reduce using rule 5 (import -> empty .)
    CONST           reduce using rule 5 (import -> empty .)
    FUNC            reduce using rule 5 (import -> empty .)
    TYPE            reduce using rule 5 (import -> empty .)


state 7

    (6) simple_import -> IMPORT . STRING

    STRING          shift and go to state 21


state 8

    (2) package_declaration -> PACKAGE IDENTIFIER .

    IMPORT          reduce using rule 2 (package_declaration -> PACKAGE IDENTIFIER .)
    VAR             reduce using rule 2 (package_declaration -> PACKAGE IDENTIFIER .)
    CONST           reduce using rule 2 (package_declaration -> PACKAGE IDENTIFIER .)
    FUNC            reduce using rule 2 (package_declaration -> PACKAGE IDENTIFIER .)
    TYPE            reduce using rule 2 (package_declaration -> PACKAGE IDENTIFIER .)


state 9

    (1) program -> package_declaration import global_statement_list .
    (9) global_statement_list -> global_statement_list . global_statement
    (10) global_statement -> . global_var_dec
    (11) global_statement -> . global_const_dec
    (12) global_statement -> . function_declaration
    (13) global_statement -> . method_declaration
    (14) global_statement -> . type_declaration
    (15) global_var_dec -> . VAR IDENTIFIER type
    (16) global_var_dec -> . VAR IDENTIFIER type ASSIGN expression
    (17) global_var_dec -> . VAR IDENTIFIER ASSIGN expression
    (18) global_const_dec -> . CONST IDENTIFIER type ASSIGN expression
    (19) global_const_dec -> . CONST IDENTIFIER ASSIGN expression
    (112) function_declaration -> . FUNC IDENTIFIER LPAREN parameter_list RPAREN return_type block
    (146) method_declaration -> . FUNC LPAREN receiver RPAREN IDENTIFIER LPAREN parameter_list RPAREN return_type block
    (150) type_declaration -> . TYPE IDENTIFIER type_alias

    $end            reduce using rule 1 (program -> package_declaration import global_statement_list .)
    VAR             shift and go to state 17
    CONST           shift and go to state 18
    FUNC            shift and go to state 19
    TYPE            shift and go to state 20

    global_statement               shift and go to state 22
    global_var_dec                 shift and go to state 12
    global_const_dec               shift and go to state 13
    function_declaration           shift and go to state 14
    method_declaration             shift and go to state 15
    type_declaration               shift and go to state 16

state 10

    (4) import -> import simple_import .

    IMPORT          reduce using rule 4 (import -> import simple_import .)
    VAR             reduce using rule 4 (import -> import simple_import .)
    CONST           reduce using rule 4 (import -> import simple_import .)
    FUNC            reduce using rule 4 (import -> import simple_import .)
    TYPE            reduce using rule 4 (import -> import simple_import .)


state 11

    (8) global_statement_list -> global_statement .

    VAR             reduce using rule 8 (global_statement_list -> global_statement .)
    CONST           reduce using rule 8 (global_statement_list -> global_statement .)
    FUNC            reduce using rule 8 (global_statement_list -> global_statement .)
    TYPE            reduce using rule 8 (global_statement_list -> global_statement .)
    $end            reduce using rule 8 (global_statement_list -> global_statement .)


state 12

    (10) global_statement -> global_var_dec .

    VAR             reduce using rule 10 (global_statement -> global_var_dec .)
    CONST           reduce using rule 10 (global_statement -> global_var_dec .)
    FUNC            reduce using rule 10 (global_statement -> global_var_dec .)
    TYPE            reduce using rule 10 (global_statement -> global_var_dec .)
    $end            reduce using rule 10 (global_statement -> global_var_dec .)


state 13

    (11) global_statement -> global_const_dec .

    VAR             reduce using rule 11 (global_statement -> global_const_dec .)
    CONST           reduce using rule 11 (global_statement -> global_const_dec .)
    FUNC            reduce using rule 11 (global_statement -> global_const_dec .)
    TYPE            reduce using rule 11 (global_statement -> global_const_dec .)
    $end            reduce using rule 11 (global_statement -> global_const_dec .)


state 14

    (12) global_statement -> function_declaration .

    VAR             reduce using rule 12 (global_statement -> function_declaration .)
    CONST           reduce using rule 12 (global_statement -> function_declaration .)
    FUNC            reduce using rule 12 (global_statement -> function_declaration .)
    TYPE            reduce using rule 12 (global_statement -> function_declaration .)
    $end            reduce using rule 12 (global_statement -> function_declaration .)


state 15

    (13) global_statement -> method_declaration .

    VAR             reduce using rule 13 (global_statement -> method_declaration .)
    CONST           reduce using rule 13 (global_statement -> method_declaration .)
    FUNC            reduce using rule 13 (global_statement -> method_declaration .)
    TYPE            reduce using rule 13 (global_statement -> method_declaration .)
    $end            reduce using rule 13 (global_statement -> method_declaration .)


state 16

    (14) global_statement -> type_declaration .

    VAR             reduce using rule 14 (global_statement -> type_declaration .)
    CONST           reduce using rule 14 (global_statement -> type_declaration .)
    FUNC            reduce using rule 14 (global_statement -> type_declaration .)
    TYPE            reduce using rule 14 (global_statement -> type_declaration .)
    $end            reduce using rule 14 (global_statement -> type_declaration .)


state 17

    (15) global_var_dec -> VAR . IDENTIFIER type
    (16) global_var_dec -> VAR . IDENTIFIER type ASSIGN expression
    (17) global_var_dec -> VAR . IDENTIFIER ASSIGN expression

    IDENTIFIER      shift and go to state 23


state 18

    (18) global_const_dec -> CONST . IDENTIFIER type ASSIGN expression
    (19) global_const_dec -> CONST . IDENTIFIER ASSIGN expression

    IDENTIFIER      shift and go to state 24


state 19

    (112) function_declaration -> FUNC . IDENTIFIER LPAREN parameter_list RPAREN return_type block
    (146) method_declaration -> FUNC . LPAREN receiver RPAREN IDENTIFIER LPAREN parameter_list RPAREN return_type block

    IDENTIFIER      shift and go to state 25
    LPAREN          shift and go to state 26


state 20

    (150) type_declaration -> TYPE . IDENTIFIER type_alias

    IDENTIFIER      shift and go to state 27


state 21

    (6) simple_import -> IMPORT STRING .

    IMPORT          reduce using rule 6 (simple_import -> IMPORT STRING .)
    VAR             reduce using rule 6 (simple_import -> IMPORT STRING .)
    CONST           reduce using rule 6 (simple_import -> IMPORT STRING .)
    FUNC            reduce using rule 6 (simple_import -> IMPORT STRING .)
    TYPE            reduce using rule 6 (simple_import -> IMPORT STRING .)


state 22

    (9) global_statement_list -> global_statement_list global_statement .

    VAR             reduce using rule 9 (global_statement_list -> global_statement_list global_statement .)
    CONST           reduce using rule 9 (global_statement_list -> global_statement_list global_statement .)
    FUNC            reduce using rule 9 (global_statement_list -> global_statement_list global_statement .)
    TYPE            reduce using rule 9 (global_statement_list -> global_statement_list global_statement .)
    $end            reduce using rule 9 (global_statement_list -> global_statement_list global_statement .)


state 23

    (15) global_var_dec -> VAR IDENTIFIER . type
    (16) global_var_dec -> VAR IDENTIFIER . type ASSIGN expression
    (17) global_var_dec -> VAR IDENTIFIER . ASSIGN expression
    (57) type -> . primitive_type
    (58) type -> . slice_type
    (59) type -> . array_type
    (60) type -> . map_type
    (61) primitive_type -> . INT_TYPE
    (62) primitive_type -> . FLOAT64_TYPE
    (63) primitive_type -> . STRING_TYPE
    (64) primitive_type -> . BOOL_TYPE
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (197) array_type -> . LBRACKET INT RBRACKET primitive_type
    (137) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type

    ASSIGN          shift and go to state 29
    INT_TYPE        shift and go to state 34
    FLOAT64_TYPE    shift and go to state 35
    STRING_TYPE     shift and go to state 36
    BOOL_TYPE       shift and go to state 37
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    type                           shift and go to state 28
    primitive_type                 shift and go to state 30
    slice_type                     shift and go to state 31
    array_type                     shift and go to state 32
    map_type                       shift and go to state 33

state 24

    (18) global_const_dec -> CONST IDENTIFIER . type ASSIGN expression
    (19) global_const_dec -> CONST IDENTIFIER . ASSIGN expression
    (57) type -> . primitive_type
    (58) type -> . slice_type
    (59) type -> . array_type
    (60) type -> . map_type
    (61) primitive_type -> . INT_TYPE
    (62) primitive_type -> . FLOAT64_TYPE
    (63) primitive_type -> . STRING_TYPE
    (64) primitive_type -> . BOOL_TYPE
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (197) array_type -> . LBRACKET INT RBRACKET primitive_type
    (137) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type

    ASSIGN          shift and go to state 41
    INT_TYPE        shift and go to state 34
    FLOAT64_TYPE    shift and go to state 35
    STRING_TYPE     shift and go to state 36
    BOOL_TYPE       shift and go to state 37
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    type                           shift and go to state 40
    primitive_type                 shift and go to state 30
    slice_type                     shift and go to state 31
    array_type                     shift and go to state 32
    map_type                       shift and go to state 33

state 25

    (112) function_declaration -> FUNC IDENTIFIER . LPAREN parameter_list RPAREN return_type block

    LPAREN          shift and go to state 42


state 26

    (146) method_declaration -> FUNC LPAREN . receiver RPAREN IDENTIFIER LPAREN parameter_list RPAREN return_type block
    (147) receiver -> . IDENTIFIER IDENTIFIER
    (148) receiver -> . IDENTIFIER TIMES IDENTIFIER
    (149) receiver -> . IDENTIFIER TIMES type

    IDENTIFIER      shift and go to state 44

    receiver                       shift and go to state 43

state 27

    (150) type_declaration -> TYPE IDENTIFIER . type_alias
    (151) type_alias -> . struct_type
    (152) type_alias -> . type
    (153) type_alias -> . IDENTIFIER
    (154) struct_type -> . STRUCT LBRACE RBRACE
    (155) struct_type -> . STRUCT LBRACE field_list RBRACE
    (57) type -> . primitive_type
    (58) type -> . slice_type
    (59) type -> . array_type
    (60) type -> . map_type
    (61) primitive_type -> . INT_TYPE
    (62) primitive_type -> . FLOAT64_TYPE
    (63) primitive_type -> . STRING_TYPE
    (64) primitive_type -> . BOOL_TYPE
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (197) array_type -> . LBRACKET INT RBRACKET primitive_type
    (137) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type

    IDENTIFIER      shift and go to state 45
    STRUCT          shift and go to state 49
    INT_TYPE        shift and go to state 34
    FLOAT64_TYPE    shift and go to state 35
    STRING_TYPE     shift and go to state 36
    BOOL_TYPE       shift and go to state 37
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    type_alias                     shift and go to state 46
    struct_type                    shift and go to state 47
    type                           shift and go to state 48
    primitive_type                 shift and go to state 30
    slice_type                     shift and go to state 31
    array_type                     shift and go to state 32
    map_type                       shift and go to state 33

state 28

    (15) global_var_dec -> VAR IDENTIFIER type .
    (16) global_var_dec -> VAR IDENTIFIER type . ASSIGN expression

    VAR             reduce using rule 15 (global_var_dec -> VAR IDENTIFIER type .)
    CONST           reduce using rule 15 (global_var_dec -> VAR IDENTIFIER type .)
    FUNC            reduce using rule 15 (global_var_dec -> VAR IDENTIFIER type .)
    TYPE            reduce using rule 15 (global_var_dec -> VAR IDENTIFIER type .)
    $end            reduce using rule 15 (global_var_dec -> VAR IDENTIFIER type .)
    ASSIGN          shift and go to state 50


state 29

    (17) global_var_dec -> VAR IDENTIFIER ASSIGN . expression
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (125) expression -> . LNOT expression
    (126) expression -> . IDENTIFIER PLUSPLUS
    (127) expression -> . IDENTIFIER MINUSMINUS
    (138) expression -> . map_type LBRACE expression_map_list RBRACE
    (139) expression -> . map_type LBRACE RBRACE
    (161) expression -> . type_name LBRACE keyed_element_list RBRACE
    (162) expression -> . type_name LBRACE RBRACE
    (198) expression -> . array_type LBRACE expression_list RBRACE
    (199) expression -> . array_type LBRACE RBRACE
    (200) expression -> . expression DOT IDENTIFIER
    (201) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> . expression LBRACKET expression RBRACKET
    (203) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (137) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (163) type_name -> . IDENTIFIER
    (164) type_name -> . slice_type
    (165) type_name -> . array_type
    (166) type_name -> . map_type
    (197) array_type -> . LBRACKET INT RBRACKET primitive_type

    LPAREN          shift and go to state 54
    INT             shift and go to state 55
    FLOAT64         shift and go to state 56
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 57
    TRUE            shift and go to state 58
    FALSE           shift and go to state 59
    LNOT            shift and go to state 60
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    expression                     shift and go to state 52
    slice_type                     shift and go to state 53
    map_type                       shift and go to state 61
    type_name                      shift and go to state 62
    array_type                     shift and go to state 63

state 30

    (57) type -> primitive_type .

    ASSIGN          reduce using rule 57 (type -> primitive_type .)
    VAR             reduce using rule 57 (type -> primitive_type .)
    CONST           reduce using rule 57 (type -> primitive_type .)
    FUNC            reduce using rule 57 (type -> primitive_type .)
    TYPE            reduce using rule 57 (type -> primitive_type .)
    $end            reduce using rule 57 (type -> primitive_type .)
    RPAREN          reduce using rule 57 (type -> primitive_type .)
    COMMA           reduce using rule 57 (type -> primitive_type .)
    LBRACE          reduce using rule 57 (type -> primitive_type .)
    RBRACE          reduce using rule 57 (type -> primitive_type .)
    IDENTIFIER      reduce using rule 57 (type -> primitive_type .)
    BREAK           reduce using rule 57 (type -> primitive_type .)
    CONTINUE        reduce using rule 57 (type -> primitive_type .)
    LPAREN          reduce using rule 57 (type -> primitive_type .)
    INT             reduce using rule 57 (type -> primitive_type .)
    FLOAT64         reduce using rule 57 (type -> primitive_type .)
    STRING          reduce using rule 57 (type -> primitive_type .)
    TRUE            reduce using rule 57 (type -> primitive_type .)
    FALSE           reduce using rule 57 (type -> primitive_type .)
    LNOT            reduce using rule 57 (type -> primitive_type .)
    IF              reduce using rule 57 (type -> primitive_type .)
    SWITCH          reduce using rule 57 (type -> primitive_type .)
    RETURN          reduce using rule 57 (type -> primitive_type .)
    LBRACKET        reduce using rule 57 (type -> primitive_type .)
    MAP             reduce using rule 57 (type -> primitive_type .)
    FOR             reduce using rule 57 (type -> primitive_type .)
    SEMICOLON       reduce using rule 57 (type -> primitive_type .)
    CASE            reduce using rule 57 (type -> primitive_type .)
    DEFAULT         reduce using rule 57 (type -> primitive_type .)


state 31

    (58) type -> slice_type .

    ASSIGN          reduce using rule 58 (type -> slice_type .)
    VAR             reduce using rule 58 (type -> slice_type .)
    CONST           reduce using rule 58 (type -> slice_type .)
    FUNC            reduce using rule 58 (type -> slice_type .)
    TYPE            reduce using rule 58 (type -> slice_type .)
    $end            reduce using rule 58 (type -> slice_type .)
    RPAREN          reduce using rule 58 (type -> slice_type .)
    COMMA           reduce using rule 58 (type -> slice_type .)
    LBRACE          reduce using rule 58 (type -> slice_type .)
    RBRACE          reduce using rule 58 (type -> slice_type .)
    IDENTIFIER      reduce using rule 58 (type -> slice_type .)
    BREAK           reduce using rule 58 (type -> slice_type .)
    CONTINUE        reduce using rule 58 (type -> slice_type .)
    LPAREN          reduce using rule 58 (type -> slice_type .)
    INT             reduce using rule 58 (type -> slice_type .)
    FLOAT64         reduce using rule 58 (type -> slice_type .)
    STRING          reduce using rule 58 (type -> slice_type .)
    TRUE            reduce using rule 58 (type -> slice_type .)
    FALSE           reduce using rule 58 (type -> slice_type .)
    LNOT            reduce using rule 58 (type -> slice_type .)
    IF              reduce using rule 58 (type -> slice_type .)
    SWITCH          reduce using rule 58 (type -> slice_type .)
    RETURN          reduce using rule 58 (type -> slice_type .)
    LBRACKET        reduce using rule 58 (type -> slice_type .)
    MAP             reduce using rule 58 (type -> slice_type .)
    FOR             reduce using rule 58 (type -> slice_type .)
    SEMICOLON       reduce using rule 58 (type -> slice_type .)
    CASE            reduce using rule 58 (type -> slice_type .)
    DEFAULT         reduce using rule 58 (type -> slice_type .)


state 32

    (59) type -> array_type .

    ASSIGN          reduce using rule 59 (type -> array_type .)
    VAR             reduce using rule 59 (type -> array_type .)
    CONST           reduce using rule 59 (type -> array_type .)
    FUNC            reduce using rule 59 (type -> array_type .)
    TYPE            reduce using rule 59 (type -> array_type .)
    $end            reduce using rule 59 (type -> array_type .)
    RPAREN          reduce using rule 59 (type -> array_type .)
    COMMA           reduce using rule 59 (type -> array_type .)
    LBRACE          reduce using rule 59 (type -> array_type .)
    RBRACE          reduce using rule 59 (type -> array_type .)
    IDENTIFIER      reduce using rule 59 (type -> array_type .)
    BREAK           reduce using rule 59 (type -> array_type .)
    CONTINUE        reduce using rule 59 (type -> array_type .)
    LPAREN          reduce using rule 59 (type -> array_type .)
    INT             reduce using rule 59 (type -> array_type .)
    FLOAT64         reduce using rule 59 (type -> array_type .)
    STRING          reduce using rule 59 (type -> array_type .)
    TRUE            reduce using rule 59 (type -> array_type .)
    FALSE           reduce using rule 59 (type -> array_type .)
    LNOT            reduce using rule 59 (type -> array_type .)
    IF              reduce using rule 59 (type -> array_type .)
    SWITCH          reduce using rule 59 (type -> array_type .)
    RETURN          reduce using rule 59 (type -> array_type .)
    LBRACKET        reduce using rule 59 (type -> array_type .)
    MAP             reduce using rule 59 (type -> array_type .)
    FOR             reduce using rule 59 (type -> array_type .)
    SEMICOLON       reduce using rule 59 (type -> array_type .)
    CASE            reduce using rule 59 (type -> array_type .)
    DEFAULT         reduce using rule 59 (type -> array_type .)


state 33

    (60) type -> map_type .

    ASSIGN          reduce using rule 60 (type -> map_type .)
    VAR             reduce using rule 60 (type -> map_type .)
    CONST           reduce using rule 60 (type -> map_type .)
    FUNC            reduce using rule 60 (type -> map_type .)
    TYPE            reduce using rule 60 (type -> map_type .)
    $end            reduce using rule 60 (type -> map_type .)
    RPAREN          reduce using rule 60 (type -> map_type .)
    COMMA           reduce using rule 60 (type -> map_type .)
    LBRACE          reduce using rule 60 (type -> map_type .)
    RBRACE          reduce using rule 60 (type -> map_type .)
    IDENTIFIER      reduce using rule 60 (type -> map_type .)
    BREAK           reduce using rule 60 (type -> map_type .)
    CONTINUE        reduce using rule 60 (type -> map_type .)
    LPAREN          reduce using rule 60 (type -> map_type .)
    INT             reduce using rule 60 (type -> map_type .)
    FLOAT64         reduce using rule 60 (type -> map_type .)
    STRING          reduce using rule 60 (type -> map_type .)
    TRUE            reduce using rule 60 (type -> map_type .)
    FALSE           reduce using rule 60 (type -> map_type .)
    LNOT            reduce using rule 60 (type -> map_type .)
    IF              reduce using rule 60 (type -> map_type .)
    SWITCH          reduce using rule 60 (type -> map_type .)
    RETURN          reduce using rule 60 (type -> map_type .)
    LBRACKET        reduce using rule 60 (type -> map_type .)
    MAP             reduce using rule 60 (type -> map_type .)
    FOR             reduce using rule 60 (type -> map_type .)
    SEMICOLON       reduce using rule 60 (type -> map_type .)
    CASE            reduce using rule 60 (type -> map_type .)
    DEFAULT         reduce using rule 60 (type -> map_type .)


state 34

    (61) primitive_type -> INT_TYPE .

    ASSIGN          reduce using rule 61 (primitive_type -> INT_TYPE .)
    VAR             reduce using rule 61 (primitive_type -> INT_TYPE .)
    CONST           reduce using rule 61 (primitive_type -> INT_TYPE .)
    FUNC            reduce using rule 61 (primitive_type -> INT_TYPE .)
    TYPE            reduce using rule 61 (primitive_type -> INT_TYPE .)
    $end            reduce using rule 61 (primitive_type -> INT_TYPE .)
    LBRACE          reduce using rule 61 (primitive_type -> INT_TYPE .)
    RPAREN          reduce using rule 61 (primitive_type -> INT_TYPE .)
    COMMA           reduce using rule 61 (primitive_type -> INT_TYPE .)
    RBRACE          reduce using rule 61 (primitive_type -> INT_TYPE .)
    IDENTIFIER      reduce using rule 61 (primitive_type -> INT_TYPE .)
    BREAK           reduce using rule 61 (primitive_type -> INT_TYPE .)
    CONTINUE        reduce using rule 61 (primitive_type -> INT_TYPE .)
    LPAREN          reduce using rule 61 (primitive_type -> INT_TYPE .)
    INT             reduce using rule 61 (primitive_type -> INT_TYPE .)
    FLOAT64         reduce using rule 61 (primitive_type -> INT_TYPE .)
    STRING          reduce using rule 61 (primitive_type -> INT_TYPE .)
    TRUE            reduce using rule 61 (primitive_type -> INT_TYPE .)
    FALSE           reduce using rule 61 (primitive_type -> INT_TYPE .)
    LNOT            reduce using rule 61 (primitive_type -> INT_TYPE .)
    IF              reduce using rule 61 (primitive_type -> INT_TYPE .)
    SWITCH          reduce using rule 61 (primitive_type -> INT_TYPE .)
    RETURN          reduce using rule 61 (primitive_type -> INT_TYPE .)
    LBRACKET        reduce using rule 61 (primitive_type -> INT_TYPE .)
    MAP             reduce using rule 61 (primitive_type -> INT_TYPE .)
    FOR             reduce using rule 61 (primitive_type -> INT_TYPE .)
    SEMICOLON       reduce using rule 61 (primitive_type -> INT_TYPE .)
    CASE            reduce using rule 61 (primitive_type -> INT_TYPE .)
    DEFAULT         reduce using rule 61 (primitive_type -> INT_TYPE .)
    RBRACKET        reduce using rule 61 (primitive_type -> INT_TYPE .)


state 35

    (62) primitive_type -> FLOAT64_TYPE .

    ASSIGN          reduce using rule 62 (primitive_type -> FLOAT64_TYPE .)
    VAR             reduce using rule 62 (primitive_type -> FLOAT64_TYPE .)
    CONST           reduce using rule 62 (primitive_type -> FLOAT64_TYPE .)
    FUNC            reduce using rule 62 (primitive_type -> FLOAT64_TYPE .)
    TYPE            reduce using rule 62 (primitive_type -> FLOAT64_TYPE .)
    $end            reduce using rule 62 (primitive_type -> FLOAT64_TYPE .)
    LBRACE          reduce using rule 62 (primitive_type -> FLOAT64_TYPE .)
    RPAREN          reduce using rule 62 (primitive_type -> FLOAT64_TYPE .)
    COMMA           reduce using rule 62 (primitive_type -> FLOAT64_TYPE .)
    RBRACE          reduce using rule 62 (primitive_type -> FLOAT64_TYPE .)
    IDENTIFIER      reduce using rule 62 (primitive_type -> FLOAT64_TYPE .)
    BREAK           reduce using rule 62 (primitive_type -> FLOAT64_TYPE .)
    CONTINUE        reduce using rule 62 (primitive_type -> FLOAT64_TYPE .)
    LPAREN          reduce using rule 62 (primitive_type -> FLOAT64_TYPE .)
    INT             reduce using rule 62 (primitive_type -> FLOAT64_TYPE .)
    FLOAT64         reduce using rule 62 (primitive_type -> FLOAT64_TYPE .)
    STRING          reduce using rule 62 (primitive_type -> FLOAT64_TYPE .)
    TRUE            reduce using rule 62 (primitive_type -> FLOAT64_TYPE .)
    FALSE           reduce using rule 62 (primitive_type -> FLOAT64_TYPE .)
    LNOT            reduce using rule 62 (primitive_type -> FLOAT64_TYPE .)
    IF              reduce using rule 62 (primitive_type -> FLOAT64_TYPE .)
    SWITCH          reduce using rule 62 (primitive_type -> FLOAT64_TYPE .)
    RETURN          reduce using rule 62 (primitive_type -> FLOAT64_TYPE .)
    LBRACKET        reduce using rule 62 (primitive_type -> FLOAT64_TYPE .)
    MAP             reduce using rule 62 (primitive_type -> FLOAT64_TYPE .)
    FOR             reduce using rule 62 (primitive_type -> FLOAT64_TYPE .)
    SEMICOLON       reduce using rule 62 (primitive_type -> FLOAT64_TYPE .)
    CASE            reduce using rule 62 (primitive_type -> FLOAT64_TYPE .)
    DEFAULT         reduce using rule 62 (primitive_type -> FLOAT64_TYPE .)
    RBRACKET        reduce using rule 62 (primitive_type -> FLOAT64_TYPE .)


state 36

    (63) primitive_type -> STRING_TYPE .

    ASSIGN          reduce using rule 63 (primitive_type -> STRING_TYPE .)
    VAR             reduce using rule 63 (primitive_type -> STRING_TYPE .)
    CONST           reduce using rule 63 (primitive_type -> STRING_TYPE .)
    FUNC            reduce using rule 63 (primitive_type -> STRING_TYPE .)
    TYPE            reduce using rule 63 (primitive_type -> STRING_TYPE .)
    $end            reduce using rule 63 (primitive_type -> STRING_TYPE .)
    LBRACE          reduce using rule 63 (primitive_type -> STRING_TYPE .)
    RPAREN          reduce using rule 63 (primitive_type -> STRING_TYPE .)
    COMMA           reduce using rule 63 (primitive_type -> STRING_TYPE .)
    RBRACE          reduce using rule 63 (primitive_type -> STRING_TYPE .)
    IDENTIFIER      reduce using rule 63 (primitive_type -> STRING_TYPE .)
    BREAK           reduce using rule 63 (primitive_type -> STRING_TYPE .)
    CONTINUE        reduce using rule 63 (primitive_type -> STRING_TYPE .)
    LPAREN          reduce using rule 63 (primitive_type -> STRING_TYPE .)
    INT             reduce using rule 63 (primitive_type -> STRING_TYPE .)
    FLOAT64         reduce using rule 63 (primitive_type -> STRING_TYPE .)
    STRING          reduce using rule 63 (primitive_type -> STRING_TYPE .)
    TRUE            reduce using rule 63 (primitive_type -> STRING_TYPE .)
    FALSE           reduce using rule 63 (primitive_type -> STRING_TYPE .)
    LNOT            reduce using rule 63 (primitive_type -> STRING_TYPE .)
    IF              reduce using rule 63 (primitive_type -> STRING_TYPE .)
    SWITCH          reduce using rule 63 (primitive_type -> STRING_TYPE .)
    RETURN          reduce using rule 63 (primitive_type -> STRING_TYPE .)
    LBRACKET        reduce using rule 63 (primitive_type -> STRING_TYPE .)
    MAP             reduce using rule 63 (primitive_type -> STRING_TYPE .)
    FOR             reduce using rule 63 (primitive_type -> STRING_TYPE .)
    SEMICOLON       reduce using rule 63 (primitive_type -> STRING_TYPE .)
    CASE            reduce using rule 63 (primitive_type -> STRING_TYPE .)
    DEFAULT         reduce using rule 63 (primitive_type -> STRING_TYPE .)
    RBRACKET        reduce using rule 63 (primitive_type -> STRING_TYPE .)


state 37

    (64) primitive_type -> BOOL_TYPE .

    ASSIGN          reduce using rule 64 (primitive_type -> BOOL_TYPE .)
    VAR             reduce using rule 64 (primitive_type -> BOOL_TYPE .)
    CONST           reduce using rule 64 (primitive_type -> BOOL_TYPE .)
    FUNC            reduce using rule 64 (primitive_type -> BOOL_TYPE .)
    TYPE            reduce using rule 64 (primitive_type -> BOOL_TYPE .)
    $end            reduce using rule 64 (primitive_type -> BOOL_TYPE .)
    LBRACE          reduce using rule 64 (primitive_type -> BOOL_TYPE .)
    RPAREN          reduce using rule 64 (primitive_type -> BOOL_TYPE .)
    COMMA           reduce using rule 64 (primitive_type -> BOOL_TYPE .)
    RBRACE          reduce using rule 64 (primitive_type -> BOOL_TYPE .)
    IDENTIFIER      reduce using rule 64 (primitive_type -> BOOL_TYPE .)
    BREAK           reduce using rule 64 (primitive_type -> BOOL_TYPE .)
    CONTINUE        reduce using rule 64 (primitive_type -> BOOL_TYPE .)
    LPAREN          reduce using rule 64 (primitive_type -> BOOL_TYPE .)
    INT             reduce using rule 64 (primitive_type -> BOOL_TYPE .)
    FLOAT64         reduce using rule 64 (primitive_type -> BOOL_TYPE .)
    STRING          reduce using rule 64 (primitive_type -> BOOL_TYPE .)
    TRUE            reduce using rule 64 (primitive_type -> BOOL_TYPE .)
    FALSE           reduce using rule 64 (primitive_type -> BOOL_TYPE .)
    LNOT            reduce using rule 64 (primitive_type -> BOOL_TYPE .)
    IF              reduce using rule 64 (primitive_type -> BOOL_TYPE .)
    SWITCH          reduce using rule 64 (primitive_type -> BOOL_TYPE .)
    RETURN          reduce using rule 64 (primitive_type -> BOOL_TYPE .)
    LBRACKET        reduce using rule 64 (primitive_type -> BOOL_TYPE .)
    MAP             reduce using rule 64 (primitive_type -> BOOL_TYPE .)
    FOR             reduce using rule 64 (primitive_type -> BOOL_TYPE .)
    SEMICOLON       reduce using rule 64 (primitive_type -> BOOL_TYPE .)
    CASE            reduce using rule 64 (primitive_type -> BOOL_TYPE .)
    DEFAULT         reduce using rule 64 (primitive_type -> BOOL_TYPE .)
    RBRACKET        reduce using rule 64 (primitive_type -> BOOL_TYPE .)


state 38

    (65) slice_type -> LBRACKET . RBRACKET primitive_type
    (197) array_type -> LBRACKET . INT RBRACKET primitive_type

    RBRACKET        shift and go to state 64
    INT             shift and go to state 65


state 39

    (137) map_type -> MAP . LBRACKET primitive_type RBRACKET primitive_type

    LBRACKET        shift and go to state 66


state 40

    (18) global_const_dec -> CONST IDENTIFIER type . ASSIGN expression

    ASSIGN          shift and go to state 67


state 41

    (19) global_const_dec -> CONST IDENTIFIER ASSIGN . expression
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (125) expression -> . LNOT expression
    (126) expression -> . IDENTIFIER PLUSPLUS
    (127) expression -> . IDENTIFIER MINUSMINUS
    (138) expression -> . map_type LBRACE expression_map_list RBRACE
    (139) expression -> . map_type LBRACE RBRACE
    (161) expression -> . type_name LBRACE keyed_element_list RBRACE
    (162) expression -> . type_name LBRACE RBRACE
    (198) expression -> . array_type LBRACE expression_list RBRACE
    (199) expression -> . array_type LBRACE RBRACE
    (200) expression -> . expression DOT IDENTIFIER
    (201) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> . expression LBRACKET expression RBRACKET
    (203) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (137) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (163) type_name -> . IDENTIFIER
    (164) type_name -> . slice_type
    (165) type_name -> . array_type
    (166) type_name -> . map_type
    (197) array_type -> . LBRACKET INT RBRACKET primitive_type

    LPAREN          shift and go to state 54
    INT             shift and go to state 55
    FLOAT64         shift and go to state 56
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 57
    TRUE            shift and go to state 58
    FALSE           shift and go to state 59
    LNOT            shift and go to state 60
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    expression                     shift and go to state 68
    slice_type                     shift and go to state 53
    map_type                       shift and go to state 61
    type_name                      shift and go to state 62
    array_type                     shift and go to state 63

state 42

    (112) function_declaration -> FUNC IDENTIFIER LPAREN . parameter_list RPAREN return_type block
    (113) parameter_list -> . parameter_list COMMA parameter
    (114) parameter_list -> . parameter
    (115) parameter_list -> . empty
    (116) parameter -> . IDENTIFIER type
    (117) parameter -> . IDENTIFIER ELLIPSIS primitive_type
    (7) empty -> .

    IDENTIFIER      shift and go to state 69
    RPAREN          reduce using rule 7 (empty -> .)
    COMMA           reduce using rule 7 (empty -> .)

    parameter_list                 shift and go to state 70
    parameter                      shift and go to state 71
    empty                          shift and go to state 72

state 43

    (146) method_declaration -> FUNC LPAREN receiver . RPAREN IDENTIFIER LPAREN parameter_list RPAREN return_type block

    RPAREN          shift and go to state 73


state 44

    (147) receiver -> IDENTIFIER . IDENTIFIER
    (148) receiver -> IDENTIFIER . TIMES IDENTIFIER
    (149) receiver -> IDENTIFIER . TIMES type

    IDENTIFIER      shift and go to state 74
    TIMES           shift and go to state 75


state 45

    (153) type_alias -> IDENTIFIER .

    VAR             reduce using rule 153 (type_alias -> IDENTIFIER .)
    CONST           reduce using rule 153 (type_alias -> IDENTIFIER .)
    FUNC            reduce using rule 153 (type_alias -> IDENTIFIER .)
    TYPE            reduce using rule 153 (type_alias -> IDENTIFIER .)
    $end            reduce using rule 153 (type_alias -> IDENTIFIER .)


state 46

    (150) type_declaration -> TYPE IDENTIFIER type_alias .

    VAR             reduce using rule 150 (type_declaration -> TYPE IDENTIFIER type_alias .)
    CONST           reduce using rule 150 (type_declaration -> TYPE IDENTIFIER type_alias .)
    FUNC            reduce using rule 150 (type_declaration -> TYPE IDENTIFIER type_alias .)
    TYPE            reduce using rule 150 (type_declaration -> TYPE IDENTIFIER type_alias .)
    $end            reduce using rule 150 (type_declaration -> TYPE IDENTIFIER type_alias .)


state 47

    (151) type_alias -> struct_type .

    VAR             reduce using rule 151 (type_alias -> struct_type .)
    CONST           reduce using rule 151 (type_alias -> struct_type .)
    FUNC            reduce using rule 151 (type_alias -> struct_type .)
    TYPE            reduce using rule 151 (type_alias -> struct_type .)
    $end            reduce using rule 151 (type_alias -> struct_type .)


state 48

    (152) type_alias -> type .

    VAR             reduce using rule 152 (type_alias -> type .)
    CONST           reduce using rule 152 (type_alias -> type .)
    FUNC            reduce using rule 152 (type_alias -> type .)
    TYPE            reduce using rule 152 (type_alias -> type .)
    $end            reduce using rule 152 (type_alias -> type .)


state 49

    (154) struct_type -> STRUCT . LBRACE RBRACE
    (155) struct_type -> STRUCT . LBRACE field_list RBRACE

    LBRACE          shift and go to state 76


state 50

    (16) global_var_dec -> VAR IDENTIFIER type ASSIGN . expression
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (125) expression -> . LNOT expression
    (126) expression -> . IDENTIFIER PLUSPLUS
    (127) expression -> . IDENTIFIER MINUSMINUS
    (138) expression -> . map_type LBRACE expression_map_list RBRACE
    (139) expression -> . map_type LBRACE RBRACE
    (161) expression -> . type_name LBRACE keyed_element_list RBRACE
    (162) expression -> . type_name LBRACE RBRACE
    (198) expression -> . array_type LBRACE expression_list RBRACE
    (199) expression -> . array_type LBRACE RBRACE
    (200) expression -> . expression DOT IDENTIFIER
    (201) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> . expression LBRACKET expression RBRACKET
    (203) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (137) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (163) type_name -> . IDENTIFIER
    (164) type_name -> . slice_type
    (165) type_name -> . array_type
    (166) type_name -> . map_type
    (197) array_type -> . LBRACKET INT RBRACKET primitive_type

    LPAREN          shift and go to state 54
    INT             shift and go to state 55
    FLOAT64         shift and go to state 56
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 57
    TRUE            shift and go to state 58
    FALSE           shift and go to state 59
    LNOT            shift and go to state 60
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    expression                     shift and go to state 77
    slice_type                     shift and go to state 53
    map_type                       shift and go to state 61
    type_name                      shift and go to state 62
    array_type                     shift and go to state 63

state 51

    (73) expression -> IDENTIFIER .
    (126) expression -> IDENTIFIER . PLUSPLUS
    (127) expression -> IDENTIFIER . MINUSMINUS
    (203) expression -> IDENTIFIER . LPAREN argument_list RPAREN
    (163) type_name -> IDENTIFIER .

  ! shift/reduce conflict for LPAREN resolved as shift
  ! reduce/reduce conflict for LBRACE resolved using rule 73 (expression -> IDENTIFIER .)
    DOT             reduce using rule 73 (expression -> IDENTIFIER .)
    LBRACKET        reduce using rule 73 (expression -> IDENTIFIER .)
    PLUS            reduce using rule 73 (expression -> IDENTIFIER .)
    MINUS           reduce using rule 73 (expression -> IDENTIFIER .)
    TIMES           reduce using rule 73 (expression -> IDENTIFIER .)
    DIVIDE          reduce using rule 73 (expression -> IDENTIFIER .)
    MODULE          reduce using rule 73 (expression -> IDENTIFIER .)
    EQ              reduce using rule 73 (expression -> IDENTIFIER .)
    NEQ             reduce using rule 73 (expression -> IDENTIFIER .)
    LT              reduce using rule 73 (expression -> IDENTIFIER .)
    LE              reduce using rule 73 (expression -> IDENTIFIER .)
    GT              reduce using rule 73 (expression -> IDENTIFIER .)
    GE              reduce using rule 73 (expression -> IDENTIFIER .)
    LAND            reduce using rule 73 (expression -> IDENTIFIER .)
    LOR             reduce using rule 73 (expression -> IDENTIFIER .)
    AND             reduce using rule 73 (expression -> IDENTIFIER .)
    OR              reduce using rule 73 (expression -> IDENTIFIER .)
    XOR             reduce using rule 73 (expression -> IDENTIFIER .)
    AND_NOT         reduce using rule 73 (expression -> IDENTIFIER .)
    LSHIFT          reduce using rule 73 (expression -> IDENTIFIER .)
    RSHIFT          reduce using rule 73 (expression -> IDENTIFIER .)
    VAR             reduce using rule 73 (expression -> IDENTIFIER .)
    CONST           reduce using rule 73 (expression -> IDENTIFIER .)
    FUNC            reduce using rule 73 (expression -> IDENTIFIER .)
    TYPE            reduce using rule 73 (expression -> IDENTIFIER .)
    $end            reduce using rule 73 (expression -> IDENTIFIER .)
    RPAREN          reduce using rule 73 (expression -> IDENTIFIER .)
    COMMA           reduce using rule 73 (expression -> IDENTIFIER .)
    RBRACKET        reduce using rule 73 (expression -> IDENTIFIER .)
    RBRACE          reduce using rule 73 (expression -> IDENTIFIER .)
    COLON           reduce using rule 73 (expression -> IDENTIFIER .)
    BREAK           reduce using rule 73 (expression -> IDENTIFIER .)
    CONTINUE        reduce using rule 73 (expression -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 73 (expression -> IDENTIFIER .)
    INT             reduce using rule 73 (expression -> IDENTIFIER .)
    FLOAT64         reduce using rule 73 (expression -> IDENTIFIER .)
    STRING          reduce using rule 73 (expression -> IDENTIFIER .)
    TRUE            reduce using rule 73 (expression -> IDENTIFIER .)
    FALSE           reduce using rule 73 (expression -> IDENTIFIER .)
    LNOT            reduce using rule 73 (expression -> IDENTIFIER .)
    IF              reduce using rule 73 (expression -> IDENTIFIER .)
    SWITCH          reduce using rule 73 (expression -> IDENTIFIER .)
    RETURN          reduce using rule 73 (expression -> IDENTIFIER .)
    MAP             reduce using rule 73 (expression -> IDENTIFIER .)
    FOR             reduce using rule 73 (expression -> IDENTIFIER .)
    LBRACE          reduce using rule 73 (expression -> IDENTIFIER .)
    CASE            reduce using rule 73 (expression -> IDENTIFIER .)
    DEFAULT         reduce using rule 73 (expression -> IDENTIFIER .)
    SEMICOLON       reduce using rule 73 (expression -> IDENTIFIER .)
    PLUSPLUS        shift and go to state 78
    MINUSMINUS      shift and go to state 79
    LPAREN          shift and go to state 80

  ! LPAREN          [ reduce using rule 73 (expression -> IDENTIFIER .) ]
  ! LBRACE          [ reduce using rule 163 (type_name -> IDENTIFIER .) ]


state 52

    (17) global_var_dec -> VAR IDENTIFIER ASSIGN expression .
    (36) expression -> expression . binary_operator expression
    (200) expression -> expression . DOT IDENTIFIER
    (201) expression -> expression . DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> expression . LBRACKET expression RBRACKET
    (37) binary_operator -> . PLUS
    (38) binary_operator -> . MINUS
    (39) binary_operator -> . TIMES
    (40) binary_operator -> . DIVIDE
    (41) binary_operator -> . MODULE
    (42) binary_operator -> . EQ
    (43) binary_operator -> . NEQ
    (44) binary_operator -> . LT
    (45) binary_operator -> . LE
    (46) binary_operator -> . GT
    (47) binary_operator -> . GE
    (48) binary_operator -> . LAND
    (49) binary_operator -> . LOR
    (50) binary_operator -> . AND
    (51) binary_operator -> . OR
    (52) binary_operator -> . XOR
    (53) binary_operator -> . AND_NOT
    (54) binary_operator -> . LSHIFT
    (55) binary_operator -> . RSHIFT

    VAR             reduce using rule 17 (global_var_dec -> VAR IDENTIFIER ASSIGN expression .)
    CONST           reduce using rule 17 (global_var_dec -> VAR IDENTIFIER ASSIGN expression .)
    FUNC            reduce using rule 17 (global_var_dec -> VAR IDENTIFIER ASSIGN expression .)
    TYPE            reduce using rule 17 (global_var_dec -> VAR IDENTIFIER ASSIGN expression .)
    $end            reduce using rule 17 (global_var_dec -> VAR IDENTIFIER ASSIGN expression .)
    DOT             shift and go to state 82
    LBRACKET        shift and go to state 83
    PLUS            shift and go to state 84
    MINUS           shift and go to state 85
    TIMES           shift and go to state 86
    DIVIDE          shift and go to state 87
    MODULE          shift and go to state 88
    EQ              shift and go to state 89
    NEQ             shift and go to state 90
    LT              shift and go to state 91
    LE              shift and go to state 92
    GT              shift and go to state 93
    GE              shift and go to state 94
    LAND            shift and go to state 95
    LOR             shift and go to state 96
    AND             shift and go to state 97
    OR              shift and go to state 98
    XOR             shift and go to state 99
    AND_NOT         shift and go to state 100
    LSHIFT          shift and go to state 101
    RSHIFT          shift and go to state 102

    binary_operator                shift and go to state 81

state 53

    (66) expression -> slice_type . LBRACE expression_list RBRACE
    (67) expression -> slice_type . LBRACE RBRACE
    (164) type_name -> slice_type .

  ! shift/reduce conflict for LBRACE resolved as shift
    LBRACE          shift and go to state 103

  ! LBRACE          [ reduce using rule 164 (type_name -> slice_type .) ]


state 54

    (70) expression -> LPAREN . expression RPAREN
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (125) expression -> . LNOT expression
    (126) expression -> . IDENTIFIER PLUSPLUS
    (127) expression -> . IDENTIFIER MINUSMINUS
    (138) expression -> . map_type LBRACE expression_map_list RBRACE
    (139) expression -> . map_type LBRACE RBRACE
    (161) expression -> . type_name LBRACE keyed_element_list RBRACE
    (162) expression -> . type_name LBRACE RBRACE
    (198) expression -> . array_type LBRACE expression_list RBRACE
    (199) expression -> . array_type LBRACE RBRACE
    (200) expression -> . expression DOT IDENTIFIER
    (201) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> . expression LBRACKET expression RBRACKET
    (203) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (137) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (163) type_name -> . IDENTIFIER
    (164) type_name -> . slice_type
    (165) type_name -> . array_type
    (166) type_name -> . map_type
    (197) array_type -> . LBRACKET INT RBRACKET primitive_type

    LPAREN          shift and go to state 54
    INT             shift and go to state 55
    FLOAT64         shift and go to state 56
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 57
    TRUE            shift and go to state 58
    FALSE           shift and go to state 59
    LNOT            shift and go to state 60
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    expression                     shift and go to state 104
    slice_type                     shift and go to state 53
    map_type                       shift and go to state 61
    type_name                      shift and go to state 62
    array_type                     shift and go to state 63

state 55

    (71) expression -> INT .

    DOT             reduce using rule 71 (expression -> INT .)
    LBRACKET        reduce using rule 71 (expression -> INT .)
    PLUS            reduce using rule 71 (expression -> INT .)
    MINUS           reduce using rule 71 (expression -> INT .)
    TIMES           reduce using rule 71 (expression -> INT .)
    DIVIDE          reduce using rule 71 (expression -> INT .)
    MODULE          reduce using rule 71 (expression -> INT .)
    EQ              reduce using rule 71 (expression -> INT .)
    NEQ             reduce using rule 71 (expression -> INT .)
    LT              reduce using rule 71 (expression -> INT .)
    LE              reduce using rule 71 (expression -> INT .)
    GT              reduce using rule 71 (expression -> INT .)
    GE              reduce using rule 71 (expression -> INT .)
    LAND            reduce using rule 71 (expression -> INT .)
    LOR             reduce using rule 71 (expression -> INT .)
    AND             reduce using rule 71 (expression -> INT .)
    OR              reduce using rule 71 (expression -> INT .)
    XOR             reduce using rule 71 (expression -> INT .)
    AND_NOT         reduce using rule 71 (expression -> INT .)
    LSHIFT          reduce using rule 71 (expression -> INT .)
    RSHIFT          reduce using rule 71 (expression -> INT .)
    VAR             reduce using rule 71 (expression -> INT .)
    CONST           reduce using rule 71 (expression -> INT .)
    FUNC            reduce using rule 71 (expression -> INT .)
    TYPE            reduce using rule 71 (expression -> INT .)
    $end            reduce using rule 71 (expression -> INT .)
    RPAREN          reduce using rule 71 (expression -> INT .)
    COMMA           reduce using rule 71 (expression -> INT .)
    RBRACKET        reduce using rule 71 (expression -> INT .)
    RBRACE          reduce using rule 71 (expression -> INT .)
    COLON           reduce using rule 71 (expression -> INT .)
    BREAK           reduce using rule 71 (expression -> INT .)
    CONTINUE        reduce using rule 71 (expression -> INT .)
    IDENTIFIER      reduce using rule 71 (expression -> INT .)
    LPAREN          reduce using rule 71 (expression -> INT .)
    INT             reduce using rule 71 (expression -> INT .)
    FLOAT64         reduce using rule 71 (expression -> INT .)
    STRING          reduce using rule 71 (expression -> INT .)
    TRUE            reduce using rule 71 (expression -> INT .)
    FALSE           reduce using rule 71 (expression -> INT .)
    LNOT            reduce using rule 71 (expression -> INT .)
    IF              reduce using rule 71 (expression -> INT .)
    SWITCH          reduce using rule 71 (expression -> INT .)
    RETURN          reduce using rule 71 (expression -> INT .)
    MAP             reduce using rule 71 (expression -> INT .)
    FOR             reduce using rule 71 (expression -> INT .)
    LBRACE          reduce using rule 71 (expression -> INT .)
    CASE            reduce using rule 71 (expression -> INT .)
    DEFAULT         reduce using rule 71 (expression -> INT .)
    SEMICOLON       reduce using rule 71 (expression -> INT .)


state 56

    (72) expression -> FLOAT64 .

    DOT             reduce using rule 72 (expression -> FLOAT64 .)
    LBRACKET        reduce using rule 72 (expression -> FLOAT64 .)
    PLUS            reduce using rule 72 (expression -> FLOAT64 .)
    MINUS           reduce using rule 72 (expression -> FLOAT64 .)
    TIMES           reduce using rule 72 (expression -> FLOAT64 .)
    DIVIDE          reduce using rule 72 (expression -> FLOAT64 .)
    MODULE          reduce using rule 72 (expression -> FLOAT64 .)
    EQ              reduce using rule 72 (expression -> FLOAT64 .)
    NEQ             reduce using rule 72 (expression -> FLOAT64 .)
    LT              reduce using rule 72 (expression -> FLOAT64 .)
    LE              reduce using rule 72 (expression -> FLOAT64 .)
    GT              reduce using rule 72 (expression -> FLOAT64 .)
    GE              reduce using rule 72 (expression -> FLOAT64 .)
    LAND            reduce using rule 72 (expression -> FLOAT64 .)
    LOR             reduce using rule 72 (expression -> FLOAT64 .)
    AND             reduce using rule 72 (expression -> FLOAT64 .)
    OR              reduce using rule 72 (expression -> FLOAT64 .)
    XOR             reduce using rule 72 (expression -> FLOAT64 .)
    AND_NOT         reduce using rule 72 (expression -> FLOAT64 .)
    LSHIFT          reduce using rule 72 (expression -> FLOAT64 .)
    RSHIFT          reduce using rule 72 (expression -> FLOAT64 .)
    VAR             reduce using rule 72 (expression -> FLOAT64 .)
    CONST           reduce using rule 72 (expression -> FLOAT64 .)
    FUNC            reduce using rule 72 (expression -> FLOAT64 .)
    TYPE            reduce using rule 72 (expression -> FLOAT64 .)
    $end            reduce using rule 72 (expression -> FLOAT64 .)
    RPAREN          reduce using rule 72 (expression -> FLOAT64 .)
    COMMA           reduce using rule 72 (expression -> FLOAT64 .)
    RBRACKET        reduce using rule 72 (expression -> FLOAT64 .)
    RBRACE          reduce using rule 72 (expression -> FLOAT64 .)
    COLON           reduce using rule 72 (expression -> FLOAT64 .)
    BREAK           reduce using rule 72 (expression -> FLOAT64 .)
    CONTINUE        reduce using rule 72 (expression -> FLOAT64 .)
    IDENTIFIER      reduce using rule 72 (expression -> FLOAT64 .)
    LPAREN          reduce using rule 72 (expression -> FLOAT64 .)
    INT             reduce using rule 72 (expression -> FLOAT64 .)
    FLOAT64         reduce using rule 72 (expression -> FLOAT64 .)
    STRING          reduce using rule 72 (expression -> FLOAT64 .)
    TRUE            reduce using rule 72 (expression -> FLOAT64 .)
    FALSE           reduce using rule 72 (expression -> FLOAT64 .)
    LNOT            reduce using rule 72 (expression -> FLOAT64 .)
    IF              reduce using rule 72 (expression -> FLOAT64 .)
    SWITCH          reduce using rule 72 (expression -> FLOAT64 .)
    RETURN          reduce using rule 72 (expression -> FLOAT64 .)
    MAP             reduce using rule 72 (expression -> FLOAT64 .)
    FOR             reduce using rule 72 (expression -> FLOAT64 .)
    LBRACE          reduce using rule 72 (expression -> FLOAT64 .)
    CASE            reduce using rule 72 (expression -> FLOAT64 .)
    DEFAULT         reduce using rule 72 (expression -> FLOAT64 .)
    SEMICOLON       reduce using rule 72 (expression -> FLOAT64 .)


state 57

    (74) expression -> STRING .

    DOT             reduce using rule 74 (expression -> STRING .)
    LBRACKET        reduce using rule 74 (expression -> STRING .)
    PLUS            reduce using rule 74 (expression -> STRING .)
    MINUS           reduce using rule 74 (expression -> STRING .)
    TIMES           reduce using rule 74 (expression -> STRING .)
    DIVIDE          reduce using rule 74 (expression -> STRING .)
    MODULE          reduce using rule 74 (expression -> STRING .)
    EQ              reduce using rule 74 (expression -> STRING .)
    NEQ             reduce using rule 74 (expression -> STRING .)
    LT              reduce using rule 74 (expression -> STRING .)
    LE              reduce using rule 74 (expression -> STRING .)
    GT              reduce using rule 74 (expression -> STRING .)
    GE              reduce using rule 74 (expression -> STRING .)
    LAND            reduce using rule 74 (expression -> STRING .)
    LOR             reduce using rule 74 (expression -> STRING .)
    AND             reduce using rule 74 (expression -> STRING .)
    OR              reduce using rule 74 (expression -> STRING .)
    XOR             reduce using rule 74 (expression -> STRING .)
    AND_NOT         reduce using rule 74 (expression -> STRING .)
    LSHIFT          reduce using rule 74 (expression -> STRING .)
    RSHIFT          reduce using rule 74 (expression -> STRING .)
    VAR             reduce using rule 74 (expression -> STRING .)
    CONST           reduce using rule 74 (expression -> STRING .)
    FUNC            reduce using rule 74 (expression -> STRING .)
    TYPE            reduce using rule 74 (expression -> STRING .)
    $end            reduce using rule 74 (expression -> STRING .)
    RPAREN          reduce using rule 74 (expression -> STRING .)
    COMMA           reduce using rule 74 (expression -> STRING .)
    RBRACKET        reduce using rule 74 (expression -> STRING .)
    RBRACE          reduce using rule 74 (expression -> STRING .)
    COLON           reduce using rule 74 (expression -> STRING .)
    BREAK           reduce using rule 74 (expression -> STRING .)
    CONTINUE        reduce using rule 74 (expression -> STRING .)
    IDENTIFIER      reduce using rule 74 (expression -> STRING .)
    LPAREN          reduce using rule 74 (expression -> STRING .)
    INT             reduce using rule 74 (expression -> STRING .)
    FLOAT64         reduce using rule 74 (expression -> STRING .)
    STRING          reduce using rule 74 (expression -> STRING .)
    TRUE            reduce using rule 74 (expression -> STRING .)
    FALSE           reduce using rule 74 (expression -> STRING .)
    LNOT            reduce using rule 74 (expression -> STRING .)
    IF              reduce using rule 74 (expression -> STRING .)
    SWITCH          reduce using rule 74 (expression -> STRING .)
    RETURN          reduce using rule 74 (expression -> STRING .)
    MAP             reduce using rule 74 (expression -> STRING .)
    FOR             reduce using rule 74 (expression -> STRING .)
    LBRACE          reduce using rule 74 (expression -> STRING .)
    CASE            reduce using rule 74 (expression -> STRING .)
    DEFAULT         reduce using rule 74 (expression -> STRING .)
    SEMICOLON       reduce using rule 74 (expression -> STRING .)


state 58

    (75) expression -> TRUE .

    DOT             reduce using rule 75 (expression -> TRUE .)
    LBRACKET        reduce using rule 75 (expression -> TRUE .)
    PLUS            reduce using rule 75 (expression -> TRUE .)
    MINUS           reduce using rule 75 (expression -> TRUE .)
    TIMES           reduce using rule 75 (expression -> TRUE .)
    DIVIDE          reduce using rule 75 (expression -> TRUE .)
    MODULE          reduce using rule 75 (expression -> TRUE .)
    EQ              reduce using rule 75 (expression -> TRUE .)
    NEQ             reduce using rule 75 (expression -> TRUE .)
    LT              reduce using rule 75 (expression -> TRUE .)
    LE              reduce using rule 75 (expression -> TRUE .)
    GT              reduce using rule 75 (expression -> TRUE .)
    GE              reduce using rule 75 (expression -> TRUE .)
    LAND            reduce using rule 75 (expression -> TRUE .)
    LOR             reduce using rule 75 (expression -> TRUE .)
    AND             reduce using rule 75 (expression -> TRUE .)
    OR              reduce using rule 75 (expression -> TRUE .)
    XOR             reduce using rule 75 (expression -> TRUE .)
    AND_NOT         reduce using rule 75 (expression -> TRUE .)
    LSHIFT          reduce using rule 75 (expression -> TRUE .)
    RSHIFT          reduce using rule 75 (expression -> TRUE .)
    VAR             reduce using rule 75 (expression -> TRUE .)
    CONST           reduce using rule 75 (expression -> TRUE .)
    FUNC            reduce using rule 75 (expression -> TRUE .)
    TYPE            reduce using rule 75 (expression -> TRUE .)
    $end            reduce using rule 75 (expression -> TRUE .)
    RPAREN          reduce using rule 75 (expression -> TRUE .)
    COMMA           reduce using rule 75 (expression -> TRUE .)
    RBRACKET        reduce using rule 75 (expression -> TRUE .)
    RBRACE          reduce using rule 75 (expression -> TRUE .)
    COLON           reduce using rule 75 (expression -> TRUE .)
    BREAK           reduce using rule 75 (expression -> TRUE .)
    CONTINUE        reduce using rule 75 (expression -> TRUE .)
    IDENTIFIER      reduce using rule 75 (expression -> TRUE .)
    LPAREN          reduce using rule 75 (expression -> TRUE .)
    INT             reduce using rule 75 (expression -> TRUE .)
    FLOAT64         reduce using rule 75 (expression -> TRUE .)
    STRING          reduce using rule 75 (expression -> TRUE .)
    TRUE            reduce using rule 75 (expression -> TRUE .)
    FALSE           reduce using rule 75 (expression -> TRUE .)
    LNOT            reduce using rule 75 (expression -> TRUE .)
    IF              reduce using rule 75 (expression -> TRUE .)
    SWITCH          reduce using rule 75 (expression -> TRUE .)
    RETURN          reduce using rule 75 (expression -> TRUE .)
    MAP             reduce using rule 75 (expression -> TRUE .)
    FOR             reduce using rule 75 (expression -> TRUE .)
    LBRACE          reduce using rule 75 (expression -> TRUE .)
    CASE            reduce using rule 75 (expression -> TRUE .)
    DEFAULT         reduce using rule 75 (expression -> TRUE .)
    SEMICOLON       reduce using rule 75 (expression -> TRUE .)


state 59

    (76) expression -> FALSE .

    DOT             reduce using rule 76 (expression -> FALSE .)
    LBRACKET        reduce using rule 76 (expression -> FALSE .)
    PLUS            reduce using rule 76 (expression -> FALSE .)
    MINUS           reduce using rule 76 (expression -> FALSE .)
    TIMES           reduce using rule 76 (expression -> FALSE .)
    DIVIDE          reduce using rule 76 (expression -> FALSE .)
    MODULE          reduce using rule 76 (expression -> FALSE .)
    EQ              reduce using rule 76 (expression -> FALSE .)
    NEQ             reduce using rule 76 (expression -> FALSE .)
    LT              reduce using rule 76 (expression -> FALSE .)
    LE              reduce using rule 76 (expression -> FALSE .)
    GT              reduce using rule 76 (expression -> FALSE .)
    GE              reduce using rule 76 (expression -> FALSE .)
    LAND            reduce using rule 76 (expression -> FALSE .)
    LOR             reduce using rule 76 (expression -> FALSE .)
    AND             reduce using rule 76 (expression -> FALSE .)
    OR              reduce using rule 76 (expression -> FALSE .)
    XOR             reduce using rule 76 (expression -> FALSE .)
    AND_NOT         reduce using rule 76 (expression -> FALSE .)
    LSHIFT          reduce using rule 76 (expression -> FALSE .)
    RSHIFT          reduce using rule 76 (expression -> FALSE .)
    VAR             reduce using rule 76 (expression -> FALSE .)
    CONST           reduce using rule 76 (expression -> FALSE .)
    FUNC            reduce using rule 76 (expression -> FALSE .)
    TYPE            reduce using rule 76 (expression -> FALSE .)
    $end            reduce using rule 76 (expression -> FALSE .)
    RPAREN          reduce using rule 76 (expression -> FALSE .)
    COMMA           reduce using rule 76 (expression -> FALSE .)
    RBRACKET        reduce using rule 76 (expression -> FALSE .)
    RBRACE          reduce using rule 76 (expression -> FALSE .)
    COLON           reduce using rule 76 (expression -> FALSE .)
    BREAK           reduce using rule 76 (expression -> FALSE .)
    CONTINUE        reduce using rule 76 (expression -> FALSE .)
    IDENTIFIER      reduce using rule 76 (expression -> FALSE .)
    LPAREN          reduce using rule 76 (expression -> FALSE .)
    INT             reduce using rule 76 (expression -> FALSE .)
    FLOAT64         reduce using rule 76 (expression -> FALSE .)
    STRING          reduce using rule 76 (expression -> FALSE .)
    TRUE            reduce using rule 76 (expression -> FALSE .)
    FALSE           reduce using rule 76 (expression -> FALSE .)
    LNOT            reduce using rule 76 (expression -> FALSE .)
    IF              reduce using rule 76 (expression -> FALSE .)
    SWITCH          reduce using rule 76 (expression -> FALSE .)
    RETURN          reduce using rule 76 (expression -> FALSE .)
    MAP             reduce using rule 76 (expression -> FALSE .)
    FOR             reduce using rule 76 (expression -> FALSE .)
    LBRACE          reduce using rule 76 (expression -> FALSE .)
    CASE            reduce using rule 76 (expression -> FALSE .)
    DEFAULT         reduce using rule 76 (expression -> FALSE .)
    SEMICOLON       reduce using rule 76 (expression -> FALSE .)


state 60

    (125) expression -> LNOT . expression
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (125) expression -> . LNOT expression
    (126) expression -> . IDENTIFIER PLUSPLUS
    (127) expression -> . IDENTIFIER MINUSMINUS
    (138) expression -> . map_type LBRACE expression_map_list RBRACE
    (139) expression -> . map_type LBRACE RBRACE
    (161) expression -> . type_name LBRACE keyed_element_list RBRACE
    (162) expression -> . type_name LBRACE RBRACE
    (198) expression -> . array_type LBRACE expression_list RBRACE
    (199) expression -> . array_type LBRACE RBRACE
    (200) expression -> . expression DOT IDENTIFIER
    (201) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> . expression LBRACKET expression RBRACKET
    (203) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (137) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (163) type_name -> . IDENTIFIER
    (164) type_name -> . slice_type
    (165) type_name -> . array_type
    (166) type_name -> . map_type
    (197) array_type -> . LBRACKET INT RBRACKET primitive_type

    LPAREN          shift and go to state 54
    INT             shift and go to state 55
    FLOAT64         shift and go to state 56
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 57
    TRUE            shift and go to state 58
    FALSE           shift and go to state 59
    LNOT            shift and go to state 60
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    expression                     shift and go to state 105
    slice_type                     shift and go to state 53
    map_type                       shift and go to state 61
    type_name                      shift and go to state 62
    array_type                     shift and go to state 63

state 61

    (138) expression -> map_type . LBRACE expression_map_list RBRACE
    (139) expression -> map_type . LBRACE RBRACE
    (166) type_name -> map_type .

  ! shift/reduce conflict for LBRACE resolved as shift
    LBRACE          shift and go to state 106

  ! LBRACE          [ reduce using rule 166 (type_name -> map_type .) ]


state 62

    (161) expression -> type_name . LBRACE keyed_element_list RBRACE
    (162) expression -> type_name . LBRACE RBRACE

    LBRACE          shift and go to state 107


state 63

    (198) expression -> array_type . LBRACE expression_list RBRACE
    (199) expression -> array_type . LBRACE RBRACE
    (165) type_name -> array_type .

  ! shift/reduce conflict for LBRACE resolved as shift
    LBRACE          shift and go to state 108

  ! LBRACE          [ reduce using rule 165 (type_name -> array_type .) ]


state 64

    (65) slice_type -> LBRACKET RBRACKET . primitive_type
    (61) primitive_type -> . INT_TYPE
    (62) primitive_type -> . FLOAT64_TYPE
    (63) primitive_type -> . STRING_TYPE
    (64) primitive_type -> . BOOL_TYPE

    INT_TYPE        shift and go to state 34
    FLOAT64_TYPE    shift and go to state 35
    STRING_TYPE     shift and go to state 36
    BOOL_TYPE       shift and go to state 37

    primitive_type                 shift and go to state 109

state 65

    (197) array_type -> LBRACKET INT . RBRACKET primitive_type

    RBRACKET        shift and go to state 110


state 66

    (137) map_type -> MAP LBRACKET . primitive_type RBRACKET primitive_type
    (61) primitive_type -> . INT_TYPE
    (62) primitive_type -> . FLOAT64_TYPE
    (63) primitive_type -> . STRING_TYPE
    (64) primitive_type -> . BOOL_TYPE

    INT_TYPE        shift and go to state 34
    FLOAT64_TYPE    shift and go to state 35
    STRING_TYPE     shift and go to state 36
    BOOL_TYPE       shift and go to state 37

    primitive_type                 shift and go to state 111

state 67

    (18) global_const_dec -> CONST IDENTIFIER type ASSIGN . expression
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (125) expression -> . LNOT expression
    (126) expression -> . IDENTIFIER PLUSPLUS
    (127) expression -> . IDENTIFIER MINUSMINUS
    (138) expression -> . map_type LBRACE expression_map_list RBRACE
    (139) expression -> . map_type LBRACE RBRACE
    (161) expression -> . type_name LBRACE keyed_element_list RBRACE
    (162) expression -> . type_name LBRACE RBRACE
    (198) expression -> . array_type LBRACE expression_list RBRACE
    (199) expression -> . array_type LBRACE RBRACE
    (200) expression -> . expression DOT IDENTIFIER
    (201) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> . expression LBRACKET expression RBRACKET
    (203) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (137) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (163) type_name -> . IDENTIFIER
    (164) type_name -> . slice_type
    (165) type_name -> . array_type
    (166) type_name -> . map_type
    (197) array_type -> . LBRACKET INT RBRACKET primitive_type

    LPAREN          shift and go to state 54
    INT             shift and go to state 55
    FLOAT64         shift and go to state 56
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 57
    TRUE            shift and go to state 58
    FALSE           shift and go to state 59
    LNOT            shift and go to state 60
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    expression                     shift and go to state 112
    slice_type                     shift and go to state 53
    map_type                       shift and go to state 61
    type_name                      shift and go to state 62
    array_type                     shift and go to state 63

state 68

    (19) global_const_dec -> CONST IDENTIFIER ASSIGN expression .
    (36) expression -> expression . binary_operator expression
    (200) expression -> expression . DOT IDENTIFIER
    (201) expression -> expression . DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> expression . LBRACKET expression RBRACKET
    (37) binary_operator -> . PLUS
    (38) binary_operator -> . MINUS
    (39) binary_operator -> . TIMES
    (40) binary_operator -> . DIVIDE
    (41) binary_operator -> . MODULE
    (42) binary_operator -> . EQ
    (43) binary_operator -> . NEQ
    (44) binary_operator -> . LT
    (45) binary_operator -> . LE
    (46) binary_operator -> . GT
    (47) binary_operator -> . GE
    (48) binary_operator -> . LAND
    (49) binary_operator -> . LOR
    (50) binary_operator -> . AND
    (51) binary_operator -> . OR
    (52) binary_operator -> . XOR
    (53) binary_operator -> . AND_NOT
    (54) binary_operator -> . LSHIFT
    (55) binary_operator -> . RSHIFT

    VAR             reduce using rule 19 (global_const_dec -> CONST IDENTIFIER ASSIGN expression .)
    CONST           reduce using rule 19 (global_const_dec -> CONST IDENTIFIER ASSIGN expression .)
    FUNC            reduce using rule 19 (global_const_dec -> CONST IDENTIFIER ASSIGN expression .)
    TYPE            reduce using rule 19 (global_const_dec -> CONST IDENTIFIER ASSIGN expression .)
    $end            reduce using rule 19 (global_const_dec -> CONST IDENTIFIER ASSIGN expression .)
    DOT             shift and go to state 82
    LBRACKET        shift and go to state 83
    PLUS            shift and go to state 84
    MINUS           shift and go to state 85
    TIMES           shift and go to state 86
    DIVIDE          shift and go to state 87
    MODULE          shift and go to state 88
    EQ              shift and go to state 89
    NEQ             shift and go to state 90
    LT              shift and go to state 91
    LE              shift and go to state 92
    GT              shift and go to state 93
    GE              shift and go to state 94
    LAND            shift and go to state 95
    LOR             shift and go to state 96
    AND             shift and go to state 97
    OR              shift and go to state 98
    XOR             shift and go to state 99
    AND_NOT         shift and go to state 100
    LSHIFT          shift and go to state 101
    RSHIFT          shift and go to state 102

    binary_operator                shift and go to state 81

state 69

    (116) parameter -> IDENTIFIER . type
    (117) parameter -> IDENTIFIER . ELLIPSIS primitive_type
    (57) type -> . primitive_type
    (58) type -> . slice_type
    (59) type -> . array_type
    (60) type -> . map_type
    (61) primitive_type -> . INT_TYPE
    (62) primitive_type -> . FLOAT64_TYPE
    (63) primitive_type -> . STRING_TYPE
    (64) primitive_type -> . BOOL_TYPE
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (197) array_type -> . LBRACKET INT RBRACKET primitive_type
    (137) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type

    ELLIPSIS        shift and go to state 114
    INT_TYPE        shift and go to state 34
    FLOAT64_TYPE    shift and go to state 35
    STRING_TYPE     shift and go to state 36
    BOOL_TYPE       shift and go to state 37
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    type                           shift and go to state 113
    primitive_type                 shift and go to state 30
    slice_type                     shift and go to state 31
    array_type                     shift and go to state 32
    map_type                       shift and go to state 33

state 70

    (112) function_declaration -> FUNC IDENTIFIER LPAREN parameter_list . RPAREN return_type block
    (113) parameter_list -> parameter_list . COMMA parameter

    RPAREN          shift and go to state 115
    COMMA           shift and go to state 116


state 71

    (114) parameter_list -> parameter .

    RPAREN          reduce using rule 114 (parameter_list -> parameter .)
    COMMA           reduce using rule 114 (parameter_list -> parameter .)


state 72

    (115) parameter_list -> empty .

    RPAREN          reduce using rule 115 (parameter_list -> empty .)
    COMMA           reduce using rule 115 (parameter_list -> empty .)


state 73

    (146) method_declaration -> FUNC LPAREN receiver RPAREN . IDENTIFIER LPAREN parameter_list RPAREN return_type block

    IDENTIFIER      shift and go to state 117


state 74

    (147) receiver -> IDENTIFIER IDENTIFIER .

    RPAREN          reduce using rule 147 (receiver -> IDENTIFIER IDENTIFIER .)


state 75

    (148) receiver -> IDENTIFIER TIMES . IDENTIFIER
    (149) receiver -> IDENTIFIER TIMES . type
    (57) type -> . primitive_type
    (58) type -> . slice_type
    (59) type -> . array_type
    (60) type -> . map_type
    (61) primitive_type -> . INT_TYPE
    (62) primitive_type -> . FLOAT64_TYPE
    (63) primitive_type -> . STRING_TYPE
    (64) primitive_type -> . BOOL_TYPE
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (197) array_type -> . LBRACKET INT RBRACKET primitive_type
    (137) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type

    IDENTIFIER      shift and go to state 118
    INT_TYPE        shift and go to state 34
    FLOAT64_TYPE    shift and go to state 35
    STRING_TYPE     shift and go to state 36
    BOOL_TYPE       shift and go to state 37
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    type                           shift and go to state 119
    primitive_type                 shift and go to state 30
    slice_type                     shift and go to state 31
    array_type                     shift and go to state 32
    map_type                       shift and go to state 33

state 76

    (154) struct_type -> STRUCT LBRACE . RBRACE
    (155) struct_type -> STRUCT LBRACE . field_list RBRACE
    (143) field_list -> . field_declaration
    (144) field_list -> . field_list field_declaration
    (145) field_declaration -> . IDENTIFIER type

    RBRACE          shift and go to state 120
    IDENTIFIER      shift and go to state 123

    field_list                     shift and go to state 121
    field_declaration              shift and go to state 122

state 77

    (16) global_var_dec -> VAR IDENTIFIER type ASSIGN expression .
    (36) expression -> expression . binary_operator expression
    (200) expression -> expression . DOT IDENTIFIER
    (201) expression -> expression . DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> expression . LBRACKET expression RBRACKET
    (37) binary_operator -> . PLUS
    (38) binary_operator -> . MINUS
    (39) binary_operator -> . TIMES
    (40) binary_operator -> . DIVIDE
    (41) binary_operator -> . MODULE
    (42) binary_operator -> . EQ
    (43) binary_operator -> . NEQ
    (44) binary_operator -> . LT
    (45) binary_operator -> . LE
    (46) binary_operator -> . GT
    (47) binary_operator -> . GE
    (48) binary_operator -> . LAND
    (49) binary_operator -> . LOR
    (50) binary_operator -> . AND
    (51) binary_operator -> . OR
    (52) binary_operator -> . XOR
    (53) binary_operator -> . AND_NOT
    (54) binary_operator -> . LSHIFT
    (55) binary_operator -> . RSHIFT

    VAR             reduce using rule 16 (global_var_dec -> VAR IDENTIFIER type ASSIGN expression .)
    CONST           reduce using rule 16 (global_var_dec -> VAR IDENTIFIER type ASSIGN expression .)
    FUNC            reduce using rule 16 (global_var_dec -> VAR IDENTIFIER type ASSIGN expression .)
    TYPE            reduce using rule 16 (global_var_dec -> VAR IDENTIFIER type ASSIGN expression .)
    $end            reduce using rule 16 (global_var_dec -> VAR IDENTIFIER type ASSIGN expression .)
    DOT             shift and go to state 82
    LBRACKET        shift and go to state 83
    PLUS            shift and go to state 84
    MINUS           shift and go to state 85
    TIMES           shift and go to state 86
    DIVIDE          shift and go to state 87
    MODULE          shift and go to state 88
    EQ              shift and go to state 89
    NEQ             shift and go to state 90
    LT              shift and go to state 91
    LE              shift and go to state 92
    GT              shift and go to state 93
    GE              shift and go to state 94
    LAND            shift and go to state 95
    LOR             shift and go to state 96
    AND             shift and go to state 97
    OR              shift and go to state 98
    XOR             shift and go to state 99
    AND_NOT         shift and go to state 100
    LSHIFT          shift and go to state 101
    RSHIFT          shift and go to state 102

    binary_operator                shift and go to state 81

state 78

    (126) expression -> IDENTIFIER PLUSPLUS .

    DOT             reduce using rule 126 (expression -> IDENTIFIER PLUSPLUS .)
    LBRACKET        reduce using rule 126 (expression -> IDENTIFIER PLUSPLUS .)
    PLUS            reduce using rule 126 (expression -> IDENTIFIER PLUSPLUS .)
    MINUS           reduce using rule 126 (expression -> IDENTIFIER PLUSPLUS .)
    TIMES           reduce using rule 126 (expression -> IDENTIFIER PLUSPLUS .)
    DIVIDE          reduce using rule 126 (expression -> IDENTIFIER PLUSPLUS .)
    MODULE          reduce using rule 126 (expression -> IDENTIFIER PLUSPLUS .)
    EQ              reduce using rule 126 (expression -> IDENTIFIER PLUSPLUS .)
    NEQ             reduce using rule 126 (expression -> IDENTIFIER PLUSPLUS .)
    LT              reduce using rule 126 (expression -> IDENTIFIER PLUSPLUS .)
    LE              reduce using rule 126 (expression -> IDENTIFIER PLUSPLUS .)
    GT              reduce using rule 126 (expression -> IDENTIFIER PLUSPLUS .)
    GE              reduce using rule 126 (expression -> IDENTIFIER PLUSPLUS .)
    LAND            reduce using rule 126 (expression -> IDENTIFIER PLUSPLUS .)
    LOR             reduce using rule 126 (expression -> IDENTIFIER PLUSPLUS .)
    AND             reduce using rule 126 (expression -> IDENTIFIER PLUSPLUS .)
    OR              reduce using rule 126 (expression -> IDENTIFIER PLUSPLUS .)
    XOR             reduce using rule 126 (expression -> IDENTIFIER PLUSPLUS .)
    AND_NOT         reduce using rule 126 (expression -> IDENTIFIER PLUSPLUS .)
    LSHIFT          reduce using rule 126 (expression -> IDENTIFIER PLUSPLUS .)
    RSHIFT          reduce using rule 126 (expression -> IDENTIFIER PLUSPLUS .)
    VAR             reduce using rule 126 (expression -> IDENTIFIER PLUSPLUS .)
    CONST           reduce using rule 126 (expression -> IDENTIFIER PLUSPLUS .)
    FUNC            reduce using rule 126 (expression -> IDENTIFIER PLUSPLUS .)
    TYPE            reduce using rule 126 (expression -> IDENTIFIER PLUSPLUS .)
    $end            reduce using rule 126 (expression -> IDENTIFIER PLUSPLUS .)
    RPAREN          reduce using rule 126 (expression -> IDENTIFIER PLUSPLUS .)
    COMMA           reduce using rule 126 (expression -> IDENTIFIER PLUSPLUS .)
    RBRACKET        reduce using rule 126 (expression -> IDENTIFIER PLUSPLUS .)
    RBRACE          reduce using rule 126 (expression -> IDENTIFIER PLUSPLUS .)
    COLON           reduce using rule 126 (expression -> IDENTIFIER PLUSPLUS .)
    BREAK           reduce using rule 126 (expression -> IDENTIFIER PLUSPLUS .)
    CONTINUE        reduce using rule 126 (expression -> IDENTIFIER PLUSPLUS .)
    IDENTIFIER      reduce using rule 126 (expression -> IDENTIFIER PLUSPLUS .)
    LPAREN          reduce using rule 126 (expression -> IDENTIFIER PLUSPLUS .)
    INT             reduce using rule 126 (expression -> IDENTIFIER PLUSPLUS .)
    FLOAT64         reduce using rule 126 (expression -> IDENTIFIER PLUSPLUS .)
    STRING          reduce using rule 126 (expression -> IDENTIFIER PLUSPLUS .)
    TRUE            reduce using rule 126 (expression -> IDENTIFIER PLUSPLUS .)
    FALSE           reduce using rule 126 (expression -> IDENTIFIER PLUSPLUS .)
    LNOT            reduce using rule 126 (expression -> IDENTIFIER PLUSPLUS .)
    IF              reduce using rule 126 (expression -> IDENTIFIER PLUSPLUS .)
    SWITCH          reduce using rule 126 (expression -> IDENTIFIER PLUSPLUS .)
    RETURN          reduce using rule 126 (expression -> IDENTIFIER PLUSPLUS .)
    MAP             reduce using rule 126 (expression -> IDENTIFIER PLUSPLUS .)
    FOR             reduce using rule 126 (expression -> IDENTIFIER PLUSPLUS .)
    LBRACE          reduce using rule 126 (expression -> IDENTIFIER PLUSPLUS .)
    CASE            reduce using rule 126 (expression -> IDENTIFIER PLUSPLUS .)
    DEFAULT         reduce using rule 126 (expression -> IDENTIFIER PLUSPLUS .)
    SEMICOLON       reduce using rule 126 (expression -> IDENTIFIER PLUSPLUS .)


state 79

    (127) expression -> IDENTIFIER MINUSMINUS .

    DOT             reduce using rule 127 (expression -> IDENTIFIER MINUSMINUS .)
    LBRACKET        reduce using rule 127 (expression -> IDENTIFIER MINUSMINUS .)
    PLUS            reduce using rule 127 (expression -> IDENTIFIER MINUSMINUS .)
    MINUS           reduce using rule 127 (expression -> IDENTIFIER MINUSMINUS .)
    TIMES           reduce using rule 127 (expression -> IDENTIFIER MINUSMINUS .)
    DIVIDE          reduce using rule 127 (expression -> IDENTIFIER MINUSMINUS .)
    MODULE          reduce using rule 127 (expression -> IDENTIFIER MINUSMINUS .)
    EQ              reduce using rule 127 (expression -> IDENTIFIER MINUSMINUS .)
    NEQ             reduce using rule 127 (expression -> IDENTIFIER MINUSMINUS .)
    LT              reduce using rule 127 (expression -> IDENTIFIER MINUSMINUS .)
    LE              reduce using rule 127 (expression -> IDENTIFIER MINUSMINUS .)
    GT              reduce using rule 127 (expression -> IDENTIFIER MINUSMINUS .)
    GE              reduce using rule 127 (expression -> IDENTIFIER MINUSMINUS .)
    LAND            reduce using rule 127 (expression -> IDENTIFIER MINUSMINUS .)
    LOR             reduce using rule 127 (expression -> IDENTIFIER MINUSMINUS .)
    AND             reduce using rule 127 (expression -> IDENTIFIER MINUSMINUS .)
    OR              reduce using rule 127 (expression -> IDENTIFIER MINUSMINUS .)
    XOR             reduce using rule 127 (expression -> IDENTIFIER MINUSMINUS .)
    AND_NOT         reduce using rule 127 (expression -> IDENTIFIER MINUSMINUS .)
    LSHIFT          reduce using rule 127 (expression -> IDENTIFIER MINUSMINUS .)
    RSHIFT          reduce using rule 127 (expression -> IDENTIFIER MINUSMINUS .)
    VAR             reduce using rule 127 (expression -> IDENTIFIER MINUSMINUS .)
    CONST           reduce using rule 127 (expression -> IDENTIFIER MINUSMINUS .)
    FUNC            reduce using rule 127 (expression -> IDENTIFIER MINUSMINUS .)
    TYPE            reduce using rule 127 (expression -> IDENTIFIER MINUSMINUS .)
    $end            reduce using rule 127 (expression -> IDENTIFIER MINUSMINUS .)
    RPAREN          reduce using rule 127 (expression -> IDENTIFIER MINUSMINUS .)
    COMMA           reduce using rule 127 (expression -> IDENTIFIER MINUSMINUS .)
    RBRACKET        reduce using rule 127 (expression -> IDENTIFIER MINUSMINUS .)
    RBRACE          reduce using rule 127 (expression -> IDENTIFIER MINUSMINUS .)
    COLON           reduce using rule 127 (expression -> IDENTIFIER MINUSMINUS .)
    BREAK           reduce using rule 127 (expression -> IDENTIFIER MINUSMINUS .)
    CONTINUE        reduce using rule 127 (expression -> IDENTIFIER MINUSMINUS .)
    IDENTIFIER      reduce using rule 127 (expression -> IDENTIFIER MINUSMINUS .)
    LPAREN          reduce using rule 127 (expression -> IDENTIFIER MINUSMINUS .)
    INT             reduce using rule 127 (expression -> IDENTIFIER MINUSMINUS .)
    FLOAT64         reduce using rule 127 (expression -> IDENTIFIER MINUSMINUS .)
    STRING          reduce using rule 127 (expression -> IDENTIFIER MINUSMINUS .)
    TRUE            reduce using rule 127 (expression -> IDENTIFIER MINUSMINUS .)
    FALSE           reduce using rule 127 (expression -> IDENTIFIER MINUSMINUS .)
    LNOT            reduce using rule 127 (expression -> IDENTIFIER MINUSMINUS .)
    IF              reduce using rule 127 (expression -> IDENTIFIER MINUSMINUS .)
    SWITCH          reduce using rule 127 (expression -> IDENTIFIER MINUSMINUS .)
    RETURN          reduce using rule 127 (expression -> IDENTIFIER MINUSMINUS .)
    MAP             reduce using rule 127 (expression -> IDENTIFIER MINUSMINUS .)
    FOR             reduce using rule 127 (expression -> IDENTIFIER MINUSMINUS .)
    LBRACE          reduce using rule 127 (expression -> IDENTIFIER MINUSMINUS .)
    CASE            reduce using rule 127 (expression -> IDENTIFIER MINUSMINUS .)
    DEFAULT         reduce using rule 127 (expression -> IDENTIFIER MINUSMINUS .)
    SEMICOLON       reduce using rule 127 (expression -> IDENTIFIER MINUSMINUS .)


state 80

    (203) expression -> IDENTIFIER LPAREN . argument_list RPAREN
    (204) argument_list -> . expression_list
    (205) argument_list -> . empty
    (68) expression_list -> . expression
    (69) expression_list -> . expression_list COMMA expression
    (7) empty -> .
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (125) expression -> . LNOT expression
    (126) expression -> . IDENTIFIER PLUSPLUS
    (127) expression -> . IDENTIFIER MINUSMINUS
    (138) expression -> . map_type LBRACE expression_map_list RBRACE
    (139) expression -> . map_type LBRACE RBRACE
    (161) expression -> . type_name LBRACE keyed_element_list RBRACE
    (162) expression -> . type_name LBRACE RBRACE
    (198) expression -> . array_type LBRACE expression_list RBRACE
    (199) expression -> . array_type LBRACE RBRACE
    (200) expression -> . expression DOT IDENTIFIER
    (201) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> . expression LBRACKET expression RBRACKET
    (203) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (137) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (163) type_name -> . IDENTIFIER
    (164) type_name -> . slice_type
    (165) type_name -> . array_type
    (166) type_name -> . map_type
    (197) array_type -> . LBRACKET INT RBRACKET primitive_type

    RPAREN          reduce using rule 7 (empty -> .)
    LPAREN          shift and go to state 54
    INT             shift and go to state 55
    FLOAT64         shift and go to state 56
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 57
    TRUE            shift and go to state 58
    FALSE           shift and go to state 59
    LNOT            shift and go to state 60
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    argument_list                  shift and go to state 124
    expression_list                shift and go to state 125
    empty                          shift and go to state 126
    expression                     shift and go to state 127
    slice_type                     shift and go to state 53
    map_type                       shift and go to state 61
    type_name                      shift and go to state 62
    array_type                     shift and go to state 63

state 81

    (36) expression -> expression binary_operator . expression
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (125) expression -> . LNOT expression
    (126) expression -> . IDENTIFIER PLUSPLUS
    (127) expression -> . IDENTIFIER MINUSMINUS
    (138) expression -> . map_type LBRACE expression_map_list RBRACE
    (139) expression -> . map_type LBRACE RBRACE
    (161) expression -> . type_name LBRACE keyed_element_list RBRACE
    (162) expression -> . type_name LBRACE RBRACE
    (198) expression -> . array_type LBRACE expression_list RBRACE
    (199) expression -> . array_type LBRACE RBRACE
    (200) expression -> . expression DOT IDENTIFIER
    (201) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> . expression LBRACKET expression RBRACKET
    (203) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (137) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (163) type_name -> . IDENTIFIER
    (164) type_name -> . slice_type
    (165) type_name -> . array_type
    (166) type_name -> . map_type
    (197) array_type -> . LBRACKET INT RBRACKET primitive_type

    LPAREN          shift and go to state 54
    INT             shift and go to state 55
    FLOAT64         shift and go to state 56
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 57
    TRUE            shift and go to state 58
    FALSE           shift and go to state 59
    LNOT            shift and go to state 60
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    expression                     shift and go to state 128
    slice_type                     shift and go to state 53
    map_type                       shift and go to state 61
    type_name                      shift and go to state 62
    array_type                     shift and go to state 63

state 82

    (200) expression -> expression DOT . IDENTIFIER
    (201) expression -> expression DOT . IDENTIFIER LPAREN argument_list RPAREN

    IDENTIFIER      shift and go to state 129


state 83

    (202) expression -> expression LBRACKET . expression RBRACKET
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (125) expression -> . LNOT expression
    (126) expression -> . IDENTIFIER PLUSPLUS
    (127) expression -> . IDENTIFIER MINUSMINUS
    (138) expression -> . map_type LBRACE expression_map_list RBRACE
    (139) expression -> . map_type LBRACE RBRACE
    (161) expression -> . type_name LBRACE keyed_element_list RBRACE
    (162) expression -> . type_name LBRACE RBRACE
    (198) expression -> . array_type LBRACE expression_list RBRACE
    (199) expression -> . array_type LBRACE RBRACE
    (200) expression -> . expression DOT IDENTIFIER
    (201) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> . expression LBRACKET expression RBRACKET
    (203) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (137) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (163) type_name -> . IDENTIFIER
    (164) type_name -> . slice_type
    (165) type_name -> . array_type
    (166) type_name -> . map_type
    (197) array_type -> . LBRACKET INT RBRACKET primitive_type

    LPAREN          shift and go to state 54
    INT             shift and go to state 55
    FLOAT64         shift and go to state 56
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 57
    TRUE            shift and go to state 58
    FALSE           shift and go to state 59
    LNOT            shift and go to state 60
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    expression                     shift and go to state 130
    slice_type                     shift and go to state 53
    map_type                       shift and go to state 61
    type_name                      shift and go to state 62
    array_type                     shift and go to state 63

state 84

    (37) binary_operator -> PLUS .

    LPAREN          reduce using rule 37 (binary_operator -> PLUS .)
    INT             reduce using rule 37 (binary_operator -> PLUS .)
    FLOAT64         reduce using rule 37 (binary_operator -> PLUS .)
    IDENTIFIER      reduce using rule 37 (binary_operator -> PLUS .)
    STRING          reduce using rule 37 (binary_operator -> PLUS .)
    TRUE            reduce using rule 37 (binary_operator -> PLUS .)
    FALSE           reduce using rule 37 (binary_operator -> PLUS .)
    LNOT            reduce using rule 37 (binary_operator -> PLUS .)
    LBRACKET        reduce using rule 37 (binary_operator -> PLUS .)
    MAP             reduce using rule 37 (binary_operator -> PLUS .)


state 85

    (38) binary_operator -> MINUS .

    LPAREN          reduce using rule 38 (binary_operator -> MINUS .)
    INT             reduce using rule 38 (binary_operator -> MINUS .)
    FLOAT64         reduce using rule 38 (binary_operator -> MINUS .)
    IDENTIFIER      reduce using rule 38 (binary_operator -> MINUS .)
    STRING          reduce using rule 38 (binary_operator -> MINUS .)
    TRUE            reduce using rule 38 (binary_operator -> MINUS .)
    FALSE           reduce using rule 38 (binary_operator -> MINUS .)
    LNOT            reduce using rule 38 (binary_operator -> MINUS .)
    LBRACKET        reduce using rule 38 (binary_operator -> MINUS .)
    MAP             reduce using rule 38 (binary_operator -> MINUS .)


state 86

    (39) binary_operator -> TIMES .

    LPAREN          reduce using rule 39 (binary_operator -> TIMES .)
    INT             reduce using rule 39 (binary_operator -> TIMES .)
    FLOAT64         reduce using rule 39 (binary_operator -> TIMES .)
    IDENTIFIER      reduce using rule 39 (binary_operator -> TIMES .)
    STRING          reduce using rule 39 (binary_operator -> TIMES .)
    TRUE            reduce using rule 39 (binary_operator -> TIMES .)
    FALSE           reduce using rule 39 (binary_operator -> TIMES .)
    LNOT            reduce using rule 39 (binary_operator -> TIMES .)
    LBRACKET        reduce using rule 39 (binary_operator -> TIMES .)
    MAP             reduce using rule 39 (binary_operator -> TIMES .)


state 87

    (40) binary_operator -> DIVIDE .

    LPAREN          reduce using rule 40 (binary_operator -> DIVIDE .)
    INT             reduce using rule 40 (binary_operator -> DIVIDE .)
    FLOAT64         reduce using rule 40 (binary_operator -> DIVIDE .)
    IDENTIFIER      reduce using rule 40 (binary_operator -> DIVIDE .)
    STRING          reduce using rule 40 (binary_operator -> DIVIDE .)
    TRUE            reduce using rule 40 (binary_operator -> DIVIDE .)
    FALSE           reduce using rule 40 (binary_operator -> DIVIDE .)
    LNOT            reduce using rule 40 (binary_operator -> DIVIDE .)
    LBRACKET        reduce using rule 40 (binary_operator -> DIVIDE .)
    MAP             reduce using rule 40 (binary_operator -> DIVIDE .)


state 88

    (41) binary_operator -> MODULE .

    LPAREN          reduce using rule 41 (binary_operator -> MODULE .)
    INT             reduce using rule 41 (binary_operator -> MODULE .)
    FLOAT64         reduce using rule 41 (binary_operator -> MODULE .)
    IDENTIFIER      reduce using rule 41 (binary_operator -> MODULE .)
    STRING          reduce using rule 41 (binary_operator -> MODULE .)
    TRUE            reduce using rule 41 (binary_operator -> MODULE .)
    FALSE           reduce using rule 41 (binary_operator -> MODULE .)
    LNOT            reduce using rule 41 (binary_operator -> MODULE .)
    LBRACKET        reduce using rule 41 (binary_operator -> MODULE .)
    MAP             reduce using rule 41 (binary_operator -> MODULE .)


state 89

    (42) binary_operator -> EQ .

    LPAREN          reduce using rule 42 (binary_operator -> EQ .)
    INT             reduce using rule 42 (binary_operator -> EQ .)
    FLOAT64         reduce using rule 42 (binary_operator -> EQ .)
    IDENTIFIER      reduce using rule 42 (binary_operator -> EQ .)
    STRING          reduce using rule 42 (binary_operator -> EQ .)
    TRUE            reduce using rule 42 (binary_operator -> EQ .)
    FALSE           reduce using rule 42 (binary_operator -> EQ .)
    LNOT            reduce using rule 42 (binary_operator -> EQ .)
    LBRACKET        reduce using rule 42 (binary_operator -> EQ .)
    MAP             reduce using rule 42 (binary_operator -> EQ .)


state 90

    (43) binary_operator -> NEQ .

    LPAREN          reduce using rule 43 (binary_operator -> NEQ .)
    INT             reduce using rule 43 (binary_operator -> NEQ .)
    FLOAT64         reduce using rule 43 (binary_operator -> NEQ .)
    IDENTIFIER      reduce using rule 43 (binary_operator -> NEQ .)
    STRING          reduce using rule 43 (binary_operator -> NEQ .)
    TRUE            reduce using rule 43 (binary_operator -> NEQ .)
    FALSE           reduce using rule 43 (binary_operator -> NEQ .)
    LNOT            reduce using rule 43 (binary_operator -> NEQ .)
    LBRACKET        reduce using rule 43 (binary_operator -> NEQ .)
    MAP             reduce using rule 43 (binary_operator -> NEQ .)


state 91

    (44) binary_operator -> LT .

    LPAREN          reduce using rule 44 (binary_operator -> LT .)
    INT             reduce using rule 44 (binary_operator -> LT .)
    FLOAT64         reduce using rule 44 (binary_operator -> LT .)
    IDENTIFIER      reduce using rule 44 (binary_operator -> LT .)
    STRING          reduce using rule 44 (binary_operator -> LT .)
    TRUE            reduce using rule 44 (binary_operator -> LT .)
    FALSE           reduce using rule 44 (binary_operator -> LT .)
    LNOT            reduce using rule 44 (binary_operator -> LT .)
    LBRACKET        reduce using rule 44 (binary_operator -> LT .)
    MAP             reduce using rule 44 (binary_operator -> LT .)


state 92

    (45) binary_operator -> LE .

    LPAREN          reduce using rule 45 (binary_operator -> LE .)
    INT             reduce using rule 45 (binary_operator -> LE .)
    FLOAT64         reduce using rule 45 (binary_operator -> LE .)
    IDENTIFIER      reduce using rule 45 (binary_operator -> LE .)
    STRING          reduce using rule 45 (binary_operator -> LE .)
    TRUE            reduce using rule 45 (binary_operator -> LE .)
    FALSE           reduce using rule 45 (binary_operator -> LE .)
    LNOT            reduce using rule 45 (binary_operator -> LE .)
    LBRACKET        reduce using rule 45 (binary_operator -> LE .)
    MAP             reduce using rule 45 (binary_operator -> LE .)


state 93

    (46) binary_operator -> GT .

    LPAREN          reduce using rule 46 (binary_operator -> GT .)
    INT             reduce using rule 46 (binary_operator -> GT .)
    FLOAT64         reduce using rule 46 (binary_operator -> GT .)
    IDENTIFIER      reduce using rule 46 (binary_operator -> GT .)
    STRING          reduce using rule 46 (binary_operator -> GT .)
    TRUE            reduce using rule 46 (binary_operator -> GT .)
    FALSE           reduce using rule 46 (binary_operator -> GT .)
    LNOT            reduce using rule 46 (binary_operator -> GT .)
    LBRACKET        reduce using rule 46 (binary_operator -> GT .)
    MAP             reduce using rule 46 (binary_operator -> GT .)


state 94

    (47) binary_operator -> GE .

    LPAREN          reduce using rule 47 (binary_operator -> GE .)
    INT             reduce using rule 47 (binary_operator -> GE .)
    FLOAT64         reduce using rule 47 (binary_operator -> GE .)
    IDENTIFIER      reduce using rule 47 (binary_operator -> GE .)
    STRING          reduce using rule 47 (binary_operator -> GE .)
    TRUE            reduce using rule 47 (binary_operator -> GE .)
    FALSE           reduce using rule 47 (binary_operator -> GE .)
    LNOT            reduce using rule 47 (binary_operator -> GE .)
    LBRACKET        reduce using rule 47 (binary_operator -> GE .)
    MAP             reduce using rule 47 (binary_operator -> GE .)


state 95

    (48) binary_operator -> LAND .

    LPAREN          reduce using rule 48 (binary_operator -> LAND .)
    INT             reduce using rule 48 (binary_operator -> LAND .)
    FLOAT64         reduce using rule 48 (binary_operator -> LAND .)
    IDENTIFIER      reduce using rule 48 (binary_operator -> LAND .)
    STRING          reduce using rule 48 (binary_operator -> LAND .)
    TRUE            reduce using rule 48 (binary_operator -> LAND .)
    FALSE           reduce using rule 48 (binary_operator -> LAND .)
    LNOT            reduce using rule 48 (binary_operator -> LAND .)
    LBRACKET        reduce using rule 48 (binary_operator -> LAND .)
    MAP             reduce using rule 48 (binary_operator -> LAND .)


state 96

    (49) binary_operator -> LOR .

    LPAREN          reduce using rule 49 (binary_operator -> LOR .)
    INT             reduce using rule 49 (binary_operator -> LOR .)
    FLOAT64         reduce using rule 49 (binary_operator -> LOR .)
    IDENTIFIER      reduce using rule 49 (binary_operator -> LOR .)
    STRING          reduce using rule 49 (binary_operator -> LOR .)
    TRUE            reduce using rule 49 (binary_operator -> LOR .)
    FALSE           reduce using rule 49 (binary_operator -> LOR .)
    LNOT            reduce using rule 49 (binary_operator -> LOR .)
    LBRACKET        reduce using rule 49 (binary_operator -> LOR .)
    MAP             reduce using rule 49 (binary_operator -> LOR .)


state 97

    (50) binary_operator -> AND .

    LPAREN          reduce using rule 50 (binary_operator -> AND .)
    INT             reduce using rule 50 (binary_operator -> AND .)
    FLOAT64         reduce using rule 50 (binary_operator -> AND .)
    IDENTIFIER      reduce using rule 50 (binary_operator -> AND .)
    STRING          reduce using rule 50 (binary_operator -> AND .)
    TRUE            reduce using rule 50 (binary_operator -> AND .)
    FALSE           reduce using rule 50 (binary_operator -> AND .)
    LNOT            reduce using rule 50 (binary_operator -> AND .)
    LBRACKET        reduce using rule 50 (binary_operator -> AND .)
    MAP             reduce using rule 50 (binary_operator -> AND .)


state 98

    (51) binary_operator -> OR .

    LPAREN          reduce using rule 51 (binary_operator -> OR .)
    INT             reduce using rule 51 (binary_operator -> OR .)
    FLOAT64         reduce using rule 51 (binary_operator -> OR .)
    IDENTIFIER      reduce using rule 51 (binary_operator -> OR .)
    STRING          reduce using rule 51 (binary_operator -> OR .)
    TRUE            reduce using rule 51 (binary_operator -> OR .)
    FALSE           reduce using rule 51 (binary_operator -> OR .)
    LNOT            reduce using rule 51 (binary_operator -> OR .)
    LBRACKET        reduce using rule 51 (binary_operator -> OR .)
    MAP             reduce using rule 51 (binary_operator -> OR .)


state 99

    (52) binary_operator -> XOR .

    LPAREN          reduce using rule 52 (binary_operator -> XOR .)
    INT             reduce using rule 52 (binary_operator -> XOR .)
    FLOAT64         reduce using rule 52 (binary_operator -> XOR .)
    IDENTIFIER      reduce using rule 52 (binary_operator -> XOR .)
    STRING          reduce using rule 52 (binary_operator -> XOR .)
    TRUE            reduce using rule 52 (binary_operator -> XOR .)
    FALSE           reduce using rule 52 (binary_operator -> XOR .)
    LNOT            reduce using rule 52 (binary_operator -> XOR .)
    LBRACKET        reduce using rule 52 (binary_operator -> XOR .)
    MAP             reduce using rule 52 (binary_operator -> XOR .)


state 100

    (53) binary_operator -> AND_NOT .

    LPAREN          reduce using rule 53 (binary_operator -> AND_NOT .)
    INT             reduce using rule 53 (binary_operator -> AND_NOT .)
    FLOAT64         reduce using rule 53 (binary_operator -> AND_NOT .)
    IDENTIFIER      reduce using rule 53 (binary_operator -> AND_NOT .)
    STRING          reduce using rule 53 (binary_operator -> AND_NOT .)
    TRUE            reduce using rule 53 (binary_operator -> AND_NOT .)
    FALSE           reduce using rule 53 (binary_operator -> AND_NOT .)
    LNOT            reduce using rule 53 (binary_operator -> AND_NOT .)
    LBRACKET        reduce using rule 53 (binary_operator -> AND_NOT .)
    MAP             reduce using rule 53 (binary_operator -> AND_NOT .)


state 101

    (54) binary_operator -> LSHIFT .

    LPAREN          reduce using rule 54 (binary_operator -> LSHIFT .)
    INT             reduce using rule 54 (binary_operator -> LSHIFT .)
    FLOAT64         reduce using rule 54 (binary_operator -> LSHIFT .)
    IDENTIFIER      reduce using rule 54 (binary_operator -> LSHIFT .)
    STRING          reduce using rule 54 (binary_operator -> LSHIFT .)
    TRUE            reduce using rule 54 (binary_operator -> LSHIFT .)
    FALSE           reduce using rule 54 (binary_operator -> LSHIFT .)
    LNOT            reduce using rule 54 (binary_operator -> LSHIFT .)
    LBRACKET        reduce using rule 54 (binary_operator -> LSHIFT .)
    MAP             reduce using rule 54 (binary_operator -> LSHIFT .)


state 102

    (55) binary_operator -> RSHIFT .

    LPAREN          reduce using rule 55 (binary_operator -> RSHIFT .)
    INT             reduce using rule 55 (binary_operator -> RSHIFT .)
    FLOAT64         reduce using rule 55 (binary_operator -> RSHIFT .)
    IDENTIFIER      reduce using rule 55 (binary_operator -> RSHIFT .)
    STRING          reduce using rule 55 (binary_operator -> RSHIFT .)
    TRUE            reduce using rule 55 (binary_operator -> RSHIFT .)
    FALSE           reduce using rule 55 (binary_operator -> RSHIFT .)
    LNOT            reduce using rule 55 (binary_operator -> RSHIFT .)
    LBRACKET        reduce using rule 55 (binary_operator -> RSHIFT .)
    MAP             reduce using rule 55 (binary_operator -> RSHIFT .)


state 103

    (66) expression -> slice_type LBRACE . expression_list RBRACE
    (67) expression -> slice_type LBRACE . RBRACE
    (68) expression_list -> . expression
    (69) expression_list -> . expression_list COMMA expression
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (125) expression -> . LNOT expression
    (126) expression -> . IDENTIFIER PLUSPLUS
    (127) expression -> . IDENTIFIER MINUSMINUS
    (138) expression -> . map_type LBRACE expression_map_list RBRACE
    (139) expression -> . map_type LBRACE RBRACE
    (161) expression -> . type_name LBRACE keyed_element_list RBRACE
    (162) expression -> . type_name LBRACE RBRACE
    (198) expression -> . array_type LBRACE expression_list RBRACE
    (199) expression -> . array_type LBRACE RBRACE
    (200) expression -> . expression DOT IDENTIFIER
    (201) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> . expression LBRACKET expression RBRACKET
    (203) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (137) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (163) type_name -> . IDENTIFIER
    (164) type_name -> . slice_type
    (165) type_name -> . array_type
    (166) type_name -> . map_type
    (197) array_type -> . LBRACKET INT RBRACKET primitive_type

    RBRACE          shift and go to state 132
    LPAREN          shift and go to state 54
    INT             shift and go to state 55
    FLOAT64         shift and go to state 56
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 57
    TRUE            shift and go to state 58
    FALSE           shift and go to state 59
    LNOT            shift and go to state 60
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    slice_type                     shift and go to state 53
    expression_list                shift and go to state 131
    expression                     shift and go to state 127
    map_type                       shift and go to state 61
    type_name                      shift and go to state 62
    array_type                     shift and go to state 63

state 104

    (70) expression -> LPAREN expression . RPAREN
    (36) expression -> expression . binary_operator expression
    (200) expression -> expression . DOT IDENTIFIER
    (201) expression -> expression . DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> expression . LBRACKET expression RBRACKET
    (37) binary_operator -> . PLUS
    (38) binary_operator -> . MINUS
    (39) binary_operator -> . TIMES
    (40) binary_operator -> . DIVIDE
    (41) binary_operator -> . MODULE
    (42) binary_operator -> . EQ
    (43) binary_operator -> . NEQ
    (44) binary_operator -> . LT
    (45) binary_operator -> . LE
    (46) binary_operator -> . GT
    (47) binary_operator -> . GE
    (48) binary_operator -> . LAND
    (49) binary_operator -> . LOR
    (50) binary_operator -> . AND
    (51) binary_operator -> . OR
    (52) binary_operator -> . XOR
    (53) binary_operator -> . AND_NOT
    (54) binary_operator -> . LSHIFT
    (55) binary_operator -> . RSHIFT

    RPAREN          shift and go to state 133
    DOT             shift and go to state 82
    LBRACKET        shift and go to state 83
    PLUS            shift and go to state 84
    MINUS           shift and go to state 85
    TIMES           shift and go to state 86
    DIVIDE          shift and go to state 87
    MODULE          shift and go to state 88
    EQ              shift and go to state 89
    NEQ             shift and go to state 90
    LT              shift and go to state 91
    LE              shift and go to state 92
    GT              shift and go to state 93
    GE              shift and go to state 94
    LAND            shift and go to state 95
    LOR             shift and go to state 96
    AND             shift and go to state 97
    OR              shift and go to state 98
    XOR             shift and go to state 99
    AND_NOT         shift and go to state 100
    LSHIFT          shift and go to state 101
    RSHIFT          shift and go to state 102

    binary_operator                shift and go to state 81

state 105

    (125) expression -> LNOT expression .
    (36) expression -> expression . binary_operator expression
    (200) expression -> expression . DOT IDENTIFIER
    (201) expression -> expression . DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> expression . LBRACKET expression RBRACKET
    (37) binary_operator -> . PLUS
    (38) binary_operator -> . MINUS
    (39) binary_operator -> . TIMES
    (40) binary_operator -> . DIVIDE
    (41) binary_operator -> . MODULE
    (42) binary_operator -> . EQ
    (43) binary_operator -> . NEQ
    (44) binary_operator -> . LT
    (45) binary_operator -> . LE
    (46) binary_operator -> . GT
    (47) binary_operator -> . GE
    (48) binary_operator -> . LAND
    (49) binary_operator -> . LOR
    (50) binary_operator -> . AND
    (51) binary_operator -> . OR
    (52) binary_operator -> . XOR
    (53) binary_operator -> . AND_NOT
    (54) binary_operator -> . LSHIFT
    (55) binary_operator -> . RSHIFT

  ! shift/reduce conflict for DOT resolved as shift
  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NEQ resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for LAND resolved as shift
  ! shift/reduce conflict for LOR resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for XOR resolved as shift
  ! shift/reduce conflict for AND_NOT resolved as shift
  ! shift/reduce conflict for LSHIFT resolved as shift
  ! shift/reduce conflict for RSHIFT resolved as shift
    VAR             reduce using rule 125 (expression -> LNOT expression .)
    CONST           reduce using rule 125 (expression -> LNOT expression .)
    FUNC            reduce using rule 125 (expression -> LNOT expression .)
    TYPE            reduce using rule 125 (expression -> LNOT expression .)
    $end            reduce using rule 125 (expression -> LNOT expression .)
    RPAREN          reduce using rule 125 (expression -> LNOT expression .)
    COMMA           reduce using rule 125 (expression -> LNOT expression .)
    RBRACKET        reduce using rule 125 (expression -> LNOT expression .)
    RBRACE          reduce using rule 125 (expression -> LNOT expression .)
    COLON           reduce using rule 125 (expression -> LNOT expression .)
    BREAK           reduce using rule 125 (expression -> LNOT expression .)
    CONTINUE        reduce using rule 125 (expression -> LNOT expression .)
    IDENTIFIER      reduce using rule 125 (expression -> LNOT expression .)
    LPAREN          reduce using rule 125 (expression -> LNOT expression .)
    INT             reduce using rule 125 (expression -> LNOT expression .)
    FLOAT64         reduce using rule 125 (expression -> LNOT expression .)
    STRING          reduce using rule 125 (expression -> LNOT expression .)
    TRUE            reduce using rule 125 (expression -> LNOT expression .)
    FALSE           reduce using rule 125 (expression -> LNOT expression .)
    LNOT            reduce using rule 125 (expression -> LNOT expression .)
    IF              reduce using rule 125 (expression -> LNOT expression .)
    SWITCH          reduce using rule 125 (expression -> LNOT expression .)
    RETURN          reduce using rule 125 (expression -> LNOT expression .)
    MAP             reduce using rule 125 (expression -> LNOT expression .)
    FOR             reduce using rule 125 (expression -> LNOT expression .)
    LBRACE          reduce using rule 125 (expression -> LNOT expression .)
    CASE            reduce using rule 125 (expression -> LNOT expression .)
    DEFAULT         reduce using rule 125 (expression -> LNOT expression .)
    SEMICOLON       reduce using rule 125 (expression -> LNOT expression .)
    DOT             shift and go to state 82
    LBRACKET        shift and go to state 83
    PLUS            shift and go to state 84
    MINUS           shift and go to state 85
    TIMES           shift and go to state 86
    DIVIDE          shift and go to state 87
    MODULE          shift and go to state 88
    EQ              shift and go to state 89
    NEQ             shift and go to state 90
    LT              shift and go to state 91
    LE              shift and go to state 92
    GT              shift and go to state 93
    GE              shift and go to state 94
    LAND            shift and go to state 95
    LOR             shift and go to state 96
    AND             shift and go to state 97
    OR              shift and go to state 98
    XOR             shift and go to state 99
    AND_NOT         shift and go to state 100
    LSHIFT          shift and go to state 101
    RSHIFT          shift and go to state 102

  ! DOT             [ reduce using rule 125 (expression -> LNOT expression .) ]
  ! LBRACKET        [ reduce using rule 125 (expression -> LNOT expression .) ]
  ! PLUS            [ reduce using rule 125 (expression -> LNOT expression .) ]
  ! MINUS           [ reduce using rule 125 (expression -> LNOT expression .) ]
  ! TIMES           [ reduce using rule 125 (expression -> LNOT expression .) ]
  ! DIVIDE          [ reduce using rule 125 (expression -> LNOT expression .) ]
  ! MODULE          [ reduce using rule 125 (expression -> LNOT expression .) ]
  ! EQ              [ reduce using rule 125 (expression -> LNOT expression .) ]
  ! NEQ             [ reduce using rule 125 (expression -> LNOT expression .) ]
  ! LT              [ reduce using rule 125 (expression -> LNOT expression .) ]
  ! LE              [ reduce using rule 125 (expression -> LNOT expression .) ]
  ! GT              [ reduce using rule 125 (expression -> LNOT expression .) ]
  ! GE              [ reduce using rule 125 (expression -> LNOT expression .) ]
  ! LAND            [ reduce using rule 125 (expression -> LNOT expression .) ]
  ! LOR             [ reduce using rule 125 (expression -> LNOT expression .) ]
  ! AND             [ reduce using rule 125 (expression -> LNOT expression .) ]
  ! OR              [ reduce using rule 125 (expression -> LNOT expression .) ]
  ! XOR             [ reduce using rule 125 (expression -> LNOT expression .) ]
  ! AND_NOT         [ reduce using rule 125 (expression -> LNOT expression .) ]
  ! LSHIFT          [ reduce using rule 125 (expression -> LNOT expression .) ]
  ! RSHIFT          [ reduce using rule 125 (expression -> LNOT expression .) ]

    binary_operator                shift and go to state 81

state 106

    (138) expression -> map_type LBRACE . expression_map_list RBRACE
    (139) expression -> map_type LBRACE . RBRACE
    (140) expression_map_list -> . key_value
    (141) expression_map_list -> . expression_map_list COMMA key_value
    (142) key_value -> . expression COLON expression
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (125) expression -> . LNOT expression
    (126) expression -> . IDENTIFIER PLUSPLUS
    (127) expression -> . IDENTIFIER MINUSMINUS
    (138) expression -> . map_type LBRACE expression_map_list RBRACE
    (139) expression -> . map_type LBRACE RBRACE
    (161) expression -> . type_name LBRACE keyed_element_list RBRACE
    (162) expression -> . type_name LBRACE RBRACE
    (198) expression -> . array_type LBRACE expression_list RBRACE
    (199) expression -> . array_type LBRACE RBRACE
    (200) expression -> . expression DOT IDENTIFIER
    (201) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> . expression LBRACKET expression RBRACKET
    (203) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (137) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (163) type_name -> . IDENTIFIER
    (164) type_name -> . slice_type
    (165) type_name -> . array_type
    (166) type_name -> . map_type
    (197) array_type -> . LBRACKET INT RBRACKET primitive_type

    RBRACE          shift and go to state 135
    LPAREN          shift and go to state 54
    INT             shift and go to state 55
    FLOAT64         shift and go to state 56
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 57
    TRUE            shift and go to state 58
    FALSE           shift and go to state 59
    LNOT            shift and go to state 60
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    map_type                       shift and go to state 61
    expression_map_list            shift and go to state 134
    key_value                      shift and go to state 136
    expression                     shift and go to state 137
    slice_type                     shift and go to state 53
    type_name                      shift and go to state 62
    array_type                     shift and go to state 63

state 107

    (161) expression -> type_name LBRACE . keyed_element_list RBRACE
    (162) expression -> type_name LBRACE . RBRACE
    (156) keyed_element_list -> . keyed_element
    (157) keyed_element_list -> . keyed_element_list COMMA keyed_element
    (158) keyed_element -> . IDENTIFIER COLON expression
    (159) keyed_element -> . INT COLON expression
    (160) keyed_element -> . expression
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (125) expression -> . LNOT expression
    (126) expression -> . IDENTIFIER PLUSPLUS
    (127) expression -> . IDENTIFIER MINUSMINUS
    (138) expression -> . map_type LBRACE expression_map_list RBRACE
    (139) expression -> . map_type LBRACE RBRACE
    (161) expression -> . type_name LBRACE keyed_element_list RBRACE
    (162) expression -> . type_name LBRACE RBRACE
    (198) expression -> . array_type LBRACE expression_list RBRACE
    (199) expression -> . array_type LBRACE RBRACE
    (200) expression -> . expression DOT IDENTIFIER
    (201) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> . expression LBRACKET expression RBRACKET
    (203) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (137) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (163) type_name -> . IDENTIFIER
    (164) type_name -> . slice_type
    (165) type_name -> . array_type
    (166) type_name -> . map_type
    (197) array_type -> . LBRACKET INT RBRACKET primitive_type

    RBRACE          shift and go to state 139
    IDENTIFIER      shift and go to state 141
    INT             shift and go to state 143
    LPAREN          shift and go to state 54
    FLOAT64         shift and go to state 56
    STRING          shift and go to state 57
    TRUE            shift and go to state 58
    FALSE           shift and go to state 59
    LNOT            shift and go to state 60
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    type_name                      shift and go to state 62
    keyed_element_list             shift and go to state 138
    keyed_element                  shift and go to state 140
    expression                     shift and go to state 142
    slice_type                     shift and go to state 53
    map_type                       shift and go to state 61
    array_type                     shift and go to state 63

state 108

    (198) expression -> array_type LBRACE . expression_list RBRACE
    (199) expression -> array_type LBRACE . RBRACE
    (68) expression_list -> . expression
    (69) expression_list -> . expression_list COMMA expression
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (125) expression -> . LNOT expression
    (126) expression -> . IDENTIFIER PLUSPLUS
    (127) expression -> . IDENTIFIER MINUSMINUS
    (138) expression -> . map_type LBRACE expression_map_list RBRACE
    (139) expression -> . map_type LBRACE RBRACE
    (161) expression -> . type_name LBRACE keyed_element_list RBRACE
    (162) expression -> . type_name LBRACE RBRACE
    (198) expression -> . array_type LBRACE expression_list RBRACE
    (199) expression -> . array_type LBRACE RBRACE
    (200) expression -> . expression DOT IDENTIFIER
    (201) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> . expression LBRACKET expression RBRACKET
    (203) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (137) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (163) type_name -> . IDENTIFIER
    (164) type_name -> . slice_type
    (165) type_name -> . array_type
    (166) type_name -> . map_type
    (197) array_type -> . LBRACKET INT RBRACKET primitive_type

    RBRACE          shift and go to state 145
    LPAREN          shift and go to state 54
    INT             shift and go to state 55
    FLOAT64         shift and go to state 56
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 57
    TRUE            shift and go to state 58
    FALSE           shift and go to state 59
    LNOT            shift and go to state 60
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    array_type                     shift and go to state 63
    expression_list                shift and go to state 144
    expression                     shift and go to state 127
    slice_type                     shift and go to state 53
    map_type                       shift and go to state 61
    type_name                      shift and go to state 62

state 109

    (65) slice_type -> LBRACKET RBRACKET primitive_type .

    ASSIGN          reduce using rule 65 (slice_type -> LBRACKET RBRACKET primitive_type .)
    VAR             reduce using rule 65 (slice_type -> LBRACKET RBRACKET primitive_type .)
    CONST           reduce using rule 65 (slice_type -> LBRACKET RBRACKET primitive_type .)
    FUNC            reduce using rule 65 (slice_type -> LBRACKET RBRACKET primitive_type .)
    TYPE            reduce using rule 65 (slice_type -> LBRACKET RBRACKET primitive_type .)
    $end            reduce using rule 65 (slice_type -> LBRACKET RBRACKET primitive_type .)
    LBRACE          reduce using rule 65 (slice_type -> LBRACKET RBRACKET primitive_type .)
    RPAREN          reduce using rule 65 (slice_type -> LBRACKET RBRACKET primitive_type .)
    COMMA           reduce using rule 65 (slice_type -> LBRACKET RBRACKET primitive_type .)
    RBRACE          reduce using rule 65 (slice_type -> LBRACKET RBRACKET primitive_type .)
    IDENTIFIER      reduce using rule 65 (slice_type -> LBRACKET RBRACKET primitive_type .)
    BREAK           reduce using rule 65 (slice_type -> LBRACKET RBRACKET primitive_type .)
    CONTINUE        reduce using rule 65 (slice_type -> LBRACKET RBRACKET primitive_type .)
    LPAREN          reduce using rule 65 (slice_type -> LBRACKET RBRACKET primitive_type .)
    INT             reduce using rule 65 (slice_type -> LBRACKET RBRACKET primitive_type .)
    FLOAT64         reduce using rule 65 (slice_type -> LBRACKET RBRACKET primitive_type .)
    STRING          reduce using rule 65 (slice_type -> LBRACKET RBRACKET primitive_type .)
    TRUE            reduce using rule 65 (slice_type -> LBRACKET RBRACKET primitive_type .)
    FALSE           reduce using rule 65 (slice_type -> LBRACKET RBRACKET primitive_type .)
    LNOT            reduce using rule 65 (slice_type -> LBRACKET RBRACKET primitive_type .)
    IF              reduce using rule 65 (slice_type -> LBRACKET RBRACKET primitive_type .)
    SWITCH          reduce using rule 65 (slice_type -> LBRACKET RBRACKET primitive_type .)
    RETURN          reduce using rule 65 (slice_type -> LBRACKET RBRACKET primitive_type .)
    LBRACKET        reduce using rule 65 (slice_type -> LBRACKET RBRACKET primitive_type .)
    MAP             reduce using rule 65 (slice_type -> LBRACKET RBRACKET primitive_type .)
    FOR             reduce using rule 65 (slice_type -> LBRACKET RBRACKET primitive_type .)
    SEMICOLON       reduce using rule 65 (slice_type -> LBRACKET RBRACKET primitive_type .)
    CASE            reduce using rule 65 (slice_type -> LBRACKET RBRACKET primitive_type .)
    DEFAULT         reduce using rule 65 (slice_type -> LBRACKET RBRACKET primitive_type .)


state 110

    (197) array_type -> LBRACKET INT RBRACKET . primitive_type
    (61) primitive_type -> . INT_TYPE
    (62) primitive_type -> . FLOAT64_TYPE
    (63) primitive_type -> . STRING_TYPE
    (64) primitive_type -> . BOOL_TYPE

    INT_TYPE        shift and go to state 34
    FLOAT64_TYPE    shift and go to state 35
    STRING_TYPE     shift and go to state 36
    BOOL_TYPE       shift and go to state 37

    primitive_type                 shift and go to state 146

state 111

    (137) map_type -> MAP LBRACKET primitive_type . RBRACKET primitive_type

    RBRACKET        shift and go to state 147


state 112

    (18) global_const_dec -> CONST IDENTIFIER type ASSIGN expression .
    (36) expression -> expression . binary_operator expression
    (200) expression -> expression . DOT IDENTIFIER
    (201) expression -> expression . DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> expression . LBRACKET expression RBRACKET
    (37) binary_operator -> . PLUS
    (38) binary_operator -> . MINUS
    (39) binary_operator -> . TIMES
    (40) binary_operator -> . DIVIDE
    (41) binary_operator -> . MODULE
    (42) binary_operator -> . EQ
    (43) binary_operator -> . NEQ
    (44) binary_operator -> . LT
    (45) binary_operator -> . LE
    (46) binary_operator -> . GT
    (47) binary_operator -> . GE
    (48) binary_operator -> . LAND
    (49) binary_operator -> . LOR
    (50) binary_operator -> . AND
    (51) binary_operator -> . OR
    (52) binary_operator -> . XOR
    (53) binary_operator -> . AND_NOT
    (54) binary_operator -> . LSHIFT
    (55) binary_operator -> . RSHIFT

    VAR             reduce using rule 18 (global_const_dec -> CONST IDENTIFIER type ASSIGN expression .)
    CONST           reduce using rule 18 (global_const_dec -> CONST IDENTIFIER type ASSIGN expression .)
    FUNC            reduce using rule 18 (global_const_dec -> CONST IDENTIFIER type ASSIGN expression .)
    TYPE            reduce using rule 18 (global_const_dec -> CONST IDENTIFIER type ASSIGN expression .)
    $end            reduce using rule 18 (global_const_dec -> CONST IDENTIFIER type ASSIGN expression .)
    DOT             shift and go to state 82
    LBRACKET        shift and go to state 83
    PLUS            shift and go to state 84
    MINUS           shift and go to state 85
    TIMES           shift and go to state 86
    DIVIDE          shift and go to state 87
    MODULE          shift and go to state 88
    EQ              shift and go to state 89
    NEQ             shift and go to state 90
    LT              shift and go to state 91
    LE              shift and go to state 92
    GT              shift and go to state 93
    GE              shift and go to state 94
    LAND            shift and go to state 95
    LOR             shift and go to state 96
    AND             shift and go to state 97
    OR              shift and go to state 98
    XOR             shift and go to state 99
    AND_NOT         shift and go to state 100
    LSHIFT          shift and go to state 101
    RSHIFT          shift and go to state 102

    binary_operator                shift and go to state 81

state 113

    (116) parameter -> IDENTIFIER type .

    RPAREN          reduce using rule 116 (parameter -> IDENTIFIER type .)
    COMMA           reduce using rule 116 (parameter -> IDENTIFIER type .)


state 114

    (117) parameter -> IDENTIFIER ELLIPSIS . primitive_type
    (61) primitive_type -> . INT_TYPE
    (62) primitive_type -> . FLOAT64_TYPE
    (63) primitive_type -> . STRING_TYPE
    (64) primitive_type -> . BOOL_TYPE

    INT_TYPE        shift and go to state 34
    FLOAT64_TYPE    shift and go to state 35
    STRING_TYPE     shift and go to state 36
    BOOL_TYPE       shift and go to state 37

    primitive_type                 shift and go to state 148

state 115

    (112) function_declaration -> FUNC IDENTIFIER LPAREN parameter_list RPAREN . return_type block
    (118) return_type -> . type
    (119) return_type -> . LPAREN type_list RPAREN
    (120) return_type -> . empty
    (57) type -> . primitive_type
    (58) type -> . slice_type
    (59) type -> . array_type
    (60) type -> . map_type
    (7) empty -> .
    (61) primitive_type -> . INT_TYPE
    (62) primitive_type -> . FLOAT64_TYPE
    (63) primitive_type -> . STRING_TYPE
    (64) primitive_type -> . BOOL_TYPE
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (197) array_type -> . LBRACKET INT RBRACKET primitive_type
    (137) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type

    LPAREN          shift and go to state 149
    LBRACE          reduce using rule 7 (empty -> .)
    INT_TYPE        shift and go to state 34
    FLOAT64_TYPE    shift and go to state 35
    STRING_TYPE     shift and go to state 36
    BOOL_TYPE       shift and go to state 37
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    return_type                    shift and go to state 150
    type                           shift and go to state 151
    empty                          shift and go to state 152
    primitive_type                 shift and go to state 30
    slice_type                     shift and go to state 31
    array_type                     shift and go to state 32
    map_type                       shift and go to state 33

state 116

    (113) parameter_list -> parameter_list COMMA . parameter
    (116) parameter -> . IDENTIFIER type
    (117) parameter -> . IDENTIFIER ELLIPSIS primitive_type

    IDENTIFIER      shift and go to state 69

    parameter                      shift and go to state 153

state 117

    (146) method_declaration -> FUNC LPAREN receiver RPAREN IDENTIFIER . LPAREN parameter_list RPAREN return_type block

    LPAREN          shift and go to state 154


state 118

    (148) receiver -> IDENTIFIER TIMES IDENTIFIER .

    RPAREN          reduce using rule 148 (receiver -> IDENTIFIER TIMES IDENTIFIER .)


state 119

    (149) receiver -> IDENTIFIER TIMES type .

    RPAREN          reduce using rule 149 (receiver -> IDENTIFIER TIMES type .)


state 120

    (154) struct_type -> STRUCT LBRACE RBRACE .

    VAR             reduce using rule 154 (struct_type -> STRUCT LBRACE RBRACE .)
    CONST           reduce using rule 154 (struct_type -> STRUCT LBRACE RBRACE .)
    FUNC            reduce using rule 154 (struct_type -> STRUCT LBRACE RBRACE .)
    TYPE            reduce using rule 154 (struct_type -> STRUCT LBRACE RBRACE .)
    $end            reduce using rule 154 (struct_type -> STRUCT LBRACE RBRACE .)


state 121

    (155) struct_type -> STRUCT LBRACE field_list . RBRACE
    (144) field_list -> field_list . field_declaration
    (145) field_declaration -> . IDENTIFIER type

    RBRACE          shift and go to state 155
    IDENTIFIER      shift and go to state 123

    field_declaration              shift and go to state 156

state 122

    (143) field_list -> field_declaration .

    RBRACE          reduce using rule 143 (field_list -> field_declaration .)
    IDENTIFIER      reduce using rule 143 (field_list -> field_declaration .)


state 123

    (145) field_declaration -> IDENTIFIER . type
    (57) type -> . primitive_type
    (58) type -> . slice_type
    (59) type -> . array_type
    (60) type -> . map_type
    (61) primitive_type -> . INT_TYPE
    (62) primitive_type -> . FLOAT64_TYPE
    (63) primitive_type -> . STRING_TYPE
    (64) primitive_type -> . BOOL_TYPE
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (197) array_type -> . LBRACKET INT RBRACKET primitive_type
    (137) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type

    INT_TYPE        shift and go to state 34
    FLOAT64_TYPE    shift and go to state 35
    STRING_TYPE     shift and go to state 36
    BOOL_TYPE       shift and go to state 37
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    type                           shift and go to state 157
    primitive_type                 shift and go to state 30
    slice_type                     shift and go to state 31
    array_type                     shift and go to state 32
    map_type                       shift and go to state 33

state 124

    (203) expression -> IDENTIFIER LPAREN argument_list . RPAREN

    RPAREN          shift and go to state 158


state 125

    (204) argument_list -> expression_list .
    (69) expression_list -> expression_list . COMMA expression

    RPAREN          reduce using rule 204 (argument_list -> expression_list .)
    COMMA           shift and go to state 159


state 126

    (205) argument_list -> empty .

    RPAREN          reduce using rule 205 (argument_list -> empty .)


state 127

    (68) expression_list -> expression .
    (36) expression -> expression . binary_operator expression
    (200) expression -> expression . DOT IDENTIFIER
    (201) expression -> expression . DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> expression . LBRACKET expression RBRACKET
    (37) binary_operator -> . PLUS
    (38) binary_operator -> . MINUS
    (39) binary_operator -> . TIMES
    (40) binary_operator -> . DIVIDE
    (41) binary_operator -> . MODULE
    (42) binary_operator -> . EQ
    (43) binary_operator -> . NEQ
    (44) binary_operator -> . LT
    (45) binary_operator -> . LE
    (46) binary_operator -> . GT
    (47) binary_operator -> . GE
    (48) binary_operator -> . LAND
    (49) binary_operator -> . LOR
    (50) binary_operator -> . AND
    (51) binary_operator -> . OR
    (52) binary_operator -> . XOR
    (53) binary_operator -> . AND_NOT
    (54) binary_operator -> . LSHIFT
    (55) binary_operator -> . RSHIFT

    COMMA           reduce using rule 68 (expression_list -> expression .)
    RPAREN          reduce using rule 68 (expression_list -> expression .)
    RBRACE          reduce using rule 68 (expression_list -> expression .)
    DOT             shift and go to state 82
    LBRACKET        shift and go to state 83
    PLUS            shift and go to state 84
    MINUS           shift and go to state 85
    TIMES           shift and go to state 86
    DIVIDE          shift and go to state 87
    MODULE          shift and go to state 88
    EQ              shift and go to state 89
    NEQ             shift and go to state 90
    LT              shift and go to state 91
    LE              shift and go to state 92
    GT              shift and go to state 93
    GE              shift and go to state 94
    LAND            shift and go to state 95
    LOR             shift and go to state 96
    AND             shift and go to state 97
    OR              shift and go to state 98
    XOR             shift and go to state 99
    AND_NOT         shift and go to state 100
    LSHIFT          shift and go to state 101
    RSHIFT          shift and go to state 102

    binary_operator                shift and go to state 81

state 128

    (36) expression -> expression binary_operator expression .
    (36) expression -> expression . binary_operator expression
    (200) expression -> expression . DOT IDENTIFIER
    (201) expression -> expression . DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> expression . LBRACKET expression RBRACKET
    (37) binary_operator -> . PLUS
    (38) binary_operator -> . MINUS
    (39) binary_operator -> . TIMES
    (40) binary_operator -> . DIVIDE
    (41) binary_operator -> . MODULE
    (42) binary_operator -> . EQ
    (43) binary_operator -> . NEQ
    (44) binary_operator -> . LT
    (45) binary_operator -> . LE
    (46) binary_operator -> . GT
    (47) binary_operator -> . GE
    (48) binary_operator -> . LAND
    (49) binary_operator -> . LOR
    (50) binary_operator -> . AND
    (51) binary_operator -> . OR
    (52) binary_operator -> . XOR
    (53) binary_operator -> . AND_NOT
    (54) binary_operator -> . LSHIFT
    (55) binary_operator -> . RSHIFT

  ! shift/reduce conflict for DOT resolved as shift
  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NEQ resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for LAND resolved as shift
  ! shift/reduce conflict for LOR resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for XOR resolved as shift
  ! shift/reduce conflict for AND_NOT resolved as shift
  ! shift/reduce conflict for LSHIFT resolved as shift
  ! shift/reduce conflict for RSHIFT resolved as shift
    VAR             reduce using rule 36 (expression -> expression binary_operator expression .)
    CONST           reduce using rule 36 (expression -> expression binary_operator expression .)
    FUNC            reduce using rule 36 (expression -> expression binary_operator expression .)
    TYPE            reduce using rule 36 (expression -> expression binary_operator expression .)
    $end            reduce using rule 36 (expression -> expression binary_operator expression .)
    RPAREN          reduce using rule 36 (expression -> expression binary_operator expression .)
    COMMA           reduce using rule 36 (expression -> expression binary_operator expression .)
    RBRACKET        reduce using rule 36 (expression -> expression binary_operator expression .)
    RBRACE          reduce using rule 36 (expression -> expression binary_operator expression .)
    COLON           reduce using rule 36 (expression -> expression binary_operator expression .)
    BREAK           reduce using rule 36 (expression -> expression binary_operator expression .)
    CONTINUE        reduce using rule 36 (expression -> expression binary_operator expression .)
    IDENTIFIER      reduce using rule 36 (expression -> expression binary_operator expression .)
    LPAREN          reduce using rule 36 (expression -> expression binary_operator expression .)
    INT             reduce using rule 36 (expression -> expression binary_operator expression .)
    FLOAT64         reduce using rule 36 (expression -> expression binary_operator expression .)
    STRING          reduce using rule 36 (expression -> expression binary_operator expression .)
    TRUE            reduce using rule 36 (expression -> expression binary_operator expression .)
    FALSE           reduce using rule 36 (expression -> expression binary_operator expression .)
    LNOT            reduce using rule 36 (expression -> expression binary_operator expression .)
    IF              reduce using rule 36 (expression -> expression binary_operator expression .)
    SWITCH          reduce using rule 36 (expression -> expression binary_operator expression .)
    RETURN          reduce using rule 36 (expression -> expression binary_operator expression .)
    MAP             reduce using rule 36 (expression -> expression binary_operator expression .)
    FOR             reduce using rule 36 (expression -> expression binary_operator expression .)
    LBRACE          reduce using rule 36 (expression -> expression binary_operator expression .)
    CASE            reduce using rule 36 (expression -> expression binary_operator expression .)
    DEFAULT         reduce using rule 36 (expression -> expression binary_operator expression .)
    SEMICOLON       reduce using rule 36 (expression -> expression binary_operator expression .)
    DOT             shift and go to state 82
    LBRACKET        shift and go to state 83
    PLUS            shift and go to state 84
    MINUS           shift and go to state 85
    TIMES           shift and go to state 86
    DIVIDE          shift and go to state 87
    MODULE          shift and go to state 88
    EQ              shift and go to state 89
    NEQ             shift and go to state 90
    LT              shift and go to state 91
    LE              shift and go to state 92
    GT              shift and go to state 93
    GE              shift and go to state 94
    LAND            shift and go to state 95
    LOR             shift and go to state 96
    AND             shift and go to state 97
    OR              shift and go to state 98
    XOR             shift and go to state 99
    AND_NOT         shift and go to state 100
    LSHIFT          shift and go to state 101
    RSHIFT          shift and go to state 102

  ! DOT             [ reduce using rule 36 (expression -> expression binary_operator expression .) ]
  ! LBRACKET        [ reduce using rule 36 (expression -> expression binary_operator expression .) ]
  ! PLUS            [ reduce using rule 36 (expression -> expression binary_operator expression .) ]
  ! MINUS           [ reduce using rule 36 (expression -> expression binary_operator expression .) ]
  ! TIMES           [ reduce using rule 36 (expression -> expression binary_operator expression .) ]
  ! DIVIDE          [ reduce using rule 36 (expression -> expression binary_operator expression .) ]
  ! MODULE          [ reduce using rule 36 (expression -> expression binary_operator expression .) ]
  ! EQ              [ reduce using rule 36 (expression -> expression binary_operator expression .) ]
  ! NEQ             [ reduce using rule 36 (expression -> expression binary_operator expression .) ]
  ! LT              [ reduce using rule 36 (expression -> expression binary_operator expression .) ]
  ! LE              [ reduce using rule 36 (expression -> expression binary_operator expression .) ]
  ! GT              [ reduce using rule 36 (expression -> expression binary_operator expression .) ]
  ! GE              [ reduce using rule 36 (expression -> expression binary_operator expression .) ]
  ! LAND            [ reduce using rule 36 (expression -> expression binary_operator expression .) ]
  ! LOR             [ reduce using rule 36 (expression -> expression binary_operator expression .) ]
  ! AND             [ reduce using rule 36 (expression -> expression binary_operator expression .) ]
  ! OR              [ reduce using rule 36 (expression -> expression binary_operator expression .) ]
  ! XOR             [ reduce using rule 36 (expression -> expression binary_operator expression .) ]
  ! AND_NOT         [ reduce using rule 36 (expression -> expression binary_operator expression .) ]
  ! LSHIFT          [ reduce using rule 36 (expression -> expression binary_operator expression .) ]
  ! RSHIFT          [ reduce using rule 36 (expression -> expression binary_operator expression .) ]

    binary_operator                shift and go to state 81

state 129

    (200) expression -> expression DOT IDENTIFIER .
    (201) expression -> expression DOT IDENTIFIER . LPAREN argument_list RPAREN

  ! shift/reduce conflict for LPAREN resolved as shift
    DOT             reduce using rule 200 (expression -> expression DOT IDENTIFIER .)
    LBRACKET        reduce using rule 200 (expression -> expression DOT IDENTIFIER .)
    PLUS            reduce using rule 200 (expression -> expression DOT IDENTIFIER .)
    MINUS           reduce using rule 200 (expression -> expression DOT IDENTIFIER .)
    TIMES           reduce using rule 200 (expression -> expression DOT IDENTIFIER .)
    DIVIDE          reduce using rule 200 (expression -> expression DOT IDENTIFIER .)
    MODULE          reduce using rule 200 (expression -> expression DOT IDENTIFIER .)
    EQ              reduce using rule 200 (expression -> expression DOT IDENTIFIER .)
    NEQ             reduce using rule 200 (expression -> expression DOT IDENTIFIER .)
    LT              reduce using rule 200 (expression -> expression DOT IDENTIFIER .)
    LE              reduce using rule 200 (expression -> expression DOT IDENTIFIER .)
    GT              reduce using rule 200 (expression -> expression DOT IDENTIFIER .)
    GE              reduce using rule 200 (expression -> expression DOT IDENTIFIER .)
    LAND            reduce using rule 200 (expression -> expression DOT IDENTIFIER .)
    LOR             reduce using rule 200 (expression -> expression DOT IDENTIFIER .)
    AND             reduce using rule 200 (expression -> expression DOT IDENTIFIER .)
    OR              reduce using rule 200 (expression -> expression DOT IDENTIFIER .)
    XOR             reduce using rule 200 (expression -> expression DOT IDENTIFIER .)
    AND_NOT         reduce using rule 200 (expression -> expression DOT IDENTIFIER .)
    LSHIFT          reduce using rule 200 (expression -> expression DOT IDENTIFIER .)
    RSHIFT          reduce using rule 200 (expression -> expression DOT IDENTIFIER .)
    VAR             reduce using rule 200 (expression -> expression DOT IDENTIFIER .)
    CONST           reduce using rule 200 (expression -> expression DOT IDENTIFIER .)
    FUNC            reduce using rule 200 (expression -> expression DOT IDENTIFIER .)
    TYPE            reduce using rule 200 (expression -> expression DOT IDENTIFIER .)
    $end            reduce using rule 200 (expression -> expression DOT IDENTIFIER .)
    RPAREN          reduce using rule 200 (expression -> expression DOT IDENTIFIER .)
    COMMA           reduce using rule 200 (expression -> expression DOT IDENTIFIER .)
    RBRACKET        reduce using rule 200 (expression -> expression DOT IDENTIFIER .)
    RBRACE          reduce using rule 200 (expression -> expression DOT IDENTIFIER .)
    COLON           reduce using rule 200 (expression -> expression DOT IDENTIFIER .)
    BREAK           reduce using rule 200 (expression -> expression DOT IDENTIFIER .)
    CONTINUE        reduce using rule 200 (expression -> expression DOT IDENTIFIER .)
    IDENTIFIER      reduce using rule 200 (expression -> expression DOT IDENTIFIER .)
    INT             reduce using rule 200 (expression -> expression DOT IDENTIFIER .)
    FLOAT64         reduce using rule 200 (expression -> expression DOT IDENTIFIER .)
    STRING          reduce using rule 200 (expression -> expression DOT IDENTIFIER .)
    TRUE            reduce using rule 200 (expression -> expression DOT IDENTIFIER .)
    FALSE           reduce using rule 200 (expression -> expression DOT IDENTIFIER .)
    LNOT            reduce using rule 200 (expression -> expression DOT IDENTIFIER .)
    IF              reduce using rule 200 (expression -> expression DOT IDENTIFIER .)
    SWITCH          reduce using rule 200 (expression -> expression DOT IDENTIFIER .)
    RETURN          reduce using rule 200 (expression -> expression DOT IDENTIFIER .)
    MAP             reduce using rule 200 (expression -> expression DOT IDENTIFIER .)
    FOR             reduce using rule 200 (expression -> expression DOT IDENTIFIER .)
    LBRACE          reduce using rule 200 (expression -> expression DOT IDENTIFIER .)
    CASE            reduce using rule 200 (expression -> expression DOT IDENTIFIER .)
    DEFAULT         reduce using rule 200 (expression -> expression DOT IDENTIFIER .)
    SEMICOLON       reduce using rule 200 (expression -> expression DOT IDENTIFIER .)
    LPAREN          shift and go to state 160

  ! LPAREN          [ reduce using rule 200 (expression -> expression DOT IDENTIFIER .) ]


state 130

    (202) expression -> expression LBRACKET expression . RBRACKET
    (36) expression -> expression . binary_operator expression
    (200) expression -> expression . DOT IDENTIFIER
    (201) expression -> expression . DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> expression . LBRACKET expression RBRACKET
    (37) binary_operator -> . PLUS
    (38) binary_operator -> . MINUS
    (39) binary_operator -> . TIMES
    (40) binary_operator -> . DIVIDE
    (41) binary_operator -> . MODULE
    (42) binary_operator -> . EQ
    (43) binary_operator -> . NEQ
    (44) binary_operator -> . LT
    (45) binary_operator -> . LE
    (46) binary_operator -> . GT
    (47) binary_operator -> . GE
    (48) binary_operator -> . LAND
    (49) binary_operator -> . LOR
    (50) binary_operator -> . AND
    (51) binary_operator -> . OR
    (52) binary_operator -> . XOR
    (53) binary_operator -> . AND_NOT
    (54) binary_operator -> . LSHIFT
    (55) binary_operator -> . RSHIFT

    RBRACKET        shift and go to state 161
    DOT             shift and go to state 82
    LBRACKET        shift and go to state 83
    PLUS            shift and go to state 84
    MINUS           shift and go to state 85
    TIMES           shift and go to state 86
    DIVIDE          shift and go to state 87
    MODULE          shift and go to state 88
    EQ              shift and go to state 89
    NEQ             shift and go to state 90
    LT              shift and go to state 91
    LE              shift and go to state 92
    GT              shift and go to state 93
    GE              shift and go to state 94
    LAND            shift and go to state 95
    LOR             shift and go to state 96
    AND             shift and go to state 97
    OR              shift and go to state 98
    XOR             shift and go to state 99
    AND_NOT         shift and go to state 100
    LSHIFT          shift and go to state 101
    RSHIFT          shift and go to state 102

    binary_operator                shift and go to state 81

state 131

    (66) expression -> slice_type LBRACE expression_list . RBRACE
    (69) expression_list -> expression_list . COMMA expression

    RBRACE          shift and go to state 162
    COMMA           shift and go to state 159


state 132

    (67) expression -> slice_type LBRACE RBRACE .

    DOT             reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    LBRACKET        reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    PLUS            reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    MINUS           reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    TIMES           reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    DIVIDE          reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    MODULE          reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    EQ              reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    NEQ             reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    LT              reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    LE              reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    GT              reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    GE              reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    LAND            reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    LOR             reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    AND             reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    OR              reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    XOR             reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    AND_NOT         reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    LSHIFT          reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    RSHIFT          reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    VAR             reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    CONST           reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    FUNC            reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    TYPE            reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    $end            reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    RPAREN          reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    COMMA           reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    RBRACKET        reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    RBRACE          reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    COLON           reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    BREAK           reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    CONTINUE        reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    IDENTIFIER      reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    LPAREN          reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    INT             reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    FLOAT64         reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    STRING          reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    TRUE            reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    FALSE           reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    LNOT            reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    IF              reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    SWITCH          reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    RETURN          reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    MAP             reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    FOR             reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    LBRACE          reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    CASE            reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    DEFAULT         reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    SEMICOLON       reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)


state 133

    (70) expression -> LPAREN expression RPAREN .

    DOT             reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    LBRACKET        reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    PLUS            reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    TIMES           reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    MODULE          reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    EQ              reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    NEQ             reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    LT              reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    LE              reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    GT              reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    GE              reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    LAND            reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    LOR             reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    AND             reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    OR              reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    XOR             reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    AND_NOT         reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    LSHIFT          reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    RSHIFT          reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    VAR             reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    CONST           reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    FUNC            reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    TYPE            reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    $end            reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    COMMA           reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    RBRACKET        reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    RBRACE          reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    COLON           reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    BREAK           reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    CONTINUE        reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    IDENTIFIER      reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    LPAREN          reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    INT             reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    FLOAT64         reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    STRING          reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    TRUE            reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    FALSE           reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    LNOT            reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    IF              reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    SWITCH          reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    RETURN          reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    MAP             reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    FOR             reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    LBRACE          reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    CASE            reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    DEFAULT         reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    SEMICOLON       reduce using rule 70 (expression -> LPAREN expression RPAREN .)


state 134

    (138) expression -> map_type LBRACE expression_map_list . RBRACE
    (141) expression_map_list -> expression_map_list . COMMA key_value

    RBRACE          shift and go to state 163
    COMMA           shift and go to state 164


state 135

    (139) expression -> map_type LBRACE RBRACE .

    DOT             reduce using rule 139 (expression -> map_type LBRACE RBRACE .)
    LBRACKET        reduce using rule 139 (expression -> map_type LBRACE RBRACE .)
    PLUS            reduce using rule 139 (expression -> map_type LBRACE RBRACE .)
    MINUS           reduce using rule 139 (expression -> map_type LBRACE RBRACE .)
    TIMES           reduce using rule 139 (expression -> map_type LBRACE RBRACE .)
    DIVIDE          reduce using rule 139 (expression -> map_type LBRACE RBRACE .)
    MODULE          reduce using rule 139 (expression -> map_type LBRACE RBRACE .)
    EQ              reduce using rule 139 (expression -> map_type LBRACE RBRACE .)
    NEQ             reduce using rule 139 (expression -> map_type LBRACE RBRACE .)
    LT              reduce using rule 139 (expression -> map_type LBRACE RBRACE .)
    LE              reduce using rule 139 (expression -> map_type LBRACE RBRACE .)
    GT              reduce using rule 139 (expression -> map_type LBRACE RBRACE .)
    GE              reduce using rule 139 (expression -> map_type LBRACE RBRACE .)
    LAND            reduce using rule 139 (expression -> map_type LBRACE RBRACE .)
    LOR             reduce using rule 139 (expression -> map_type LBRACE RBRACE .)
    AND             reduce using rule 139 (expression -> map_type LBRACE RBRACE .)
    OR              reduce using rule 139 (expression -> map_type LBRACE RBRACE .)
    XOR             reduce using rule 139 (expression -> map_type LBRACE RBRACE .)
    AND_NOT         reduce using rule 139 (expression -> map_type LBRACE RBRACE .)
    LSHIFT          reduce using rule 139 (expression -> map_type LBRACE RBRACE .)
    RSHIFT          reduce using rule 139 (expression -> map_type LBRACE RBRACE .)
    VAR             reduce using rule 139 (expression -> map_type LBRACE RBRACE .)
    CONST           reduce using rule 139 (expression -> map_type LBRACE RBRACE .)
    FUNC            reduce using rule 139 (expression -> map_type LBRACE RBRACE .)
    TYPE            reduce using rule 139 (expression -> map_type LBRACE RBRACE .)
    $end            reduce using rule 139 (expression -> map_type LBRACE RBRACE .)
    RPAREN          reduce using rule 139 (expression -> map_type LBRACE RBRACE .)
    COMMA           reduce using rule 139 (expression -> map_type LBRACE RBRACE .)
    RBRACKET        reduce using rule 139 (expression -> map_type LBRACE RBRACE .)
    RBRACE          reduce using rule 139 (expression -> map_type LBRACE RBRACE .)
    COLON           reduce using rule 139 (expression -> map_type LBRACE RBRACE .)
    BREAK           reduce using rule 139 (expression -> map_type LBRACE RBRACE .)
    CONTINUE        reduce using rule 139 (expression -> map_type LBRACE RBRACE .)
    IDENTIFIER      reduce using rule 139 (expression -> map_type LBRACE RBRACE .)
    LPAREN          reduce using rule 139 (expression -> map_type LBRACE RBRACE .)
    INT             reduce using rule 139 (expression -> map_type LBRACE RBRACE .)
    FLOAT64         reduce using rule 139 (expression -> map_type LBRACE RBRACE .)
    STRING          reduce using rule 139 (expression -> map_type LBRACE RBRACE .)
    TRUE            reduce using rule 139 (expression -> map_type LBRACE RBRACE .)
    FALSE           reduce using rule 139 (expression -> map_type LBRACE RBRACE .)
    LNOT            reduce using rule 139 (expression -> map_type LBRACE RBRACE .)
    IF              reduce using rule 139 (expression -> map_type LBRACE RBRACE .)
    SWITCH          reduce using rule 139 (expression -> map_type LBRACE RBRACE .)
    RETURN          reduce using rule 139 (expression -> map_type LBRACE RBRACE .)
    MAP             reduce using rule 139 (expression -> map_type LBRACE RBRACE .)
    FOR             reduce using rule 139 (expression -> map_type LBRACE RBRACE .)
    LBRACE          reduce using rule 139 (expression -> map_type LBRACE RBRACE .)
    CASE            reduce using rule 139 (expression -> map_type LBRACE RBRACE .)
    DEFAULT         reduce using rule 139 (expression -> map_type LBRACE RBRACE .)
    SEMICOLON       reduce using rule 139 (expression -> map_type LBRACE RBRACE .)


state 136

    (140) expression_map_list -> key_value .

    RBRACE          reduce using rule 140 (expression_map_list -> key_value .)
    COMMA           reduce using rule 140 (expression_map_list -> key_value .)


state 137

    (142) key_value -> expression . COLON expression
    (36) expression -> expression . binary_operator expression
    (200) expression -> expression . DOT IDENTIFIER
    (201) expression -> expression . DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> expression . LBRACKET expression RBRACKET
    (37) binary_operator -> . PLUS
    (38) binary_operator -> . MINUS
    (39) binary_operator -> . TIMES
    (40) binary_operator -> . DIVIDE
    (41) binary_operator -> . MODULE
    (42) binary_operator -> . EQ
    (43) binary_operator -> . NEQ
    (44) binary_operator -> . LT
    (45) binary_operator -> . LE
    (46) binary_operator -> . GT
    (47) binary_operator -> . GE
    (48) binary_operator -> . LAND
    (49) binary_operator -> . LOR
    (50) binary_operator -> . AND
    (51) binary_operator -> . OR
    (52) binary_operator -> . XOR
    (53) binary_operator -> . AND_NOT
    (54) binary_operator -> . LSHIFT
    (55) binary_operator -> . RSHIFT

    COLON           shift and go to state 165
    DOT             shift and go to state 82
    LBRACKET        shift and go to state 83
    PLUS            shift and go to state 84
    MINUS           shift and go to state 85
    TIMES           shift and go to state 86
    DIVIDE          shift and go to state 87
    MODULE          shift and go to state 88
    EQ              shift and go to state 89
    NEQ             shift and go to state 90
    LT              shift and go to state 91
    LE              shift and go to state 92
    GT              shift and go to state 93
    GE              shift and go to state 94
    LAND            shift and go to state 95
    LOR             shift and go to state 96
    AND             shift and go to state 97
    OR              shift and go to state 98
    XOR             shift and go to state 99
    AND_NOT         shift and go to state 100
    LSHIFT          shift and go to state 101
    RSHIFT          shift and go to state 102

    binary_operator                shift and go to state 81

state 138

    (161) expression -> type_name LBRACE keyed_element_list . RBRACE
    (157) keyed_element_list -> keyed_element_list . COMMA keyed_element

    RBRACE          shift and go to state 166
    COMMA           shift and go to state 167


state 139

    (162) expression -> type_name LBRACE RBRACE .

    DOT             reduce using rule 162 (expression -> type_name LBRACE RBRACE .)
    LBRACKET        reduce using rule 162 (expression -> type_name LBRACE RBRACE .)
    PLUS            reduce using rule 162 (expression -> type_name LBRACE RBRACE .)
    MINUS           reduce using rule 162 (expression -> type_name LBRACE RBRACE .)
    TIMES           reduce using rule 162 (expression -> type_name LBRACE RBRACE .)
    DIVIDE          reduce using rule 162 (expression -> type_name LBRACE RBRACE .)
    MODULE          reduce using rule 162 (expression -> type_name LBRACE RBRACE .)
    EQ              reduce using rule 162 (expression -> type_name LBRACE RBRACE .)
    NEQ             reduce using rule 162 (expression -> type_name LBRACE RBRACE .)
    LT              reduce using rule 162 (expression -> type_name LBRACE RBRACE .)
    LE              reduce using rule 162 (expression -> type_name LBRACE RBRACE .)
    GT              reduce using rule 162 (expression -> type_name LBRACE RBRACE .)
    GE              reduce using rule 162 (expression -> type_name LBRACE RBRACE .)
    LAND            reduce using rule 162 (expression -> type_name LBRACE RBRACE .)
    LOR             reduce using rule 162 (expression -> type_name LBRACE RBRACE .)
    AND             reduce using rule 162 (expression -> type_name LBRACE RBRACE .)
    OR              reduce using rule 162 (expression -> type_name LBRACE RBRACE .)
    XOR             reduce using rule 162 (expression -> type_name LBRACE RBRACE .)
    AND_NOT         reduce using rule 162 (expression -> type_name LBRACE RBRACE .)
    LSHIFT          reduce using rule 162 (expression -> type_name LBRACE RBRACE .)
    RSHIFT          reduce using rule 162 (expression -> type_name LBRACE RBRACE .)
    VAR             reduce using rule 162 (expression -> type_name LBRACE RBRACE .)
    CONST           reduce using rule 162 (expression -> type_name LBRACE RBRACE .)
    FUNC            reduce using rule 162 (expression -> type_name LBRACE RBRACE .)
    TYPE            reduce using rule 162 (expression -> type_name LBRACE RBRACE .)
    $end            reduce using rule 162 (expression -> type_name LBRACE RBRACE .)
    RPAREN          reduce using rule 162 (expression -> type_name LBRACE RBRACE .)
    COMMA           reduce using rule 162 (expression -> type_name LBRACE RBRACE .)
    RBRACKET        reduce using rule 162 (expression -> type_name LBRACE RBRACE .)
    RBRACE          reduce using rule 162 (expression -> type_name LBRACE RBRACE .)
    COLON           reduce using rule 162 (expression -> type_name LBRACE RBRACE .)
    BREAK           reduce using rule 162 (expression -> type_name LBRACE RBRACE .)
    CONTINUE        reduce using rule 162 (expression -> type_name LBRACE RBRACE .)
    IDENTIFIER      reduce using rule 162 (expression -> type_name LBRACE RBRACE .)
    LPAREN          reduce using rule 162 (expression -> type_name LBRACE RBRACE .)
    INT             reduce using rule 162 (expression -> type_name LBRACE RBRACE .)
    FLOAT64         reduce using rule 162 (expression -> type_name LBRACE RBRACE .)
    STRING          reduce using rule 162 (expression -> type_name LBRACE RBRACE .)
    TRUE            reduce using rule 162 (expression -> type_name LBRACE RBRACE .)
    FALSE           reduce using rule 162 (expression -> type_name LBRACE RBRACE .)
    LNOT            reduce using rule 162 (expression -> type_name LBRACE RBRACE .)
    IF              reduce using rule 162 (expression -> type_name LBRACE RBRACE .)
    SWITCH          reduce using rule 162 (expression -> type_name LBRACE RBRACE .)
    RETURN          reduce using rule 162 (expression -> type_name LBRACE RBRACE .)
    MAP             reduce using rule 162 (expression -> type_name LBRACE RBRACE .)
    FOR             reduce using rule 162 (expression -> type_name LBRACE RBRACE .)
    LBRACE          reduce using rule 162 (expression -> type_name LBRACE RBRACE .)
    CASE            reduce using rule 162 (expression -> type_name LBRACE RBRACE .)
    DEFAULT         reduce using rule 162 (expression -> type_name LBRACE RBRACE .)
    SEMICOLON       reduce using rule 162 (expression -> type_name LBRACE RBRACE .)


state 140

    (156) keyed_element_list -> keyed_element .

    RBRACE          reduce using rule 156 (keyed_element_list -> keyed_element .)
    COMMA           reduce using rule 156 (keyed_element_list -> keyed_element .)


state 141

    (158) keyed_element -> IDENTIFIER . COLON expression
    (73) expression -> IDENTIFIER .
    (126) expression -> IDENTIFIER . PLUSPLUS
    (127) expression -> IDENTIFIER . MINUSMINUS
    (203) expression -> IDENTIFIER . LPAREN argument_list RPAREN
    (163) type_name -> IDENTIFIER .

    COLON           shift and go to state 168
    DOT             reduce using rule 73 (expression -> IDENTIFIER .)
    LBRACKET        reduce using rule 73 (expression -> IDENTIFIER .)
    PLUS            reduce using rule 73 (expression -> IDENTIFIER .)
    MINUS           reduce using rule 73 (expression -> IDENTIFIER .)
    TIMES           reduce using rule 73 (expression -> IDENTIFIER .)
    DIVIDE          reduce using rule 73 (expression -> IDENTIFIER .)
    MODULE          reduce using rule 73 (expression -> IDENTIFIER .)
    EQ              reduce using rule 73 (expression -> IDENTIFIER .)
    NEQ             reduce using rule 73 (expression -> IDENTIFIER .)
    LT              reduce using rule 73 (expression -> IDENTIFIER .)
    LE              reduce using rule 73 (expression -> IDENTIFIER .)
    GT              reduce using rule 73 (expression -> IDENTIFIER .)
    GE              reduce using rule 73 (expression -> IDENTIFIER .)
    LAND            reduce using rule 73 (expression -> IDENTIFIER .)
    LOR             reduce using rule 73 (expression -> IDENTIFIER .)
    AND             reduce using rule 73 (expression -> IDENTIFIER .)
    OR              reduce using rule 73 (expression -> IDENTIFIER .)
    XOR             reduce using rule 73 (expression -> IDENTIFIER .)
    AND_NOT         reduce using rule 73 (expression -> IDENTIFIER .)
    LSHIFT          reduce using rule 73 (expression -> IDENTIFIER .)
    RSHIFT          reduce using rule 73 (expression -> IDENTIFIER .)
    RBRACE          reduce using rule 73 (expression -> IDENTIFIER .)
    COMMA           reduce using rule 73 (expression -> IDENTIFIER .)
    PLUSPLUS        shift and go to state 78
    MINUSMINUS      shift and go to state 79
    LPAREN          shift and go to state 80
    LBRACE          reduce using rule 163 (type_name -> IDENTIFIER .)


state 142

    (160) keyed_element -> expression .
    (36) expression -> expression . binary_operator expression
    (200) expression -> expression . DOT IDENTIFIER
    (201) expression -> expression . DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> expression . LBRACKET expression RBRACKET
    (37) binary_operator -> . PLUS
    (38) binary_operator -> . MINUS
    (39) binary_operator -> . TIMES
    (40) binary_operator -> . DIVIDE
    (41) binary_operator -> . MODULE
    (42) binary_operator -> . EQ
    (43) binary_operator -> . NEQ
    (44) binary_operator -> . LT
    (45) binary_operator -> . LE
    (46) binary_operator -> . GT
    (47) binary_operator -> . GE
    (48) binary_operator -> . LAND
    (49) binary_operator -> . LOR
    (50) binary_operator -> . AND
    (51) binary_operator -> . OR
    (52) binary_operator -> . XOR
    (53) binary_operator -> . AND_NOT
    (54) binary_operator -> . LSHIFT
    (55) binary_operator -> . RSHIFT

    RBRACE          reduce using rule 160 (keyed_element -> expression .)
    COMMA           reduce using rule 160 (keyed_element -> expression .)
    DOT             shift and go to state 82
    LBRACKET        shift and go to state 83
    PLUS            shift and go to state 84
    MINUS           shift and go to state 85
    TIMES           shift and go to state 86
    DIVIDE          shift and go to state 87
    MODULE          shift and go to state 88
    EQ              shift and go to state 89
    NEQ             shift and go to state 90
    LT              shift and go to state 91
    LE              shift and go to state 92
    GT              shift and go to state 93
    GE              shift and go to state 94
    LAND            shift and go to state 95
    LOR             shift and go to state 96
    AND             shift and go to state 97
    OR              shift and go to state 98
    XOR             shift and go to state 99
    AND_NOT         shift and go to state 100
    LSHIFT          shift and go to state 101
    RSHIFT          shift and go to state 102

    binary_operator                shift and go to state 81

state 143

    (159) keyed_element -> INT . COLON expression
    (71) expression -> INT .

    COLON           shift and go to state 169
    DOT             reduce using rule 71 (expression -> INT .)
    LBRACKET        reduce using rule 71 (expression -> INT .)
    PLUS            reduce using rule 71 (expression -> INT .)
    MINUS           reduce using rule 71 (expression -> INT .)
    TIMES           reduce using rule 71 (expression -> INT .)
    DIVIDE          reduce using rule 71 (expression -> INT .)
    MODULE          reduce using rule 71 (expression -> INT .)
    EQ              reduce using rule 71 (expression -> INT .)
    NEQ             reduce using rule 71 (expression -> INT .)
    LT              reduce using rule 71 (expression -> INT .)
    LE              reduce using rule 71 (expression -> INT .)
    GT              reduce using rule 71 (expression -> INT .)
    GE              reduce using rule 71 (expression -> INT .)
    LAND            reduce using rule 71 (expression -> INT .)
    LOR             reduce using rule 71 (expression -> INT .)
    AND             reduce using rule 71 (expression -> INT .)
    OR              reduce using rule 71 (expression -> INT .)
    XOR             reduce using rule 71 (expression -> INT .)
    AND_NOT         reduce using rule 71 (expression -> INT .)
    LSHIFT          reduce using rule 71 (expression -> INT .)
    RSHIFT          reduce using rule 71 (expression -> INT .)
    RBRACE          reduce using rule 71 (expression -> INT .)
    COMMA           reduce using rule 71 (expression -> INT .)


state 144

    (198) expression -> array_type LBRACE expression_list . RBRACE
    (69) expression_list -> expression_list . COMMA expression

    RBRACE          shift and go to state 170
    COMMA           shift and go to state 159


state 145

    (199) expression -> array_type LBRACE RBRACE .

    DOT             reduce using rule 199 (expression -> array_type LBRACE RBRACE .)
    LBRACKET        reduce using rule 199 (expression -> array_type LBRACE RBRACE .)
    PLUS            reduce using rule 199 (expression -> array_type LBRACE RBRACE .)
    MINUS           reduce using rule 199 (expression -> array_type LBRACE RBRACE .)
    TIMES           reduce using rule 199 (expression -> array_type LBRACE RBRACE .)
    DIVIDE          reduce using rule 199 (expression -> array_type LBRACE RBRACE .)
    MODULE          reduce using rule 199 (expression -> array_type LBRACE RBRACE .)
    EQ              reduce using rule 199 (expression -> array_type LBRACE RBRACE .)
    NEQ             reduce using rule 199 (expression -> array_type LBRACE RBRACE .)
    LT              reduce using rule 199 (expression -> array_type LBRACE RBRACE .)
    LE              reduce using rule 199 (expression -> array_type LBRACE RBRACE .)
    GT              reduce using rule 199 (expression -> array_type LBRACE RBRACE .)
    GE              reduce using rule 199 (expression -> array_type LBRACE RBRACE .)
    LAND            reduce using rule 199 (expression -> array_type LBRACE RBRACE .)
    LOR             reduce using rule 199 (expression -> array_type LBRACE RBRACE .)
    AND             reduce using rule 199 (expression -> array_type LBRACE RBRACE .)
    OR              reduce using rule 199 (expression -> array_type LBRACE RBRACE .)
    XOR             reduce using rule 199 (expression -> array_type LBRACE RBRACE .)
    AND_NOT         reduce using rule 199 (expression -> array_type LBRACE RBRACE .)
    LSHIFT          reduce using rule 199 (expression -> array_type LBRACE RBRACE .)
    RSHIFT          reduce using rule 199 (expression -> array_type LBRACE RBRACE .)
    VAR             reduce using rule 199 (expression -> array_type LBRACE RBRACE .)
    CONST           reduce using rule 199 (expression -> array_type LBRACE RBRACE .)
    FUNC            reduce using rule 199 (expression -> array_type LBRACE RBRACE .)
    TYPE            reduce using rule 199 (expression -> array_type LBRACE RBRACE .)
    $end            reduce using rule 199 (expression -> array_type LBRACE RBRACE .)
    RPAREN          reduce using rule 199 (expression -> array_type LBRACE RBRACE .)
    COMMA           reduce using rule 199 (expression -> array_type LBRACE RBRACE .)
    RBRACKET        reduce using rule 199 (expression -> array_type LBRACE RBRACE .)
    RBRACE          reduce using rule 199 (expression -> array_type LBRACE RBRACE .)
    COLON           reduce using rule 199 (expression -> array_type LBRACE RBRACE .)
    BREAK           reduce using rule 199 (expression -> array_type LBRACE RBRACE .)
    CONTINUE        reduce using rule 199 (expression -> array_type LBRACE RBRACE .)
    IDENTIFIER      reduce using rule 199 (expression -> array_type LBRACE RBRACE .)
    LPAREN          reduce using rule 199 (expression -> array_type LBRACE RBRACE .)
    INT             reduce using rule 199 (expression -> array_type LBRACE RBRACE .)
    FLOAT64         reduce using rule 199 (expression -> array_type LBRACE RBRACE .)
    STRING          reduce using rule 199 (expression -> array_type LBRACE RBRACE .)
    TRUE            reduce using rule 199 (expression -> array_type LBRACE RBRACE .)
    FALSE           reduce using rule 199 (expression -> array_type LBRACE RBRACE .)
    LNOT            reduce using rule 199 (expression -> array_type LBRACE RBRACE .)
    IF              reduce using rule 199 (expression -> array_type LBRACE RBRACE .)
    SWITCH          reduce using rule 199 (expression -> array_type LBRACE RBRACE .)
    RETURN          reduce using rule 199 (expression -> array_type LBRACE RBRACE .)
    MAP             reduce using rule 199 (expression -> array_type LBRACE RBRACE .)
    FOR             reduce using rule 199 (expression -> array_type LBRACE RBRACE .)
    LBRACE          reduce using rule 199 (expression -> array_type LBRACE RBRACE .)
    CASE            reduce using rule 199 (expression -> array_type LBRACE RBRACE .)
    DEFAULT         reduce using rule 199 (expression -> array_type LBRACE RBRACE .)
    SEMICOLON       reduce using rule 199 (expression -> array_type LBRACE RBRACE .)


state 146

    (197) array_type -> LBRACKET INT RBRACKET primitive_type .

    ASSIGN          reduce using rule 197 (array_type -> LBRACKET INT RBRACKET primitive_type .)
    VAR             reduce using rule 197 (array_type -> LBRACKET INT RBRACKET primitive_type .)
    CONST           reduce using rule 197 (array_type -> LBRACKET INT RBRACKET primitive_type .)
    FUNC            reduce using rule 197 (array_type -> LBRACKET INT RBRACKET primitive_type .)
    TYPE            reduce using rule 197 (array_type -> LBRACKET INT RBRACKET primitive_type .)
    $end            reduce using rule 197 (array_type -> LBRACKET INT RBRACKET primitive_type .)
    LBRACE          reduce using rule 197 (array_type -> LBRACKET INT RBRACKET primitive_type .)
    RPAREN          reduce using rule 197 (array_type -> LBRACKET INT RBRACKET primitive_type .)
    COMMA           reduce using rule 197 (array_type -> LBRACKET INT RBRACKET primitive_type .)
    RBRACE          reduce using rule 197 (array_type -> LBRACKET INT RBRACKET primitive_type .)
    IDENTIFIER      reduce using rule 197 (array_type -> LBRACKET INT RBRACKET primitive_type .)
    BREAK           reduce using rule 197 (array_type -> LBRACKET INT RBRACKET primitive_type .)
    CONTINUE        reduce using rule 197 (array_type -> LBRACKET INT RBRACKET primitive_type .)
    LPAREN          reduce using rule 197 (array_type -> LBRACKET INT RBRACKET primitive_type .)
    INT             reduce using rule 197 (array_type -> LBRACKET INT RBRACKET primitive_type .)
    FLOAT64         reduce using rule 197 (array_type -> LBRACKET INT RBRACKET primitive_type .)
    STRING          reduce using rule 197 (array_type -> LBRACKET INT RBRACKET primitive_type .)
    TRUE            reduce using rule 197 (array_type -> LBRACKET INT RBRACKET primitive_type .)
    FALSE           reduce using rule 197 (array_type -> LBRACKET INT RBRACKET primitive_type .)
    LNOT            reduce using rule 197 (array_type -> LBRACKET INT RBRACKET primitive_type .)
    IF              reduce using rule 197 (array_type -> LBRACKET INT RBRACKET primitive_type .)
    SWITCH          reduce using rule 197 (array_type -> LBRACKET INT RBRACKET primitive_type .)
    RETURN          reduce using rule 197 (array_type -> LBRACKET INT RBRACKET primitive_type .)
    LBRACKET        reduce using rule 197 (array_type -> LBRACKET INT RBRACKET primitive_type .)
    MAP             reduce using rule 197 (array_type -> LBRACKET INT RBRACKET primitive_type .)
    FOR             reduce using rule 197 (array_type -> LBRACKET INT RBRACKET primitive_type .)
    SEMICOLON       reduce using rule 197 (array_type -> LBRACKET INT RBRACKET primitive_type .)
    CASE            reduce using rule 197 (array_type -> LBRACKET INT RBRACKET primitive_type .)
    DEFAULT         reduce using rule 197 (array_type -> LBRACKET INT RBRACKET primitive_type .)


state 147

    (137) map_type -> MAP LBRACKET primitive_type RBRACKET . primitive_type
    (61) primitive_type -> . INT_TYPE
    (62) primitive_type -> . FLOAT64_TYPE
    (63) primitive_type -> . STRING_TYPE
    (64) primitive_type -> . BOOL_TYPE

    INT_TYPE        shift and go to state 34
    FLOAT64_TYPE    shift and go to state 35
    STRING_TYPE     shift and go to state 36
    BOOL_TYPE       shift and go to state 37

    primitive_type                 shift and go to state 171

state 148

    (117) parameter -> IDENTIFIER ELLIPSIS primitive_type .

    RPAREN          reduce using rule 117 (parameter -> IDENTIFIER ELLIPSIS primitive_type .)
    COMMA           reduce using rule 117 (parameter -> IDENTIFIER ELLIPSIS primitive_type .)


state 149

    (119) return_type -> LPAREN . type_list RPAREN
    (121) type_list -> . type
    (122) type_list -> . type_list COMMA type
    (57) type -> . primitive_type
    (58) type -> . slice_type
    (59) type -> . array_type
    (60) type -> . map_type
    (61) primitive_type -> . INT_TYPE
    (62) primitive_type -> . FLOAT64_TYPE
    (63) primitive_type -> . STRING_TYPE
    (64) primitive_type -> . BOOL_TYPE
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (197) array_type -> . LBRACKET INT RBRACKET primitive_type
    (137) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type

    INT_TYPE        shift and go to state 34
    FLOAT64_TYPE    shift and go to state 35
    STRING_TYPE     shift and go to state 36
    BOOL_TYPE       shift and go to state 37
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    type_list                      shift and go to state 172
    type                           shift and go to state 173
    primitive_type                 shift and go to state 30
    slice_type                     shift and go to state 31
    array_type                     shift and go to state 32
    map_type                       shift and go to state 33

state 150

    (112) function_declaration -> FUNC IDENTIFIER LPAREN parameter_list RPAREN return_type . block
    (90) block -> . LBRACE local_statement_list RBRACE
    (91) block -> . LBRACE RBRACE

    LBRACE          shift and go to state 175

    block                          shift and go to state 174

state 151

    (118) return_type -> type .

    LBRACE          reduce using rule 118 (return_type -> type .)


state 152

    (120) return_type -> empty .

    LBRACE          reduce using rule 120 (return_type -> empty .)


state 153

    (113) parameter_list -> parameter_list COMMA parameter .

    RPAREN          reduce using rule 113 (parameter_list -> parameter_list COMMA parameter .)
    COMMA           reduce using rule 113 (parameter_list -> parameter_list COMMA parameter .)


state 154

    (146) method_declaration -> FUNC LPAREN receiver RPAREN IDENTIFIER LPAREN . parameter_list RPAREN return_type block
    (113) parameter_list -> . parameter_list COMMA parameter
    (114) parameter_list -> . parameter
    (115) parameter_list -> . empty
    (116) parameter -> . IDENTIFIER type
    (117) parameter -> . IDENTIFIER ELLIPSIS primitive_type
    (7) empty -> .

    IDENTIFIER      shift and go to state 69
    RPAREN          reduce using rule 7 (empty -> .)
    COMMA           reduce using rule 7 (empty -> .)

    parameter_list                 shift and go to state 176
    parameter                      shift and go to state 71
    empty                          shift and go to state 72

state 155

    (155) struct_type -> STRUCT LBRACE field_list RBRACE .

    VAR             reduce using rule 155 (struct_type -> STRUCT LBRACE field_list RBRACE .)
    CONST           reduce using rule 155 (struct_type -> STRUCT LBRACE field_list RBRACE .)
    FUNC            reduce using rule 155 (struct_type -> STRUCT LBRACE field_list RBRACE .)
    TYPE            reduce using rule 155 (struct_type -> STRUCT LBRACE field_list RBRACE .)
    $end            reduce using rule 155 (struct_type -> STRUCT LBRACE field_list RBRACE .)


state 156

    (144) field_list -> field_list field_declaration .

    RBRACE          reduce using rule 144 (field_list -> field_list field_declaration .)
    IDENTIFIER      reduce using rule 144 (field_list -> field_list field_declaration .)


state 157

    (145) field_declaration -> IDENTIFIER type .

    RBRACE          reduce using rule 145 (field_declaration -> IDENTIFIER type .)
    IDENTIFIER      reduce using rule 145 (field_declaration -> IDENTIFIER type .)


state 158

    (203) expression -> IDENTIFIER LPAREN argument_list RPAREN .

    DOT             reduce using rule 203 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    LBRACKET        reduce using rule 203 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    PLUS            reduce using rule 203 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    MINUS           reduce using rule 203 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    TIMES           reduce using rule 203 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    DIVIDE          reduce using rule 203 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    MODULE          reduce using rule 203 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    EQ              reduce using rule 203 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    NEQ             reduce using rule 203 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    LT              reduce using rule 203 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    LE              reduce using rule 203 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    GT              reduce using rule 203 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    GE              reduce using rule 203 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    LAND            reduce using rule 203 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    LOR             reduce using rule 203 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    AND             reduce using rule 203 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    OR              reduce using rule 203 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    XOR             reduce using rule 203 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    AND_NOT         reduce using rule 203 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    LSHIFT          reduce using rule 203 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    RSHIFT          reduce using rule 203 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    VAR             reduce using rule 203 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    CONST           reduce using rule 203 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    FUNC            reduce using rule 203 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    TYPE            reduce using rule 203 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    $end            reduce using rule 203 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    RPAREN          reduce using rule 203 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    COMMA           reduce using rule 203 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    RBRACKET        reduce using rule 203 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    RBRACE          reduce using rule 203 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    COLON           reduce using rule 203 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    BREAK           reduce using rule 203 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    CONTINUE        reduce using rule 203 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    IDENTIFIER      reduce using rule 203 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    LPAREN          reduce using rule 203 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    INT             reduce using rule 203 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    FLOAT64         reduce using rule 203 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    STRING          reduce using rule 203 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    TRUE            reduce using rule 203 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    FALSE           reduce using rule 203 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    LNOT            reduce using rule 203 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    IF              reduce using rule 203 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    SWITCH          reduce using rule 203 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    RETURN          reduce using rule 203 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    MAP             reduce using rule 203 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    FOR             reduce using rule 203 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    LBRACE          reduce using rule 203 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    CASE            reduce using rule 203 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    DEFAULT         reduce using rule 203 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    SEMICOLON       reduce using rule 203 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)


state 159

    (69) expression_list -> expression_list COMMA . expression
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (125) expression -> . LNOT expression
    (126) expression -> . IDENTIFIER PLUSPLUS
    (127) expression -> . IDENTIFIER MINUSMINUS
    (138) expression -> . map_type LBRACE expression_map_list RBRACE
    (139) expression -> . map_type LBRACE RBRACE
    (161) expression -> . type_name LBRACE keyed_element_list RBRACE
    (162) expression -> . type_name LBRACE RBRACE
    (198) expression -> . array_type LBRACE expression_list RBRACE
    (199) expression -> . array_type LBRACE RBRACE
    (200) expression -> . expression DOT IDENTIFIER
    (201) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> . expression LBRACKET expression RBRACKET
    (203) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (137) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (163) type_name -> . IDENTIFIER
    (164) type_name -> . slice_type
    (165) type_name -> . array_type
    (166) type_name -> . map_type
    (197) array_type -> . LBRACKET INT RBRACKET primitive_type

    LPAREN          shift and go to state 54
    INT             shift and go to state 55
    FLOAT64         shift and go to state 56
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 57
    TRUE            shift and go to state 58
    FALSE           shift and go to state 59
    LNOT            shift and go to state 60
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    expression                     shift and go to state 177
    slice_type                     shift and go to state 53
    map_type                       shift and go to state 61
    type_name                      shift and go to state 62
    array_type                     shift and go to state 63

state 160

    (201) expression -> expression DOT IDENTIFIER LPAREN . argument_list RPAREN
    (204) argument_list -> . expression_list
    (205) argument_list -> . empty
    (68) expression_list -> . expression
    (69) expression_list -> . expression_list COMMA expression
    (7) empty -> .
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (125) expression -> . LNOT expression
    (126) expression -> . IDENTIFIER PLUSPLUS
    (127) expression -> . IDENTIFIER MINUSMINUS
    (138) expression -> . map_type LBRACE expression_map_list RBRACE
    (139) expression -> . map_type LBRACE RBRACE
    (161) expression -> . type_name LBRACE keyed_element_list RBRACE
    (162) expression -> . type_name LBRACE RBRACE
    (198) expression -> . array_type LBRACE expression_list RBRACE
    (199) expression -> . array_type LBRACE RBRACE
    (200) expression -> . expression DOT IDENTIFIER
    (201) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> . expression LBRACKET expression RBRACKET
    (203) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (137) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (163) type_name -> . IDENTIFIER
    (164) type_name -> . slice_type
    (165) type_name -> . array_type
    (166) type_name -> . map_type
    (197) array_type -> . LBRACKET INT RBRACKET primitive_type

    RPAREN          reduce using rule 7 (empty -> .)
    LPAREN          shift and go to state 54
    INT             shift and go to state 55
    FLOAT64         shift and go to state 56
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 57
    TRUE            shift and go to state 58
    FALSE           shift and go to state 59
    LNOT            shift and go to state 60
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    expression                     shift and go to state 127
    argument_list                  shift and go to state 178
    expression_list                shift and go to state 125
    empty                          shift and go to state 126
    slice_type                     shift and go to state 53
    map_type                       shift and go to state 61
    type_name                      shift and go to state 62
    array_type                     shift and go to state 63

state 161

    (202) expression -> expression LBRACKET expression RBRACKET .

    DOT             reduce using rule 202 (expression -> expression LBRACKET expression RBRACKET .)
    LBRACKET        reduce using rule 202 (expression -> expression LBRACKET expression RBRACKET .)
    PLUS            reduce using rule 202 (expression -> expression LBRACKET expression RBRACKET .)
    MINUS           reduce using rule 202 (expression -> expression LBRACKET expression RBRACKET .)
    TIMES           reduce using rule 202 (expression -> expression LBRACKET expression RBRACKET .)
    DIVIDE          reduce using rule 202 (expression -> expression LBRACKET expression RBRACKET .)
    MODULE          reduce using rule 202 (expression -> expression LBRACKET expression RBRACKET .)
    EQ              reduce using rule 202 (expression -> expression LBRACKET expression RBRACKET .)
    NEQ             reduce using rule 202 (expression -> expression LBRACKET expression RBRACKET .)
    LT              reduce using rule 202 (expression -> expression LBRACKET expression RBRACKET .)
    LE              reduce using rule 202 (expression -> expression LBRACKET expression RBRACKET .)
    GT              reduce using rule 202 (expression -> expression LBRACKET expression RBRACKET .)
    GE              reduce using rule 202 (expression -> expression LBRACKET expression RBRACKET .)
    LAND            reduce using rule 202 (expression -> expression LBRACKET expression RBRACKET .)
    LOR             reduce using rule 202 (expression -> expression LBRACKET expression RBRACKET .)
    AND             reduce using rule 202 (expression -> expression LBRACKET expression RBRACKET .)
    OR              reduce using rule 202 (expression -> expression LBRACKET expression RBRACKET .)
    XOR             reduce using rule 202 (expression -> expression LBRACKET expression RBRACKET .)
    AND_NOT         reduce using rule 202 (expression -> expression LBRACKET expression RBRACKET .)
    LSHIFT          reduce using rule 202 (expression -> expression LBRACKET expression RBRACKET .)
    RSHIFT          reduce using rule 202 (expression -> expression LBRACKET expression RBRACKET .)
    VAR             reduce using rule 202 (expression -> expression LBRACKET expression RBRACKET .)
    CONST           reduce using rule 202 (expression -> expression LBRACKET expression RBRACKET .)
    FUNC            reduce using rule 202 (expression -> expression LBRACKET expression RBRACKET .)
    TYPE            reduce using rule 202 (expression -> expression LBRACKET expression RBRACKET .)
    $end            reduce using rule 202 (expression -> expression LBRACKET expression RBRACKET .)
    RPAREN          reduce using rule 202 (expression -> expression LBRACKET expression RBRACKET .)
    COMMA           reduce using rule 202 (expression -> expression LBRACKET expression RBRACKET .)
    RBRACKET        reduce using rule 202 (expression -> expression LBRACKET expression RBRACKET .)
    RBRACE          reduce using rule 202 (expression -> expression LBRACKET expression RBRACKET .)
    COLON           reduce using rule 202 (expression -> expression LBRACKET expression RBRACKET .)
    BREAK           reduce using rule 202 (expression -> expression LBRACKET expression RBRACKET .)
    CONTINUE        reduce using rule 202 (expression -> expression LBRACKET expression RBRACKET .)
    IDENTIFIER      reduce using rule 202 (expression -> expression LBRACKET expression RBRACKET .)
    LPAREN          reduce using rule 202 (expression -> expression LBRACKET expression RBRACKET .)
    INT             reduce using rule 202 (expression -> expression LBRACKET expression RBRACKET .)
    FLOAT64         reduce using rule 202 (expression -> expression LBRACKET expression RBRACKET .)
    STRING          reduce using rule 202 (expression -> expression LBRACKET expression RBRACKET .)
    TRUE            reduce using rule 202 (expression -> expression LBRACKET expression RBRACKET .)
    FALSE           reduce using rule 202 (expression -> expression LBRACKET expression RBRACKET .)
    LNOT            reduce using rule 202 (expression -> expression LBRACKET expression RBRACKET .)
    IF              reduce using rule 202 (expression -> expression LBRACKET expression RBRACKET .)
    SWITCH          reduce using rule 202 (expression -> expression LBRACKET expression RBRACKET .)
    RETURN          reduce using rule 202 (expression -> expression LBRACKET expression RBRACKET .)
    MAP             reduce using rule 202 (expression -> expression LBRACKET expression RBRACKET .)
    FOR             reduce using rule 202 (expression -> expression LBRACKET expression RBRACKET .)
    LBRACE          reduce using rule 202 (expression -> expression LBRACKET expression RBRACKET .)
    CASE            reduce using rule 202 (expression -> expression LBRACKET expression RBRACKET .)
    DEFAULT         reduce using rule 202 (expression -> expression LBRACKET expression RBRACKET .)
    SEMICOLON       reduce using rule 202 (expression -> expression LBRACKET expression RBRACKET .)


state 162

    (66) expression -> slice_type LBRACE expression_list RBRACE .

    DOT             reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    LBRACKET        reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    PLUS            reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    MINUS           reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    TIMES           reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    DIVIDE          reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    MODULE          reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    EQ              reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    NEQ             reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    LT              reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    LE              reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    GT              reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    GE              reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    LAND            reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    LOR             reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    AND             reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    OR              reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    XOR             reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    AND_NOT         reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    LSHIFT          reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    RSHIFT          reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    VAR             reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    CONST           reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    FUNC            reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    TYPE            reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    $end            reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    RPAREN          reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    COMMA           reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    RBRACKET        reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    RBRACE          reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    COLON           reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    BREAK           reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    CONTINUE        reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    IDENTIFIER      reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    LPAREN          reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    INT             reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    FLOAT64         reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    STRING          reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    TRUE            reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    FALSE           reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    LNOT            reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    IF              reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    SWITCH          reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    RETURN          reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    MAP             reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    FOR             reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    LBRACE          reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    CASE            reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    DEFAULT         reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    SEMICOLON       reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)


state 163

    (138) expression -> map_type LBRACE expression_map_list RBRACE .

    DOT             reduce using rule 138 (expression -> map_type LBRACE expression_map_list RBRACE .)
    LBRACKET        reduce using rule 138 (expression -> map_type LBRACE expression_map_list RBRACE .)
    PLUS            reduce using rule 138 (expression -> map_type LBRACE expression_map_list RBRACE .)
    MINUS           reduce using rule 138 (expression -> map_type LBRACE expression_map_list RBRACE .)
    TIMES           reduce using rule 138 (expression -> map_type LBRACE expression_map_list RBRACE .)
    DIVIDE          reduce using rule 138 (expression -> map_type LBRACE expression_map_list RBRACE .)
    MODULE          reduce using rule 138 (expression -> map_type LBRACE expression_map_list RBRACE .)
    EQ              reduce using rule 138 (expression -> map_type LBRACE expression_map_list RBRACE .)
    NEQ             reduce using rule 138 (expression -> map_type LBRACE expression_map_list RBRACE .)
    LT              reduce using rule 138 (expression -> map_type LBRACE expression_map_list RBRACE .)
    LE              reduce using rule 138 (expression -> map_type LBRACE expression_map_list RBRACE .)
    GT              reduce using rule 138 (expression -> map_type LBRACE expression_map_list RBRACE .)
    GE              reduce using rule 138 (expression -> map_type LBRACE expression_map_list RBRACE .)
    LAND            reduce using rule 138 (expression -> map_type LBRACE expression_map_list RBRACE .)
    LOR             reduce using rule 138 (expression -> map_type LBRACE expression_map_list RBRACE .)
    AND             reduce using rule 138 (expression -> map_type LBRACE expression_map_list RBRACE .)
    OR              reduce using rule 138 (expression -> map_type LBRACE expression_map_list RBRACE .)
    XOR             reduce using rule 138 (expression -> map_type LBRACE expression_map_list RBRACE .)
    AND_NOT         reduce using rule 138 (expression -> map_type LBRACE expression_map_list RBRACE .)
    LSHIFT          reduce using rule 138 (expression -> map_type LBRACE expression_map_list RBRACE .)
    RSHIFT          reduce using rule 138 (expression -> map_type LBRACE expression_map_list RBRACE .)
    VAR             reduce using rule 138 (expression -> map_type LBRACE expression_map_list RBRACE .)
    CONST           reduce using rule 138 (expression -> map_type LBRACE expression_map_list RBRACE .)
    FUNC            reduce using rule 138 (expression -> map_type LBRACE expression_map_list RBRACE .)
    TYPE            reduce using rule 138 (expression -> map_type LBRACE expression_map_list RBRACE .)
    $end            reduce using rule 138 (expression -> map_type LBRACE expression_map_list RBRACE .)
    RPAREN          reduce using rule 138 (expression -> map_type LBRACE expression_map_list RBRACE .)
    COMMA           reduce using rule 138 (expression -> map_type LBRACE expression_map_list RBRACE .)
    RBRACKET        reduce using rule 138 (expression -> map_type LBRACE expression_map_list RBRACE .)
    RBRACE          reduce using rule 138 (expression -> map_type LBRACE expression_map_list RBRACE .)
    COLON           reduce using rule 138 (expression -> map_type LBRACE expression_map_list RBRACE .)
    BREAK           reduce using rule 138 (expression -> map_type LBRACE expression_map_list RBRACE .)
    CONTINUE        reduce using rule 138 (expression -> map_type LBRACE expression_map_list RBRACE .)
    IDENTIFIER      reduce using rule 138 (expression -> map_type LBRACE expression_map_list RBRACE .)
    LPAREN          reduce using rule 138 (expression -> map_type LBRACE expression_map_list RBRACE .)
    INT             reduce using rule 138 (expression -> map_type LBRACE expression_map_list RBRACE .)
    FLOAT64         reduce using rule 138 (expression -> map_type LBRACE expression_map_list RBRACE .)
    STRING          reduce using rule 138 (expression -> map_type LBRACE expression_map_list RBRACE .)
    TRUE            reduce using rule 138 (expression -> map_type LBRACE expression_map_list RBRACE .)
    FALSE           reduce using rule 138 (expression -> map_type LBRACE expression_map_list RBRACE .)
    LNOT            reduce using rule 138 (expression -> map_type LBRACE expression_map_list RBRACE .)
    IF              reduce using rule 138 (expression -> map_type LBRACE expression_map_list RBRACE .)
    SWITCH          reduce using rule 138 (expression -> map_type LBRACE expression_map_list RBRACE .)
    RETURN          reduce using rule 138 (expression -> map_type LBRACE expression_map_list RBRACE .)
    MAP             reduce using rule 138 (expression -> map_type LBRACE expression_map_list RBRACE .)
    FOR             reduce using rule 138 (expression -> map_type LBRACE expression_map_list RBRACE .)
    LBRACE          reduce using rule 138 (expression -> map_type LBRACE expression_map_list RBRACE .)
    CASE            reduce using rule 138 (expression -> map_type LBRACE expression_map_list RBRACE .)
    DEFAULT         reduce using rule 138 (expression -> map_type LBRACE expression_map_list RBRACE .)
    SEMICOLON       reduce using rule 138 (expression -> map_type LBRACE expression_map_list RBRACE .)


state 164

    (141) expression_map_list -> expression_map_list COMMA . key_value
    (142) key_value -> . expression COLON expression
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (125) expression -> . LNOT expression
    (126) expression -> . IDENTIFIER PLUSPLUS
    (127) expression -> . IDENTIFIER MINUSMINUS
    (138) expression -> . map_type LBRACE expression_map_list RBRACE
    (139) expression -> . map_type LBRACE RBRACE
    (161) expression -> . type_name LBRACE keyed_element_list RBRACE
    (162) expression -> . type_name LBRACE RBRACE
    (198) expression -> . array_type LBRACE expression_list RBRACE
    (199) expression -> . array_type LBRACE RBRACE
    (200) expression -> . expression DOT IDENTIFIER
    (201) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> . expression LBRACKET expression RBRACKET
    (203) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (137) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (163) type_name -> . IDENTIFIER
    (164) type_name -> . slice_type
    (165) type_name -> . array_type
    (166) type_name -> . map_type
    (197) array_type -> . LBRACKET INT RBRACKET primitive_type

    LPAREN          shift and go to state 54
    INT             shift and go to state 55
    FLOAT64         shift and go to state 56
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 57
    TRUE            shift and go to state 58
    FALSE           shift and go to state 59
    LNOT            shift and go to state 60
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    key_value                      shift and go to state 179
    expression                     shift and go to state 137
    slice_type                     shift and go to state 53
    map_type                       shift and go to state 61
    type_name                      shift and go to state 62
    array_type                     shift and go to state 63

state 165

    (142) key_value -> expression COLON . expression
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (125) expression -> . LNOT expression
    (126) expression -> . IDENTIFIER PLUSPLUS
    (127) expression -> . IDENTIFIER MINUSMINUS
    (138) expression -> . map_type LBRACE expression_map_list RBRACE
    (139) expression -> . map_type LBRACE RBRACE
    (161) expression -> . type_name LBRACE keyed_element_list RBRACE
    (162) expression -> . type_name LBRACE RBRACE
    (198) expression -> . array_type LBRACE expression_list RBRACE
    (199) expression -> . array_type LBRACE RBRACE
    (200) expression -> . expression DOT IDENTIFIER
    (201) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> . expression LBRACKET expression RBRACKET
    (203) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (137) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (163) type_name -> . IDENTIFIER
    (164) type_name -> . slice_type
    (165) type_name -> . array_type
    (166) type_name -> . map_type
    (197) array_type -> . LBRACKET INT RBRACKET primitive_type

    LPAREN          shift and go to state 54
    INT             shift and go to state 55
    FLOAT64         shift and go to state 56
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 57
    TRUE            shift and go to state 58
    FALSE           shift and go to state 59
    LNOT            shift and go to state 60
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    expression                     shift and go to state 180
    slice_type                     shift and go to state 53
    map_type                       shift and go to state 61
    type_name                      shift and go to state 62
    array_type                     shift and go to state 63

state 166

    (161) expression -> type_name LBRACE keyed_element_list RBRACE .

    DOT             reduce using rule 161 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    LBRACKET        reduce using rule 161 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    PLUS            reduce using rule 161 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    MINUS           reduce using rule 161 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    TIMES           reduce using rule 161 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    DIVIDE          reduce using rule 161 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    MODULE          reduce using rule 161 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    EQ              reduce using rule 161 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    NEQ             reduce using rule 161 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    LT              reduce using rule 161 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    LE              reduce using rule 161 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    GT              reduce using rule 161 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    GE              reduce using rule 161 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    LAND            reduce using rule 161 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    LOR             reduce using rule 161 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    AND             reduce using rule 161 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    OR              reduce using rule 161 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    XOR             reduce using rule 161 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    AND_NOT         reduce using rule 161 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    LSHIFT          reduce using rule 161 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    RSHIFT          reduce using rule 161 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    VAR             reduce using rule 161 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    CONST           reduce using rule 161 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    FUNC            reduce using rule 161 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    TYPE            reduce using rule 161 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    $end            reduce using rule 161 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    RPAREN          reduce using rule 161 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    COMMA           reduce using rule 161 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    RBRACKET        reduce using rule 161 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    RBRACE          reduce using rule 161 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    COLON           reduce using rule 161 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    BREAK           reduce using rule 161 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    CONTINUE        reduce using rule 161 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    IDENTIFIER      reduce using rule 161 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    LPAREN          reduce using rule 161 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    INT             reduce using rule 161 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    FLOAT64         reduce using rule 161 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    STRING          reduce using rule 161 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    TRUE            reduce using rule 161 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    FALSE           reduce using rule 161 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    LNOT            reduce using rule 161 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    IF              reduce using rule 161 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    SWITCH          reduce using rule 161 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    RETURN          reduce using rule 161 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    MAP             reduce using rule 161 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    FOR             reduce using rule 161 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    LBRACE          reduce using rule 161 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    CASE            reduce using rule 161 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    DEFAULT         reduce using rule 161 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    SEMICOLON       reduce using rule 161 (expression -> type_name LBRACE keyed_element_list RBRACE .)


state 167

    (157) keyed_element_list -> keyed_element_list COMMA . keyed_element
    (158) keyed_element -> . IDENTIFIER COLON expression
    (159) keyed_element -> . INT COLON expression
    (160) keyed_element -> . expression
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (125) expression -> . LNOT expression
    (126) expression -> . IDENTIFIER PLUSPLUS
    (127) expression -> . IDENTIFIER MINUSMINUS
    (138) expression -> . map_type LBRACE expression_map_list RBRACE
    (139) expression -> . map_type LBRACE RBRACE
    (161) expression -> . type_name LBRACE keyed_element_list RBRACE
    (162) expression -> . type_name LBRACE RBRACE
    (198) expression -> . array_type LBRACE expression_list RBRACE
    (199) expression -> . array_type LBRACE RBRACE
    (200) expression -> . expression DOT IDENTIFIER
    (201) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> . expression LBRACKET expression RBRACKET
    (203) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (137) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (163) type_name -> . IDENTIFIER
    (164) type_name -> . slice_type
    (165) type_name -> . array_type
    (166) type_name -> . map_type
    (197) array_type -> . LBRACKET INT RBRACKET primitive_type

    IDENTIFIER      shift and go to state 141
    INT             shift and go to state 143
    LPAREN          shift and go to state 54
    FLOAT64         shift and go to state 56
    STRING          shift and go to state 57
    TRUE            shift and go to state 58
    FALSE           shift and go to state 59
    LNOT            shift and go to state 60
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    keyed_element                  shift and go to state 181
    expression                     shift and go to state 142
    slice_type                     shift and go to state 53
    map_type                       shift and go to state 61
    type_name                      shift and go to state 62
    array_type                     shift and go to state 63

state 168

    (158) keyed_element -> IDENTIFIER COLON . expression
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (125) expression -> . LNOT expression
    (126) expression -> . IDENTIFIER PLUSPLUS
    (127) expression -> . IDENTIFIER MINUSMINUS
    (138) expression -> . map_type LBRACE expression_map_list RBRACE
    (139) expression -> . map_type LBRACE RBRACE
    (161) expression -> . type_name LBRACE keyed_element_list RBRACE
    (162) expression -> . type_name LBRACE RBRACE
    (198) expression -> . array_type LBRACE expression_list RBRACE
    (199) expression -> . array_type LBRACE RBRACE
    (200) expression -> . expression DOT IDENTIFIER
    (201) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> . expression LBRACKET expression RBRACKET
    (203) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (137) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (163) type_name -> . IDENTIFIER
    (164) type_name -> . slice_type
    (165) type_name -> . array_type
    (166) type_name -> . map_type
    (197) array_type -> . LBRACKET INT RBRACKET primitive_type

    LPAREN          shift and go to state 54
    INT             shift and go to state 55
    FLOAT64         shift and go to state 56
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 57
    TRUE            shift and go to state 58
    FALSE           shift and go to state 59
    LNOT            shift and go to state 60
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    expression                     shift and go to state 182
    slice_type                     shift and go to state 53
    map_type                       shift and go to state 61
    type_name                      shift and go to state 62
    array_type                     shift and go to state 63

state 169

    (159) keyed_element -> INT COLON . expression
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (125) expression -> . LNOT expression
    (126) expression -> . IDENTIFIER PLUSPLUS
    (127) expression -> . IDENTIFIER MINUSMINUS
    (138) expression -> . map_type LBRACE expression_map_list RBRACE
    (139) expression -> . map_type LBRACE RBRACE
    (161) expression -> . type_name LBRACE keyed_element_list RBRACE
    (162) expression -> . type_name LBRACE RBRACE
    (198) expression -> . array_type LBRACE expression_list RBRACE
    (199) expression -> . array_type LBRACE RBRACE
    (200) expression -> . expression DOT IDENTIFIER
    (201) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> . expression LBRACKET expression RBRACKET
    (203) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (137) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (163) type_name -> . IDENTIFIER
    (164) type_name -> . slice_type
    (165) type_name -> . array_type
    (166) type_name -> . map_type
    (197) array_type -> . LBRACKET INT RBRACKET primitive_type

    LPAREN          shift and go to state 54
    INT             shift and go to state 55
    FLOAT64         shift and go to state 56
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 57
    TRUE            shift and go to state 58
    FALSE           shift and go to state 59
    LNOT            shift and go to state 60
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    expression                     shift and go to state 183
    slice_type                     shift and go to state 53
    map_type                       shift and go to state 61
    type_name                      shift and go to state 62
    array_type                     shift and go to state 63

state 170

    (198) expression -> array_type LBRACE expression_list RBRACE .

    DOT             reduce using rule 198 (expression -> array_type LBRACE expression_list RBRACE .)
    LBRACKET        reduce using rule 198 (expression -> array_type LBRACE expression_list RBRACE .)
    PLUS            reduce using rule 198 (expression -> array_type LBRACE expression_list RBRACE .)
    MINUS           reduce using rule 198 (expression -> array_type LBRACE expression_list RBRACE .)
    TIMES           reduce using rule 198 (expression -> array_type LBRACE expression_list RBRACE .)
    DIVIDE          reduce using rule 198 (expression -> array_type LBRACE expression_list RBRACE .)
    MODULE          reduce using rule 198 (expression -> array_type LBRACE expression_list RBRACE .)
    EQ              reduce using rule 198 (expression -> array_type LBRACE expression_list RBRACE .)
    NEQ             reduce using rule 198 (expression -> array_type LBRACE expression_list RBRACE .)
    LT              reduce using rule 198 (expression -> array_type LBRACE expression_list RBRACE .)
    LE              reduce using rule 198 (expression -> array_type LBRACE expression_list RBRACE .)
    GT              reduce using rule 198 (expression -> array_type LBRACE expression_list RBRACE .)
    GE              reduce using rule 198 (expression -> array_type LBRACE expression_list RBRACE .)
    LAND            reduce using rule 198 (expression -> array_type LBRACE expression_list RBRACE .)
    LOR             reduce using rule 198 (expression -> array_type LBRACE expression_list RBRACE .)
    AND             reduce using rule 198 (expression -> array_type LBRACE expression_list RBRACE .)
    OR              reduce using rule 198 (expression -> array_type LBRACE expression_list RBRACE .)
    XOR             reduce using rule 198 (expression -> array_type LBRACE expression_list RBRACE .)
    AND_NOT         reduce using rule 198 (expression -> array_type LBRACE expression_list RBRACE .)
    LSHIFT          reduce using rule 198 (expression -> array_type LBRACE expression_list RBRACE .)
    RSHIFT          reduce using rule 198 (expression -> array_type LBRACE expression_list RBRACE .)
    VAR             reduce using rule 198 (expression -> array_type LBRACE expression_list RBRACE .)
    CONST           reduce using rule 198 (expression -> array_type LBRACE expression_list RBRACE .)
    FUNC            reduce using rule 198 (expression -> array_type LBRACE expression_list RBRACE .)
    TYPE            reduce using rule 198 (expression -> array_type LBRACE expression_list RBRACE .)
    $end            reduce using rule 198 (expression -> array_type LBRACE expression_list RBRACE .)
    RPAREN          reduce using rule 198 (expression -> array_type LBRACE expression_list RBRACE .)
    COMMA           reduce using rule 198 (expression -> array_type LBRACE expression_list RBRACE .)
    RBRACKET        reduce using rule 198 (expression -> array_type LBRACE expression_list RBRACE .)
    RBRACE          reduce using rule 198 (expression -> array_type LBRACE expression_list RBRACE .)
    COLON           reduce using rule 198 (expression -> array_type LBRACE expression_list RBRACE .)
    BREAK           reduce using rule 198 (expression -> array_type LBRACE expression_list RBRACE .)
    CONTINUE        reduce using rule 198 (expression -> array_type LBRACE expression_list RBRACE .)
    IDENTIFIER      reduce using rule 198 (expression -> array_type LBRACE expression_list RBRACE .)
    LPAREN          reduce using rule 198 (expression -> array_type LBRACE expression_list RBRACE .)
    INT             reduce using rule 198 (expression -> array_type LBRACE expression_list RBRACE .)
    FLOAT64         reduce using rule 198 (expression -> array_type LBRACE expression_list RBRACE .)
    STRING          reduce using rule 198 (expression -> array_type LBRACE expression_list RBRACE .)
    TRUE            reduce using rule 198 (expression -> array_type LBRACE expression_list RBRACE .)
    FALSE           reduce using rule 198 (expression -> array_type LBRACE expression_list RBRACE .)
    LNOT            reduce using rule 198 (expression -> array_type LBRACE expression_list RBRACE .)
    IF              reduce using rule 198 (expression -> array_type LBRACE expression_list RBRACE .)
    SWITCH          reduce using rule 198 (expression -> array_type LBRACE expression_list RBRACE .)
    RETURN          reduce using rule 198 (expression -> array_type LBRACE expression_list RBRACE .)
    MAP             reduce using rule 198 (expression -> array_type LBRACE expression_list RBRACE .)
    FOR             reduce using rule 198 (expression -> array_type LBRACE expression_list RBRACE .)
    LBRACE          reduce using rule 198 (expression -> array_type LBRACE expression_list RBRACE .)
    CASE            reduce using rule 198 (expression -> array_type LBRACE expression_list RBRACE .)
    DEFAULT         reduce using rule 198 (expression -> array_type LBRACE expression_list RBRACE .)
    SEMICOLON       reduce using rule 198 (expression -> array_type LBRACE expression_list RBRACE .)


state 171

    (137) map_type -> MAP LBRACKET primitive_type RBRACKET primitive_type .

    ASSIGN          reduce using rule 137 (map_type -> MAP LBRACKET primitive_type RBRACKET primitive_type .)
    VAR             reduce using rule 137 (map_type -> MAP LBRACKET primitive_type RBRACKET primitive_type .)
    CONST           reduce using rule 137 (map_type -> MAP LBRACKET primitive_type RBRACKET primitive_type .)
    FUNC            reduce using rule 137 (map_type -> MAP LBRACKET primitive_type RBRACKET primitive_type .)
    TYPE            reduce using rule 137 (map_type -> MAP LBRACKET primitive_type RBRACKET primitive_type .)
    $end            reduce using rule 137 (map_type -> MAP LBRACKET primitive_type RBRACKET primitive_type .)
    LBRACE          reduce using rule 137 (map_type -> MAP LBRACKET primitive_type RBRACKET primitive_type .)
    RPAREN          reduce using rule 137 (map_type -> MAP LBRACKET primitive_type RBRACKET primitive_type .)
    COMMA           reduce using rule 137 (map_type -> MAP LBRACKET primitive_type RBRACKET primitive_type .)
    RBRACE          reduce using rule 137 (map_type -> MAP LBRACKET primitive_type RBRACKET primitive_type .)
    IDENTIFIER      reduce using rule 137 (map_type -> MAP LBRACKET primitive_type RBRACKET primitive_type .)
    BREAK           reduce using rule 137 (map_type -> MAP LBRACKET primitive_type RBRACKET primitive_type .)
    CONTINUE        reduce using rule 137 (map_type -> MAP LBRACKET primitive_type RBRACKET primitive_type .)
    LPAREN          reduce using rule 137 (map_type -> MAP LBRACKET primitive_type RBRACKET primitive_type .)
    INT             reduce using rule 137 (map_type -> MAP LBRACKET primitive_type RBRACKET primitive_type .)
    FLOAT64         reduce using rule 137 (map_type -> MAP LBRACKET primitive_type RBRACKET primitive_type .)
    STRING          reduce using rule 137 (map_type -> MAP LBRACKET primitive_type RBRACKET primitive_type .)
    TRUE            reduce using rule 137 (map_type -> MAP LBRACKET primitive_type RBRACKET primitive_type .)
    FALSE           reduce using rule 137 (map_type -> MAP LBRACKET primitive_type RBRACKET primitive_type .)
    LNOT            reduce using rule 137 (map_type -> MAP LBRACKET primitive_type RBRACKET primitive_type .)
    IF              reduce using rule 137 (map_type -> MAP LBRACKET primitive_type RBRACKET primitive_type .)
    SWITCH          reduce using rule 137 (map_type -> MAP LBRACKET primitive_type RBRACKET primitive_type .)
    RETURN          reduce using rule 137 (map_type -> MAP LBRACKET primitive_type RBRACKET primitive_type .)
    LBRACKET        reduce using rule 137 (map_type -> MAP LBRACKET primitive_type RBRACKET primitive_type .)
    MAP             reduce using rule 137 (map_type -> MAP LBRACKET primitive_type RBRACKET primitive_type .)
    FOR             reduce using rule 137 (map_type -> MAP LBRACKET primitive_type RBRACKET primitive_type .)
    SEMICOLON       reduce using rule 137 (map_type -> MAP LBRACKET primitive_type RBRACKET primitive_type .)
    CASE            reduce using rule 137 (map_type -> MAP LBRACKET primitive_type RBRACKET primitive_type .)
    DEFAULT         reduce using rule 137 (map_type -> MAP LBRACKET primitive_type RBRACKET primitive_type .)


state 172

    (119) return_type -> LPAREN type_list . RPAREN
    (122) type_list -> type_list . COMMA type

    RPAREN          shift and go to state 184
    COMMA           shift and go to state 185


state 173

    (121) type_list -> type .

    RPAREN          reduce using rule 121 (type_list -> type .)
    COMMA           reduce using rule 121 (type_list -> type .)


state 174

    (112) function_declaration -> FUNC IDENTIFIER LPAREN parameter_list RPAREN return_type block .

    VAR             reduce using rule 112 (function_declaration -> FUNC IDENTIFIER LPAREN parameter_list RPAREN return_type block .)
    CONST           reduce using rule 112 (function_declaration -> FUNC IDENTIFIER LPAREN parameter_list RPAREN return_type block .)
    FUNC            reduce using rule 112 (function_declaration -> FUNC IDENTIFIER LPAREN parameter_list RPAREN return_type block .)
    TYPE            reduce using rule 112 (function_declaration -> FUNC IDENTIFIER LPAREN parameter_list RPAREN return_type block .)
    $end            reduce using rule 112 (function_declaration -> FUNC IDENTIFIER LPAREN parameter_list RPAREN return_type block .)


state 175

    (90) block -> LBRACE . local_statement_list RBRACE
    (91) block -> LBRACE . RBRACE
    (92) local_statement_list -> . local_statement
    (93) local_statement_list -> . local_statement_list local_statement
    (78) local_statement -> . local_var_dec
    (79) local_statement -> . local_const_dec
    (80) local_statement -> . short_assignment
    (81) local_statement -> . simple_assignment
    (82) local_statement -> . assignment_compound
    (83) local_statement -> . expression
    (84) local_statement -> . for_statement
    (85) local_statement -> . if_statement
    (86) local_statement -> . switch_statement
    (87) local_statement -> . return_statement
    (88) local_statement -> . BREAK
    (89) local_statement -> . CONTINUE
    (20) local_var_dec -> . VAR IDENTIFIER type
    (21) local_var_dec -> . VAR IDENTIFIER type ASSIGN expression
    (22) local_var_dec -> . VAR IDENTIFIER ASSIGN expression
    (23) local_const_dec -> . CONST IDENTIFIER type ASSIGN expression
    (24) local_const_dec -> . CONST IDENTIFIER ASSIGN expression
    (77) short_assignment -> . IDENTIFIER SHORT_ASSIGN expression
    (56) simple_assignment -> . IDENTIFIER ASSIGN expression
    (25) assignment_compound -> . IDENTIFIER operator_assign expression
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (125) expression -> . LNOT expression
    (126) expression -> . IDENTIFIER PLUSPLUS
    (127) expression -> . IDENTIFIER MINUSMINUS
    (138) expression -> . map_type LBRACE expression_map_list RBRACE
    (139) expression -> . map_type LBRACE RBRACE
    (161) expression -> . type_name LBRACE keyed_element_list RBRACE
    (162) expression -> . type_name LBRACE RBRACE
    (198) expression -> . array_type LBRACE expression_list RBRACE
    (199) expression -> . array_type LBRACE RBRACE
    (200) expression -> . expression DOT IDENTIFIER
    (201) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> . expression LBRACKET expression RBRACKET
    (203) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (94) for_statement -> . for_classic
    (95) for_statement -> . for_condition
    (96) for_statement -> . for_infinite
    (128) if_statement -> . IF expression block
    (129) if_statement -> . IF expression block ELSE block
    (130) if_statement -> . IF expression block ELSE if_statement
    (131) if_statement -> . IF if_assignment SEMICOLON expression block
    (132) if_statement -> . IF if_assignment SEMICOLON expression block ELSE block
    (133) if_statement -> . IF if_assignment SEMICOLON expression block ELSE if_statement
    (167) switch_statement -> . SWITCH switch_expr LBRACE case_clause_list RBRACE
    (168) switch_statement -> . SWITCH switch_expr LBRACE RBRACE
    (169) switch_statement -> . SWITCH LBRACE case_clause_list RBRACE
    (170) switch_statement -> . SWITCH LBRACE RBRACE
    (171) switch_statement -> . SWITCH switch_assignment SEMICOLON switch_expr LBRACE case_clause_list RBRACE
    (172) switch_statement -> . SWITCH switch_assignment SEMICOLON switch_expr LBRACE RBRACE
    (173) switch_statement -> . SWITCH switch_assignment SEMICOLON LBRACE case_clause_list RBRACE
    (174) switch_statement -> . SWITCH switch_assignment SEMICOLON LBRACE RBRACE
    (123) return_statement -> . RETURN
    (124) return_statement -> . RETURN return_list
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (137) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (163) type_name -> . IDENTIFIER
    (164) type_name -> . slice_type
    (165) type_name -> . array_type
    (166) type_name -> . map_type
    (197) array_type -> . LBRACKET INT RBRACKET primitive_type
    (97) for_classic -> . FOR for_init SEMICOLON for_cond SEMICOLON for_post block
    (98) for_condition -> . FOR expression block
    (99) for_infinite -> . FOR block

    RBRACE          shift and go to state 187
    BREAK           shift and go to state 199
    CONTINUE        shift and go to state 200
    VAR             shift and go to state 201
    CONST           shift and go to state 203
    IDENTIFIER      shift and go to state 202
    LPAREN          shift and go to state 54
    INT             shift and go to state 55
    FLOAT64         shift and go to state 56
    STRING          shift and go to state 57
    TRUE            shift and go to state 58
    FALSE           shift and go to state 59
    LNOT            shift and go to state 60
    IF              shift and go to state 207
    SWITCH          shift and go to state 208
    RETURN          shift and go to state 209
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39
    FOR             shift and go to state 210

    local_statement_list           shift and go to state 186
    local_statement                shift and go to state 188
    local_var_dec                  shift and go to state 189
    local_const_dec                shift and go to state 190
    short_assignment               shift and go to state 191
    simple_assignment              shift and go to state 192
    assignment_compound            shift and go to state 193
    expression                     shift and go to state 194
    for_statement                  shift and go to state 195
    if_statement                   shift and go to state 196
    switch_statement               shift and go to state 197
    return_statement               shift and go to state 198
    slice_type                     shift and go to state 53
    map_type                       shift and go to state 61
    type_name                      shift and go to state 62
    array_type                     shift and go to state 63
    for_classic                    shift and go to state 204
    for_condition                  shift and go to state 205
    for_infinite                   shift and go to state 206

state 176

    (146) method_declaration -> FUNC LPAREN receiver RPAREN IDENTIFIER LPAREN parameter_list . RPAREN return_type block
    (113) parameter_list -> parameter_list . COMMA parameter

    RPAREN          shift and go to state 211
    COMMA           shift and go to state 116


state 177

    (69) expression_list -> expression_list COMMA expression .
    (36) expression -> expression . binary_operator expression
    (200) expression -> expression . DOT IDENTIFIER
    (201) expression -> expression . DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> expression . LBRACKET expression RBRACKET
    (37) binary_operator -> . PLUS
    (38) binary_operator -> . MINUS
    (39) binary_operator -> . TIMES
    (40) binary_operator -> . DIVIDE
    (41) binary_operator -> . MODULE
    (42) binary_operator -> . EQ
    (43) binary_operator -> . NEQ
    (44) binary_operator -> . LT
    (45) binary_operator -> . LE
    (46) binary_operator -> . GT
    (47) binary_operator -> . GE
    (48) binary_operator -> . LAND
    (49) binary_operator -> . LOR
    (50) binary_operator -> . AND
    (51) binary_operator -> . OR
    (52) binary_operator -> . XOR
    (53) binary_operator -> . AND_NOT
    (54) binary_operator -> . LSHIFT
    (55) binary_operator -> . RSHIFT

    COMMA           reduce using rule 69 (expression_list -> expression_list COMMA expression .)
    RPAREN          reduce using rule 69 (expression_list -> expression_list COMMA expression .)
    RBRACE          reduce using rule 69 (expression_list -> expression_list COMMA expression .)
    DOT             shift and go to state 82
    LBRACKET        shift and go to state 83
    PLUS            shift and go to state 84
    MINUS           shift and go to state 85
    TIMES           shift and go to state 86
    DIVIDE          shift and go to state 87
    MODULE          shift and go to state 88
    EQ              shift and go to state 89
    NEQ             shift and go to state 90
    LT              shift and go to state 91
    LE              shift and go to state 92
    GT              shift and go to state 93
    GE              shift and go to state 94
    LAND            shift and go to state 95
    LOR             shift and go to state 96
    AND             shift and go to state 97
    OR              shift and go to state 98
    XOR             shift and go to state 99
    AND_NOT         shift and go to state 100
    LSHIFT          shift and go to state 101
    RSHIFT          shift and go to state 102

    binary_operator                shift and go to state 81

state 178

    (201) expression -> expression DOT IDENTIFIER LPAREN argument_list . RPAREN

    RPAREN          shift and go to state 212


state 179

    (141) expression_map_list -> expression_map_list COMMA key_value .

    RBRACE          reduce using rule 141 (expression_map_list -> expression_map_list COMMA key_value .)
    COMMA           reduce using rule 141 (expression_map_list -> expression_map_list COMMA key_value .)


state 180

    (142) key_value -> expression COLON expression .
    (36) expression -> expression . binary_operator expression
    (200) expression -> expression . DOT IDENTIFIER
    (201) expression -> expression . DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> expression . LBRACKET expression RBRACKET
    (37) binary_operator -> . PLUS
    (38) binary_operator -> . MINUS
    (39) binary_operator -> . TIMES
    (40) binary_operator -> . DIVIDE
    (41) binary_operator -> . MODULE
    (42) binary_operator -> . EQ
    (43) binary_operator -> . NEQ
    (44) binary_operator -> . LT
    (45) binary_operator -> . LE
    (46) binary_operator -> . GT
    (47) binary_operator -> . GE
    (48) binary_operator -> . LAND
    (49) binary_operator -> . LOR
    (50) binary_operator -> . AND
    (51) binary_operator -> . OR
    (52) binary_operator -> . XOR
    (53) binary_operator -> . AND_NOT
    (54) binary_operator -> . LSHIFT
    (55) binary_operator -> . RSHIFT

    RBRACE          reduce using rule 142 (key_value -> expression COLON expression .)
    COMMA           reduce using rule 142 (key_value -> expression COLON expression .)
    DOT             shift and go to state 82
    LBRACKET        shift and go to state 83
    PLUS            shift and go to state 84
    MINUS           shift and go to state 85
    TIMES           shift and go to state 86
    DIVIDE          shift and go to state 87
    MODULE          shift and go to state 88
    EQ              shift and go to state 89
    NEQ             shift and go to state 90
    LT              shift and go to state 91
    LE              shift and go to state 92
    GT              shift and go to state 93
    GE              shift and go to state 94
    LAND            shift and go to state 95
    LOR             shift and go to state 96
    AND             shift and go to state 97
    OR              shift and go to state 98
    XOR             shift and go to state 99
    AND_NOT         shift and go to state 100
    LSHIFT          shift and go to state 101
    RSHIFT          shift and go to state 102

    binary_operator                shift and go to state 81

state 181

    (157) keyed_element_list -> keyed_element_list COMMA keyed_element .

    RBRACE          reduce using rule 157 (keyed_element_list -> keyed_element_list COMMA keyed_element .)
    COMMA           reduce using rule 157 (keyed_element_list -> keyed_element_list COMMA keyed_element .)


state 182

    (158) keyed_element -> IDENTIFIER COLON expression .
    (36) expression -> expression . binary_operator expression
    (200) expression -> expression . DOT IDENTIFIER
    (201) expression -> expression . DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> expression . LBRACKET expression RBRACKET
    (37) binary_operator -> . PLUS
    (38) binary_operator -> . MINUS
    (39) binary_operator -> . TIMES
    (40) binary_operator -> . DIVIDE
    (41) binary_operator -> . MODULE
    (42) binary_operator -> . EQ
    (43) binary_operator -> . NEQ
    (44) binary_operator -> . LT
    (45) binary_operator -> . LE
    (46) binary_operator -> . GT
    (47) binary_operator -> . GE
    (48) binary_operator -> . LAND
    (49) binary_operator -> . LOR
    (50) binary_operator -> . AND
    (51) binary_operator -> . OR
    (52) binary_operator -> . XOR
    (53) binary_operator -> . AND_NOT
    (54) binary_operator -> . LSHIFT
    (55) binary_operator -> . RSHIFT

    RBRACE          reduce using rule 158 (keyed_element -> IDENTIFIER COLON expression .)
    COMMA           reduce using rule 158 (keyed_element -> IDENTIFIER COLON expression .)
    DOT             shift and go to state 82
    LBRACKET        shift and go to state 83
    PLUS            shift and go to state 84
    MINUS           shift and go to state 85
    TIMES           shift and go to state 86
    DIVIDE          shift and go to state 87
    MODULE          shift and go to state 88
    EQ              shift and go to state 89
    NEQ             shift and go to state 90
    LT              shift and go to state 91
    LE              shift and go to state 92
    GT              shift and go to state 93
    GE              shift and go to state 94
    LAND            shift and go to state 95
    LOR             shift and go to state 96
    AND             shift and go to state 97
    OR              shift and go to state 98
    XOR             shift and go to state 99
    AND_NOT         shift and go to state 100
    LSHIFT          shift and go to state 101
    RSHIFT          shift and go to state 102

    binary_operator                shift and go to state 81

state 183

    (159) keyed_element -> INT COLON expression .
    (36) expression -> expression . binary_operator expression
    (200) expression -> expression . DOT IDENTIFIER
    (201) expression -> expression . DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> expression . LBRACKET expression RBRACKET
    (37) binary_operator -> . PLUS
    (38) binary_operator -> . MINUS
    (39) binary_operator -> . TIMES
    (40) binary_operator -> . DIVIDE
    (41) binary_operator -> . MODULE
    (42) binary_operator -> . EQ
    (43) binary_operator -> . NEQ
    (44) binary_operator -> . LT
    (45) binary_operator -> . LE
    (46) binary_operator -> . GT
    (47) binary_operator -> . GE
    (48) binary_operator -> . LAND
    (49) binary_operator -> . LOR
    (50) binary_operator -> . AND
    (51) binary_operator -> . OR
    (52) binary_operator -> . XOR
    (53) binary_operator -> . AND_NOT
    (54) binary_operator -> . LSHIFT
    (55) binary_operator -> . RSHIFT

    RBRACE          reduce using rule 159 (keyed_element -> INT COLON expression .)
    COMMA           reduce using rule 159 (keyed_element -> INT COLON expression .)
    DOT             shift and go to state 82
    LBRACKET        shift and go to state 83
    PLUS            shift and go to state 84
    MINUS           shift and go to state 85
    TIMES           shift and go to state 86
    DIVIDE          shift and go to state 87
    MODULE          shift and go to state 88
    EQ              shift and go to state 89
    NEQ             shift and go to state 90
    LT              shift and go to state 91
    LE              shift and go to state 92
    GT              shift and go to state 93
    GE              shift and go to state 94
    LAND            shift and go to state 95
    LOR             shift and go to state 96
    AND             shift and go to state 97
    OR              shift and go to state 98
    XOR             shift and go to state 99
    AND_NOT         shift and go to state 100
    LSHIFT          shift and go to state 101
    RSHIFT          shift and go to state 102

    binary_operator                shift and go to state 81

state 184

    (119) return_type -> LPAREN type_list RPAREN .

    LBRACE          reduce using rule 119 (return_type -> LPAREN type_list RPAREN .)


state 185

    (122) type_list -> type_list COMMA . type
    (57) type -> . primitive_type
    (58) type -> . slice_type
    (59) type -> . array_type
    (60) type -> . map_type
    (61) primitive_type -> . INT_TYPE
    (62) primitive_type -> . FLOAT64_TYPE
    (63) primitive_type -> . STRING_TYPE
    (64) primitive_type -> . BOOL_TYPE
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (197) array_type -> . LBRACKET INT RBRACKET primitive_type
    (137) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type

    INT_TYPE        shift and go to state 34
    FLOAT64_TYPE    shift and go to state 35
    STRING_TYPE     shift and go to state 36
    BOOL_TYPE       shift and go to state 37
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    type                           shift and go to state 213
    primitive_type                 shift and go to state 30
    slice_type                     shift and go to state 31
    array_type                     shift and go to state 32
    map_type                       shift and go to state 33

state 186

    (90) block -> LBRACE local_statement_list . RBRACE
    (93) local_statement_list -> local_statement_list . local_statement
    (78) local_statement -> . local_var_dec
    (79) local_statement -> . local_const_dec
    (80) local_statement -> . short_assignment
    (81) local_statement -> . simple_assignment
    (82) local_statement -> . assignment_compound
    (83) local_statement -> . expression
    (84) local_statement -> . for_statement
    (85) local_statement -> . if_statement
    (86) local_statement -> . switch_statement
    (87) local_statement -> . return_statement
    (88) local_statement -> . BREAK
    (89) local_statement -> . CONTINUE
    (20) local_var_dec -> . VAR IDENTIFIER type
    (21) local_var_dec -> . VAR IDENTIFIER type ASSIGN expression
    (22) local_var_dec -> . VAR IDENTIFIER ASSIGN expression
    (23) local_const_dec -> . CONST IDENTIFIER type ASSIGN expression
    (24) local_const_dec -> . CONST IDENTIFIER ASSIGN expression
    (77) short_assignment -> . IDENTIFIER SHORT_ASSIGN expression
    (56) simple_assignment -> . IDENTIFIER ASSIGN expression
    (25) assignment_compound -> . IDENTIFIER operator_assign expression
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (125) expression -> . LNOT expression
    (126) expression -> . IDENTIFIER PLUSPLUS
    (127) expression -> . IDENTIFIER MINUSMINUS
    (138) expression -> . map_type LBRACE expression_map_list RBRACE
    (139) expression -> . map_type LBRACE RBRACE
    (161) expression -> . type_name LBRACE keyed_element_list RBRACE
    (162) expression -> . type_name LBRACE RBRACE
    (198) expression -> . array_type LBRACE expression_list RBRACE
    (199) expression -> . array_type LBRACE RBRACE
    (200) expression -> . expression DOT IDENTIFIER
    (201) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> . expression LBRACKET expression RBRACKET
    (203) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (94) for_statement -> . for_classic
    (95) for_statement -> . for_condition
    (96) for_statement -> . for_infinite
    (128) if_statement -> . IF expression block
    (129) if_statement -> . IF expression block ELSE block
    (130) if_statement -> . IF expression block ELSE if_statement
    (131) if_statement -> . IF if_assignment SEMICOLON expression block
    (132) if_statement -> . IF if_assignment SEMICOLON expression block ELSE block
    (133) if_statement -> . IF if_assignment SEMICOLON expression block ELSE if_statement
    (167) switch_statement -> . SWITCH switch_expr LBRACE case_clause_list RBRACE
    (168) switch_statement -> . SWITCH switch_expr LBRACE RBRACE
    (169) switch_statement -> . SWITCH LBRACE case_clause_list RBRACE
    (170) switch_statement -> . SWITCH LBRACE RBRACE
    (171) switch_statement -> . SWITCH switch_assignment SEMICOLON switch_expr LBRACE case_clause_list RBRACE
    (172) switch_statement -> . SWITCH switch_assignment SEMICOLON switch_expr LBRACE RBRACE
    (173) switch_statement -> . SWITCH switch_assignment SEMICOLON LBRACE case_clause_list RBRACE
    (174) switch_statement -> . SWITCH switch_assignment SEMICOLON LBRACE RBRACE
    (123) return_statement -> . RETURN
    (124) return_statement -> . RETURN return_list
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (137) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (163) type_name -> . IDENTIFIER
    (164) type_name -> . slice_type
    (165) type_name -> . array_type
    (166) type_name -> . map_type
    (197) array_type -> . LBRACKET INT RBRACKET primitive_type
    (97) for_classic -> . FOR for_init SEMICOLON for_cond SEMICOLON for_post block
    (98) for_condition -> . FOR expression block
    (99) for_infinite -> . FOR block

    RBRACE          shift and go to state 214
    BREAK           shift and go to state 199
    CONTINUE        shift and go to state 200
    VAR             shift and go to state 201
    CONST           shift and go to state 203
    IDENTIFIER      shift and go to state 202
    LPAREN          shift and go to state 54
    INT             shift and go to state 55
    FLOAT64         shift and go to state 56
    STRING          shift and go to state 57
    TRUE            shift and go to state 58
    FALSE           shift and go to state 59
    LNOT            shift and go to state 60
    IF              shift and go to state 207
    SWITCH          shift and go to state 208
    RETURN          shift and go to state 209
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39
    FOR             shift and go to state 210

    local_statement                shift and go to state 215
    local_var_dec                  shift and go to state 189
    local_const_dec                shift and go to state 190
    short_assignment               shift and go to state 191
    simple_assignment              shift and go to state 192
    assignment_compound            shift and go to state 193
    expression                     shift and go to state 194
    for_statement                  shift and go to state 195
    if_statement                   shift and go to state 196
    switch_statement               shift and go to state 197
    return_statement               shift and go to state 198
    slice_type                     shift and go to state 53
    map_type                       shift and go to state 61
    type_name                      shift and go to state 62
    array_type                     shift and go to state 63
    for_classic                    shift and go to state 204
    for_condition                  shift and go to state 205
    for_infinite                   shift and go to state 206

state 187

    (91) block -> LBRACE RBRACE .

    VAR             reduce using rule 91 (block -> LBRACE RBRACE .)
    CONST           reduce using rule 91 (block -> LBRACE RBRACE .)
    FUNC            reduce using rule 91 (block -> LBRACE RBRACE .)
    TYPE            reduce using rule 91 (block -> LBRACE RBRACE .)
    $end            reduce using rule 91 (block -> LBRACE RBRACE .)
    RBRACE          reduce using rule 91 (block -> LBRACE RBRACE .)
    BREAK           reduce using rule 91 (block -> LBRACE RBRACE .)
    CONTINUE        reduce using rule 91 (block -> LBRACE RBRACE .)
    IDENTIFIER      reduce using rule 91 (block -> LBRACE RBRACE .)
    LPAREN          reduce using rule 91 (block -> LBRACE RBRACE .)
    INT             reduce using rule 91 (block -> LBRACE RBRACE .)
    FLOAT64         reduce using rule 91 (block -> LBRACE RBRACE .)
    STRING          reduce using rule 91 (block -> LBRACE RBRACE .)
    TRUE            reduce using rule 91 (block -> LBRACE RBRACE .)
    FALSE           reduce using rule 91 (block -> LBRACE RBRACE .)
    LNOT            reduce using rule 91 (block -> LBRACE RBRACE .)
    IF              reduce using rule 91 (block -> LBRACE RBRACE .)
    SWITCH          reduce using rule 91 (block -> LBRACE RBRACE .)
    RETURN          reduce using rule 91 (block -> LBRACE RBRACE .)
    LBRACKET        reduce using rule 91 (block -> LBRACE RBRACE .)
    MAP             reduce using rule 91 (block -> LBRACE RBRACE .)
    FOR             reduce using rule 91 (block -> LBRACE RBRACE .)
    CASE            reduce using rule 91 (block -> LBRACE RBRACE .)
    DEFAULT         reduce using rule 91 (block -> LBRACE RBRACE .)
    ELSE            reduce using rule 91 (block -> LBRACE RBRACE .)


state 188

    (92) local_statement_list -> local_statement .

    RBRACE          reduce using rule 92 (local_statement_list -> local_statement .)
    BREAK           reduce using rule 92 (local_statement_list -> local_statement .)
    CONTINUE        reduce using rule 92 (local_statement_list -> local_statement .)
    VAR             reduce using rule 92 (local_statement_list -> local_statement .)
    CONST           reduce using rule 92 (local_statement_list -> local_statement .)
    IDENTIFIER      reduce using rule 92 (local_statement_list -> local_statement .)
    LPAREN          reduce using rule 92 (local_statement_list -> local_statement .)
    INT             reduce using rule 92 (local_statement_list -> local_statement .)
    FLOAT64         reduce using rule 92 (local_statement_list -> local_statement .)
    STRING          reduce using rule 92 (local_statement_list -> local_statement .)
    TRUE            reduce using rule 92 (local_statement_list -> local_statement .)
    FALSE           reduce using rule 92 (local_statement_list -> local_statement .)
    LNOT            reduce using rule 92 (local_statement_list -> local_statement .)
    IF              reduce using rule 92 (local_statement_list -> local_statement .)
    SWITCH          reduce using rule 92 (local_statement_list -> local_statement .)
    RETURN          reduce using rule 92 (local_statement_list -> local_statement .)
    LBRACKET        reduce using rule 92 (local_statement_list -> local_statement .)
    MAP             reduce using rule 92 (local_statement_list -> local_statement .)
    FOR             reduce using rule 92 (local_statement_list -> local_statement .)
    CASE            reduce using rule 92 (local_statement_list -> local_statement .)
    DEFAULT         reduce using rule 92 (local_statement_list -> local_statement .)


state 189

    (78) local_statement -> local_var_dec .

    RBRACE          reduce using rule 78 (local_statement -> local_var_dec .)
    BREAK           reduce using rule 78 (local_statement -> local_var_dec .)
    CONTINUE        reduce using rule 78 (local_statement -> local_var_dec .)
    VAR             reduce using rule 78 (local_statement -> local_var_dec .)
    CONST           reduce using rule 78 (local_statement -> local_var_dec .)
    IDENTIFIER      reduce using rule 78 (local_statement -> local_var_dec .)
    LPAREN          reduce using rule 78 (local_statement -> local_var_dec .)
    INT             reduce using rule 78 (local_statement -> local_var_dec .)
    FLOAT64         reduce using rule 78 (local_statement -> local_var_dec .)
    STRING          reduce using rule 78 (local_statement -> local_var_dec .)
    TRUE            reduce using rule 78 (local_statement -> local_var_dec .)
    FALSE           reduce using rule 78 (local_statement -> local_var_dec .)
    LNOT            reduce using rule 78 (local_statement -> local_var_dec .)
    IF              reduce using rule 78 (local_statement -> local_var_dec .)
    SWITCH          reduce using rule 78 (local_statement -> local_var_dec .)
    RETURN          reduce using rule 78 (local_statement -> local_var_dec .)
    LBRACKET        reduce using rule 78 (local_statement -> local_var_dec .)
    MAP             reduce using rule 78 (local_statement -> local_var_dec .)
    FOR             reduce using rule 78 (local_statement -> local_var_dec .)
    CASE            reduce using rule 78 (local_statement -> local_var_dec .)
    DEFAULT         reduce using rule 78 (local_statement -> local_var_dec .)


state 190

    (79) local_statement -> local_const_dec .

    RBRACE          reduce using rule 79 (local_statement -> local_const_dec .)
    BREAK           reduce using rule 79 (local_statement -> local_const_dec .)
    CONTINUE        reduce using rule 79 (local_statement -> local_const_dec .)
    VAR             reduce using rule 79 (local_statement -> local_const_dec .)
    CONST           reduce using rule 79 (local_statement -> local_const_dec .)
    IDENTIFIER      reduce using rule 79 (local_statement -> local_const_dec .)
    LPAREN          reduce using rule 79 (local_statement -> local_const_dec .)
    INT             reduce using rule 79 (local_statement -> local_const_dec .)
    FLOAT64         reduce using rule 79 (local_statement -> local_const_dec .)
    STRING          reduce using rule 79 (local_statement -> local_const_dec .)
    TRUE            reduce using rule 79 (local_statement -> local_const_dec .)
    FALSE           reduce using rule 79 (local_statement -> local_const_dec .)
    LNOT            reduce using rule 79 (local_statement -> local_const_dec .)
    IF              reduce using rule 79 (local_statement -> local_const_dec .)
    SWITCH          reduce using rule 79 (local_statement -> local_const_dec .)
    RETURN          reduce using rule 79 (local_statement -> local_const_dec .)
    LBRACKET        reduce using rule 79 (local_statement -> local_const_dec .)
    MAP             reduce using rule 79 (local_statement -> local_const_dec .)
    FOR             reduce using rule 79 (local_statement -> local_const_dec .)
    CASE            reduce using rule 79 (local_statement -> local_const_dec .)
    DEFAULT         reduce using rule 79 (local_statement -> local_const_dec .)


state 191

    (80) local_statement -> short_assignment .

    RBRACE          reduce using rule 80 (local_statement -> short_assignment .)
    BREAK           reduce using rule 80 (local_statement -> short_assignment .)
    CONTINUE        reduce using rule 80 (local_statement -> short_assignment .)
    VAR             reduce using rule 80 (local_statement -> short_assignment .)
    CONST           reduce using rule 80 (local_statement -> short_assignment .)
    IDENTIFIER      reduce using rule 80 (local_statement -> short_assignment .)
    LPAREN          reduce using rule 80 (local_statement -> short_assignment .)
    INT             reduce using rule 80 (local_statement -> short_assignment .)
    FLOAT64         reduce using rule 80 (local_statement -> short_assignment .)
    STRING          reduce using rule 80 (local_statement -> short_assignment .)
    TRUE            reduce using rule 80 (local_statement -> short_assignment .)
    FALSE           reduce using rule 80 (local_statement -> short_assignment .)
    LNOT            reduce using rule 80 (local_statement -> short_assignment .)
    IF              reduce using rule 80 (local_statement -> short_assignment .)
    SWITCH          reduce using rule 80 (local_statement -> short_assignment .)
    RETURN          reduce using rule 80 (local_statement -> short_assignment .)
    LBRACKET        reduce using rule 80 (local_statement -> short_assignment .)
    MAP             reduce using rule 80 (local_statement -> short_assignment .)
    FOR             reduce using rule 80 (local_statement -> short_assignment .)
    CASE            reduce using rule 80 (local_statement -> short_assignment .)
    DEFAULT         reduce using rule 80 (local_statement -> short_assignment .)


state 192

    (81) local_statement -> simple_assignment .

    RBRACE          reduce using rule 81 (local_statement -> simple_assignment .)
    BREAK           reduce using rule 81 (local_statement -> simple_assignment .)
    CONTINUE        reduce using rule 81 (local_statement -> simple_assignment .)
    VAR             reduce using rule 81 (local_statement -> simple_assignment .)
    CONST           reduce using rule 81 (local_statement -> simple_assignment .)
    IDENTIFIER      reduce using rule 81 (local_statement -> simple_assignment .)
    LPAREN          reduce using rule 81 (local_statement -> simple_assignment .)
    INT             reduce using rule 81 (local_statement -> simple_assignment .)
    FLOAT64         reduce using rule 81 (local_statement -> simple_assignment .)
    STRING          reduce using rule 81 (local_statement -> simple_assignment .)
    TRUE            reduce using rule 81 (local_statement -> simple_assignment .)
    FALSE           reduce using rule 81 (local_statement -> simple_assignment .)
    LNOT            reduce using rule 81 (local_statement -> simple_assignment .)
    IF              reduce using rule 81 (local_statement -> simple_assignment .)
    SWITCH          reduce using rule 81 (local_statement -> simple_assignment .)
    RETURN          reduce using rule 81 (local_statement -> simple_assignment .)
    LBRACKET        reduce using rule 81 (local_statement -> simple_assignment .)
    MAP             reduce using rule 81 (local_statement -> simple_assignment .)
    FOR             reduce using rule 81 (local_statement -> simple_assignment .)
    CASE            reduce using rule 81 (local_statement -> simple_assignment .)
    DEFAULT         reduce using rule 81 (local_statement -> simple_assignment .)


state 193

    (82) local_statement -> assignment_compound .

    RBRACE          reduce using rule 82 (local_statement -> assignment_compound .)
    BREAK           reduce using rule 82 (local_statement -> assignment_compound .)
    CONTINUE        reduce using rule 82 (local_statement -> assignment_compound .)
    VAR             reduce using rule 82 (local_statement -> assignment_compound .)
    CONST           reduce using rule 82 (local_statement -> assignment_compound .)
    IDENTIFIER      reduce using rule 82 (local_statement -> assignment_compound .)
    LPAREN          reduce using rule 82 (local_statement -> assignment_compound .)
    INT             reduce using rule 82 (local_statement -> assignment_compound .)
    FLOAT64         reduce using rule 82 (local_statement -> assignment_compound .)
    STRING          reduce using rule 82 (local_statement -> assignment_compound .)
    TRUE            reduce using rule 82 (local_statement -> assignment_compound .)
    FALSE           reduce using rule 82 (local_statement -> assignment_compound .)
    LNOT            reduce using rule 82 (local_statement -> assignment_compound .)
    IF              reduce using rule 82 (local_statement -> assignment_compound .)
    SWITCH          reduce using rule 82 (local_statement -> assignment_compound .)
    RETURN          reduce using rule 82 (local_statement -> assignment_compound .)
    LBRACKET        reduce using rule 82 (local_statement -> assignment_compound .)
    MAP             reduce using rule 82 (local_statement -> assignment_compound .)
    FOR             reduce using rule 82 (local_statement -> assignment_compound .)
    CASE            reduce using rule 82 (local_statement -> assignment_compound .)
    DEFAULT         reduce using rule 82 (local_statement -> assignment_compound .)


state 194

    (83) local_statement -> expression .
    (36) expression -> expression . binary_operator expression
    (200) expression -> expression . DOT IDENTIFIER
    (201) expression -> expression . DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> expression . LBRACKET expression RBRACKET
    (37) binary_operator -> . PLUS
    (38) binary_operator -> . MINUS
    (39) binary_operator -> . TIMES
    (40) binary_operator -> . DIVIDE
    (41) binary_operator -> . MODULE
    (42) binary_operator -> . EQ
    (43) binary_operator -> . NEQ
    (44) binary_operator -> . LT
    (45) binary_operator -> . LE
    (46) binary_operator -> . GT
    (47) binary_operator -> . GE
    (48) binary_operator -> . LAND
    (49) binary_operator -> . LOR
    (50) binary_operator -> . AND
    (51) binary_operator -> . OR
    (52) binary_operator -> . XOR
    (53) binary_operator -> . AND_NOT
    (54) binary_operator -> . LSHIFT
    (55) binary_operator -> . RSHIFT

  ! shift/reduce conflict for LBRACKET resolved as shift
    RBRACE          reduce using rule 83 (local_statement -> expression .)
    BREAK           reduce using rule 83 (local_statement -> expression .)
    CONTINUE        reduce using rule 83 (local_statement -> expression .)
    VAR             reduce using rule 83 (local_statement -> expression .)
    CONST           reduce using rule 83 (local_statement -> expression .)
    IDENTIFIER      reduce using rule 83 (local_statement -> expression .)
    LPAREN          reduce using rule 83 (local_statement -> expression .)
    INT             reduce using rule 83 (local_statement -> expression .)
    FLOAT64         reduce using rule 83 (local_statement -> expression .)
    STRING          reduce using rule 83 (local_statement -> expression .)
    TRUE            reduce using rule 83 (local_statement -> expression .)
    FALSE           reduce using rule 83 (local_statement -> expression .)
    LNOT            reduce using rule 83 (local_statement -> expression .)
    IF              reduce using rule 83 (local_statement -> expression .)
    SWITCH          reduce using rule 83 (local_statement -> expression .)
    RETURN          reduce using rule 83 (local_statement -> expression .)
    MAP             reduce using rule 83 (local_statement -> expression .)
    FOR             reduce using rule 83 (local_statement -> expression .)
    CASE            reduce using rule 83 (local_statement -> expression .)
    DEFAULT         reduce using rule 83 (local_statement -> expression .)
    DOT             shift and go to state 82
    LBRACKET        shift and go to state 83
    PLUS            shift and go to state 84
    MINUS           shift and go to state 85
    TIMES           shift and go to state 86
    DIVIDE          shift and go to state 87
    MODULE          shift and go to state 88
    EQ              shift and go to state 89
    NEQ             shift and go to state 90
    LT              shift and go to state 91
    LE              shift and go to state 92
    GT              shift and go to state 93
    GE              shift and go to state 94
    LAND            shift and go to state 95
    LOR             shift and go to state 96
    AND             shift and go to state 97
    OR              shift and go to state 98
    XOR             shift and go to state 99
    AND_NOT         shift and go to state 100
    LSHIFT          shift and go to state 101
    RSHIFT          shift and go to state 102

  ! LBRACKET        [ reduce using rule 83 (local_statement -> expression .) ]

    binary_operator                shift and go to state 81

state 195

    (84) local_statement -> for_statement .

    RBRACE          reduce using rule 84 (local_statement -> for_statement .)
    BREAK           reduce using rule 84 (local_statement -> for_statement .)
    CONTINUE        reduce using rule 84 (local_statement -> for_statement .)
    VAR             reduce using rule 84 (local_statement -> for_statement .)
    CONST           reduce using rule 84 (local_statement -> for_statement .)
    IDENTIFIER      reduce using rule 84 (local_statement -> for_statement .)
    LPAREN          reduce using rule 84 (local_statement -> for_statement .)
    INT             reduce using rule 84 (local_statement -> for_statement .)
    FLOAT64         reduce using rule 84 (local_statement -> for_statement .)
    STRING          reduce using rule 84 (local_statement -> for_statement .)
    TRUE            reduce using rule 84 (local_statement -> for_statement .)
    FALSE           reduce using rule 84 (local_statement -> for_statement .)
    LNOT            reduce using rule 84 (local_statement -> for_statement .)
    IF              reduce using rule 84 (local_statement -> for_statement .)
    SWITCH          reduce using rule 84 (local_statement -> for_statement .)
    RETURN          reduce using rule 84 (local_statement -> for_statement .)
    LBRACKET        reduce using rule 84 (local_statement -> for_statement .)
    MAP             reduce using rule 84 (local_statement -> for_statement .)
    FOR             reduce using rule 84 (local_statement -> for_statement .)
    CASE            reduce using rule 84 (local_statement -> for_statement .)
    DEFAULT         reduce using rule 84 (local_statement -> for_statement .)


state 196

    (85) local_statement -> if_statement .

    RBRACE          reduce using rule 85 (local_statement -> if_statement .)
    BREAK           reduce using rule 85 (local_statement -> if_statement .)
    CONTINUE        reduce using rule 85 (local_statement -> if_statement .)
    VAR             reduce using rule 85 (local_statement -> if_statement .)
    CONST           reduce using rule 85 (local_statement -> if_statement .)
    IDENTIFIER      reduce using rule 85 (local_statement -> if_statement .)
    LPAREN          reduce using rule 85 (local_statement -> if_statement .)
    INT             reduce using rule 85 (local_statement -> if_statement .)
    FLOAT64         reduce using rule 85 (local_statement -> if_statement .)
    STRING          reduce using rule 85 (local_statement -> if_statement .)
    TRUE            reduce using rule 85 (local_statement -> if_statement .)
    FALSE           reduce using rule 85 (local_statement -> if_statement .)
    LNOT            reduce using rule 85 (local_statement -> if_statement .)
    IF              reduce using rule 85 (local_statement -> if_statement .)
    SWITCH          reduce using rule 85 (local_statement -> if_statement .)
    RETURN          reduce using rule 85 (local_statement -> if_statement .)
    LBRACKET        reduce using rule 85 (local_statement -> if_statement .)
    MAP             reduce using rule 85 (local_statement -> if_statement .)
    FOR             reduce using rule 85 (local_statement -> if_statement .)
    CASE            reduce using rule 85 (local_statement -> if_statement .)
    DEFAULT         reduce using rule 85 (local_statement -> if_statement .)


state 197

    (86) local_statement -> switch_statement .

    RBRACE          reduce using rule 86 (local_statement -> switch_statement .)
    BREAK           reduce using rule 86 (local_statement -> switch_statement .)
    CONTINUE        reduce using rule 86 (local_statement -> switch_statement .)
    VAR             reduce using rule 86 (local_statement -> switch_statement .)
    CONST           reduce using rule 86 (local_statement -> switch_statement .)
    IDENTIFIER      reduce using rule 86 (local_statement -> switch_statement .)
    LPAREN          reduce using rule 86 (local_statement -> switch_statement .)
    INT             reduce using rule 86 (local_statement -> switch_statement .)
    FLOAT64         reduce using rule 86 (local_statement -> switch_statement .)
    STRING          reduce using rule 86 (local_statement -> switch_statement .)
    TRUE            reduce using rule 86 (local_statement -> switch_statement .)
    FALSE           reduce using rule 86 (local_statement -> switch_statement .)
    LNOT            reduce using rule 86 (local_statement -> switch_statement .)
    IF              reduce using rule 86 (local_statement -> switch_statement .)
    SWITCH          reduce using rule 86 (local_statement -> switch_statement .)
    RETURN          reduce using rule 86 (local_statement -> switch_statement .)
    LBRACKET        reduce using rule 86 (local_statement -> switch_statement .)
    MAP             reduce using rule 86 (local_statement -> switch_statement .)
    FOR             reduce using rule 86 (local_statement -> switch_statement .)
    CASE            reduce using rule 86 (local_statement -> switch_statement .)
    DEFAULT         reduce using rule 86 (local_statement -> switch_statement .)


state 198

    (87) local_statement -> return_statement .

    RBRACE          reduce using rule 87 (local_statement -> return_statement .)
    BREAK           reduce using rule 87 (local_statement -> return_statement .)
    CONTINUE        reduce using rule 87 (local_statement -> return_statement .)
    VAR             reduce using rule 87 (local_statement -> return_statement .)
    CONST           reduce using rule 87 (local_statement -> return_statement .)
    IDENTIFIER      reduce using rule 87 (local_statement -> return_statement .)
    LPAREN          reduce using rule 87 (local_statement -> return_statement .)
    INT             reduce using rule 87 (local_statement -> return_statement .)
    FLOAT64         reduce using rule 87 (local_statement -> return_statement .)
    STRING          reduce using rule 87 (local_statement -> return_statement .)
    TRUE            reduce using rule 87 (local_statement -> return_statement .)
    FALSE           reduce using rule 87 (local_statement -> return_statement .)
    LNOT            reduce using rule 87 (local_statement -> return_statement .)
    IF              reduce using rule 87 (local_statement -> return_statement .)
    SWITCH          reduce using rule 87 (local_statement -> return_statement .)
    RETURN          reduce using rule 87 (local_statement -> return_statement .)
    LBRACKET        reduce using rule 87 (local_statement -> return_statement .)
    MAP             reduce using rule 87 (local_statement -> return_statement .)
    FOR             reduce using rule 87 (local_statement -> return_statement .)
    CASE            reduce using rule 87 (local_statement -> return_statement .)
    DEFAULT         reduce using rule 87 (local_statement -> return_statement .)


state 199

    (88) local_statement -> BREAK .

    RBRACE          reduce using rule 88 (local_statement -> BREAK .)
    BREAK           reduce using rule 88 (local_statement -> BREAK .)
    CONTINUE        reduce using rule 88 (local_statement -> BREAK .)
    VAR             reduce using rule 88 (local_statement -> BREAK .)
    CONST           reduce using rule 88 (local_statement -> BREAK .)
    IDENTIFIER      reduce using rule 88 (local_statement -> BREAK .)
    LPAREN          reduce using rule 88 (local_statement -> BREAK .)
    INT             reduce using rule 88 (local_statement -> BREAK .)
    FLOAT64         reduce using rule 88 (local_statement -> BREAK .)
    STRING          reduce using rule 88 (local_statement -> BREAK .)
    TRUE            reduce using rule 88 (local_statement -> BREAK .)
    FALSE           reduce using rule 88 (local_statement -> BREAK .)
    LNOT            reduce using rule 88 (local_statement -> BREAK .)
    IF              reduce using rule 88 (local_statement -> BREAK .)
    SWITCH          reduce using rule 88 (local_statement -> BREAK .)
    RETURN          reduce using rule 88 (local_statement -> BREAK .)
    LBRACKET        reduce using rule 88 (local_statement -> BREAK .)
    MAP             reduce using rule 88 (local_statement -> BREAK .)
    FOR             reduce using rule 88 (local_statement -> BREAK .)
    CASE            reduce using rule 88 (local_statement -> BREAK .)
    DEFAULT         reduce using rule 88 (local_statement -> BREAK .)


state 200

    (89) local_statement -> CONTINUE .

    RBRACE          reduce using rule 89 (local_statement -> CONTINUE .)
    BREAK           reduce using rule 89 (local_statement -> CONTINUE .)
    CONTINUE        reduce using rule 89 (local_statement -> CONTINUE .)
    VAR             reduce using rule 89 (local_statement -> CONTINUE .)
    CONST           reduce using rule 89 (local_statement -> CONTINUE .)
    IDENTIFIER      reduce using rule 89 (local_statement -> CONTINUE .)
    LPAREN          reduce using rule 89 (local_statement -> CONTINUE .)
    INT             reduce using rule 89 (local_statement -> CONTINUE .)
    FLOAT64         reduce using rule 89 (local_statement -> CONTINUE .)
    STRING          reduce using rule 89 (local_statement -> CONTINUE .)
    TRUE            reduce using rule 89 (local_statement -> CONTINUE .)
    FALSE           reduce using rule 89 (local_statement -> CONTINUE .)
    LNOT            reduce using rule 89 (local_statement -> CONTINUE .)
    IF              reduce using rule 89 (local_statement -> CONTINUE .)
    SWITCH          reduce using rule 89 (local_statement -> CONTINUE .)
    RETURN          reduce using rule 89 (local_statement -> CONTINUE .)
    LBRACKET        reduce using rule 89 (local_statement -> CONTINUE .)
    MAP             reduce using rule 89 (local_statement -> CONTINUE .)
    FOR             reduce using rule 89 (local_statement -> CONTINUE .)
    CASE            reduce using rule 89 (local_statement -> CONTINUE .)
    DEFAULT         reduce using rule 89 (local_statement -> CONTINUE .)


state 201

    (20) local_var_dec -> VAR . IDENTIFIER type
    (21) local_var_dec -> VAR . IDENTIFIER type ASSIGN expression
    (22) local_var_dec -> VAR . IDENTIFIER ASSIGN expression

    IDENTIFIER      shift and go to state 216


state 202

    (77) short_assignment -> IDENTIFIER . SHORT_ASSIGN expression
    (56) simple_assignment -> IDENTIFIER . ASSIGN expression
    (25) assignment_compound -> IDENTIFIER . operator_assign expression
    (73) expression -> IDENTIFIER .
    (126) expression -> IDENTIFIER . PLUSPLUS
    (127) expression -> IDENTIFIER . MINUSMINUS
    (203) expression -> IDENTIFIER . LPAREN argument_list RPAREN
    (163) type_name -> IDENTIFIER .
    (26) operator_assign -> . PLUS_ASSIGN
    (27) operator_assign -> . MINUS_ASSIGN
    (28) operator_assign -> . MULT_ASSIGN
    (29) operator_assign -> . DIV_ASSIGN
    (30) operator_assign -> . MOD_ASSIGN
    (31) operator_assign -> . AND_ASSIGN
    (32) operator_assign -> . OR_ASSIGN
    (33) operator_assign -> . XOR_ASSIGN
    (34) operator_assign -> . LSHIFT_ASSIGN
    (35) operator_assign -> . RSHIFT_ASSIGN

  ! shift/reduce conflict for LPAREN resolved as shift
    SHORT_ASSIGN    shift and go to state 217
    ASSIGN          shift and go to state 218
    DOT             reduce using rule 73 (expression -> IDENTIFIER .)
    LBRACKET        reduce using rule 73 (expression -> IDENTIFIER .)
    PLUS            reduce using rule 73 (expression -> IDENTIFIER .)
    MINUS           reduce using rule 73 (expression -> IDENTIFIER .)
    TIMES           reduce using rule 73 (expression -> IDENTIFIER .)
    DIVIDE          reduce using rule 73 (expression -> IDENTIFIER .)
    MODULE          reduce using rule 73 (expression -> IDENTIFIER .)
    EQ              reduce using rule 73 (expression -> IDENTIFIER .)
    NEQ             reduce using rule 73 (expression -> IDENTIFIER .)
    LT              reduce using rule 73 (expression -> IDENTIFIER .)
    LE              reduce using rule 73 (expression -> IDENTIFIER .)
    GT              reduce using rule 73 (expression -> IDENTIFIER .)
    GE              reduce using rule 73 (expression -> IDENTIFIER .)
    LAND            reduce using rule 73 (expression -> IDENTIFIER .)
    LOR             reduce using rule 73 (expression -> IDENTIFIER .)
    AND             reduce using rule 73 (expression -> IDENTIFIER .)
    OR              reduce using rule 73 (expression -> IDENTIFIER .)
    XOR             reduce using rule 73 (expression -> IDENTIFIER .)
    AND_NOT         reduce using rule 73 (expression -> IDENTIFIER .)
    LSHIFT          reduce using rule 73 (expression -> IDENTIFIER .)
    RSHIFT          reduce using rule 73 (expression -> IDENTIFIER .)
    RBRACE          reduce using rule 73 (expression -> IDENTIFIER .)
    BREAK           reduce using rule 73 (expression -> IDENTIFIER .)
    CONTINUE        reduce using rule 73 (expression -> IDENTIFIER .)
    VAR             reduce using rule 73 (expression -> IDENTIFIER .)
    CONST           reduce using rule 73 (expression -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 73 (expression -> IDENTIFIER .)
    INT             reduce using rule 73 (expression -> IDENTIFIER .)
    FLOAT64         reduce using rule 73 (expression -> IDENTIFIER .)
    STRING          reduce using rule 73 (expression -> IDENTIFIER .)
    TRUE            reduce using rule 73 (expression -> IDENTIFIER .)
    FALSE           reduce using rule 73 (expression -> IDENTIFIER .)
    LNOT            reduce using rule 73 (expression -> IDENTIFIER .)
    IF              reduce using rule 73 (expression -> IDENTIFIER .)
    SWITCH          reduce using rule 73 (expression -> IDENTIFIER .)
    RETURN          reduce using rule 73 (expression -> IDENTIFIER .)
    MAP             reduce using rule 73 (expression -> IDENTIFIER .)
    FOR             reduce using rule 73 (expression -> IDENTIFIER .)
    CASE            reduce using rule 73 (expression -> IDENTIFIER .)
    DEFAULT         reduce using rule 73 (expression -> IDENTIFIER .)
    PLUSPLUS        shift and go to state 78
    MINUSMINUS      shift and go to state 79
    LPAREN          shift and go to state 80
    LBRACE          reduce using rule 163 (type_name -> IDENTIFIER .)
    PLUS_ASSIGN     shift and go to state 220
    MINUS_ASSIGN    shift and go to state 221
    MULT_ASSIGN     shift and go to state 222
    DIV_ASSIGN      shift and go to state 223
    MOD_ASSIGN      shift and go to state 224
    AND_ASSIGN      shift and go to state 225
    OR_ASSIGN       shift and go to state 226
    XOR_ASSIGN      shift and go to state 227
    LSHIFT_ASSIGN   shift and go to state 228
    RSHIFT_ASSIGN   shift and go to state 229

  ! LPAREN          [ reduce using rule 73 (expression -> IDENTIFIER .) ]

    operator_assign                shift and go to state 219

state 203

    (23) local_const_dec -> CONST . IDENTIFIER type ASSIGN expression
    (24) local_const_dec -> CONST . IDENTIFIER ASSIGN expression

    IDENTIFIER      shift and go to state 230


state 204

    (94) for_statement -> for_classic .

    RBRACE          reduce using rule 94 (for_statement -> for_classic .)
    BREAK           reduce using rule 94 (for_statement -> for_classic .)
    CONTINUE        reduce using rule 94 (for_statement -> for_classic .)
    VAR             reduce using rule 94 (for_statement -> for_classic .)
    CONST           reduce using rule 94 (for_statement -> for_classic .)
    IDENTIFIER      reduce using rule 94 (for_statement -> for_classic .)
    LPAREN          reduce using rule 94 (for_statement -> for_classic .)
    INT             reduce using rule 94 (for_statement -> for_classic .)
    FLOAT64         reduce using rule 94 (for_statement -> for_classic .)
    STRING          reduce using rule 94 (for_statement -> for_classic .)
    TRUE            reduce using rule 94 (for_statement -> for_classic .)
    FALSE           reduce using rule 94 (for_statement -> for_classic .)
    LNOT            reduce using rule 94 (for_statement -> for_classic .)
    IF              reduce using rule 94 (for_statement -> for_classic .)
    SWITCH          reduce using rule 94 (for_statement -> for_classic .)
    RETURN          reduce using rule 94 (for_statement -> for_classic .)
    LBRACKET        reduce using rule 94 (for_statement -> for_classic .)
    MAP             reduce using rule 94 (for_statement -> for_classic .)
    FOR             reduce using rule 94 (for_statement -> for_classic .)
    CASE            reduce using rule 94 (for_statement -> for_classic .)
    DEFAULT         reduce using rule 94 (for_statement -> for_classic .)


state 205

    (95) for_statement -> for_condition .

    RBRACE          reduce using rule 95 (for_statement -> for_condition .)
    BREAK           reduce using rule 95 (for_statement -> for_condition .)
    CONTINUE        reduce using rule 95 (for_statement -> for_condition .)
    VAR             reduce using rule 95 (for_statement -> for_condition .)
    CONST           reduce using rule 95 (for_statement -> for_condition .)
    IDENTIFIER      reduce using rule 95 (for_statement -> for_condition .)
    LPAREN          reduce using rule 95 (for_statement -> for_condition .)
    INT             reduce using rule 95 (for_statement -> for_condition .)
    FLOAT64         reduce using rule 95 (for_statement -> for_condition .)
    STRING          reduce using rule 95 (for_statement -> for_condition .)
    TRUE            reduce using rule 95 (for_statement -> for_condition .)
    FALSE           reduce using rule 95 (for_statement -> for_condition .)
    LNOT            reduce using rule 95 (for_statement -> for_condition .)
    IF              reduce using rule 95 (for_statement -> for_condition .)
    SWITCH          reduce using rule 95 (for_statement -> for_condition .)
    RETURN          reduce using rule 95 (for_statement -> for_condition .)
    LBRACKET        reduce using rule 95 (for_statement -> for_condition .)
    MAP             reduce using rule 95 (for_statement -> for_condition .)
    FOR             reduce using rule 95 (for_statement -> for_condition .)
    CASE            reduce using rule 95 (for_statement -> for_condition .)
    DEFAULT         reduce using rule 95 (for_statement -> for_condition .)


state 206

    (96) for_statement -> for_infinite .

    RBRACE          reduce using rule 96 (for_statement -> for_infinite .)
    BREAK           reduce using rule 96 (for_statement -> for_infinite .)
    CONTINUE        reduce using rule 96 (for_statement -> for_infinite .)
    VAR             reduce using rule 96 (for_statement -> for_infinite .)
    CONST           reduce using rule 96 (for_statement -> for_infinite .)
    IDENTIFIER      reduce using rule 96 (for_statement -> for_infinite .)
    LPAREN          reduce using rule 96 (for_statement -> for_infinite .)
    INT             reduce using rule 96 (for_statement -> for_infinite .)
    FLOAT64         reduce using rule 96 (for_statement -> for_infinite .)
    STRING          reduce using rule 96 (for_statement -> for_infinite .)
    TRUE            reduce using rule 96 (for_statement -> for_infinite .)
    FALSE           reduce using rule 96 (for_statement -> for_infinite .)
    LNOT            reduce using rule 96 (for_statement -> for_infinite .)
    IF              reduce using rule 96 (for_statement -> for_infinite .)
    SWITCH          reduce using rule 96 (for_statement -> for_infinite .)
    RETURN          reduce using rule 96 (for_statement -> for_infinite .)
    LBRACKET        reduce using rule 96 (for_statement -> for_infinite .)
    MAP             reduce using rule 96 (for_statement -> for_infinite .)
    FOR             reduce using rule 96 (for_statement -> for_infinite .)
    CASE            reduce using rule 96 (for_statement -> for_infinite .)
    DEFAULT         reduce using rule 96 (for_statement -> for_infinite .)


state 207

    (128) if_statement -> IF . expression block
    (129) if_statement -> IF . expression block ELSE block
    (130) if_statement -> IF . expression block ELSE if_statement
    (131) if_statement -> IF . if_assignment SEMICOLON expression block
    (132) if_statement -> IF . if_assignment SEMICOLON expression block ELSE block
    (133) if_statement -> IF . if_assignment SEMICOLON expression block ELSE if_statement
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (125) expression -> . LNOT expression
    (126) expression -> . IDENTIFIER PLUSPLUS
    (127) expression -> . IDENTIFIER MINUSMINUS
    (138) expression -> . map_type LBRACE expression_map_list RBRACE
    (139) expression -> . map_type LBRACE RBRACE
    (161) expression -> . type_name LBRACE keyed_element_list RBRACE
    (162) expression -> . type_name LBRACE RBRACE
    (198) expression -> . array_type LBRACE expression_list RBRACE
    (199) expression -> . array_type LBRACE RBRACE
    (200) expression -> . expression DOT IDENTIFIER
    (201) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> . expression LBRACKET expression RBRACKET
    (203) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (134) if_assignment -> . simple_assignment
    (135) if_assignment -> . short_assignment
    (136) if_assignment -> . local_var_dec
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (137) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (163) type_name -> . IDENTIFIER
    (164) type_name -> . slice_type
    (165) type_name -> . array_type
    (166) type_name -> . map_type
    (197) array_type -> . LBRACKET INT RBRACKET primitive_type
    (56) simple_assignment -> . IDENTIFIER ASSIGN expression
    (77) short_assignment -> . IDENTIFIER SHORT_ASSIGN expression
    (20) local_var_dec -> . VAR IDENTIFIER type
    (21) local_var_dec -> . VAR IDENTIFIER type ASSIGN expression
    (22) local_var_dec -> . VAR IDENTIFIER ASSIGN expression

    LPAREN          shift and go to state 54
    INT             shift and go to state 55
    FLOAT64         shift and go to state 56
    IDENTIFIER      shift and go to state 233
    STRING          shift and go to state 57
    TRUE            shift and go to state 58
    FALSE           shift and go to state 59
    LNOT            shift and go to state 60
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39
    VAR             shift and go to state 201

    expression                     shift and go to state 231
    if_assignment                  shift and go to state 232
    slice_type                     shift and go to state 53
    map_type                       shift and go to state 61
    type_name                      shift and go to state 62
    array_type                     shift and go to state 63
    simple_assignment              shift and go to state 234
    short_assignment               shift and go to state 235
    local_var_dec                  shift and go to state 236

state 208

    (167) switch_statement -> SWITCH . switch_expr LBRACE case_clause_list RBRACE
    (168) switch_statement -> SWITCH . switch_expr LBRACE RBRACE
    (169) switch_statement -> SWITCH . LBRACE case_clause_list RBRACE
    (170) switch_statement -> SWITCH . LBRACE RBRACE
    (171) switch_statement -> SWITCH . switch_assignment SEMICOLON switch_expr LBRACE case_clause_list RBRACE
    (172) switch_statement -> SWITCH . switch_assignment SEMICOLON switch_expr LBRACE RBRACE
    (173) switch_statement -> SWITCH . switch_assignment SEMICOLON LBRACE case_clause_list RBRACE
    (174) switch_statement -> SWITCH . switch_assignment SEMICOLON LBRACE RBRACE
    (175) switch_expr -> . primary_expression
    (188) switch_assignment -> . simple_assignment
    (189) switch_assignment -> . short_assignment
    (190) switch_assignment -> . local_var_dec
    (176) primary_expression -> . IDENTIFIER
    (177) primary_expression -> . INT
    (178) primary_expression -> . FLOAT64
    (179) primary_expression -> . STRING
    (180) primary_expression -> . TRUE
    (181) primary_expression -> . FALSE
    (182) primary_expression -> . LPAREN expression RPAREN
    (183) primary_expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (184) primary_expression -> . primary_expression DOT IDENTIFIER
    (185) primary_expression -> . primary_expression LBRACKET expression RBRACKET
    (56) simple_assignment -> . IDENTIFIER ASSIGN expression
    (77) short_assignment -> . IDENTIFIER SHORT_ASSIGN expression
    (20) local_var_dec -> . VAR IDENTIFIER type
    (21) local_var_dec -> . VAR IDENTIFIER type ASSIGN expression
    (22) local_var_dec -> . VAR IDENTIFIER ASSIGN expression

    LBRACE          shift and go to state 238
    IDENTIFIER      shift and go to state 244
    INT             shift and go to state 245
    FLOAT64         shift and go to state 246
    STRING          shift and go to state 247
    TRUE            shift and go to state 248
    FALSE           shift and go to state 249
    LPAREN          shift and go to state 250
    VAR             shift and go to state 201

    switch_expr                    shift and go to state 237
    switch_assignment              shift and go to state 239
    primary_expression             shift and go to state 240
    simple_assignment              shift and go to state 241
    short_assignment               shift and go to state 242
    local_var_dec                  shift and go to state 243

state 209

    (123) return_statement -> RETURN .
    (124) return_statement -> RETURN . return_list
    (110) return_list -> . expression
    (111) return_list -> . return_list COMMA expression
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (125) expression -> . LNOT expression
    (126) expression -> . IDENTIFIER PLUSPLUS
    (127) expression -> . IDENTIFIER MINUSMINUS
    (138) expression -> . map_type LBRACE expression_map_list RBRACE
    (139) expression -> . map_type LBRACE RBRACE
    (161) expression -> . type_name LBRACE keyed_element_list RBRACE
    (162) expression -> . type_name LBRACE RBRACE
    (198) expression -> . array_type LBRACE expression_list RBRACE
    (199) expression -> . array_type LBRACE RBRACE
    (200) expression -> . expression DOT IDENTIFIER
    (201) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> . expression LBRACKET expression RBRACKET
    (203) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (137) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (163) type_name -> . IDENTIFIER
    (164) type_name -> . slice_type
    (165) type_name -> . array_type
    (166) type_name -> . map_type
    (197) array_type -> . LBRACKET INT RBRACKET primitive_type

  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT64 resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for LNOT resolved as shift
  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for MAP resolved as shift
    RBRACE          reduce using rule 123 (return_statement -> RETURN .)
    BREAK           reduce using rule 123 (return_statement -> RETURN .)
    CONTINUE        reduce using rule 123 (return_statement -> RETURN .)
    VAR             reduce using rule 123 (return_statement -> RETURN .)
    CONST           reduce using rule 123 (return_statement -> RETURN .)
    IF              reduce using rule 123 (return_statement -> RETURN .)
    SWITCH          reduce using rule 123 (return_statement -> RETURN .)
    RETURN          reduce using rule 123 (return_statement -> RETURN .)
    FOR             reduce using rule 123 (return_statement -> RETURN .)
    CASE            reduce using rule 123 (return_statement -> RETURN .)
    DEFAULT         reduce using rule 123 (return_statement -> RETURN .)
    LPAREN          shift and go to state 54
    INT             shift and go to state 55
    FLOAT64         shift and go to state 56
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 57
    TRUE            shift and go to state 58
    FALSE           shift and go to state 59
    LNOT            shift and go to state 60
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

  ! IDENTIFIER      [ reduce using rule 123 (return_statement -> RETURN .) ]
  ! LPAREN          [ reduce using rule 123 (return_statement -> RETURN .) ]
  ! INT             [ reduce using rule 123 (return_statement -> RETURN .) ]
  ! FLOAT64         [ reduce using rule 123 (return_statement -> RETURN .) ]
  ! STRING          [ reduce using rule 123 (return_statement -> RETURN .) ]
  ! TRUE            [ reduce using rule 123 (return_statement -> RETURN .) ]
  ! FALSE           [ reduce using rule 123 (return_statement -> RETURN .) ]
  ! LNOT            [ reduce using rule 123 (return_statement -> RETURN .) ]
  ! LBRACKET        [ reduce using rule 123 (return_statement -> RETURN .) ]
  ! MAP             [ reduce using rule 123 (return_statement -> RETURN .) ]

    return_list                    shift and go to state 251
    expression                     shift and go to state 252
    slice_type                     shift and go to state 53
    map_type                       shift and go to state 61
    type_name                      shift and go to state 62
    array_type                     shift and go to state 63

state 210

    (97) for_classic -> FOR . for_init SEMICOLON for_cond SEMICOLON for_post block
    (98) for_condition -> FOR . expression block
    (99) for_infinite -> FOR . block
    (100) for_init -> . simple_assignment
    (101) for_init -> . short_assignment
    (102) for_init -> . local_var_dec
    (103) for_init -> . empty
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (125) expression -> . LNOT expression
    (126) expression -> . IDENTIFIER PLUSPLUS
    (127) expression -> . IDENTIFIER MINUSMINUS
    (138) expression -> . map_type LBRACE expression_map_list RBRACE
    (139) expression -> . map_type LBRACE RBRACE
    (161) expression -> . type_name LBRACE keyed_element_list RBRACE
    (162) expression -> . type_name LBRACE RBRACE
    (198) expression -> . array_type LBRACE expression_list RBRACE
    (199) expression -> . array_type LBRACE RBRACE
    (200) expression -> . expression DOT IDENTIFIER
    (201) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> . expression LBRACKET expression RBRACKET
    (203) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (90) block -> . LBRACE local_statement_list RBRACE
    (91) block -> . LBRACE RBRACE
    (56) simple_assignment -> . IDENTIFIER ASSIGN expression
    (77) short_assignment -> . IDENTIFIER SHORT_ASSIGN expression
    (20) local_var_dec -> . VAR IDENTIFIER type
    (21) local_var_dec -> . VAR IDENTIFIER type ASSIGN expression
    (22) local_var_dec -> . VAR IDENTIFIER ASSIGN expression
    (7) empty -> .
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (137) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (163) type_name -> . IDENTIFIER
    (164) type_name -> . slice_type
    (165) type_name -> . array_type
    (166) type_name -> . map_type
    (197) array_type -> . LBRACKET INT RBRACKET primitive_type

    LPAREN          shift and go to state 54
    INT             shift and go to state 55
    FLOAT64         shift and go to state 56
    IDENTIFIER      shift and go to state 260
    STRING          shift and go to state 57
    TRUE            shift and go to state 58
    FALSE           shift and go to state 59
    LNOT            shift and go to state 60
    LBRACE          shift and go to state 175
    VAR             shift and go to state 201
    SEMICOLON       reduce using rule 7 (empty -> .)
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    for_init                       shift and go to state 253
    block                          shift and go to state 254
    expression                     shift and go to state 255
    simple_assignment              shift and go to state 256
    short_assignment               shift and go to state 257
    local_var_dec                  shift and go to state 258
    empty                          shift and go to state 259
    slice_type                     shift and go to state 53
    map_type                       shift and go to state 61
    type_name                      shift and go to state 62
    array_type                     shift and go to state 63

state 211

    (146) method_declaration -> FUNC LPAREN receiver RPAREN IDENTIFIER LPAREN parameter_list RPAREN . return_type block
    (118) return_type -> . type
    (119) return_type -> . LPAREN type_list RPAREN
    (120) return_type -> . empty
    (57) type -> . primitive_type
    (58) type -> . slice_type
    (59) type -> . array_type
    (60) type -> . map_type
    (7) empty -> .
    (61) primitive_type -> . INT_TYPE
    (62) primitive_type -> . FLOAT64_TYPE
    (63) primitive_type -> . STRING_TYPE
    (64) primitive_type -> . BOOL_TYPE
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (197) array_type -> . LBRACKET INT RBRACKET primitive_type
    (137) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type

    LPAREN          shift and go to state 149
    LBRACE          reduce using rule 7 (empty -> .)
    INT_TYPE        shift and go to state 34
    FLOAT64_TYPE    shift and go to state 35
    STRING_TYPE     shift and go to state 36
    BOOL_TYPE       shift and go to state 37
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    return_type                    shift and go to state 261
    type                           shift and go to state 151
    empty                          shift and go to state 152
    primitive_type                 shift and go to state 30
    slice_type                     shift and go to state 31
    array_type                     shift and go to state 32
    map_type                       shift and go to state 33

state 212

    (201) expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .

    DOT             reduce using rule 201 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    LBRACKET        reduce using rule 201 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    PLUS            reduce using rule 201 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    MINUS           reduce using rule 201 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    TIMES           reduce using rule 201 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    DIVIDE          reduce using rule 201 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    MODULE          reduce using rule 201 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    EQ              reduce using rule 201 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    NEQ             reduce using rule 201 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    LT              reduce using rule 201 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    LE              reduce using rule 201 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    GT              reduce using rule 201 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    GE              reduce using rule 201 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    LAND            reduce using rule 201 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    LOR             reduce using rule 201 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    AND             reduce using rule 201 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    OR              reduce using rule 201 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    XOR             reduce using rule 201 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    AND_NOT         reduce using rule 201 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    LSHIFT          reduce using rule 201 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    RSHIFT          reduce using rule 201 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    VAR             reduce using rule 201 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    CONST           reduce using rule 201 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    FUNC            reduce using rule 201 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    TYPE            reduce using rule 201 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    $end            reduce using rule 201 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    RPAREN          reduce using rule 201 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    COMMA           reduce using rule 201 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    RBRACKET        reduce using rule 201 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    RBRACE          reduce using rule 201 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    COLON           reduce using rule 201 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    BREAK           reduce using rule 201 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    CONTINUE        reduce using rule 201 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    IDENTIFIER      reduce using rule 201 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    LPAREN          reduce using rule 201 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    INT             reduce using rule 201 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    FLOAT64         reduce using rule 201 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    STRING          reduce using rule 201 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    TRUE            reduce using rule 201 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    FALSE           reduce using rule 201 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    LNOT            reduce using rule 201 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    IF              reduce using rule 201 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    SWITCH          reduce using rule 201 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    RETURN          reduce using rule 201 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    MAP             reduce using rule 201 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    FOR             reduce using rule 201 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    LBRACE          reduce using rule 201 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    CASE            reduce using rule 201 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    DEFAULT         reduce using rule 201 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    SEMICOLON       reduce using rule 201 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)


state 213

    (122) type_list -> type_list COMMA type .

    RPAREN          reduce using rule 122 (type_list -> type_list COMMA type .)
    COMMA           reduce using rule 122 (type_list -> type_list COMMA type .)


state 214

    (90) block -> LBRACE local_statement_list RBRACE .

    VAR             reduce using rule 90 (block -> LBRACE local_statement_list RBRACE .)
    CONST           reduce using rule 90 (block -> LBRACE local_statement_list RBRACE .)
    FUNC            reduce using rule 90 (block -> LBRACE local_statement_list RBRACE .)
    TYPE            reduce using rule 90 (block -> LBRACE local_statement_list RBRACE .)
    $end            reduce using rule 90 (block -> LBRACE local_statement_list RBRACE .)
    RBRACE          reduce using rule 90 (block -> LBRACE local_statement_list RBRACE .)
    BREAK           reduce using rule 90 (block -> LBRACE local_statement_list RBRACE .)
    CONTINUE        reduce using rule 90 (block -> LBRACE local_statement_list RBRACE .)
    IDENTIFIER      reduce using rule 90 (block -> LBRACE local_statement_list RBRACE .)
    LPAREN          reduce using rule 90 (block -> LBRACE local_statement_list RBRACE .)
    INT             reduce using rule 90 (block -> LBRACE local_statement_list RBRACE .)
    FLOAT64         reduce using rule 90 (block -> LBRACE local_statement_list RBRACE .)
    STRING          reduce using rule 90 (block -> LBRACE local_statement_list RBRACE .)
    TRUE            reduce using rule 90 (block -> LBRACE local_statement_list RBRACE .)
    FALSE           reduce using rule 90 (block -> LBRACE local_statement_list RBRACE .)
    LNOT            reduce using rule 90 (block -> LBRACE local_statement_list RBRACE .)
    IF              reduce using rule 90 (block -> LBRACE local_statement_list RBRACE .)
    SWITCH          reduce using rule 90 (block -> LBRACE local_statement_list RBRACE .)
    RETURN          reduce using rule 90 (block -> LBRACE local_statement_list RBRACE .)
    LBRACKET        reduce using rule 90 (block -> LBRACE local_statement_list RBRACE .)
    MAP             reduce using rule 90 (block -> LBRACE local_statement_list RBRACE .)
    FOR             reduce using rule 90 (block -> LBRACE local_statement_list RBRACE .)
    CASE            reduce using rule 90 (block -> LBRACE local_statement_list RBRACE .)
    DEFAULT         reduce using rule 90 (block -> LBRACE local_statement_list RBRACE .)
    ELSE            reduce using rule 90 (block -> LBRACE local_statement_list RBRACE .)


state 215

    (93) local_statement_list -> local_statement_list local_statement .

    RBRACE          reduce using rule 93 (local_statement_list -> local_statement_list local_statement .)
    BREAK           reduce using rule 93 (local_statement_list -> local_statement_list local_statement .)
    CONTINUE        reduce using rule 93 (local_statement_list -> local_statement_list local_statement .)
    VAR             reduce using rule 93 (local_statement_list -> local_statement_list local_statement .)
    CONST           reduce using rule 93 (local_statement_list -> local_statement_list local_statement .)
    IDENTIFIER      reduce using rule 93 (local_statement_list -> local_statement_list local_statement .)
    LPAREN          reduce using rule 93 (local_statement_list -> local_statement_list local_statement .)
    INT             reduce using rule 93 (local_statement_list -> local_statement_list local_statement .)
    FLOAT64         reduce using rule 93 (local_statement_list -> local_statement_list local_statement .)
    STRING          reduce using rule 93 (local_statement_list -> local_statement_list local_statement .)
    TRUE            reduce using rule 93 (local_statement_list -> local_statement_list local_statement .)
    FALSE           reduce using rule 93 (local_statement_list -> local_statement_list local_statement .)
    LNOT            reduce using rule 93 (local_statement_list -> local_statement_list local_statement .)
    IF              reduce using rule 93 (local_statement_list -> local_statement_list local_statement .)
    SWITCH          reduce using rule 93 (local_statement_list -> local_statement_list local_statement .)
    RETURN          reduce using rule 93 (local_statement_list -> local_statement_list local_statement .)
    LBRACKET        reduce using rule 93 (local_statement_list -> local_statement_list local_statement .)
    MAP             reduce using rule 93 (local_statement_list -> local_statement_list local_statement .)
    FOR             reduce using rule 93 (local_statement_list -> local_statement_list local_statement .)
    CASE            reduce using rule 93 (local_statement_list -> local_statement_list local_statement .)
    DEFAULT         reduce using rule 93 (local_statement_list -> local_statement_list local_statement .)


state 216

    (20) local_var_dec -> VAR IDENTIFIER . type
    (21) local_var_dec -> VAR IDENTIFIER . type ASSIGN expression
    (22) local_var_dec -> VAR IDENTIFIER . ASSIGN expression
    (57) type -> . primitive_type
    (58) type -> . slice_type
    (59) type -> . array_type
    (60) type -> . map_type
    (61) primitive_type -> . INT_TYPE
    (62) primitive_type -> . FLOAT64_TYPE
    (63) primitive_type -> . STRING_TYPE
    (64) primitive_type -> . BOOL_TYPE
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (197) array_type -> . LBRACKET INT RBRACKET primitive_type
    (137) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type

    ASSIGN          shift and go to state 263
    INT_TYPE        shift and go to state 34
    FLOAT64_TYPE    shift and go to state 35
    STRING_TYPE     shift and go to state 36
    BOOL_TYPE       shift and go to state 37
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    type                           shift and go to state 262
    primitive_type                 shift and go to state 30
    slice_type                     shift and go to state 31
    array_type                     shift and go to state 32
    map_type                       shift and go to state 33

state 217

    (77) short_assignment -> IDENTIFIER SHORT_ASSIGN . expression
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (125) expression -> . LNOT expression
    (126) expression -> . IDENTIFIER PLUSPLUS
    (127) expression -> . IDENTIFIER MINUSMINUS
    (138) expression -> . map_type LBRACE expression_map_list RBRACE
    (139) expression -> . map_type LBRACE RBRACE
    (161) expression -> . type_name LBRACE keyed_element_list RBRACE
    (162) expression -> . type_name LBRACE RBRACE
    (198) expression -> . array_type LBRACE expression_list RBRACE
    (199) expression -> . array_type LBRACE RBRACE
    (200) expression -> . expression DOT IDENTIFIER
    (201) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> . expression LBRACKET expression RBRACKET
    (203) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (137) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (163) type_name -> . IDENTIFIER
    (164) type_name -> . slice_type
    (165) type_name -> . array_type
    (166) type_name -> . map_type
    (197) array_type -> . LBRACKET INT RBRACKET primitive_type

    LPAREN          shift and go to state 54
    INT             shift and go to state 55
    FLOAT64         shift and go to state 56
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 57
    TRUE            shift and go to state 58
    FALSE           shift and go to state 59
    LNOT            shift and go to state 60
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    expression                     shift and go to state 264
    slice_type                     shift and go to state 53
    map_type                       shift and go to state 61
    type_name                      shift and go to state 62
    array_type                     shift and go to state 63

state 218

    (56) simple_assignment -> IDENTIFIER ASSIGN . expression
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (125) expression -> . LNOT expression
    (126) expression -> . IDENTIFIER PLUSPLUS
    (127) expression -> . IDENTIFIER MINUSMINUS
    (138) expression -> . map_type LBRACE expression_map_list RBRACE
    (139) expression -> . map_type LBRACE RBRACE
    (161) expression -> . type_name LBRACE keyed_element_list RBRACE
    (162) expression -> . type_name LBRACE RBRACE
    (198) expression -> . array_type LBRACE expression_list RBRACE
    (199) expression -> . array_type LBRACE RBRACE
    (200) expression -> . expression DOT IDENTIFIER
    (201) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> . expression LBRACKET expression RBRACKET
    (203) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (137) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (163) type_name -> . IDENTIFIER
    (164) type_name -> . slice_type
    (165) type_name -> . array_type
    (166) type_name -> . map_type
    (197) array_type -> . LBRACKET INT RBRACKET primitive_type

    LPAREN          shift and go to state 54
    INT             shift and go to state 55
    FLOAT64         shift and go to state 56
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 57
    TRUE            shift and go to state 58
    FALSE           shift and go to state 59
    LNOT            shift and go to state 60
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    expression                     shift and go to state 265
    slice_type                     shift and go to state 53
    map_type                       shift and go to state 61
    type_name                      shift and go to state 62
    array_type                     shift and go to state 63

state 219

    (25) assignment_compound -> IDENTIFIER operator_assign . expression
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (125) expression -> . LNOT expression
    (126) expression -> . IDENTIFIER PLUSPLUS
    (127) expression -> . IDENTIFIER MINUSMINUS
    (138) expression -> . map_type LBRACE expression_map_list RBRACE
    (139) expression -> . map_type LBRACE RBRACE
    (161) expression -> . type_name LBRACE keyed_element_list RBRACE
    (162) expression -> . type_name LBRACE RBRACE
    (198) expression -> . array_type LBRACE expression_list RBRACE
    (199) expression -> . array_type LBRACE RBRACE
    (200) expression -> . expression DOT IDENTIFIER
    (201) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> . expression LBRACKET expression RBRACKET
    (203) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (137) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (163) type_name -> . IDENTIFIER
    (164) type_name -> . slice_type
    (165) type_name -> . array_type
    (166) type_name -> . map_type
    (197) array_type -> . LBRACKET INT RBRACKET primitive_type

    LPAREN          shift and go to state 54
    INT             shift and go to state 55
    FLOAT64         shift and go to state 56
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 57
    TRUE            shift and go to state 58
    FALSE           shift and go to state 59
    LNOT            shift and go to state 60
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    expression                     shift and go to state 266
    slice_type                     shift and go to state 53
    map_type                       shift and go to state 61
    type_name                      shift and go to state 62
    array_type                     shift and go to state 63

state 220

    (26) operator_assign -> PLUS_ASSIGN .

    LPAREN          reduce using rule 26 (operator_assign -> PLUS_ASSIGN .)
    INT             reduce using rule 26 (operator_assign -> PLUS_ASSIGN .)
    FLOAT64         reduce using rule 26 (operator_assign -> PLUS_ASSIGN .)
    IDENTIFIER      reduce using rule 26 (operator_assign -> PLUS_ASSIGN .)
    STRING          reduce using rule 26 (operator_assign -> PLUS_ASSIGN .)
    TRUE            reduce using rule 26 (operator_assign -> PLUS_ASSIGN .)
    FALSE           reduce using rule 26 (operator_assign -> PLUS_ASSIGN .)
    LNOT            reduce using rule 26 (operator_assign -> PLUS_ASSIGN .)
    LBRACKET        reduce using rule 26 (operator_assign -> PLUS_ASSIGN .)
    MAP             reduce using rule 26 (operator_assign -> PLUS_ASSIGN .)


state 221

    (27) operator_assign -> MINUS_ASSIGN .

    LPAREN          reduce using rule 27 (operator_assign -> MINUS_ASSIGN .)
    INT             reduce using rule 27 (operator_assign -> MINUS_ASSIGN .)
    FLOAT64         reduce using rule 27 (operator_assign -> MINUS_ASSIGN .)
    IDENTIFIER      reduce using rule 27 (operator_assign -> MINUS_ASSIGN .)
    STRING          reduce using rule 27 (operator_assign -> MINUS_ASSIGN .)
    TRUE            reduce using rule 27 (operator_assign -> MINUS_ASSIGN .)
    FALSE           reduce using rule 27 (operator_assign -> MINUS_ASSIGN .)
    LNOT            reduce using rule 27 (operator_assign -> MINUS_ASSIGN .)
    LBRACKET        reduce using rule 27 (operator_assign -> MINUS_ASSIGN .)
    MAP             reduce using rule 27 (operator_assign -> MINUS_ASSIGN .)


state 222

    (28) operator_assign -> MULT_ASSIGN .

    LPAREN          reduce using rule 28 (operator_assign -> MULT_ASSIGN .)
    INT             reduce using rule 28 (operator_assign -> MULT_ASSIGN .)
    FLOAT64         reduce using rule 28 (operator_assign -> MULT_ASSIGN .)
    IDENTIFIER      reduce using rule 28 (operator_assign -> MULT_ASSIGN .)
    STRING          reduce using rule 28 (operator_assign -> MULT_ASSIGN .)
    TRUE            reduce using rule 28 (operator_assign -> MULT_ASSIGN .)
    FALSE           reduce using rule 28 (operator_assign -> MULT_ASSIGN .)
    LNOT            reduce using rule 28 (operator_assign -> MULT_ASSIGN .)
    LBRACKET        reduce using rule 28 (operator_assign -> MULT_ASSIGN .)
    MAP             reduce using rule 28 (operator_assign -> MULT_ASSIGN .)


state 223

    (29) operator_assign -> DIV_ASSIGN .

    LPAREN          reduce using rule 29 (operator_assign -> DIV_ASSIGN .)
    INT             reduce using rule 29 (operator_assign -> DIV_ASSIGN .)
    FLOAT64         reduce using rule 29 (operator_assign -> DIV_ASSIGN .)
    IDENTIFIER      reduce using rule 29 (operator_assign -> DIV_ASSIGN .)
    STRING          reduce using rule 29 (operator_assign -> DIV_ASSIGN .)
    TRUE            reduce using rule 29 (operator_assign -> DIV_ASSIGN .)
    FALSE           reduce using rule 29 (operator_assign -> DIV_ASSIGN .)
    LNOT            reduce using rule 29 (operator_assign -> DIV_ASSIGN .)
    LBRACKET        reduce using rule 29 (operator_assign -> DIV_ASSIGN .)
    MAP             reduce using rule 29 (operator_assign -> DIV_ASSIGN .)


state 224

    (30) operator_assign -> MOD_ASSIGN .

    LPAREN          reduce using rule 30 (operator_assign -> MOD_ASSIGN .)
    INT             reduce using rule 30 (operator_assign -> MOD_ASSIGN .)
    FLOAT64         reduce using rule 30 (operator_assign -> MOD_ASSIGN .)
    IDENTIFIER      reduce using rule 30 (operator_assign -> MOD_ASSIGN .)
    STRING          reduce using rule 30 (operator_assign -> MOD_ASSIGN .)
    TRUE            reduce using rule 30 (operator_assign -> MOD_ASSIGN .)
    FALSE           reduce using rule 30 (operator_assign -> MOD_ASSIGN .)
    LNOT            reduce using rule 30 (operator_assign -> MOD_ASSIGN .)
    LBRACKET        reduce using rule 30 (operator_assign -> MOD_ASSIGN .)
    MAP             reduce using rule 30 (operator_assign -> MOD_ASSIGN .)


state 225

    (31) operator_assign -> AND_ASSIGN .

    LPAREN          reduce using rule 31 (operator_assign -> AND_ASSIGN .)
    INT             reduce using rule 31 (operator_assign -> AND_ASSIGN .)
    FLOAT64         reduce using rule 31 (operator_assign -> AND_ASSIGN .)
    IDENTIFIER      reduce using rule 31 (operator_assign -> AND_ASSIGN .)
    STRING          reduce using rule 31 (operator_assign -> AND_ASSIGN .)
    TRUE            reduce using rule 31 (operator_assign -> AND_ASSIGN .)
    FALSE           reduce using rule 31 (operator_assign -> AND_ASSIGN .)
    LNOT            reduce using rule 31 (operator_assign -> AND_ASSIGN .)
    LBRACKET        reduce using rule 31 (operator_assign -> AND_ASSIGN .)
    MAP             reduce using rule 31 (operator_assign -> AND_ASSIGN .)


state 226

    (32) operator_assign -> OR_ASSIGN .

    LPAREN          reduce using rule 32 (operator_assign -> OR_ASSIGN .)
    INT             reduce using rule 32 (operator_assign -> OR_ASSIGN .)
    FLOAT64         reduce using rule 32 (operator_assign -> OR_ASSIGN .)
    IDENTIFIER      reduce using rule 32 (operator_assign -> OR_ASSIGN .)
    STRING          reduce using rule 32 (operator_assign -> OR_ASSIGN .)
    TRUE            reduce using rule 32 (operator_assign -> OR_ASSIGN .)
    FALSE           reduce using rule 32 (operator_assign -> OR_ASSIGN .)
    LNOT            reduce using rule 32 (operator_assign -> OR_ASSIGN .)
    LBRACKET        reduce using rule 32 (operator_assign -> OR_ASSIGN .)
    MAP             reduce using rule 32 (operator_assign -> OR_ASSIGN .)


state 227

    (33) operator_assign -> XOR_ASSIGN .

    LPAREN          reduce using rule 33 (operator_assign -> XOR_ASSIGN .)
    INT             reduce using rule 33 (operator_assign -> XOR_ASSIGN .)
    FLOAT64         reduce using rule 33 (operator_assign -> XOR_ASSIGN .)
    IDENTIFIER      reduce using rule 33 (operator_assign -> XOR_ASSIGN .)
    STRING          reduce using rule 33 (operator_assign -> XOR_ASSIGN .)
    TRUE            reduce using rule 33 (operator_assign -> XOR_ASSIGN .)
    FALSE           reduce using rule 33 (operator_assign -> XOR_ASSIGN .)
    LNOT            reduce using rule 33 (operator_assign -> XOR_ASSIGN .)
    LBRACKET        reduce using rule 33 (operator_assign -> XOR_ASSIGN .)
    MAP             reduce using rule 33 (operator_assign -> XOR_ASSIGN .)


state 228

    (34) operator_assign -> LSHIFT_ASSIGN .

    LPAREN          reduce using rule 34 (operator_assign -> LSHIFT_ASSIGN .)
    INT             reduce using rule 34 (operator_assign -> LSHIFT_ASSIGN .)
    FLOAT64         reduce using rule 34 (operator_assign -> LSHIFT_ASSIGN .)
    IDENTIFIER      reduce using rule 34 (operator_assign -> LSHIFT_ASSIGN .)
    STRING          reduce using rule 34 (operator_assign -> LSHIFT_ASSIGN .)
    TRUE            reduce using rule 34 (operator_assign -> LSHIFT_ASSIGN .)
    FALSE           reduce using rule 34 (operator_assign -> LSHIFT_ASSIGN .)
    LNOT            reduce using rule 34 (operator_assign -> LSHIFT_ASSIGN .)
    LBRACKET        reduce using rule 34 (operator_assign -> LSHIFT_ASSIGN .)
    MAP             reduce using rule 34 (operator_assign -> LSHIFT_ASSIGN .)


state 229

    (35) operator_assign -> RSHIFT_ASSIGN .

    LPAREN          reduce using rule 35 (operator_assign -> RSHIFT_ASSIGN .)
    INT             reduce using rule 35 (operator_assign -> RSHIFT_ASSIGN .)
    FLOAT64         reduce using rule 35 (operator_assign -> RSHIFT_ASSIGN .)
    IDENTIFIER      reduce using rule 35 (operator_assign -> RSHIFT_ASSIGN .)
    STRING          reduce using rule 35 (operator_assign -> RSHIFT_ASSIGN .)
    TRUE            reduce using rule 35 (operator_assign -> RSHIFT_ASSIGN .)
    FALSE           reduce using rule 35 (operator_assign -> RSHIFT_ASSIGN .)
    LNOT            reduce using rule 35 (operator_assign -> RSHIFT_ASSIGN .)
    LBRACKET        reduce using rule 35 (operator_assign -> RSHIFT_ASSIGN .)
    MAP             reduce using rule 35 (operator_assign -> RSHIFT_ASSIGN .)


state 230

    (23) local_const_dec -> CONST IDENTIFIER . type ASSIGN expression
    (24) local_const_dec -> CONST IDENTIFIER . ASSIGN expression
    (57) type -> . primitive_type
    (58) type -> . slice_type
    (59) type -> . array_type
    (60) type -> . map_type
    (61) primitive_type -> . INT_TYPE
    (62) primitive_type -> . FLOAT64_TYPE
    (63) primitive_type -> . STRING_TYPE
    (64) primitive_type -> . BOOL_TYPE
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (197) array_type -> . LBRACKET INT RBRACKET primitive_type
    (137) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type

    ASSIGN          shift and go to state 268
    INT_TYPE        shift and go to state 34
    FLOAT64_TYPE    shift and go to state 35
    STRING_TYPE     shift and go to state 36
    BOOL_TYPE       shift and go to state 37
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    type                           shift and go to state 267
    primitive_type                 shift and go to state 30
    slice_type                     shift and go to state 31
    array_type                     shift and go to state 32
    map_type                       shift and go to state 33

state 231

    (128) if_statement -> IF expression . block
    (129) if_statement -> IF expression . block ELSE block
    (130) if_statement -> IF expression . block ELSE if_statement
    (36) expression -> expression . binary_operator expression
    (200) expression -> expression . DOT IDENTIFIER
    (201) expression -> expression . DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> expression . LBRACKET expression RBRACKET
    (90) block -> . LBRACE local_statement_list RBRACE
    (91) block -> . LBRACE RBRACE
    (37) binary_operator -> . PLUS
    (38) binary_operator -> . MINUS
    (39) binary_operator -> . TIMES
    (40) binary_operator -> . DIVIDE
    (41) binary_operator -> . MODULE
    (42) binary_operator -> . EQ
    (43) binary_operator -> . NEQ
    (44) binary_operator -> . LT
    (45) binary_operator -> . LE
    (46) binary_operator -> . GT
    (47) binary_operator -> . GE
    (48) binary_operator -> . LAND
    (49) binary_operator -> . LOR
    (50) binary_operator -> . AND
    (51) binary_operator -> . OR
    (52) binary_operator -> . XOR
    (53) binary_operator -> . AND_NOT
    (54) binary_operator -> . LSHIFT
    (55) binary_operator -> . RSHIFT

    DOT             shift and go to state 82
    LBRACKET        shift and go to state 83
    LBRACE          shift and go to state 175
    PLUS            shift and go to state 84
    MINUS           shift and go to state 85
    TIMES           shift and go to state 86
    DIVIDE          shift and go to state 87
    MODULE          shift and go to state 88
    EQ              shift and go to state 89
    NEQ             shift and go to state 90
    LT              shift and go to state 91
    LE              shift and go to state 92
    GT              shift and go to state 93
    GE              shift and go to state 94
    LAND            shift and go to state 95
    LOR             shift and go to state 96
    AND             shift and go to state 97
    OR              shift and go to state 98
    XOR             shift and go to state 99
    AND_NOT         shift and go to state 100
    LSHIFT          shift and go to state 101
    RSHIFT          shift and go to state 102

    block                          shift and go to state 269
    binary_operator                shift and go to state 81

state 232

    (131) if_statement -> IF if_assignment . SEMICOLON expression block
    (132) if_statement -> IF if_assignment . SEMICOLON expression block ELSE block
    (133) if_statement -> IF if_assignment . SEMICOLON expression block ELSE if_statement

    SEMICOLON       shift and go to state 270


state 233

    (73) expression -> IDENTIFIER .
    (126) expression -> IDENTIFIER . PLUSPLUS
    (127) expression -> IDENTIFIER . MINUSMINUS
    (203) expression -> IDENTIFIER . LPAREN argument_list RPAREN
    (163) type_name -> IDENTIFIER .
    (56) simple_assignment -> IDENTIFIER . ASSIGN expression
    (77) short_assignment -> IDENTIFIER . SHORT_ASSIGN expression

  ! reduce/reduce conflict for LBRACE resolved using rule 73 (expression -> IDENTIFIER .)
    DOT             reduce using rule 73 (expression -> IDENTIFIER .)
    LBRACKET        reduce using rule 73 (expression -> IDENTIFIER .)
    LBRACE          reduce using rule 73 (expression -> IDENTIFIER .)
    PLUS            reduce using rule 73 (expression -> IDENTIFIER .)
    MINUS           reduce using rule 73 (expression -> IDENTIFIER .)
    TIMES           reduce using rule 73 (expression -> IDENTIFIER .)
    DIVIDE          reduce using rule 73 (expression -> IDENTIFIER .)
    MODULE          reduce using rule 73 (expression -> IDENTIFIER .)
    EQ              reduce using rule 73 (expression -> IDENTIFIER .)
    NEQ             reduce using rule 73 (expression -> IDENTIFIER .)
    LT              reduce using rule 73 (expression -> IDENTIFIER .)
    LE              reduce using rule 73 (expression -> IDENTIFIER .)
    GT              reduce using rule 73 (expression -> IDENTIFIER .)
    GE              reduce using rule 73 (expression -> IDENTIFIER .)
    LAND            reduce using rule 73 (expression -> IDENTIFIER .)
    LOR             reduce using rule 73 (expression -> IDENTIFIER .)
    AND             reduce using rule 73 (expression -> IDENTIFIER .)
    OR              reduce using rule 73 (expression -> IDENTIFIER .)
    XOR             reduce using rule 73 (expression -> IDENTIFIER .)
    AND_NOT         reduce using rule 73 (expression -> IDENTIFIER .)
    LSHIFT          reduce using rule 73 (expression -> IDENTIFIER .)
    RSHIFT          reduce using rule 73 (expression -> IDENTIFIER .)
    PLUSPLUS        shift and go to state 78
    MINUSMINUS      shift and go to state 79
    LPAREN          shift and go to state 80
    ASSIGN          shift and go to state 218
    SHORT_ASSIGN    shift and go to state 217

  ! LBRACE          [ reduce using rule 163 (type_name -> IDENTIFIER .) ]


state 234

    (134) if_assignment -> simple_assignment .

    SEMICOLON       reduce using rule 134 (if_assignment -> simple_assignment .)


state 235

    (135) if_assignment -> short_assignment .

    SEMICOLON       reduce using rule 135 (if_assignment -> short_assignment .)


state 236

    (136) if_assignment -> local_var_dec .

    SEMICOLON       reduce using rule 136 (if_assignment -> local_var_dec .)


state 237

    (167) switch_statement -> SWITCH switch_expr . LBRACE case_clause_list RBRACE
    (168) switch_statement -> SWITCH switch_expr . LBRACE RBRACE

    LBRACE          shift and go to state 271


state 238

    (169) switch_statement -> SWITCH LBRACE . case_clause_list RBRACE
    (170) switch_statement -> SWITCH LBRACE . RBRACE
    (186) case_clause_list -> . case_clause
    (187) case_clause_list -> . case_clause_list case_clause
    (191) case_clause -> . CASE case_expression_list COLON case_body
    (192) case_clause -> . DEFAULT COLON case_body

    RBRACE          shift and go to state 273
    CASE            shift and go to state 275
    DEFAULT         shift and go to state 276

    case_clause_list               shift and go to state 272
    case_clause                    shift and go to state 274

state 239

    (171) switch_statement -> SWITCH switch_assignment . SEMICOLON switch_expr LBRACE case_clause_list RBRACE
    (172) switch_statement -> SWITCH switch_assignment . SEMICOLON switch_expr LBRACE RBRACE
    (173) switch_statement -> SWITCH switch_assignment . SEMICOLON LBRACE case_clause_list RBRACE
    (174) switch_statement -> SWITCH switch_assignment . SEMICOLON LBRACE RBRACE

    SEMICOLON       shift and go to state 277


state 240

    (175) switch_expr -> primary_expression .
    (184) primary_expression -> primary_expression . DOT IDENTIFIER
    (185) primary_expression -> primary_expression . LBRACKET expression RBRACKET

    LBRACE          reduce using rule 175 (switch_expr -> primary_expression .)
    DOT             shift and go to state 278
    LBRACKET        shift and go to state 279


state 241

    (188) switch_assignment -> simple_assignment .

    SEMICOLON       reduce using rule 188 (switch_assignment -> simple_assignment .)


state 242

    (189) switch_assignment -> short_assignment .

    SEMICOLON       reduce using rule 189 (switch_assignment -> short_assignment .)


state 243

    (190) switch_assignment -> local_var_dec .

    SEMICOLON       reduce using rule 190 (switch_assignment -> local_var_dec .)


state 244

    (176) primary_expression -> IDENTIFIER .
    (183) primary_expression -> IDENTIFIER . LPAREN argument_list RPAREN
    (56) simple_assignment -> IDENTIFIER . ASSIGN expression
    (77) short_assignment -> IDENTIFIER . SHORT_ASSIGN expression

    DOT             reduce using rule 176 (primary_expression -> IDENTIFIER .)
    LBRACKET        reduce using rule 176 (primary_expression -> IDENTIFIER .)
    LBRACE          reduce using rule 176 (primary_expression -> IDENTIFIER .)
    LPAREN          shift and go to state 280
    ASSIGN          shift and go to state 218
    SHORT_ASSIGN    shift and go to state 217


state 245

    (177) primary_expression -> INT .

    DOT             reduce using rule 177 (primary_expression -> INT .)
    LBRACKET        reduce using rule 177 (primary_expression -> INT .)
    LBRACE          reduce using rule 177 (primary_expression -> INT .)


state 246

    (178) primary_expression -> FLOAT64 .

    DOT             reduce using rule 178 (primary_expression -> FLOAT64 .)
    LBRACKET        reduce using rule 178 (primary_expression -> FLOAT64 .)
    LBRACE          reduce using rule 178 (primary_expression -> FLOAT64 .)


state 247

    (179) primary_expression -> STRING .

    DOT             reduce using rule 179 (primary_expression -> STRING .)
    LBRACKET        reduce using rule 179 (primary_expression -> STRING .)
    LBRACE          reduce using rule 179 (primary_expression -> STRING .)


state 248

    (180) primary_expression -> TRUE .

    DOT             reduce using rule 180 (primary_expression -> TRUE .)
    LBRACKET        reduce using rule 180 (primary_expression -> TRUE .)
    LBRACE          reduce using rule 180 (primary_expression -> TRUE .)


state 249

    (181) primary_expression -> FALSE .

    DOT             reduce using rule 181 (primary_expression -> FALSE .)
    LBRACKET        reduce using rule 181 (primary_expression -> FALSE .)
    LBRACE          reduce using rule 181 (primary_expression -> FALSE .)


state 250

    (182) primary_expression -> LPAREN . expression RPAREN
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (125) expression -> . LNOT expression
    (126) expression -> . IDENTIFIER PLUSPLUS
    (127) expression -> . IDENTIFIER MINUSMINUS
    (138) expression -> . map_type LBRACE expression_map_list RBRACE
    (139) expression -> . map_type LBRACE RBRACE
    (161) expression -> . type_name LBRACE keyed_element_list RBRACE
    (162) expression -> . type_name LBRACE RBRACE
    (198) expression -> . array_type LBRACE expression_list RBRACE
    (199) expression -> . array_type LBRACE RBRACE
    (200) expression -> . expression DOT IDENTIFIER
    (201) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> . expression LBRACKET expression RBRACKET
    (203) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (137) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (163) type_name -> . IDENTIFIER
    (164) type_name -> . slice_type
    (165) type_name -> . array_type
    (166) type_name -> . map_type
    (197) array_type -> . LBRACKET INT RBRACKET primitive_type

    LPAREN          shift and go to state 54
    INT             shift and go to state 55
    FLOAT64         shift and go to state 56
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 57
    TRUE            shift and go to state 58
    FALSE           shift and go to state 59
    LNOT            shift and go to state 60
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    expression                     shift and go to state 281
    slice_type                     shift and go to state 53
    map_type                       shift and go to state 61
    type_name                      shift and go to state 62
    array_type                     shift and go to state 63

state 251

    (124) return_statement -> RETURN return_list .
    (111) return_list -> return_list . COMMA expression

    RBRACE          reduce using rule 124 (return_statement -> RETURN return_list .)
    BREAK           reduce using rule 124 (return_statement -> RETURN return_list .)
    CONTINUE        reduce using rule 124 (return_statement -> RETURN return_list .)
    VAR             reduce using rule 124 (return_statement -> RETURN return_list .)
    CONST           reduce using rule 124 (return_statement -> RETURN return_list .)
    IDENTIFIER      reduce using rule 124 (return_statement -> RETURN return_list .)
    LPAREN          reduce using rule 124 (return_statement -> RETURN return_list .)
    INT             reduce using rule 124 (return_statement -> RETURN return_list .)
    FLOAT64         reduce using rule 124 (return_statement -> RETURN return_list .)
    STRING          reduce using rule 124 (return_statement -> RETURN return_list .)
    TRUE            reduce using rule 124 (return_statement -> RETURN return_list .)
    FALSE           reduce using rule 124 (return_statement -> RETURN return_list .)
    LNOT            reduce using rule 124 (return_statement -> RETURN return_list .)
    IF              reduce using rule 124 (return_statement -> RETURN return_list .)
    SWITCH          reduce using rule 124 (return_statement -> RETURN return_list .)
    RETURN          reduce using rule 124 (return_statement -> RETURN return_list .)
    LBRACKET        reduce using rule 124 (return_statement -> RETURN return_list .)
    MAP             reduce using rule 124 (return_statement -> RETURN return_list .)
    FOR             reduce using rule 124 (return_statement -> RETURN return_list .)
    CASE            reduce using rule 124 (return_statement -> RETURN return_list .)
    DEFAULT         reduce using rule 124 (return_statement -> RETURN return_list .)
    COMMA           shift and go to state 282


state 252

    (110) return_list -> expression .
    (36) expression -> expression . binary_operator expression
    (200) expression -> expression . DOT IDENTIFIER
    (201) expression -> expression . DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> expression . LBRACKET expression RBRACKET
    (37) binary_operator -> . PLUS
    (38) binary_operator -> . MINUS
    (39) binary_operator -> . TIMES
    (40) binary_operator -> . DIVIDE
    (41) binary_operator -> . MODULE
    (42) binary_operator -> . EQ
    (43) binary_operator -> . NEQ
    (44) binary_operator -> . LT
    (45) binary_operator -> . LE
    (46) binary_operator -> . GT
    (47) binary_operator -> . GE
    (48) binary_operator -> . LAND
    (49) binary_operator -> . LOR
    (50) binary_operator -> . AND
    (51) binary_operator -> . OR
    (52) binary_operator -> . XOR
    (53) binary_operator -> . AND_NOT
    (54) binary_operator -> . LSHIFT
    (55) binary_operator -> . RSHIFT

  ! shift/reduce conflict for LBRACKET resolved as shift
    COMMA           reduce using rule 110 (return_list -> expression .)
    RBRACE          reduce using rule 110 (return_list -> expression .)
    BREAK           reduce using rule 110 (return_list -> expression .)
    CONTINUE        reduce using rule 110 (return_list -> expression .)
    VAR             reduce using rule 110 (return_list -> expression .)
    CONST           reduce using rule 110 (return_list -> expression .)
    IDENTIFIER      reduce using rule 110 (return_list -> expression .)
    LPAREN          reduce using rule 110 (return_list -> expression .)
    INT             reduce using rule 110 (return_list -> expression .)
    FLOAT64         reduce using rule 110 (return_list -> expression .)
    STRING          reduce using rule 110 (return_list -> expression .)
    TRUE            reduce using rule 110 (return_list -> expression .)
    FALSE           reduce using rule 110 (return_list -> expression .)
    LNOT            reduce using rule 110 (return_list -> expression .)
    IF              reduce using rule 110 (return_list -> expression .)
    SWITCH          reduce using rule 110 (return_list -> expression .)
    RETURN          reduce using rule 110 (return_list -> expression .)
    MAP             reduce using rule 110 (return_list -> expression .)
    FOR             reduce using rule 110 (return_list -> expression .)
    CASE            reduce using rule 110 (return_list -> expression .)
    DEFAULT         reduce using rule 110 (return_list -> expression .)
    DOT             shift and go to state 82
    LBRACKET        shift and go to state 83
    PLUS            shift and go to state 84
    MINUS           shift and go to state 85
    TIMES           shift and go to state 86
    DIVIDE          shift and go to state 87
    MODULE          shift and go to state 88
    EQ              shift and go to state 89
    NEQ             shift and go to state 90
    LT              shift and go to state 91
    LE              shift and go to state 92
    GT              shift and go to state 93
    GE              shift and go to state 94
    LAND            shift and go to state 95
    LOR             shift and go to state 96
    AND             shift and go to state 97
    OR              shift and go to state 98
    XOR             shift and go to state 99
    AND_NOT         shift and go to state 100
    LSHIFT          shift and go to state 101
    RSHIFT          shift and go to state 102

  ! LBRACKET        [ reduce using rule 110 (return_list -> expression .) ]

    binary_operator                shift and go to state 81

state 253

    (97) for_classic -> FOR for_init . SEMICOLON for_cond SEMICOLON for_post block

    SEMICOLON       shift and go to state 283


state 254

    (99) for_infinite -> FOR block .

    RBRACE          reduce using rule 99 (for_infinite -> FOR block .)
    BREAK           reduce using rule 99 (for_infinite -> FOR block .)
    CONTINUE        reduce using rule 99 (for_infinite -> FOR block .)
    VAR             reduce using rule 99 (for_infinite -> FOR block .)
    CONST           reduce using rule 99 (for_infinite -> FOR block .)
    IDENTIFIER      reduce using rule 99 (for_infinite -> FOR block .)
    LPAREN          reduce using rule 99 (for_infinite -> FOR block .)
    INT             reduce using rule 99 (for_infinite -> FOR block .)
    FLOAT64         reduce using rule 99 (for_infinite -> FOR block .)
    STRING          reduce using rule 99 (for_infinite -> FOR block .)
    TRUE            reduce using rule 99 (for_infinite -> FOR block .)
    FALSE           reduce using rule 99 (for_infinite -> FOR block .)
    LNOT            reduce using rule 99 (for_infinite -> FOR block .)
    IF              reduce using rule 99 (for_infinite -> FOR block .)
    SWITCH          reduce using rule 99 (for_infinite -> FOR block .)
    RETURN          reduce using rule 99 (for_infinite -> FOR block .)
    LBRACKET        reduce using rule 99 (for_infinite -> FOR block .)
    MAP             reduce using rule 99 (for_infinite -> FOR block .)
    FOR             reduce using rule 99 (for_infinite -> FOR block .)
    CASE            reduce using rule 99 (for_infinite -> FOR block .)
    DEFAULT         reduce using rule 99 (for_infinite -> FOR block .)


state 255

    (98) for_condition -> FOR expression . block
    (36) expression -> expression . binary_operator expression
    (200) expression -> expression . DOT IDENTIFIER
    (201) expression -> expression . DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> expression . LBRACKET expression RBRACKET
    (90) block -> . LBRACE local_statement_list RBRACE
    (91) block -> . LBRACE RBRACE
    (37) binary_operator -> . PLUS
    (38) binary_operator -> . MINUS
    (39) binary_operator -> . TIMES
    (40) binary_operator -> . DIVIDE
    (41) binary_operator -> . MODULE
    (42) binary_operator -> . EQ
    (43) binary_operator -> . NEQ
    (44) binary_operator -> . LT
    (45) binary_operator -> . LE
    (46) binary_operator -> . GT
    (47) binary_operator -> . GE
    (48) binary_operator -> . LAND
    (49) binary_operator -> . LOR
    (50) binary_operator -> . AND
    (51) binary_operator -> . OR
    (52) binary_operator -> . XOR
    (53) binary_operator -> . AND_NOT
    (54) binary_operator -> . LSHIFT
    (55) binary_operator -> . RSHIFT

    DOT             shift and go to state 82
    LBRACKET        shift and go to state 83
    LBRACE          shift and go to state 175
    PLUS            shift and go to state 84
    MINUS           shift and go to state 85
    TIMES           shift and go to state 86
    DIVIDE          shift and go to state 87
    MODULE          shift and go to state 88
    EQ              shift and go to state 89
    NEQ             shift and go to state 90
    LT              shift and go to state 91
    LE              shift and go to state 92
    GT              shift and go to state 93
    GE              shift and go to state 94
    LAND            shift and go to state 95
    LOR             shift and go to state 96
    AND             shift and go to state 97
    OR              shift and go to state 98
    XOR             shift and go to state 99
    AND_NOT         shift and go to state 100
    LSHIFT          shift and go to state 101
    RSHIFT          shift and go to state 102

    block                          shift and go to state 284
    binary_operator                shift and go to state 81

state 256

    (100) for_init -> simple_assignment .

    SEMICOLON       reduce using rule 100 (for_init -> simple_assignment .)


state 257

    (101) for_init -> short_assignment .

    SEMICOLON       reduce using rule 101 (for_init -> short_assignment .)


state 258

    (102) for_init -> local_var_dec .

    SEMICOLON       reduce using rule 102 (for_init -> local_var_dec .)


state 259

    (103) for_init -> empty .

    SEMICOLON       reduce using rule 103 (for_init -> empty .)


state 260

    (73) expression -> IDENTIFIER .
    (126) expression -> IDENTIFIER . PLUSPLUS
    (127) expression -> IDENTIFIER . MINUSMINUS
    (203) expression -> IDENTIFIER . LPAREN argument_list RPAREN
    (56) simple_assignment -> IDENTIFIER . ASSIGN expression
    (77) short_assignment -> IDENTIFIER . SHORT_ASSIGN expression
    (163) type_name -> IDENTIFIER .

  ! reduce/reduce conflict for LBRACE resolved using rule 73 (expression -> IDENTIFIER .)
    DOT             reduce using rule 73 (expression -> IDENTIFIER .)
    LBRACKET        reduce using rule 73 (expression -> IDENTIFIER .)
    LBRACE          reduce using rule 73 (expression -> IDENTIFIER .)
    PLUS            reduce using rule 73 (expression -> IDENTIFIER .)
    MINUS           reduce using rule 73 (expression -> IDENTIFIER .)
    TIMES           reduce using rule 73 (expression -> IDENTIFIER .)
    DIVIDE          reduce using rule 73 (expression -> IDENTIFIER .)
    MODULE          reduce using rule 73 (expression -> IDENTIFIER .)
    EQ              reduce using rule 73 (expression -> IDENTIFIER .)
    NEQ             reduce using rule 73 (expression -> IDENTIFIER .)
    LT              reduce using rule 73 (expression -> IDENTIFIER .)
    LE              reduce using rule 73 (expression -> IDENTIFIER .)
    GT              reduce using rule 73 (expression -> IDENTIFIER .)
    GE              reduce using rule 73 (expression -> IDENTIFIER .)
    LAND            reduce using rule 73 (expression -> IDENTIFIER .)
    LOR             reduce using rule 73 (expression -> IDENTIFIER .)
    AND             reduce using rule 73 (expression -> IDENTIFIER .)
    OR              reduce using rule 73 (expression -> IDENTIFIER .)
    XOR             reduce using rule 73 (expression -> IDENTIFIER .)
    AND_NOT         reduce using rule 73 (expression -> IDENTIFIER .)
    LSHIFT          reduce using rule 73 (expression -> IDENTIFIER .)
    RSHIFT          reduce using rule 73 (expression -> IDENTIFIER .)
    PLUSPLUS        shift and go to state 78
    MINUSMINUS      shift and go to state 79
    LPAREN          shift and go to state 80
    ASSIGN          shift and go to state 218
    SHORT_ASSIGN    shift and go to state 217

  ! LBRACE          [ reduce using rule 163 (type_name -> IDENTIFIER .) ]


state 261

    (146) method_declaration -> FUNC LPAREN receiver RPAREN IDENTIFIER LPAREN parameter_list RPAREN return_type . block
    (90) block -> . LBRACE local_statement_list RBRACE
    (91) block -> . LBRACE RBRACE

    LBRACE          shift and go to state 175

    block                          shift and go to state 285

state 262

    (20) local_var_dec -> VAR IDENTIFIER type .
    (21) local_var_dec -> VAR IDENTIFIER type . ASSIGN expression

    RBRACE          reduce using rule 20 (local_var_dec -> VAR IDENTIFIER type .)
    BREAK           reduce using rule 20 (local_var_dec -> VAR IDENTIFIER type .)
    CONTINUE        reduce using rule 20 (local_var_dec -> VAR IDENTIFIER type .)
    VAR             reduce using rule 20 (local_var_dec -> VAR IDENTIFIER type .)
    CONST           reduce using rule 20 (local_var_dec -> VAR IDENTIFIER type .)
    IDENTIFIER      reduce using rule 20 (local_var_dec -> VAR IDENTIFIER type .)
    LPAREN          reduce using rule 20 (local_var_dec -> VAR IDENTIFIER type .)
    INT             reduce using rule 20 (local_var_dec -> VAR IDENTIFIER type .)
    FLOAT64         reduce using rule 20 (local_var_dec -> VAR IDENTIFIER type .)
    STRING          reduce using rule 20 (local_var_dec -> VAR IDENTIFIER type .)
    TRUE            reduce using rule 20 (local_var_dec -> VAR IDENTIFIER type .)
    FALSE           reduce using rule 20 (local_var_dec -> VAR IDENTIFIER type .)
    LNOT            reduce using rule 20 (local_var_dec -> VAR IDENTIFIER type .)
    IF              reduce using rule 20 (local_var_dec -> VAR IDENTIFIER type .)
    SWITCH          reduce using rule 20 (local_var_dec -> VAR IDENTIFIER type .)
    RETURN          reduce using rule 20 (local_var_dec -> VAR IDENTIFIER type .)
    LBRACKET        reduce using rule 20 (local_var_dec -> VAR IDENTIFIER type .)
    MAP             reduce using rule 20 (local_var_dec -> VAR IDENTIFIER type .)
    FOR             reduce using rule 20 (local_var_dec -> VAR IDENTIFIER type .)
    SEMICOLON       reduce using rule 20 (local_var_dec -> VAR IDENTIFIER type .)
    CASE            reduce using rule 20 (local_var_dec -> VAR IDENTIFIER type .)
    DEFAULT         reduce using rule 20 (local_var_dec -> VAR IDENTIFIER type .)
    ASSIGN          shift and go to state 286


state 263

    (22) local_var_dec -> VAR IDENTIFIER ASSIGN . expression
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (125) expression -> . LNOT expression
    (126) expression -> . IDENTIFIER PLUSPLUS
    (127) expression -> . IDENTIFIER MINUSMINUS
    (138) expression -> . map_type LBRACE expression_map_list RBRACE
    (139) expression -> . map_type LBRACE RBRACE
    (161) expression -> . type_name LBRACE keyed_element_list RBRACE
    (162) expression -> . type_name LBRACE RBRACE
    (198) expression -> . array_type LBRACE expression_list RBRACE
    (199) expression -> . array_type LBRACE RBRACE
    (200) expression -> . expression DOT IDENTIFIER
    (201) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> . expression LBRACKET expression RBRACKET
    (203) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (137) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (163) type_name -> . IDENTIFIER
    (164) type_name -> . slice_type
    (165) type_name -> . array_type
    (166) type_name -> . map_type
    (197) array_type -> . LBRACKET INT RBRACKET primitive_type

    LPAREN          shift and go to state 54
    INT             shift and go to state 55
    FLOAT64         shift and go to state 56
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 57
    TRUE            shift and go to state 58
    FALSE           shift and go to state 59
    LNOT            shift and go to state 60
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    expression                     shift and go to state 287
    slice_type                     shift and go to state 53
    map_type                       shift and go to state 61
    type_name                      shift and go to state 62
    array_type                     shift and go to state 63

state 264

    (77) short_assignment -> IDENTIFIER SHORT_ASSIGN expression .
    (36) expression -> expression . binary_operator expression
    (200) expression -> expression . DOT IDENTIFIER
    (201) expression -> expression . DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> expression . LBRACKET expression RBRACKET
    (37) binary_operator -> . PLUS
    (38) binary_operator -> . MINUS
    (39) binary_operator -> . TIMES
    (40) binary_operator -> . DIVIDE
    (41) binary_operator -> . MODULE
    (42) binary_operator -> . EQ
    (43) binary_operator -> . NEQ
    (44) binary_operator -> . LT
    (45) binary_operator -> . LE
    (46) binary_operator -> . GT
    (47) binary_operator -> . GE
    (48) binary_operator -> . LAND
    (49) binary_operator -> . LOR
    (50) binary_operator -> . AND
    (51) binary_operator -> . OR
    (52) binary_operator -> . XOR
    (53) binary_operator -> . AND_NOT
    (54) binary_operator -> . LSHIFT
    (55) binary_operator -> . RSHIFT

  ! shift/reduce conflict for LBRACKET resolved as shift
    RBRACE          reduce using rule 77 (short_assignment -> IDENTIFIER SHORT_ASSIGN expression .)
    BREAK           reduce using rule 77 (short_assignment -> IDENTIFIER SHORT_ASSIGN expression .)
    CONTINUE        reduce using rule 77 (short_assignment -> IDENTIFIER SHORT_ASSIGN expression .)
    VAR             reduce using rule 77 (short_assignment -> IDENTIFIER SHORT_ASSIGN expression .)
    CONST           reduce using rule 77 (short_assignment -> IDENTIFIER SHORT_ASSIGN expression .)
    IDENTIFIER      reduce using rule 77 (short_assignment -> IDENTIFIER SHORT_ASSIGN expression .)
    LPAREN          reduce using rule 77 (short_assignment -> IDENTIFIER SHORT_ASSIGN expression .)
    INT             reduce using rule 77 (short_assignment -> IDENTIFIER SHORT_ASSIGN expression .)
    FLOAT64         reduce using rule 77 (short_assignment -> IDENTIFIER SHORT_ASSIGN expression .)
    STRING          reduce using rule 77 (short_assignment -> IDENTIFIER SHORT_ASSIGN expression .)
    TRUE            reduce using rule 77 (short_assignment -> IDENTIFIER SHORT_ASSIGN expression .)
    FALSE           reduce using rule 77 (short_assignment -> IDENTIFIER SHORT_ASSIGN expression .)
    LNOT            reduce using rule 77 (short_assignment -> IDENTIFIER SHORT_ASSIGN expression .)
    IF              reduce using rule 77 (short_assignment -> IDENTIFIER SHORT_ASSIGN expression .)
    SWITCH          reduce using rule 77 (short_assignment -> IDENTIFIER SHORT_ASSIGN expression .)
    RETURN          reduce using rule 77 (short_assignment -> IDENTIFIER SHORT_ASSIGN expression .)
    MAP             reduce using rule 77 (short_assignment -> IDENTIFIER SHORT_ASSIGN expression .)
    FOR             reduce using rule 77 (short_assignment -> IDENTIFIER SHORT_ASSIGN expression .)
    SEMICOLON       reduce using rule 77 (short_assignment -> IDENTIFIER SHORT_ASSIGN expression .)
    CASE            reduce using rule 77 (short_assignment -> IDENTIFIER SHORT_ASSIGN expression .)
    DEFAULT         reduce using rule 77 (short_assignment -> IDENTIFIER SHORT_ASSIGN expression .)
    DOT             shift and go to state 82
    LBRACKET        shift and go to state 83
    PLUS            shift and go to state 84
    MINUS           shift and go to state 85
    TIMES           shift and go to state 86
    DIVIDE          shift and go to state 87
    MODULE          shift and go to state 88
    EQ              shift and go to state 89
    NEQ             shift and go to state 90
    LT              shift and go to state 91
    LE              shift and go to state 92
    GT              shift and go to state 93
    GE              shift and go to state 94
    LAND            shift and go to state 95
    LOR             shift and go to state 96
    AND             shift and go to state 97
    OR              shift and go to state 98
    XOR             shift and go to state 99
    AND_NOT         shift and go to state 100
    LSHIFT          shift and go to state 101
    RSHIFT          shift and go to state 102

  ! LBRACKET        [ reduce using rule 77 (short_assignment -> IDENTIFIER SHORT_ASSIGN expression .) ]

    binary_operator                shift and go to state 81

state 265

    (56) simple_assignment -> IDENTIFIER ASSIGN expression .
    (36) expression -> expression . binary_operator expression
    (200) expression -> expression . DOT IDENTIFIER
    (201) expression -> expression . DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> expression . LBRACKET expression RBRACKET
    (37) binary_operator -> . PLUS
    (38) binary_operator -> . MINUS
    (39) binary_operator -> . TIMES
    (40) binary_operator -> . DIVIDE
    (41) binary_operator -> . MODULE
    (42) binary_operator -> . EQ
    (43) binary_operator -> . NEQ
    (44) binary_operator -> . LT
    (45) binary_operator -> . LE
    (46) binary_operator -> . GT
    (47) binary_operator -> . GE
    (48) binary_operator -> . LAND
    (49) binary_operator -> . LOR
    (50) binary_operator -> . AND
    (51) binary_operator -> . OR
    (52) binary_operator -> . XOR
    (53) binary_operator -> . AND_NOT
    (54) binary_operator -> . LSHIFT
    (55) binary_operator -> . RSHIFT

  ! shift/reduce conflict for LBRACKET resolved as shift
    RBRACE          reduce using rule 56 (simple_assignment -> IDENTIFIER ASSIGN expression .)
    BREAK           reduce using rule 56 (simple_assignment -> IDENTIFIER ASSIGN expression .)
    CONTINUE        reduce using rule 56 (simple_assignment -> IDENTIFIER ASSIGN expression .)
    VAR             reduce using rule 56 (simple_assignment -> IDENTIFIER ASSIGN expression .)
    CONST           reduce using rule 56 (simple_assignment -> IDENTIFIER ASSIGN expression .)
    IDENTIFIER      reduce using rule 56 (simple_assignment -> IDENTIFIER ASSIGN expression .)
    LPAREN          reduce using rule 56 (simple_assignment -> IDENTIFIER ASSIGN expression .)
    INT             reduce using rule 56 (simple_assignment -> IDENTIFIER ASSIGN expression .)
    FLOAT64         reduce using rule 56 (simple_assignment -> IDENTIFIER ASSIGN expression .)
    STRING          reduce using rule 56 (simple_assignment -> IDENTIFIER ASSIGN expression .)
    TRUE            reduce using rule 56 (simple_assignment -> IDENTIFIER ASSIGN expression .)
    FALSE           reduce using rule 56 (simple_assignment -> IDENTIFIER ASSIGN expression .)
    LNOT            reduce using rule 56 (simple_assignment -> IDENTIFIER ASSIGN expression .)
    IF              reduce using rule 56 (simple_assignment -> IDENTIFIER ASSIGN expression .)
    SWITCH          reduce using rule 56 (simple_assignment -> IDENTIFIER ASSIGN expression .)
    RETURN          reduce using rule 56 (simple_assignment -> IDENTIFIER ASSIGN expression .)
    MAP             reduce using rule 56 (simple_assignment -> IDENTIFIER ASSIGN expression .)
    FOR             reduce using rule 56 (simple_assignment -> IDENTIFIER ASSIGN expression .)
    SEMICOLON       reduce using rule 56 (simple_assignment -> IDENTIFIER ASSIGN expression .)
    CASE            reduce using rule 56 (simple_assignment -> IDENTIFIER ASSIGN expression .)
    DEFAULT         reduce using rule 56 (simple_assignment -> IDENTIFIER ASSIGN expression .)
    LBRACE          reduce using rule 56 (simple_assignment -> IDENTIFIER ASSIGN expression .)
    DOT             shift and go to state 82
    LBRACKET        shift and go to state 83
    PLUS            shift and go to state 84
    MINUS           shift and go to state 85
    TIMES           shift and go to state 86
    DIVIDE          shift and go to state 87
    MODULE          shift and go to state 88
    EQ              shift and go to state 89
    NEQ             shift and go to state 90
    LT              shift and go to state 91
    LE              shift and go to state 92
    GT              shift and go to state 93
    GE              shift and go to state 94
    LAND            shift and go to state 95
    LOR             shift and go to state 96
    AND             shift and go to state 97
    OR              shift and go to state 98
    XOR             shift and go to state 99
    AND_NOT         shift and go to state 100
    LSHIFT          shift and go to state 101
    RSHIFT          shift and go to state 102

  ! LBRACKET        [ reduce using rule 56 (simple_assignment -> IDENTIFIER ASSIGN expression .) ]

    binary_operator                shift and go to state 81

state 266

    (25) assignment_compound -> IDENTIFIER operator_assign expression .
    (36) expression -> expression . binary_operator expression
    (200) expression -> expression . DOT IDENTIFIER
    (201) expression -> expression . DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> expression . LBRACKET expression RBRACKET
    (37) binary_operator -> . PLUS
    (38) binary_operator -> . MINUS
    (39) binary_operator -> . TIMES
    (40) binary_operator -> . DIVIDE
    (41) binary_operator -> . MODULE
    (42) binary_operator -> . EQ
    (43) binary_operator -> . NEQ
    (44) binary_operator -> . LT
    (45) binary_operator -> . LE
    (46) binary_operator -> . GT
    (47) binary_operator -> . GE
    (48) binary_operator -> . LAND
    (49) binary_operator -> . LOR
    (50) binary_operator -> . AND
    (51) binary_operator -> . OR
    (52) binary_operator -> . XOR
    (53) binary_operator -> . AND_NOT
    (54) binary_operator -> . LSHIFT
    (55) binary_operator -> . RSHIFT

  ! shift/reduce conflict for LBRACKET resolved as shift
    RBRACE          reduce using rule 25 (assignment_compound -> IDENTIFIER operator_assign expression .)
    BREAK           reduce using rule 25 (assignment_compound -> IDENTIFIER operator_assign expression .)
    CONTINUE        reduce using rule 25 (assignment_compound -> IDENTIFIER operator_assign expression .)
    VAR             reduce using rule 25 (assignment_compound -> IDENTIFIER operator_assign expression .)
    CONST           reduce using rule 25 (assignment_compound -> IDENTIFIER operator_assign expression .)
    IDENTIFIER      reduce using rule 25 (assignment_compound -> IDENTIFIER operator_assign expression .)
    LPAREN          reduce using rule 25 (assignment_compound -> IDENTIFIER operator_assign expression .)
    INT             reduce using rule 25 (assignment_compound -> IDENTIFIER operator_assign expression .)
    FLOAT64         reduce using rule 25 (assignment_compound -> IDENTIFIER operator_assign expression .)
    STRING          reduce using rule 25 (assignment_compound -> IDENTIFIER operator_assign expression .)
    TRUE            reduce using rule 25 (assignment_compound -> IDENTIFIER operator_assign expression .)
    FALSE           reduce using rule 25 (assignment_compound -> IDENTIFIER operator_assign expression .)
    LNOT            reduce using rule 25 (assignment_compound -> IDENTIFIER operator_assign expression .)
    IF              reduce using rule 25 (assignment_compound -> IDENTIFIER operator_assign expression .)
    SWITCH          reduce using rule 25 (assignment_compound -> IDENTIFIER operator_assign expression .)
    RETURN          reduce using rule 25 (assignment_compound -> IDENTIFIER operator_assign expression .)
    MAP             reduce using rule 25 (assignment_compound -> IDENTIFIER operator_assign expression .)
    FOR             reduce using rule 25 (assignment_compound -> IDENTIFIER operator_assign expression .)
    CASE            reduce using rule 25 (assignment_compound -> IDENTIFIER operator_assign expression .)
    DEFAULT         reduce using rule 25 (assignment_compound -> IDENTIFIER operator_assign expression .)
    LBRACE          reduce using rule 25 (assignment_compound -> IDENTIFIER operator_assign expression .)
    DOT             shift and go to state 82
    LBRACKET        shift and go to state 83
    PLUS            shift and go to state 84
    MINUS           shift and go to state 85
    TIMES           shift and go to state 86
    DIVIDE          shift and go to state 87
    MODULE          shift and go to state 88
    EQ              shift and go to state 89
    NEQ             shift and go to state 90
    LT              shift and go to state 91
    LE              shift and go to state 92
    GT              shift and go to state 93
    GE              shift and go to state 94
    LAND            shift and go to state 95
    LOR             shift and go to state 96
    AND             shift and go to state 97
    OR              shift and go to state 98
    XOR             shift and go to state 99
    AND_NOT         shift and go to state 100
    LSHIFT          shift and go to state 101
    RSHIFT          shift and go to state 102

  ! LBRACKET        [ reduce using rule 25 (assignment_compound -> IDENTIFIER operator_assign expression .) ]

    binary_operator                shift and go to state 81

state 267

    (23) local_const_dec -> CONST IDENTIFIER type . ASSIGN expression

    ASSIGN          shift and go to state 288


state 268

    (24) local_const_dec -> CONST IDENTIFIER ASSIGN . expression
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (125) expression -> . LNOT expression
    (126) expression -> . IDENTIFIER PLUSPLUS
    (127) expression -> . IDENTIFIER MINUSMINUS
    (138) expression -> . map_type LBRACE expression_map_list RBRACE
    (139) expression -> . map_type LBRACE RBRACE
    (161) expression -> . type_name LBRACE keyed_element_list RBRACE
    (162) expression -> . type_name LBRACE RBRACE
    (198) expression -> . array_type LBRACE expression_list RBRACE
    (199) expression -> . array_type LBRACE RBRACE
    (200) expression -> . expression DOT IDENTIFIER
    (201) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> . expression LBRACKET expression RBRACKET
    (203) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (137) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (163) type_name -> . IDENTIFIER
    (164) type_name -> . slice_type
    (165) type_name -> . array_type
    (166) type_name -> . map_type
    (197) array_type -> . LBRACKET INT RBRACKET primitive_type

    LPAREN          shift and go to state 54
    INT             shift and go to state 55
    FLOAT64         shift and go to state 56
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 57
    TRUE            shift and go to state 58
    FALSE           shift and go to state 59
    LNOT            shift and go to state 60
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    expression                     shift and go to state 289
    slice_type                     shift and go to state 53
    map_type                       shift and go to state 61
    type_name                      shift and go to state 62
    array_type                     shift and go to state 63

state 269

    (128) if_statement -> IF expression block .
    (129) if_statement -> IF expression block . ELSE block
    (130) if_statement -> IF expression block . ELSE if_statement

    RBRACE          reduce using rule 128 (if_statement -> IF expression block .)
    BREAK           reduce using rule 128 (if_statement -> IF expression block .)
    CONTINUE        reduce using rule 128 (if_statement -> IF expression block .)
    VAR             reduce using rule 128 (if_statement -> IF expression block .)
    CONST           reduce using rule 128 (if_statement -> IF expression block .)
    IDENTIFIER      reduce using rule 128 (if_statement -> IF expression block .)
    LPAREN          reduce using rule 128 (if_statement -> IF expression block .)
    INT             reduce using rule 128 (if_statement -> IF expression block .)
    FLOAT64         reduce using rule 128 (if_statement -> IF expression block .)
    STRING          reduce using rule 128 (if_statement -> IF expression block .)
    TRUE            reduce using rule 128 (if_statement -> IF expression block .)
    FALSE           reduce using rule 128 (if_statement -> IF expression block .)
    LNOT            reduce using rule 128 (if_statement -> IF expression block .)
    IF              reduce using rule 128 (if_statement -> IF expression block .)
    SWITCH          reduce using rule 128 (if_statement -> IF expression block .)
    RETURN          reduce using rule 128 (if_statement -> IF expression block .)
    LBRACKET        reduce using rule 128 (if_statement -> IF expression block .)
    MAP             reduce using rule 128 (if_statement -> IF expression block .)
    FOR             reduce using rule 128 (if_statement -> IF expression block .)
    CASE            reduce using rule 128 (if_statement -> IF expression block .)
    DEFAULT         reduce using rule 128 (if_statement -> IF expression block .)
    ELSE            shift and go to state 290


state 270

    (131) if_statement -> IF if_assignment SEMICOLON . expression block
    (132) if_statement -> IF if_assignment SEMICOLON . expression block ELSE block
    (133) if_statement -> IF if_assignment SEMICOLON . expression block ELSE if_statement
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (125) expression -> . LNOT expression
    (126) expression -> . IDENTIFIER PLUSPLUS
    (127) expression -> . IDENTIFIER MINUSMINUS
    (138) expression -> . map_type LBRACE expression_map_list RBRACE
    (139) expression -> . map_type LBRACE RBRACE
    (161) expression -> . type_name LBRACE keyed_element_list RBRACE
    (162) expression -> . type_name LBRACE RBRACE
    (198) expression -> . array_type LBRACE expression_list RBRACE
    (199) expression -> . array_type LBRACE RBRACE
    (200) expression -> . expression DOT IDENTIFIER
    (201) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> . expression LBRACKET expression RBRACKET
    (203) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (137) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (163) type_name -> . IDENTIFIER
    (164) type_name -> . slice_type
    (165) type_name -> . array_type
    (166) type_name -> . map_type
    (197) array_type -> . LBRACKET INT RBRACKET primitive_type

    LPAREN          shift and go to state 54
    INT             shift and go to state 55
    FLOAT64         shift and go to state 56
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 57
    TRUE            shift and go to state 58
    FALSE           shift and go to state 59
    LNOT            shift and go to state 60
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    expression                     shift and go to state 291
    slice_type                     shift and go to state 53
    map_type                       shift and go to state 61
    type_name                      shift and go to state 62
    array_type                     shift and go to state 63

state 271

    (167) switch_statement -> SWITCH switch_expr LBRACE . case_clause_list RBRACE
    (168) switch_statement -> SWITCH switch_expr LBRACE . RBRACE
    (186) case_clause_list -> . case_clause
    (187) case_clause_list -> . case_clause_list case_clause
    (191) case_clause -> . CASE case_expression_list COLON case_body
    (192) case_clause -> . DEFAULT COLON case_body

    RBRACE          shift and go to state 293
    CASE            shift and go to state 275
    DEFAULT         shift and go to state 276

    case_clause_list               shift and go to state 292
    case_clause                    shift and go to state 274

state 272

    (169) switch_statement -> SWITCH LBRACE case_clause_list . RBRACE
    (187) case_clause_list -> case_clause_list . case_clause
    (191) case_clause -> . CASE case_expression_list COLON case_body
    (192) case_clause -> . DEFAULT COLON case_body

    RBRACE          shift and go to state 294
    CASE            shift and go to state 275
    DEFAULT         shift and go to state 276

    case_clause                    shift and go to state 295

state 273

    (170) switch_statement -> SWITCH LBRACE RBRACE .

    RBRACE          reduce using rule 170 (switch_statement -> SWITCH LBRACE RBRACE .)
    BREAK           reduce using rule 170 (switch_statement -> SWITCH LBRACE RBRACE .)
    CONTINUE        reduce using rule 170 (switch_statement -> SWITCH LBRACE RBRACE .)
    VAR             reduce using rule 170 (switch_statement -> SWITCH LBRACE RBRACE .)
    CONST           reduce using rule 170 (switch_statement -> SWITCH LBRACE RBRACE .)
    IDENTIFIER      reduce using rule 170 (switch_statement -> SWITCH LBRACE RBRACE .)
    LPAREN          reduce using rule 170 (switch_statement -> SWITCH LBRACE RBRACE .)
    INT             reduce using rule 170 (switch_statement -> SWITCH LBRACE RBRACE .)
    FLOAT64         reduce using rule 170 (switch_statement -> SWITCH LBRACE RBRACE .)
    STRING          reduce using rule 170 (switch_statement -> SWITCH LBRACE RBRACE .)
    TRUE            reduce using rule 170 (switch_statement -> SWITCH LBRACE RBRACE .)
    FALSE           reduce using rule 170 (switch_statement -> SWITCH LBRACE RBRACE .)
    LNOT            reduce using rule 170 (switch_statement -> SWITCH LBRACE RBRACE .)
    IF              reduce using rule 170 (switch_statement -> SWITCH LBRACE RBRACE .)
    SWITCH          reduce using rule 170 (switch_statement -> SWITCH LBRACE RBRACE .)
    RETURN          reduce using rule 170 (switch_statement -> SWITCH LBRACE RBRACE .)
    LBRACKET        reduce using rule 170 (switch_statement -> SWITCH LBRACE RBRACE .)
    MAP             reduce using rule 170 (switch_statement -> SWITCH LBRACE RBRACE .)
    FOR             reduce using rule 170 (switch_statement -> SWITCH LBRACE RBRACE .)
    CASE            reduce using rule 170 (switch_statement -> SWITCH LBRACE RBRACE .)
    DEFAULT         reduce using rule 170 (switch_statement -> SWITCH LBRACE RBRACE .)


state 274

    (186) case_clause_list -> case_clause .

    RBRACE          reduce using rule 186 (case_clause_list -> case_clause .)
    CASE            reduce using rule 186 (case_clause_list -> case_clause .)
    DEFAULT         reduce using rule 186 (case_clause_list -> case_clause .)


state 275

    (191) case_clause -> CASE . case_expression_list COLON case_body
    (193) case_expression_list -> . expression
    (194) case_expression_list -> . case_expression_list COMMA expression
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (125) expression -> . LNOT expression
    (126) expression -> . IDENTIFIER PLUSPLUS
    (127) expression -> . IDENTIFIER MINUSMINUS
    (138) expression -> . map_type LBRACE expression_map_list RBRACE
    (139) expression -> . map_type LBRACE RBRACE
    (161) expression -> . type_name LBRACE keyed_element_list RBRACE
    (162) expression -> . type_name LBRACE RBRACE
    (198) expression -> . array_type LBRACE expression_list RBRACE
    (199) expression -> . array_type LBRACE RBRACE
    (200) expression -> . expression DOT IDENTIFIER
    (201) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> . expression LBRACKET expression RBRACKET
    (203) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (137) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (163) type_name -> . IDENTIFIER
    (164) type_name -> . slice_type
    (165) type_name -> . array_type
    (166) type_name -> . map_type
    (197) array_type -> . LBRACKET INT RBRACKET primitive_type

    LPAREN          shift and go to state 54
    INT             shift and go to state 55
    FLOAT64         shift and go to state 56
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 57
    TRUE            shift and go to state 58
    FALSE           shift and go to state 59
    LNOT            shift and go to state 60
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    case_expression_list           shift and go to state 296
    expression                     shift and go to state 297
    slice_type                     shift and go to state 53
    map_type                       shift and go to state 61
    type_name                      shift and go to state 62
    array_type                     shift and go to state 63

state 276

    (192) case_clause -> DEFAULT . COLON case_body

    COLON           shift and go to state 298


state 277

    (171) switch_statement -> SWITCH switch_assignment SEMICOLON . switch_expr LBRACE case_clause_list RBRACE
    (172) switch_statement -> SWITCH switch_assignment SEMICOLON . switch_expr LBRACE RBRACE
    (173) switch_statement -> SWITCH switch_assignment SEMICOLON . LBRACE case_clause_list RBRACE
    (174) switch_statement -> SWITCH switch_assignment SEMICOLON . LBRACE RBRACE
    (175) switch_expr -> . primary_expression
    (176) primary_expression -> . IDENTIFIER
    (177) primary_expression -> . INT
    (178) primary_expression -> . FLOAT64
    (179) primary_expression -> . STRING
    (180) primary_expression -> . TRUE
    (181) primary_expression -> . FALSE
    (182) primary_expression -> . LPAREN expression RPAREN
    (183) primary_expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (184) primary_expression -> . primary_expression DOT IDENTIFIER
    (185) primary_expression -> . primary_expression LBRACKET expression RBRACKET

    LBRACE          shift and go to state 300
    IDENTIFIER      shift and go to state 301
    INT             shift and go to state 245
    FLOAT64         shift and go to state 246
    STRING          shift and go to state 247
    TRUE            shift and go to state 248
    FALSE           shift and go to state 249
    LPAREN          shift and go to state 250

    switch_expr                    shift and go to state 299
    primary_expression             shift and go to state 240

state 278

    (184) primary_expression -> primary_expression DOT . IDENTIFIER

    IDENTIFIER      shift and go to state 302


state 279

    (185) primary_expression -> primary_expression LBRACKET . expression RBRACKET
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (125) expression -> . LNOT expression
    (126) expression -> . IDENTIFIER PLUSPLUS
    (127) expression -> . IDENTIFIER MINUSMINUS
    (138) expression -> . map_type LBRACE expression_map_list RBRACE
    (139) expression -> . map_type LBRACE RBRACE
    (161) expression -> . type_name LBRACE keyed_element_list RBRACE
    (162) expression -> . type_name LBRACE RBRACE
    (198) expression -> . array_type LBRACE expression_list RBRACE
    (199) expression -> . array_type LBRACE RBRACE
    (200) expression -> . expression DOT IDENTIFIER
    (201) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> . expression LBRACKET expression RBRACKET
    (203) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (137) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (163) type_name -> . IDENTIFIER
    (164) type_name -> . slice_type
    (165) type_name -> . array_type
    (166) type_name -> . map_type
    (197) array_type -> . LBRACKET INT RBRACKET primitive_type

    LPAREN          shift and go to state 54
    INT             shift and go to state 55
    FLOAT64         shift and go to state 56
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 57
    TRUE            shift and go to state 58
    FALSE           shift and go to state 59
    LNOT            shift and go to state 60
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    expression                     shift and go to state 303
    slice_type                     shift and go to state 53
    map_type                       shift and go to state 61
    type_name                      shift and go to state 62
    array_type                     shift and go to state 63

state 280

    (183) primary_expression -> IDENTIFIER LPAREN . argument_list RPAREN
    (204) argument_list -> . expression_list
    (205) argument_list -> . empty
    (68) expression_list -> . expression
    (69) expression_list -> . expression_list COMMA expression
    (7) empty -> .
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (125) expression -> . LNOT expression
    (126) expression -> . IDENTIFIER PLUSPLUS
    (127) expression -> . IDENTIFIER MINUSMINUS
    (138) expression -> . map_type LBRACE expression_map_list RBRACE
    (139) expression -> . map_type LBRACE RBRACE
    (161) expression -> . type_name LBRACE keyed_element_list RBRACE
    (162) expression -> . type_name LBRACE RBRACE
    (198) expression -> . array_type LBRACE expression_list RBRACE
    (199) expression -> . array_type LBRACE RBRACE
    (200) expression -> . expression DOT IDENTIFIER
    (201) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> . expression LBRACKET expression RBRACKET
    (203) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (137) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (163) type_name -> . IDENTIFIER
    (164) type_name -> . slice_type
    (165) type_name -> . array_type
    (166) type_name -> . map_type
    (197) array_type -> . LBRACKET INT RBRACKET primitive_type

    RPAREN          reduce using rule 7 (empty -> .)
    LPAREN          shift and go to state 54
    INT             shift and go to state 55
    FLOAT64         shift and go to state 56
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 57
    TRUE            shift and go to state 58
    FALSE           shift and go to state 59
    LNOT            shift and go to state 60
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    argument_list                  shift and go to state 304
    expression_list                shift and go to state 125
    empty                          shift and go to state 126
    expression                     shift and go to state 127
    slice_type                     shift and go to state 53
    map_type                       shift and go to state 61
    type_name                      shift and go to state 62
    array_type                     shift and go to state 63

state 281

    (182) primary_expression -> LPAREN expression . RPAREN
    (36) expression -> expression . binary_operator expression
    (200) expression -> expression . DOT IDENTIFIER
    (201) expression -> expression . DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> expression . LBRACKET expression RBRACKET
    (37) binary_operator -> . PLUS
    (38) binary_operator -> . MINUS
    (39) binary_operator -> . TIMES
    (40) binary_operator -> . DIVIDE
    (41) binary_operator -> . MODULE
    (42) binary_operator -> . EQ
    (43) binary_operator -> . NEQ
    (44) binary_operator -> . LT
    (45) binary_operator -> . LE
    (46) binary_operator -> . GT
    (47) binary_operator -> . GE
    (48) binary_operator -> . LAND
    (49) binary_operator -> . LOR
    (50) binary_operator -> . AND
    (51) binary_operator -> . OR
    (52) binary_operator -> . XOR
    (53) binary_operator -> . AND_NOT
    (54) binary_operator -> . LSHIFT
    (55) binary_operator -> . RSHIFT

    RPAREN          shift and go to state 305
    DOT             shift and go to state 82
    LBRACKET        shift and go to state 83
    PLUS            shift and go to state 84
    MINUS           shift and go to state 85
    TIMES           shift and go to state 86
    DIVIDE          shift and go to state 87
    MODULE          shift and go to state 88
    EQ              shift and go to state 89
    NEQ             shift and go to state 90
    LT              shift and go to state 91
    LE              shift and go to state 92
    GT              shift and go to state 93
    GE              shift and go to state 94
    LAND            shift and go to state 95
    LOR             shift and go to state 96
    AND             shift and go to state 97
    OR              shift and go to state 98
    XOR             shift and go to state 99
    AND_NOT         shift and go to state 100
    LSHIFT          shift and go to state 101
    RSHIFT          shift and go to state 102

    binary_operator                shift and go to state 81

state 282

    (111) return_list -> return_list COMMA . expression
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (125) expression -> . LNOT expression
    (126) expression -> . IDENTIFIER PLUSPLUS
    (127) expression -> . IDENTIFIER MINUSMINUS
    (138) expression -> . map_type LBRACE expression_map_list RBRACE
    (139) expression -> . map_type LBRACE RBRACE
    (161) expression -> . type_name LBRACE keyed_element_list RBRACE
    (162) expression -> . type_name LBRACE RBRACE
    (198) expression -> . array_type LBRACE expression_list RBRACE
    (199) expression -> . array_type LBRACE RBRACE
    (200) expression -> . expression DOT IDENTIFIER
    (201) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> . expression LBRACKET expression RBRACKET
    (203) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (137) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (163) type_name -> . IDENTIFIER
    (164) type_name -> . slice_type
    (165) type_name -> . array_type
    (166) type_name -> . map_type
    (197) array_type -> . LBRACKET INT RBRACKET primitive_type

    LPAREN          shift and go to state 54
    INT             shift and go to state 55
    FLOAT64         shift and go to state 56
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 57
    TRUE            shift and go to state 58
    FALSE           shift and go to state 59
    LNOT            shift and go to state 60
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    expression                     shift and go to state 306
    slice_type                     shift and go to state 53
    map_type                       shift and go to state 61
    type_name                      shift and go to state 62
    array_type                     shift and go to state 63

state 283

    (97) for_classic -> FOR for_init SEMICOLON . for_cond SEMICOLON for_post block
    (104) for_cond -> . expression
    (105) for_cond -> . empty
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (125) expression -> . LNOT expression
    (126) expression -> . IDENTIFIER PLUSPLUS
    (127) expression -> . IDENTIFIER MINUSMINUS
    (138) expression -> . map_type LBRACE expression_map_list RBRACE
    (139) expression -> . map_type LBRACE RBRACE
    (161) expression -> . type_name LBRACE keyed_element_list RBRACE
    (162) expression -> . type_name LBRACE RBRACE
    (198) expression -> . array_type LBRACE expression_list RBRACE
    (199) expression -> . array_type LBRACE RBRACE
    (200) expression -> . expression DOT IDENTIFIER
    (201) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> . expression LBRACKET expression RBRACKET
    (203) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (7) empty -> .
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (137) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (163) type_name -> . IDENTIFIER
    (164) type_name -> . slice_type
    (165) type_name -> . array_type
    (166) type_name -> . map_type
    (197) array_type -> . LBRACKET INT RBRACKET primitive_type

    LPAREN          shift and go to state 54
    INT             shift and go to state 55
    FLOAT64         shift and go to state 56
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 57
    TRUE            shift and go to state 58
    FALSE           shift and go to state 59
    LNOT            shift and go to state 60
    SEMICOLON       reduce using rule 7 (empty -> .)
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    for_cond                       shift and go to state 307
    expression                     shift and go to state 308
    empty                          shift and go to state 309
    slice_type                     shift and go to state 53
    map_type                       shift and go to state 61
    type_name                      shift and go to state 62
    array_type                     shift and go to state 63

state 284

    (98) for_condition -> FOR expression block .

    RBRACE          reduce using rule 98 (for_condition -> FOR expression block .)
    BREAK           reduce using rule 98 (for_condition -> FOR expression block .)
    CONTINUE        reduce using rule 98 (for_condition -> FOR expression block .)
    VAR             reduce using rule 98 (for_condition -> FOR expression block .)
    CONST           reduce using rule 98 (for_condition -> FOR expression block .)
    IDENTIFIER      reduce using rule 98 (for_condition -> FOR expression block .)
    LPAREN          reduce using rule 98 (for_condition -> FOR expression block .)
    INT             reduce using rule 98 (for_condition -> FOR expression block .)
    FLOAT64         reduce using rule 98 (for_condition -> FOR expression block .)
    STRING          reduce using rule 98 (for_condition -> FOR expression block .)
    TRUE            reduce using rule 98 (for_condition -> FOR expression block .)
    FALSE           reduce using rule 98 (for_condition -> FOR expression block .)
    LNOT            reduce using rule 98 (for_condition -> FOR expression block .)
    IF              reduce using rule 98 (for_condition -> FOR expression block .)
    SWITCH          reduce using rule 98 (for_condition -> FOR expression block .)
    RETURN          reduce using rule 98 (for_condition -> FOR expression block .)
    LBRACKET        reduce using rule 98 (for_condition -> FOR expression block .)
    MAP             reduce using rule 98 (for_condition -> FOR expression block .)
    FOR             reduce using rule 98 (for_condition -> FOR expression block .)
    CASE            reduce using rule 98 (for_condition -> FOR expression block .)
    DEFAULT         reduce using rule 98 (for_condition -> FOR expression block .)


state 285

    (146) method_declaration -> FUNC LPAREN receiver RPAREN IDENTIFIER LPAREN parameter_list RPAREN return_type block .

    VAR             reduce using rule 146 (method_declaration -> FUNC LPAREN receiver RPAREN IDENTIFIER LPAREN parameter_list RPAREN return_type block .)
    CONST           reduce using rule 146 (method_declaration -> FUNC LPAREN receiver RPAREN IDENTIFIER LPAREN parameter_list RPAREN return_type block .)
    FUNC            reduce using rule 146 (method_declaration -> FUNC LPAREN receiver RPAREN IDENTIFIER LPAREN parameter_list RPAREN return_type block .)
    TYPE            reduce using rule 146 (method_declaration -> FUNC LPAREN receiver RPAREN IDENTIFIER LPAREN parameter_list RPAREN return_type block .)
    $end            reduce using rule 146 (method_declaration -> FUNC LPAREN receiver RPAREN IDENTIFIER LPAREN parameter_list RPAREN return_type block .)


state 286

    (21) local_var_dec -> VAR IDENTIFIER type ASSIGN . expression
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (125) expression -> . LNOT expression
    (126) expression -> . IDENTIFIER PLUSPLUS
    (127) expression -> . IDENTIFIER MINUSMINUS
    (138) expression -> . map_type LBRACE expression_map_list RBRACE
    (139) expression -> . map_type LBRACE RBRACE
    (161) expression -> . type_name LBRACE keyed_element_list RBRACE
    (162) expression -> . type_name LBRACE RBRACE
    (198) expression -> . array_type LBRACE expression_list RBRACE
    (199) expression -> . array_type LBRACE RBRACE
    (200) expression -> . expression DOT IDENTIFIER
    (201) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> . expression LBRACKET expression RBRACKET
    (203) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (137) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (163) type_name -> . IDENTIFIER
    (164) type_name -> . slice_type
    (165) type_name -> . array_type
    (166) type_name -> . map_type
    (197) array_type -> . LBRACKET INT RBRACKET primitive_type

    LPAREN          shift and go to state 54
    INT             shift and go to state 55
    FLOAT64         shift and go to state 56
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 57
    TRUE            shift and go to state 58
    FALSE           shift and go to state 59
    LNOT            shift and go to state 60
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    expression                     shift and go to state 310
    slice_type                     shift and go to state 53
    map_type                       shift and go to state 61
    type_name                      shift and go to state 62
    array_type                     shift and go to state 63

state 287

    (22) local_var_dec -> VAR IDENTIFIER ASSIGN expression .
    (36) expression -> expression . binary_operator expression
    (200) expression -> expression . DOT IDENTIFIER
    (201) expression -> expression . DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> expression . LBRACKET expression RBRACKET
    (37) binary_operator -> . PLUS
    (38) binary_operator -> . MINUS
    (39) binary_operator -> . TIMES
    (40) binary_operator -> . DIVIDE
    (41) binary_operator -> . MODULE
    (42) binary_operator -> . EQ
    (43) binary_operator -> . NEQ
    (44) binary_operator -> . LT
    (45) binary_operator -> . LE
    (46) binary_operator -> . GT
    (47) binary_operator -> . GE
    (48) binary_operator -> . LAND
    (49) binary_operator -> . LOR
    (50) binary_operator -> . AND
    (51) binary_operator -> . OR
    (52) binary_operator -> . XOR
    (53) binary_operator -> . AND_NOT
    (54) binary_operator -> . LSHIFT
    (55) binary_operator -> . RSHIFT

  ! shift/reduce conflict for LBRACKET resolved as shift
    RBRACE          reduce using rule 22 (local_var_dec -> VAR IDENTIFIER ASSIGN expression .)
    BREAK           reduce using rule 22 (local_var_dec -> VAR IDENTIFIER ASSIGN expression .)
    CONTINUE        reduce using rule 22 (local_var_dec -> VAR IDENTIFIER ASSIGN expression .)
    VAR             reduce using rule 22 (local_var_dec -> VAR IDENTIFIER ASSIGN expression .)
    CONST           reduce using rule 22 (local_var_dec -> VAR IDENTIFIER ASSIGN expression .)
    IDENTIFIER      reduce using rule 22 (local_var_dec -> VAR IDENTIFIER ASSIGN expression .)
    LPAREN          reduce using rule 22 (local_var_dec -> VAR IDENTIFIER ASSIGN expression .)
    INT             reduce using rule 22 (local_var_dec -> VAR IDENTIFIER ASSIGN expression .)
    FLOAT64         reduce using rule 22 (local_var_dec -> VAR IDENTIFIER ASSIGN expression .)
    STRING          reduce using rule 22 (local_var_dec -> VAR IDENTIFIER ASSIGN expression .)
    TRUE            reduce using rule 22 (local_var_dec -> VAR IDENTIFIER ASSIGN expression .)
    FALSE           reduce using rule 22 (local_var_dec -> VAR IDENTIFIER ASSIGN expression .)
    LNOT            reduce using rule 22 (local_var_dec -> VAR IDENTIFIER ASSIGN expression .)
    IF              reduce using rule 22 (local_var_dec -> VAR IDENTIFIER ASSIGN expression .)
    SWITCH          reduce using rule 22 (local_var_dec -> VAR IDENTIFIER ASSIGN expression .)
    RETURN          reduce using rule 22 (local_var_dec -> VAR IDENTIFIER ASSIGN expression .)
    MAP             reduce using rule 22 (local_var_dec -> VAR IDENTIFIER ASSIGN expression .)
    FOR             reduce using rule 22 (local_var_dec -> VAR IDENTIFIER ASSIGN expression .)
    SEMICOLON       reduce using rule 22 (local_var_dec -> VAR IDENTIFIER ASSIGN expression .)
    CASE            reduce using rule 22 (local_var_dec -> VAR IDENTIFIER ASSIGN expression .)
    DEFAULT         reduce using rule 22 (local_var_dec -> VAR IDENTIFIER ASSIGN expression .)
    DOT             shift and go to state 82
    LBRACKET        shift and go to state 83
    PLUS            shift and go to state 84
    MINUS           shift and go to state 85
    TIMES           shift and go to state 86
    DIVIDE          shift and go to state 87
    MODULE          shift and go to state 88
    EQ              shift and go to state 89
    NEQ             shift and go to state 90
    LT              shift and go to state 91
    LE              shift and go to state 92
    GT              shift and go to state 93
    GE              shift and go to state 94
    LAND            shift and go to state 95
    LOR             shift and go to state 96
    AND             shift and go to state 97
    OR              shift and go to state 98
    XOR             shift and go to state 99
    AND_NOT         shift and go to state 100
    LSHIFT          shift and go to state 101
    RSHIFT          shift and go to state 102

  ! LBRACKET        [ reduce using rule 22 (local_var_dec -> VAR IDENTIFIER ASSIGN expression .) ]

    binary_operator                shift and go to state 81

state 288

    (23) local_const_dec -> CONST IDENTIFIER type ASSIGN . expression
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (125) expression -> . LNOT expression
    (126) expression -> . IDENTIFIER PLUSPLUS
    (127) expression -> . IDENTIFIER MINUSMINUS
    (138) expression -> . map_type LBRACE expression_map_list RBRACE
    (139) expression -> . map_type LBRACE RBRACE
    (161) expression -> . type_name LBRACE keyed_element_list RBRACE
    (162) expression -> . type_name LBRACE RBRACE
    (198) expression -> . array_type LBRACE expression_list RBRACE
    (199) expression -> . array_type LBRACE RBRACE
    (200) expression -> . expression DOT IDENTIFIER
    (201) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> . expression LBRACKET expression RBRACKET
    (203) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (137) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (163) type_name -> . IDENTIFIER
    (164) type_name -> . slice_type
    (165) type_name -> . array_type
    (166) type_name -> . map_type
    (197) array_type -> . LBRACKET INT RBRACKET primitive_type

    LPAREN          shift and go to state 54
    INT             shift and go to state 55
    FLOAT64         shift and go to state 56
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 57
    TRUE            shift and go to state 58
    FALSE           shift and go to state 59
    LNOT            shift and go to state 60
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    expression                     shift and go to state 311
    slice_type                     shift and go to state 53
    map_type                       shift and go to state 61
    type_name                      shift and go to state 62
    array_type                     shift and go to state 63

state 289

    (24) local_const_dec -> CONST IDENTIFIER ASSIGN expression .
    (36) expression -> expression . binary_operator expression
    (200) expression -> expression . DOT IDENTIFIER
    (201) expression -> expression . DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> expression . LBRACKET expression RBRACKET
    (37) binary_operator -> . PLUS
    (38) binary_operator -> . MINUS
    (39) binary_operator -> . TIMES
    (40) binary_operator -> . DIVIDE
    (41) binary_operator -> . MODULE
    (42) binary_operator -> . EQ
    (43) binary_operator -> . NEQ
    (44) binary_operator -> . LT
    (45) binary_operator -> . LE
    (46) binary_operator -> . GT
    (47) binary_operator -> . GE
    (48) binary_operator -> . LAND
    (49) binary_operator -> . LOR
    (50) binary_operator -> . AND
    (51) binary_operator -> . OR
    (52) binary_operator -> . XOR
    (53) binary_operator -> . AND_NOT
    (54) binary_operator -> . LSHIFT
    (55) binary_operator -> . RSHIFT

  ! shift/reduce conflict for LBRACKET resolved as shift
    RBRACE          reduce using rule 24 (local_const_dec -> CONST IDENTIFIER ASSIGN expression .)
    BREAK           reduce using rule 24 (local_const_dec -> CONST IDENTIFIER ASSIGN expression .)
    CONTINUE        reduce using rule 24 (local_const_dec -> CONST IDENTIFIER ASSIGN expression .)
    VAR             reduce using rule 24 (local_const_dec -> CONST IDENTIFIER ASSIGN expression .)
    CONST           reduce using rule 24 (local_const_dec -> CONST IDENTIFIER ASSIGN expression .)
    IDENTIFIER      reduce using rule 24 (local_const_dec -> CONST IDENTIFIER ASSIGN expression .)
    LPAREN          reduce using rule 24 (local_const_dec -> CONST IDENTIFIER ASSIGN expression .)
    INT             reduce using rule 24 (local_const_dec -> CONST IDENTIFIER ASSIGN expression .)
    FLOAT64         reduce using rule 24 (local_const_dec -> CONST IDENTIFIER ASSIGN expression .)
    STRING          reduce using rule 24 (local_const_dec -> CONST IDENTIFIER ASSIGN expression .)
    TRUE            reduce using rule 24 (local_const_dec -> CONST IDENTIFIER ASSIGN expression .)
    FALSE           reduce using rule 24 (local_const_dec -> CONST IDENTIFIER ASSIGN expression .)
    LNOT            reduce using rule 24 (local_const_dec -> CONST IDENTIFIER ASSIGN expression .)
    IF              reduce using rule 24 (local_const_dec -> CONST IDENTIFIER ASSIGN expression .)
    SWITCH          reduce using rule 24 (local_const_dec -> CONST IDENTIFIER ASSIGN expression .)
    RETURN          reduce using rule 24 (local_const_dec -> CONST IDENTIFIER ASSIGN expression .)
    MAP             reduce using rule 24 (local_const_dec -> CONST IDENTIFIER ASSIGN expression .)
    FOR             reduce using rule 24 (local_const_dec -> CONST IDENTIFIER ASSIGN expression .)
    CASE            reduce using rule 24 (local_const_dec -> CONST IDENTIFIER ASSIGN expression .)
    DEFAULT         reduce using rule 24 (local_const_dec -> CONST IDENTIFIER ASSIGN expression .)
    DOT             shift and go to state 82
    LBRACKET        shift and go to state 83
    PLUS            shift and go to state 84
    MINUS           shift and go to state 85
    TIMES           shift and go to state 86
    DIVIDE          shift and go to state 87
    MODULE          shift and go to state 88
    EQ              shift and go to state 89
    NEQ             shift and go to state 90
    LT              shift and go to state 91
    LE              shift and go to state 92
    GT              shift and go to state 93
    GE              shift and go to state 94
    LAND            shift and go to state 95
    LOR             shift and go to state 96
    AND             shift and go to state 97
    OR              shift and go to state 98
    XOR             shift and go to state 99
    AND_NOT         shift and go to state 100
    LSHIFT          shift and go to state 101
    RSHIFT          shift and go to state 102

  ! LBRACKET        [ reduce using rule 24 (local_const_dec -> CONST IDENTIFIER ASSIGN expression .) ]

    binary_operator                shift and go to state 81

state 290

    (129) if_statement -> IF expression block ELSE . block
    (130) if_statement -> IF expression block ELSE . if_statement
    (90) block -> . LBRACE local_statement_list RBRACE
    (91) block -> . LBRACE RBRACE
    (128) if_statement -> . IF expression block
    (129) if_statement -> . IF expression block ELSE block
    (130) if_statement -> . IF expression block ELSE if_statement
    (131) if_statement -> . IF if_assignment SEMICOLON expression block
    (132) if_statement -> . IF if_assignment SEMICOLON expression block ELSE block
    (133) if_statement -> . IF if_assignment SEMICOLON expression block ELSE if_statement

    LBRACE          shift and go to state 175
    IF              shift and go to state 207

    block                          shift and go to state 312
    if_statement                   shift and go to state 313

state 291

    (131) if_statement -> IF if_assignment SEMICOLON expression . block
    (132) if_statement -> IF if_assignment SEMICOLON expression . block ELSE block
    (133) if_statement -> IF if_assignment SEMICOLON expression . block ELSE if_statement
    (36) expression -> expression . binary_operator expression
    (200) expression -> expression . DOT IDENTIFIER
    (201) expression -> expression . DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> expression . LBRACKET expression RBRACKET
    (90) block -> . LBRACE local_statement_list RBRACE
    (91) block -> . LBRACE RBRACE
    (37) binary_operator -> . PLUS
    (38) binary_operator -> . MINUS
    (39) binary_operator -> . TIMES
    (40) binary_operator -> . DIVIDE
    (41) binary_operator -> . MODULE
    (42) binary_operator -> . EQ
    (43) binary_operator -> . NEQ
    (44) binary_operator -> . LT
    (45) binary_operator -> . LE
    (46) binary_operator -> . GT
    (47) binary_operator -> . GE
    (48) binary_operator -> . LAND
    (49) binary_operator -> . LOR
    (50) binary_operator -> . AND
    (51) binary_operator -> . OR
    (52) binary_operator -> . XOR
    (53) binary_operator -> . AND_NOT
    (54) binary_operator -> . LSHIFT
    (55) binary_operator -> . RSHIFT

    DOT             shift and go to state 82
    LBRACKET        shift and go to state 83
    LBRACE          shift and go to state 175
    PLUS            shift and go to state 84
    MINUS           shift and go to state 85
    TIMES           shift and go to state 86
    DIVIDE          shift and go to state 87
    MODULE          shift and go to state 88
    EQ              shift and go to state 89
    NEQ             shift and go to state 90
    LT              shift and go to state 91
    LE              shift and go to state 92
    GT              shift and go to state 93
    GE              shift and go to state 94
    LAND            shift and go to state 95
    LOR             shift and go to state 96
    AND             shift and go to state 97
    OR              shift and go to state 98
    XOR             shift and go to state 99
    AND_NOT         shift and go to state 100
    LSHIFT          shift and go to state 101
    RSHIFT          shift and go to state 102

    block                          shift and go to state 314
    binary_operator                shift and go to state 81

state 292

    (167) switch_statement -> SWITCH switch_expr LBRACE case_clause_list . RBRACE
    (187) case_clause_list -> case_clause_list . case_clause
    (191) case_clause -> . CASE case_expression_list COLON case_body
    (192) case_clause -> . DEFAULT COLON case_body

    RBRACE          shift and go to state 315
    CASE            shift and go to state 275
    DEFAULT         shift and go to state 276

    case_clause                    shift and go to state 295

state 293

    (168) switch_statement -> SWITCH switch_expr LBRACE RBRACE .

    RBRACE          reduce using rule 168 (switch_statement -> SWITCH switch_expr LBRACE RBRACE .)
    BREAK           reduce using rule 168 (switch_statement -> SWITCH switch_expr LBRACE RBRACE .)
    CONTINUE        reduce using rule 168 (switch_statement -> SWITCH switch_expr LBRACE RBRACE .)
    VAR             reduce using rule 168 (switch_statement -> SWITCH switch_expr LBRACE RBRACE .)
    CONST           reduce using rule 168 (switch_statement -> SWITCH switch_expr LBRACE RBRACE .)
    IDENTIFIER      reduce using rule 168 (switch_statement -> SWITCH switch_expr LBRACE RBRACE .)
    LPAREN          reduce using rule 168 (switch_statement -> SWITCH switch_expr LBRACE RBRACE .)
    INT             reduce using rule 168 (switch_statement -> SWITCH switch_expr LBRACE RBRACE .)
    FLOAT64         reduce using rule 168 (switch_statement -> SWITCH switch_expr LBRACE RBRACE .)
    STRING          reduce using rule 168 (switch_statement -> SWITCH switch_expr LBRACE RBRACE .)
    TRUE            reduce using rule 168 (switch_statement -> SWITCH switch_expr LBRACE RBRACE .)
    FALSE           reduce using rule 168 (switch_statement -> SWITCH switch_expr LBRACE RBRACE .)
    LNOT            reduce using rule 168 (switch_statement -> SWITCH switch_expr LBRACE RBRACE .)
    IF              reduce using rule 168 (switch_statement -> SWITCH switch_expr LBRACE RBRACE .)
    SWITCH          reduce using rule 168 (switch_statement -> SWITCH switch_expr LBRACE RBRACE .)
    RETURN          reduce using rule 168 (switch_statement -> SWITCH switch_expr LBRACE RBRACE .)
    LBRACKET        reduce using rule 168 (switch_statement -> SWITCH switch_expr LBRACE RBRACE .)
    MAP             reduce using rule 168 (switch_statement -> SWITCH switch_expr LBRACE RBRACE .)
    FOR             reduce using rule 168 (switch_statement -> SWITCH switch_expr LBRACE RBRACE .)
    CASE            reduce using rule 168 (switch_statement -> SWITCH switch_expr LBRACE RBRACE .)
    DEFAULT         reduce using rule 168 (switch_statement -> SWITCH switch_expr LBRACE RBRACE .)


state 294

    (169) switch_statement -> SWITCH LBRACE case_clause_list RBRACE .

    RBRACE          reduce using rule 169 (switch_statement -> SWITCH LBRACE case_clause_list RBRACE .)
    BREAK           reduce using rule 169 (switch_statement -> SWITCH LBRACE case_clause_list RBRACE .)
    CONTINUE        reduce using rule 169 (switch_statement -> SWITCH LBRACE case_clause_list RBRACE .)
    VAR             reduce using rule 169 (switch_statement -> SWITCH LBRACE case_clause_list RBRACE .)
    CONST           reduce using rule 169 (switch_statement -> SWITCH LBRACE case_clause_list RBRACE .)
    IDENTIFIER      reduce using rule 169 (switch_statement -> SWITCH LBRACE case_clause_list RBRACE .)
    LPAREN          reduce using rule 169 (switch_statement -> SWITCH LBRACE case_clause_list RBRACE .)
    INT             reduce using rule 169 (switch_statement -> SWITCH LBRACE case_clause_list RBRACE .)
    FLOAT64         reduce using rule 169 (switch_statement -> SWITCH LBRACE case_clause_list RBRACE .)
    STRING          reduce using rule 169 (switch_statement -> SWITCH LBRACE case_clause_list RBRACE .)
    TRUE            reduce using rule 169 (switch_statement -> SWITCH LBRACE case_clause_list RBRACE .)
    FALSE           reduce using rule 169 (switch_statement -> SWITCH LBRACE case_clause_list RBRACE .)
    LNOT            reduce using rule 169 (switch_statement -> SWITCH LBRACE case_clause_list RBRACE .)
    IF              reduce using rule 169 (switch_statement -> SWITCH LBRACE case_clause_list RBRACE .)
    SWITCH          reduce using rule 169 (switch_statement -> SWITCH LBRACE case_clause_list RBRACE .)
    RETURN          reduce using rule 169 (switch_statement -> SWITCH LBRACE case_clause_list RBRACE .)
    LBRACKET        reduce using rule 169 (switch_statement -> SWITCH LBRACE case_clause_list RBRACE .)
    MAP             reduce using rule 169 (switch_statement -> SWITCH LBRACE case_clause_list RBRACE .)
    FOR             reduce using rule 169 (switch_statement -> SWITCH LBRACE case_clause_list RBRACE .)
    CASE            reduce using rule 169 (switch_statement -> SWITCH LBRACE case_clause_list RBRACE .)
    DEFAULT         reduce using rule 169 (switch_statement -> SWITCH LBRACE case_clause_list RBRACE .)


state 295

    (187) case_clause_list -> case_clause_list case_clause .

    RBRACE          reduce using rule 187 (case_clause_list -> case_clause_list case_clause .)
    CASE            reduce using rule 187 (case_clause_list -> case_clause_list case_clause .)
    DEFAULT         reduce using rule 187 (case_clause_list -> case_clause_list case_clause .)


state 296

    (191) case_clause -> CASE case_expression_list . COLON case_body
    (194) case_expression_list -> case_expression_list . COMMA expression

    COLON           shift and go to state 316
    COMMA           shift and go to state 317


state 297

    (193) case_expression_list -> expression .
    (36) expression -> expression . binary_operator expression
    (200) expression -> expression . DOT IDENTIFIER
    (201) expression -> expression . DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> expression . LBRACKET expression RBRACKET
    (37) binary_operator -> . PLUS
    (38) binary_operator -> . MINUS
    (39) binary_operator -> . TIMES
    (40) binary_operator -> . DIVIDE
    (41) binary_operator -> . MODULE
    (42) binary_operator -> . EQ
    (43) binary_operator -> . NEQ
    (44) binary_operator -> . LT
    (45) binary_operator -> . LE
    (46) binary_operator -> . GT
    (47) binary_operator -> . GE
    (48) binary_operator -> . LAND
    (49) binary_operator -> . LOR
    (50) binary_operator -> . AND
    (51) binary_operator -> . OR
    (52) binary_operator -> . XOR
    (53) binary_operator -> . AND_NOT
    (54) binary_operator -> . LSHIFT
    (55) binary_operator -> . RSHIFT

    COLON           reduce using rule 193 (case_expression_list -> expression .)
    COMMA           reduce using rule 193 (case_expression_list -> expression .)
    DOT             shift and go to state 82
    LBRACKET        shift and go to state 83
    PLUS            shift and go to state 84
    MINUS           shift and go to state 85
    TIMES           shift and go to state 86
    DIVIDE          shift and go to state 87
    MODULE          shift and go to state 88
    EQ              shift and go to state 89
    NEQ             shift and go to state 90
    LT              shift and go to state 91
    LE              shift and go to state 92
    GT              shift and go to state 93
    GE              shift and go to state 94
    LAND            shift and go to state 95
    LOR             shift and go to state 96
    AND             shift and go to state 97
    OR              shift and go to state 98
    XOR             shift and go to state 99
    AND_NOT         shift and go to state 100
    LSHIFT          shift and go to state 101
    RSHIFT          shift and go to state 102

    binary_operator                shift and go to state 81

state 298

    (192) case_clause -> DEFAULT COLON . case_body
    (195) case_body -> . local_statement_list
    (196) case_body -> . empty
    (92) local_statement_list -> . local_statement
    (93) local_statement_list -> . local_statement_list local_statement
    (7) empty -> .
    (78) local_statement -> . local_var_dec
    (79) local_statement -> . local_const_dec
    (80) local_statement -> . short_assignment
    (81) local_statement -> . simple_assignment
    (82) local_statement -> . assignment_compound
    (83) local_statement -> . expression
    (84) local_statement -> . for_statement
    (85) local_statement -> . if_statement
    (86) local_statement -> . switch_statement
    (87) local_statement -> . return_statement
    (88) local_statement -> . BREAK
    (89) local_statement -> . CONTINUE
    (20) local_var_dec -> . VAR IDENTIFIER type
    (21) local_var_dec -> . VAR IDENTIFIER type ASSIGN expression
    (22) local_var_dec -> . VAR IDENTIFIER ASSIGN expression
    (23) local_const_dec -> . CONST IDENTIFIER type ASSIGN expression
    (24) local_const_dec -> . CONST IDENTIFIER ASSIGN expression
    (77) short_assignment -> . IDENTIFIER SHORT_ASSIGN expression
    (56) simple_assignment -> . IDENTIFIER ASSIGN expression
    (25) assignment_compound -> . IDENTIFIER operator_assign expression
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (125) expression -> . LNOT expression
    (126) expression -> . IDENTIFIER PLUSPLUS
    (127) expression -> . IDENTIFIER MINUSMINUS
    (138) expression -> . map_type LBRACE expression_map_list RBRACE
    (139) expression -> . map_type LBRACE RBRACE
    (161) expression -> . type_name LBRACE keyed_element_list RBRACE
    (162) expression -> . type_name LBRACE RBRACE
    (198) expression -> . array_type LBRACE expression_list RBRACE
    (199) expression -> . array_type LBRACE RBRACE
    (200) expression -> . expression DOT IDENTIFIER
    (201) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> . expression LBRACKET expression RBRACKET
    (203) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (94) for_statement -> . for_classic
    (95) for_statement -> . for_condition
    (96) for_statement -> . for_infinite
    (128) if_statement -> . IF expression block
    (129) if_statement -> . IF expression block ELSE block
    (130) if_statement -> . IF expression block ELSE if_statement
    (131) if_statement -> . IF if_assignment SEMICOLON expression block
    (132) if_statement -> . IF if_assignment SEMICOLON expression block ELSE block
    (133) if_statement -> . IF if_assignment SEMICOLON expression block ELSE if_statement
    (167) switch_statement -> . SWITCH switch_expr LBRACE case_clause_list RBRACE
    (168) switch_statement -> . SWITCH switch_expr LBRACE RBRACE
    (169) switch_statement -> . SWITCH LBRACE case_clause_list RBRACE
    (170) switch_statement -> . SWITCH LBRACE RBRACE
    (171) switch_statement -> . SWITCH switch_assignment SEMICOLON switch_expr LBRACE case_clause_list RBRACE
    (172) switch_statement -> . SWITCH switch_assignment SEMICOLON switch_expr LBRACE RBRACE
    (173) switch_statement -> . SWITCH switch_assignment SEMICOLON LBRACE case_clause_list RBRACE
    (174) switch_statement -> . SWITCH switch_assignment SEMICOLON LBRACE RBRACE
    (123) return_statement -> . RETURN
    (124) return_statement -> . RETURN return_list
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (137) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (163) type_name -> . IDENTIFIER
    (164) type_name -> . slice_type
    (165) type_name -> . array_type
    (166) type_name -> . map_type
    (197) array_type -> . LBRACKET INT RBRACKET primitive_type
    (97) for_classic -> . FOR for_init SEMICOLON for_cond SEMICOLON for_post block
    (98) for_condition -> . FOR expression block
    (99) for_infinite -> . FOR block

    RBRACE          reduce using rule 7 (empty -> .)
    CASE            reduce using rule 7 (empty -> .)
    DEFAULT         reduce using rule 7 (empty -> .)
    BREAK           shift and go to state 199
    CONTINUE        shift and go to state 200
    VAR             shift and go to state 201
    CONST           shift and go to state 203
    IDENTIFIER      shift and go to state 202
    LPAREN          shift and go to state 54
    INT             shift and go to state 55
    FLOAT64         shift and go to state 56
    STRING          shift and go to state 57
    TRUE            shift and go to state 58
    FALSE           shift and go to state 59
    LNOT            shift and go to state 60
    IF              shift and go to state 207
    SWITCH          shift and go to state 208
    RETURN          shift and go to state 209
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39
    FOR             shift and go to state 210

    case_body                      shift and go to state 318
    local_statement_list           shift and go to state 319
    empty                          shift and go to state 320
    local_statement                shift and go to state 188
    local_var_dec                  shift and go to state 189
    local_const_dec                shift and go to state 190
    short_assignment               shift and go to state 191
    simple_assignment              shift and go to state 192
    assignment_compound            shift and go to state 193
    expression                     shift and go to state 194
    for_statement                  shift and go to state 195
    if_statement                   shift and go to state 196
    switch_statement               shift and go to state 197
    return_statement               shift and go to state 198
    slice_type                     shift and go to state 53
    map_type                       shift and go to state 61
    type_name                      shift and go to state 62
    array_type                     shift and go to state 63
    for_classic                    shift and go to state 204
    for_condition                  shift and go to state 205
    for_infinite                   shift and go to state 206

state 299

    (171) switch_statement -> SWITCH switch_assignment SEMICOLON switch_expr . LBRACE case_clause_list RBRACE
    (172) switch_statement -> SWITCH switch_assignment SEMICOLON switch_expr . LBRACE RBRACE

    LBRACE          shift and go to state 321


state 300

    (173) switch_statement -> SWITCH switch_assignment SEMICOLON LBRACE . case_clause_list RBRACE
    (174) switch_statement -> SWITCH switch_assignment SEMICOLON LBRACE . RBRACE
    (186) case_clause_list -> . case_clause
    (187) case_clause_list -> . case_clause_list case_clause
    (191) case_clause -> . CASE case_expression_list COLON case_body
    (192) case_clause -> . DEFAULT COLON case_body

    RBRACE          shift and go to state 323
    CASE            shift and go to state 275
    DEFAULT         shift and go to state 276

    case_clause_list               shift and go to state 322
    case_clause                    shift and go to state 274

state 301

    (176) primary_expression -> IDENTIFIER .
    (183) primary_expression -> IDENTIFIER . LPAREN argument_list RPAREN

    DOT             reduce using rule 176 (primary_expression -> IDENTIFIER .)
    LBRACKET        reduce using rule 176 (primary_expression -> IDENTIFIER .)
    LBRACE          reduce using rule 176 (primary_expression -> IDENTIFIER .)
    LPAREN          shift and go to state 280


state 302

    (184) primary_expression -> primary_expression DOT IDENTIFIER .

    DOT             reduce using rule 184 (primary_expression -> primary_expression DOT IDENTIFIER .)
    LBRACKET        reduce using rule 184 (primary_expression -> primary_expression DOT IDENTIFIER .)
    LBRACE          reduce using rule 184 (primary_expression -> primary_expression DOT IDENTIFIER .)


state 303

    (185) primary_expression -> primary_expression LBRACKET expression . RBRACKET
    (36) expression -> expression . binary_operator expression
    (200) expression -> expression . DOT IDENTIFIER
    (201) expression -> expression . DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> expression . LBRACKET expression RBRACKET
    (37) binary_operator -> . PLUS
    (38) binary_operator -> . MINUS
    (39) binary_operator -> . TIMES
    (40) binary_operator -> . DIVIDE
    (41) binary_operator -> . MODULE
    (42) binary_operator -> . EQ
    (43) binary_operator -> . NEQ
    (44) binary_operator -> . LT
    (45) binary_operator -> . LE
    (46) binary_operator -> . GT
    (47) binary_operator -> . GE
    (48) binary_operator -> . LAND
    (49) binary_operator -> . LOR
    (50) binary_operator -> . AND
    (51) binary_operator -> . OR
    (52) binary_operator -> . XOR
    (53) binary_operator -> . AND_NOT
    (54) binary_operator -> . LSHIFT
    (55) binary_operator -> . RSHIFT

    RBRACKET        shift and go to state 324
    DOT             shift and go to state 82
    LBRACKET        shift and go to state 83
    PLUS            shift and go to state 84
    MINUS           shift and go to state 85
    TIMES           shift and go to state 86
    DIVIDE          shift and go to state 87
    MODULE          shift and go to state 88
    EQ              shift and go to state 89
    NEQ             shift and go to state 90
    LT              shift and go to state 91
    LE              shift and go to state 92
    GT              shift and go to state 93
    GE              shift and go to state 94
    LAND            shift and go to state 95
    LOR             shift and go to state 96
    AND             shift and go to state 97
    OR              shift and go to state 98
    XOR             shift and go to state 99
    AND_NOT         shift and go to state 100
    LSHIFT          shift and go to state 101
    RSHIFT          shift and go to state 102

    binary_operator                shift and go to state 81

state 304

    (183) primary_expression -> IDENTIFIER LPAREN argument_list . RPAREN

    RPAREN          shift and go to state 325


state 305

    (182) primary_expression -> LPAREN expression RPAREN .

    DOT             reduce using rule 182 (primary_expression -> LPAREN expression RPAREN .)
    LBRACKET        reduce using rule 182 (primary_expression -> LPAREN expression RPAREN .)
    LBRACE          reduce using rule 182 (primary_expression -> LPAREN expression RPAREN .)


state 306

    (111) return_list -> return_list COMMA expression .
    (36) expression -> expression . binary_operator expression
    (200) expression -> expression . DOT IDENTIFIER
    (201) expression -> expression . DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> expression . LBRACKET expression RBRACKET
    (37) binary_operator -> . PLUS
    (38) binary_operator -> . MINUS
    (39) binary_operator -> . TIMES
    (40) binary_operator -> . DIVIDE
    (41) binary_operator -> . MODULE
    (42) binary_operator -> . EQ
    (43) binary_operator -> . NEQ
    (44) binary_operator -> . LT
    (45) binary_operator -> . LE
    (46) binary_operator -> . GT
    (47) binary_operator -> . GE
    (48) binary_operator -> . LAND
    (49) binary_operator -> . LOR
    (50) binary_operator -> . AND
    (51) binary_operator -> . OR
    (52) binary_operator -> . XOR
    (53) binary_operator -> . AND_NOT
    (54) binary_operator -> . LSHIFT
    (55) binary_operator -> . RSHIFT

  ! shift/reduce conflict for LBRACKET resolved as shift
    COMMA           reduce using rule 111 (return_list -> return_list COMMA expression .)
    RBRACE          reduce using rule 111 (return_list -> return_list COMMA expression .)
    BREAK           reduce using rule 111 (return_list -> return_list COMMA expression .)
    CONTINUE        reduce using rule 111 (return_list -> return_list COMMA expression .)
    VAR             reduce using rule 111 (return_list -> return_list COMMA expression .)
    CONST           reduce using rule 111 (return_list -> return_list COMMA expression .)
    IDENTIFIER      reduce using rule 111 (return_list -> return_list COMMA expression .)
    LPAREN          reduce using rule 111 (return_list -> return_list COMMA expression .)
    INT             reduce using rule 111 (return_list -> return_list COMMA expression .)
    FLOAT64         reduce using rule 111 (return_list -> return_list COMMA expression .)
    STRING          reduce using rule 111 (return_list -> return_list COMMA expression .)
    TRUE            reduce using rule 111 (return_list -> return_list COMMA expression .)
    FALSE           reduce using rule 111 (return_list -> return_list COMMA expression .)
    LNOT            reduce using rule 111 (return_list -> return_list COMMA expression .)
    IF              reduce using rule 111 (return_list -> return_list COMMA expression .)
    SWITCH          reduce using rule 111 (return_list -> return_list COMMA expression .)
    RETURN          reduce using rule 111 (return_list -> return_list COMMA expression .)
    MAP             reduce using rule 111 (return_list -> return_list COMMA expression .)
    FOR             reduce using rule 111 (return_list -> return_list COMMA expression .)
    CASE            reduce using rule 111 (return_list -> return_list COMMA expression .)
    DEFAULT         reduce using rule 111 (return_list -> return_list COMMA expression .)
    DOT             shift and go to state 82
    LBRACKET        shift and go to state 83
    PLUS            shift and go to state 84
    MINUS           shift and go to state 85
    TIMES           shift and go to state 86
    DIVIDE          shift and go to state 87
    MODULE          shift and go to state 88
    EQ              shift and go to state 89
    NEQ             shift and go to state 90
    LT              shift and go to state 91
    LE              shift and go to state 92
    GT              shift and go to state 93
    GE              shift and go to state 94
    LAND            shift and go to state 95
    LOR             shift and go to state 96
    AND             shift and go to state 97
    OR              shift and go to state 98
    XOR             shift and go to state 99
    AND_NOT         shift and go to state 100
    LSHIFT          shift and go to state 101
    RSHIFT          shift and go to state 102

  ! LBRACKET        [ reduce using rule 111 (return_list -> return_list COMMA expression .) ]

    binary_operator                shift and go to state 81

state 307

    (97) for_classic -> FOR for_init SEMICOLON for_cond . SEMICOLON for_post block

    SEMICOLON       shift and go to state 326


state 308

    (104) for_cond -> expression .
    (36) expression -> expression . binary_operator expression
    (200) expression -> expression . DOT IDENTIFIER
    (201) expression -> expression . DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> expression . LBRACKET expression RBRACKET
    (37) binary_operator -> . PLUS
    (38) binary_operator -> . MINUS
    (39) binary_operator -> . TIMES
    (40) binary_operator -> . DIVIDE
    (41) binary_operator -> . MODULE
    (42) binary_operator -> . EQ
    (43) binary_operator -> . NEQ
    (44) binary_operator -> . LT
    (45) binary_operator -> . LE
    (46) binary_operator -> . GT
    (47) binary_operator -> . GE
    (48) binary_operator -> . LAND
    (49) binary_operator -> . LOR
    (50) binary_operator -> . AND
    (51) binary_operator -> . OR
    (52) binary_operator -> . XOR
    (53) binary_operator -> . AND_NOT
    (54) binary_operator -> . LSHIFT
    (55) binary_operator -> . RSHIFT

    SEMICOLON       reduce using rule 104 (for_cond -> expression .)
    DOT             shift and go to state 82
    LBRACKET        shift and go to state 83
    PLUS            shift and go to state 84
    MINUS           shift and go to state 85
    TIMES           shift and go to state 86
    DIVIDE          shift and go to state 87
    MODULE          shift and go to state 88
    EQ              shift and go to state 89
    NEQ             shift and go to state 90
    LT              shift and go to state 91
    LE              shift and go to state 92
    GT              shift and go to state 93
    GE              shift and go to state 94
    LAND            shift and go to state 95
    LOR             shift and go to state 96
    AND             shift and go to state 97
    OR              shift and go to state 98
    XOR             shift and go to state 99
    AND_NOT         shift and go to state 100
    LSHIFT          shift and go to state 101
    RSHIFT          shift and go to state 102

    binary_operator                shift and go to state 81

state 309

    (105) for_cond -> empty .

    SEMICOLON       reduce using rule 105 (for_cond -> empty .)


state 310

    (21) local_var_dec -> VAR IDENTIFIER type ASSIGN expression .
    (36) expression -> expression . binary_operator expression
    (200) expression -> expression . DOT IDENTIFIER
    (201) expression -> expression . DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> expression . LBRACKET expression RBRACKET
    (37) binary_operator -> . PLUS
    (38) binary_operator -> . MINUS
    (39) binary_operator -> . TIMES
    (40) binary_operator -> . DIVIDE
    (41) binary_operator -> . MODULE
    (42) binary_operator -> . EQ
    (43) binary_operator -> . NEQ
    (44) binary_operator -> . LT
    (45) binary_operator -> . LE
    (46) binary_operator -> . GT
    (47) binary_operator -> . GE
    (48) binary_operator -> . LAND
    (49) binary_operator -> . LOR
    (50) binary_operator -> . AND
    (51) binary_operator -> . OR
    (52) binary_operator -> . XOR
    (53) binary_operator -> . AND_NOT
    (54) binary_operator -> . LSHIFT
    (55) binary_operator -> . RSHIFT

  ! shift/reduce conflict for LBRACKET resolved as shift
    RBRACE          reduce using rule 21 (local_var_dec -> VAR IDENTIFIER type ASSIGN expression .)
    BREAK           reduce using rule 21 (local_var_dec -> VAR IDENTIFIER type ASSIGN expression .)
    CONTINUE        reduce using rule 21 (local_var_dec -> VAR IDENTIFIER type ASSIGN expression .)
    VAR             reduce using rule 21 (local_var_dec -> VAR IDENTIFIER type ASSIGN expression .)
    CONST           reduce using rule 21 (local_var_dec -> VAR IDENTIFIER type ASSIGN expression .)
    IDENTIFIER      reduce using rule 21 (local_var_dec -> VAR IDENTIFIER type ASSIGN expression .)
    LPAREN          reduce using rule 21 (local_var_dec -> VAR IDENTIFIER type ASSIGN expression .)
    INT             reduce using rule 21 (local_var_dec -> VAR IDENTIFIER type ASSIGN expression .)
    FLOAT64         reduce using rule 21 (local_var_dec -> VAR IDENTIFIER type ASSIGN expression .)
    STRING          reduce using rule 21 (local_var_dec -> VAR IDENTIFIER type ASSIGN expression .)
    TRUE            reduce using rule 21 (local_var_dec -> VAR IDENTIFIER type ASSIGN expression .)
    FALSE           reduce using rule 21 (local_var_dec -> VAR IDENTIFIER type ASSIGN expression .)
    LNOT            reduce using rule 21 (local_var_dec -> VAR IDENTIFIER type ASSIGN expression .)
    IF              reduce using rule 21 (local_var_dec -> VAR IDENTIFIER type ASSIGN expression .)
    SWITCH          reduce using rule 21 (local_var_dec -> VAR IDENTIFIER type ASSIGN expression .)
    RETURN          reduce using rule 21 (local_var_dec -> VAR IDENTIFIER type ASSIGN expression .)
    MAP             reduce using rule 21 (local_var_dec -> VAR IDENTIFIER type ASSIGN expression .)
    FOR             reduce using rule 21 (local_var_dec -> VAR IDENTIFIER type ASSIGN expression .)
    SEMICOLON       reduce using rule 21 (local_var_dec -> VAR IDENTIFIER type ASSIGN expression .)
    CASE            reduce using rule 21 (local_var_dec -> VAR IDENTIFIER type ASSIGN expression .)
    DEFAULT         reduce using rule 21 (local_var_dec -> VAR IDENTIFIER type ASSIGN expression .)
    DOT             shift and go to state 82
    LBRACKET        shift and go to state 83
    PLUS            shift and go to state 84
    MINUS           shift and go to state 85
    TIMES           shift and go to state 86
    DIVIDE          shift and go to state 87
    MODULE          shift and go to state 88
    EQ              shift and go to state 89
    NEQ             shift and go to state 90
    LT              shift and go to state 91
    LE              shift and go to state 92
    GT              shift and go to state 93
    GE              shift and go to state 94
    LAND            shift and go to state 95
    LOR             shift and go to state 96
    AND             shift and go to state 97
    OR              shift and go to state 98
    XOR             shift and go to state 99
    AND_NOT         shift and go to state 100
    LSHIFT          shift and go to state 101
    RSHIFT          shift and go to state 102

  ! LBRACKET        [ reduce using rule 21 (local_var_dec -> VAR IDENTIFIER type ASSIGN expression .) ]

    binary_operator                shift and go to state 81

state 311

    (23) local_const_dec -> CONST IDENTIFIER type ASSIGN expression .
    (36) expression -> expression . binary_operator expression
    (200) expression -> expression . DOT IDENTIFIER
    (201) expression -> expression . DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> expression . LBRACKET expression RBRACKET
    (37) binary_operator -> . PLUS
    (38) binary_operator -> . MINUS
    (39) binary_operator -> . TIMES
    (40) binary_operator -> . DIVIDE
    (41) binary_operator -> . MODULE
    (42) binary_operator -> . EQ
    (43) binary_operator -> . NEQ
    (44) binary_operator -> . LT
    (45) binary_operator -> . LE
    (46) binary_operator -> . GT
    (47) binary_operator -> . GE
    (48) binary_operator -> . LAND
    (49) binary_operator -> . LOR
    (50) binary_operator -> . AND
    (51) binary_operator -> . OR
    (52) binary_operator -> . XOR
    (53) binary_operator -> . AND_NOT
    (54) binary_operator -> . LSHIFT
    (55) binary_operator -> . RSHIFT

  ! shift/reduce conflict for LBRACKET resolved as shift
    RBRACE          reduce using rule 23 (local_const_dec -> CONST IDENTIFIER type ASSIGN expression .)
    BREAK           reduce using rule 23 (local_const_dec -> CONST IDENTIFIER type ASSIGN expression .)
    CONTINUE        reduce using rule 23 (local_const_dec -> CONST IDENTIFIER type ASSIGN expression .)
    VAR             reduce using rule 23 (local_const_dec -> CONST IDENTIFIER type ASSIGN expression .)
    CONST           reduce using rule 23 (local_const_dec -> CONST IDENTIFIER type ASSIGN expression .)
    IDENTIFIER      reduce using rule 23 (local_const_dec -> CONST IDENTIFIER type ASSIGN expression .)
    LPAREN          reduce using rule 23 (local_const_dec -> CONST IDENTIFIER type ASSIGN expression .)
    INT             reduce using rule 23 (local_const_dec -> CONST IDENTIFIER type ASSIGN expression .)
    FLOAT64         reduce using rule 23 (local_const_dec -> CONST IDENTIFIER type ASSIGN expression .)
    STRING          reduce using rule 23 (local_const_dec -> CONST IDENTIFIER type ASSIGN expression .)
    TRUE            reduce using rule 23 (local_const_dec -> CONST IDENTIFIER type ASSIGN expression .)
    FALSE           reduce using rule 23 (local_const_dec -> CONST IDENTIFIER type ASSIGN expression .)
    LNOT            reduce using rule 23 (local_const_dec -> CONST IDENTIFIER type ASSIGN expression .)
    IF              reduce using rule 23 (local_const_dec -> CONST IDENTIFIER type ASSIGN expression .)
    SWITCH          reduce using rule 23 (local_const_dec -> CONST IDENTIFIER type ASSIGN expression .)
    RETURN          reduce using rule 23 (local_const_dec -> CONST IDENTIFIER type ASSIGN expression .)
    MAP             reduce using rule 23 (local_const_dec -> CONST IDENTIFIER type ASSIGN expression .)
    FOR             reduce using rule 23 (local_const_dec -> CONST IDENTIFIER type ASSIGN expression .)
    CASE            reduce using rule 23 (local_const_dec -> CONST IDENTIFIER type ASSIGN expression .)
    DEFAULT         reduce using rule 23 (local_const_dec -> CONST IDENTIFIER type ASSIGN expression .)
    DOT             shift and go to state 82
    LBRACKET        shift and go to state 83
    PLUS            shift and go to state 84
    MINUS           shift and go to state 85
    TIMES           shift and go to state 86
    DIVIDE          shift and go to state 87
    MODULE          shift and go to state 88
    EQ              shift and go to state 89
    NEQ             shift and go to state 90
    LT              shift and go to state 91
    LE              shift and go to state 92
    GT              shift and go to state 93
    GE              shift and go to state 94
    LAND            shift and go to state 95
    LOR             shift and go to state 96
    AND             shift and go to state 97
    OR              shift and go to state 98
    XOR             shift and go to state 99
    AND_NOT         shift and go to state 100
    LSHIFT          shift and go to state 101
    RSHIFT          shift and go to state 102

  ! LBRACKET        [ reduce using rule 23 (local_const_dec -> CONST IDENTIFIER type ASSIGN expression .) ]

    binary_operator                shift and go to state 81

state 312

    (129) if_statement -> IF expression block ELSE block .

    RBRACE          reduce using rule 129 (if_statement -> IF expression block ELSE block .)
    BREAK           reduce using rule 129 (if_statement -> IF expression block ELSE block .)
    CONTINUE        reduce using rule 129 (if_statement -> IF expression block ELSE block .)
    VAR             reduce using rule 129 (if_statement -> IF expression block ELSE block .)
    CONST           reduce using rule 129 (if_statement -> IF expression block ELSE block .)
    IDENTIFIER      reduce using rule 129 (if_statement -> IF expression block ELSE block .)
    LPAREN          reduce using rule 129 (if_statement -> IF expression block ELSE block .)
    INT             reduce using rule 129 (if_statement -> IF expression block ELSE block .)
    FLOAT64         reduce using rule 129 (if_statement -> IF expression block ELSE block .)
    STRING          reduce using rule 129 (if_statement -> IF expression block ELSE block .)
    TRUE            reduce using rule 129 (if_statement -> IF expression block ELSE block .)
    FALSE           reduce using rule 129 (if_statement -> IF expression block ELSE block .)
    LNOT            reduce using rule 129 (if_statement -> IF expression block ELSE block .)
    IF              reduce using rule 129 (if_statement -> IF expression block ELSE block .)
    SWITCH          reduce using rule 129 (if_statement -> IF expression block ELSE block .)
    RETURN          reduce using rule 129 (if_statement -> IF expression block ELSE block .)
    LBRACKET        reduce using rule 129 (if_statement -> IF expression block ELSE block .)
    MAP             reduce using rule 129 (if_statement -> IF expression block ELSE block .)
    FOR             reduce using rule 129 (if_statement -> IF expression block ELSE block .)
    CASE            reduce using rule 129 (if_statement -> IF expression block ELSE block .)
    DEFAULT         reduce using rule 129 (if_statement -> IF expression block ELSE block .)


state 313

    (130) if_statement -> IF expression block ELSE if_statement .

    RBRACE          reduce using rule 130 (if_statement -> IF expression block ELSE if_statement .)
    BREAK           reduce using rule 130 (if_statement -> IF expression block ELSE if_statement .)
    CONTINUE        reduce using rule 130 (if_statement -> IF expression block ELSE if_statement .)
    VAR             reduce using rule 130 (if_statement -> IF expression block ELSE if_statement .)
    CONST           reduce using rule 130 (if_statement -> IF expression block ELSE if_statement .)
    IDENTIFIER      reduce using rule 130 (if_statement -> IF expression block ELSE if_statement .)
    LPAREN          reduce using rule 130 (if_statement -> IF expression block ELSE if_statement .)
    INT             reduce using rule 130 (if_statement -> IF expression block ELSE if_statement .)
    FLOAT64         reduce using rule 130 (if_statement -> IF expression block ELSE if_statement .)
    STRING          reduce using rule 130 (if_statement -> IF expression block ELSE if_statement .)
    TRUE            reduce using rule 130 (if_statement -> IF expression block ELSE if_statement .)
    FALSE           reduce using rule 130 (if_statement -> IF expression block ELSE if_statement .)
    LNOT            reduce using rule 130 (if_statement -> IF expression block ELSE if_statement .)
    IF              reduce using rule 130 (if_statement -> IF expression block ELSE if_statement .)
    SWITCH          reduce using rule 130 (if_statement -> IF expression block ELSE if_statement .)
    RETURN          reduce using rule 130 (if_statement -> IF expression block ELSE if_statement .)
    LBRACKET        reduce using rule 130 (if_statement -> IF expression block ELSE if_statement .)
    MAP             reduce using rule 130 (if_statement -> IF expression block ELSE if_statement .)
    FOR             reduce using rule 130 (if_statement -> IF expression block ELSE if_statement .)
    CASE            reduce using rule 130 (if_statement -> IF expression block ELSE if_statement .)
    DEFAULT         reduce using rule 130 (if_statement -> IF expression block ELSE if_statement .)


state 314

    (131) if_statement -> IF if_assignment SEMICOLON expression block .
    (132) if_statement -> IF if_assignment SEMICOLON expression block . ELSE block
    (133) if_statement -> IF if_assignment SEMICOLON expression block . ELSE if_statement

    RBRACE          reduce using rule 131 (if_statement -> IF if_assignment SEMICOLON expression block .)
    BREAK           reduce using rule 131 (if_statement -> IF if_assignment SEMICOLON expression block .)
    CONTINUE        reduce using rule 131 (if_statement -> IF if_assignment SEMICOLON expression block .)
    VAR             reduce using rule 131 (if_statement -> IF if_assignment SEMICOLON expression block .)
    CONST           reduce using rule 131 (if_statement -> IF if_assignment SEMICOLON expression block .)
    IDENTIFIER      reduce using rule 131 (if_statement -> IF if_assignment SEMICOLON expression block .)
    LPAREN          reduce using rule 131 (if_statement -> IF if_assignment SEMICOLON expression block .)
    INT             reduce using rule 131 (if_statement -> IF if_assignment SEMICOLON expression block .)
    FLOAT64         reduce using rule 131 (if_statement -> IF if_assignment SEMICOLON expression block .)
    STRING          reduce using rule 131 (if_statement -> IF if_assignment SEMICOLON expression block .)
    TRUE            reduce using rule 131 (if_statement -> IF if_assignment SEMICOLON expression block .)
    FALSE           reduce using rule 131 (if_statement -> IF if_assignment SEMICOLON expression block .)
    LNOT            reduce using rule 131 (if_statement -> IF if_assignment SEMICOLON expression block .)
    IF              reduce using rule 131 (if_statement -> IF if_assignment SEMICOLON expression block .)
    SWITCH          reduce using rule 131 (if_statement -> IF if_assignment SEMICOLON expression block .)
    RETURN          reduce using rule 131 (if_statement -> IF if_assignment SEMICOLON expression block .)
    LBRACKET        reduce using rule 131 (if_statement -> IF if_assignment SEMICOLON expression block .)
    MAP             reduce using rule 131 (if_statement -> IF if_assignment SEMICOLON expression block .)
    FOR             reduce using rule 131 (if_statement -> IF if_assignment SEMICOLON expression block .)
    CASE            reduce using rule 131 (if_statement -> IF if_assignment SEMICOLON expression block .)
    DEFAULT         reduce using rule 131 (if_statement -> IF if_assignment SEMICOLON expression block .)
    ELSE            shift and go to state 327


state 315

    (167) switch_statement -> SWITCH switch_expr LBRACE case_clause_list RBRACE .

    RBRACE          reduce using rule 167 (switch_statement -> SWITCH switch_expr LBRACE case_clause_list RBRACE .)
    BREAK           reduce using rule 167 (switch_statement -> SWITCH switch_expr LBRACE case_clause_list RBRACE .)
    CONTINUE        reduce using rule 167 (switch_statement -> SWITCH switch_expr LBRACE case_clause_list RBRACE .)
    VAR             reduce using rule 167 (switch_statement -> SWITCH switch_expr LBRACE case_clause_list RBRACE .)
    CONST           reduce using rule 167 (switch_statement -> SWITCH switch_expr LBRACE case_clause_list RBRACE .)
    IDENTIFIER      reduce using rule 167 (switch_statement -> SWITCH switch_expr LBRACE case_clause_list RBRACE .)
    LPAREN          reduce using rule 167 (switch_statement -> SWITCH switch_expr LBRACE case_clause_list RBRACE .)
    INT             reduce using rule 167 (switch_statement -> SWITCH switch_expr LBRACE case_clause_list RBRACE .)
    FLOAT64         reduce using rule 167 (switch_statement -> SWITCH switch_expr LBRACE case_clause_list RBRACE .)
    STRING          reduce using rule 167 (switch_statement -> SWITCH switch_expr LBRACE case_clause_list RBRACE .)
    TRUE            reduce using rule 167 (switch_statement -> SWITCH switch_expr LBRACE case_clause_list RBRACE .)
    FALSE           reduce using rule 167 (switch_statement -> SWITCH switch_expr LBRACE case_clause_list RBRACE .)
    LNOT            reduce using rule 167 (switch_statement -> SWITCH switch_expr LBRACE case_clause_list RBRACE .)
    IF              reduce using rule 167 (switch_statement -> SWITCH switch_expr LBRACE case_clause_list RBRACE .)
    SWITCH          reduce using rule 167 (switch_statement -> SWITCH switch_expr LBRACE case_clause_list RBRACE .)
    RETURN          reduce using rule 167 (switch_statement -> SWITCH switch_expr LBRACE case_clause_list RBRACE .)
    LBRACKET        reduce using rule 167 (switch_statement -> SWITCH switch_expr LBRACE case_clause_list RBRACE .)
    MAP             reduce using rule 167 (switch_statement -> SWITCH switch_expr LBRACE case_clause_list RBRACE .)
    FOR             reduce using rule 167 (switch_statement -> SWITCH switch_expr LBRACE case_clause_list RBRACE .)
    CASE            reduce using rule 167 (switch_statement -> SWITCH switch_expr LBRACE case_clause_list RBRACE .)
    DEFAULT         reduce using rule 167 (switch_statement -> SWITCH switch_expr LBRACE case_clause_list RBRACE .)


state 316

    (191) case_clause -> CASE case_expression_list COLON . case_body
    (195) case_body -> . local_statement_list
    (196) case_body -> . empty
    (92) local_statement_list -> . local_statement
    (93) local_statement_list -> . local_statement_list local_statement
    (7) empty -> .
    (78) local_statement -> . local_var_dec
    (79) local_statement -> . local_const_dec
    (80) local_statement -> . short_assignment
    (81) local_statement -> . simple_assignment
    (82) local_statement -> . assignment_compound
    (83) local_statement -> . expression
    (84) local_statement -> . for_statement
    (85) local_statement -> . if_statement
    (86) local_statement -> . switch_statement
    (87) local_statement -> . return_statement
    (88) local_statement -> . BREAK
    (89) local_statement -> . CONTINUE
    (20) local_var_dec -> . VAR IDENTIFIER type
    (21) local_var_dec -> . VAR IDENTIFIER type ASSIGN expression
    (22) local_var_dec -> . VAR IDENTIFIER ASSIGN expression
    (23) local_const_dec -> . CONST IDENTIFIER type ASSIGN expression
    (24) local_const_dec -> . CONST IDENTIFIER ASSIGN expression
    (77) short_assignment -> . IDENTIFIER SHORT_ASSIGN expression
    (56) simple_assignment -> . IDENTIFIER ASSIGN expression
    (25) assignment_compound -> . IDENTIFIER operator_assign expression
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (125) expression -> . LNOT expression
    (126) expression -> . IDENTIFIER PLUSPLUS
    (127) expression -> . IDENTIFIER MINUSMINUS
    (138) expression -> . map_type LBRACE expression_map_list RBRACE
    (139) expression -> . map_type LBRACE RBRACE
    (161) expression -> . type_name LBRACE keyed_element_list RBRACE
    (162) expression -> . type_name LBRACE RBRACE
    (198) expression -> . array_type LBRACE expression_list RBRACE
    (199) expression -> . array_type LBRACE RBRACE
    (200) expression -> . expression DOT IDENTIFIER
    (201) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> . expression LBRACKET expression RBRACKET
    (203) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (94) for_statement -> . for_classic
    (95) for_statement -> . for_condition
    (96) for_statement -> . for_infinite
    (128) if_statement -> . IF expression block
    (129) if_statement -> . IF expression block ELSE block
    (130) if_statement -> . IF expression block ELSE if_statement
    (131) if_statement -> . IF if_assignment SEMICOLON expression block
    (132) if_statement -> . IF if_assignment SEMICOLON expression block ELSE block
    (133) if_statement -> . IF if_assignment SEMICOLON expression block ELSE if_statement
    (167) switch_statement -> . SWITCH switch_expr LBRACE case_clause_list RBRACE
    (168) switch_statement -> . SWITCH switch_expr LBRACE RBRACE
    (169) switch_statement -> . SWITCH LBRACE case_clause_list RBRACE
    (170) switch_statement -> . SWITCH LBRACE RBRACE
    (171) switch_statement -> . SWITCH switch_assignment SEMICOLON switch_expr LBRACE case_clause_list RBRACE
    (172) switch_statement -> . SWITCH switch_assignment SEMICOLON switch_expr LBRACE RBRACE
    (173) switch_statement -> . SWITCH switch_assignment SEMICOLON LBRACE case_clause_list RBRACE
    (174) switch_statement -> . SWITCH switch_assignment SEMICOLON LBRACE RBRACE
    (123) return_statement -> . RETURN
    (124) return_statement -> . RETURN return_list
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (137) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (163) type_name -> . IDENTIFIER
    (164) type_name -> . slice_type
    (165) type_name -> . array_type
    (166) type_name -> . map_type
    (197) array_type -> . LBRACKET INT RBRACKET primitive_type
    (97) for_classic -> . FOR for_init SEMICOLON for_cond SEMICOLON for_post block
    (98) for_condition -> . FOR expression block
    (99) for_infinite -> . FOR block

    RBRACE          reduce using rule 7 (empty -> .)
    CASE            reduce using rule 7 (empty -> .)
    DEFAULT         reduce using rule 7 (empty -> .)
    BREAK           shift and go to state 199
    CONTINUE        shift and go to state 200
    VAR             shift and go to state 201
    CONST           shift and go to state 203
    IDENTIFIER      shift and go to state 202
    LPAREN          shift and go to state 54
    INT             shift and go to state 55
    FLOAT64         shift and go to state 56
    STRING          shift and go to state 57
    TRUE            shift and go to state 58
    FALSE           shift and go to state 59
    LNOT            shift and go to state 60
    IF              shift and go to state 207
    SWITCH          shift and go to state 208
    RETURN          shift and go to state 209
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39
    FOR             shift and go to state 210

    case_body                      shift and go to state 328
    local_statement_list           shift and go to state 319
    empty                          shift and go to state 320
    local_statement                shift and go to state 188
    local_var_dec                  shift and go to state 189
    local_const_dec                shift and go to state 190
    short_assignment               shift and go to state 191
    simple_assignment              shift and go to state 192
    assignment_compound            shift and go to state 193
    expression                     shift and go to state 194
    for_statement                  shift and go to state 195
    if_statement                   shift and go to state 196
    switch_statement               shift and go to state 197
    return_statement               shift and go to state 198
    slice_type                     shift and go to state 53
    map_type                       shift and go to state 61
    type_name                      shift and go to state 62
    array_type                     shift and go to state 63
    for_classic                    shift and go to state 204
    for_condition                  shift and go to state 205
    for_infinite                   shift and go to state 206

state 317

    (194) case_expression_list -> case_expression_list COMMA . expression
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (125) expression -> . LNOT expression
    (126) expression -> . IDENTIFIER PLUSPLUS
    (127) expression -> . IDENTIFIER MINUSMINUS
    (138) expression -> . map_type LBRACE expression_map_list RBRACE
    (139) expression -> . map_type LBRACE RBRACE
    (161) expression -> . type_name LBRACE keyed_element_list RBRACE
    (162) expression -> . type_name LBRACE RBRACE
    (198) expression -> . array_type LBRACE expression_list RBRACE
    (199) expression -> . array_type LBRACE RBRACE
    (200) expression -> . expression DOT IDENTIFIER
    (201) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> . expression LBRACKET expression RBRACKET
    (203) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (137) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (163) type_name -> . IDENTIFIER
    (164) type_name -> . slice_type
    (165) type_name -> . array_type
    (166) type_name -> . map_type
    (197) array_type -> . LBRACKET INT RBRACKET primitive_type

    LPAREN          shift and go to state 54
    INT             shift and go to state 55
    FLOAT64         shift and go to state 56
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 57
    TRUE            shift and go to state 58
    FALSE           shift and go to state 59
    LNOT            shift and go to state 60
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    expression                     shift and go to state 329
    slice_type                     shift and go to state 53
    map_type                       shift and go to state 61
    type_name                      shift and go to state 62
    array_type                     shift and go to state 63

state 318

    (192) case_clause -> DEFAULT COLON case_body .

    RBRACE          reduce using rule 192 (case_clause -> DEFAULT COLON case_body .)
    CASE            reduce using rule 192 (case_clause -> DEFAULT COLON case_body .)
    DEFAULT         reduce using rule 192 (case_clause -> DEFAULT COLON case_body .)


state 319

    (195) case_body -> local_statement_list .
    (93) local_statement_list -> local_statement_list . local_statement
    (78) local_statement -> . local_var_dec
    (79) local_statement -> . local_const_dec
    (80) local_statement -> . short_assignment
    (81) local_statement -> . simple_assignment
    (82) local_statement -> . assignment_compound
    (83) local_statement -> . expression
    (84) local_statement -> . for_statement
    (85) local_statement -> . if_statement
    (86) local_statement -> . switch_statement
    (87) local_statement -> . return_statement
    (88) local_statement -> . BREAK
    (89) local_statement -> . CONTINUE
    (20) local_var_dec -> . VAR IDENTIFIER type
    (21) local_var_dec -> . VAR IDENTIFIER type ASSIGN expression
    (22) local_var_dec -> . VAR IDENTIFIER ASSIGN expression
    (23) local_const_dec -> . CONST IDENTIFIER type ASSIGN expression
    (24) local_const_dec -> . CONST IDENTIFIER ASSIGN expression
    (77) short_assignment -> . IDENTIFIER SHORT_ASSIGN expression
    (56) simple_assignment -> . IDENTIFIER ASSIGN expression
    (25) assignment_compound -> . IDENTIFIER operator_assign expression
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (125) expression -> . LNOT expression
    (126) expression -> . IDENTIFIER PLUSPLUS
    (127) expression -> . IDENTIFIER MINUSMINUS
    (138) expression -> . map_type LBRACE expression_map_list RBRACE
    (139) expression -> . map_type LBRACE RBRACE
    (161) expression -> . type_name LBRACE keyed_element_list RBRACE
    (162) expression -> . type_name LBRACE RBRACE
    (198) expression -> . array_type LBRACE expression_list RBRACE
    (199) expression -> . array_type LBRACE RBRACE
    (200) expression -> . expression DOT IDENTIFIER
    (201) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> . expression LBRACKET expression RBRACKET
    (203) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (94) for_statement -> . for_classic
    (95) for_statement -> . for_condition
    (96) for_statement -> . for_infinite
    (128) if_statement -> . IF expression block
    (129) if_statement -> . IF expression block ELSE block
    (130) if_statement -> . IF expression block ELSE if_statement
    (131) if_statement -> . IF if_assignment SEMICOLON expression block
    (132) if_statement -> . IF if_assignment SEMICOLON expression block ELSE block
    (133) if_statement -> . IF if_assignment SEMICOLON expression block ELSE if_statement
    (167) switch_statement -> . SWITCH switch_expr LBRACE case_clause_list RBRACE
    (168) switch_statement -> . SWITCH switch_expr LBRACE RBRACE
    (169) switch_statement -> . SWITCH LBRACE case_clause_list RBRACE
    (170) switch_statement -> . SWITCH LBRACE RBRACE
    (171) switch_statement -> . SWITCH switch_assignment SEMICOLON switch_expr LBRACE case_clause_list RBRACE
    (172) switch_statement -> . SWITCH switch_assignment SEMICOLON switch_expr LBRACE RBRACE
    (173) switch_statement -> . SWITCH switch_assignment SEMICOLON LBRACE case_clause_list RBRACE
    (174) switch_statement -> . SWITCH switch_assignment SEMICOLON LBRACE RBRACE
    (123) return_statement -> . RETURN
    (124) return_statement -> . RETURN return_list
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (137) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (163) type_name -> . IDENTIFIER
    (164) type_name -> . slice_type
    (165) type_name -> . array_type
    (166) type_name -> . map_type
    (197) array_type -> . LBRACKET INT RBRACKET primitive_type
    (97) for_classic -> . FOR for_init SEMICOLON for_cond SEMICOLON for_post block
    (98) for_condition -> . FOR expression block
    (99) for_infinite -> . FOR block

    RBRACE          reduce using rule 195 (case_body -> local_statement_list .)
    CASE            reduce using rule 195 (case_body -> local_statement_list .)
    DEFAULT         reduce using rule 195 (case_body -> local_statement_list .)
    BREAK           shift and go to state 199
    CONTINUE        shift and go to state 200
    VAR             shift and go to state 201
    CONST           shift and go to state 203
    IDENTIFIER      shift and go to state 202
    LPAREN          shift and go to state 54
    INT             shift and go to state 55
    FLOAT64         shift and go to state 56
    STRING          shift and go to state 57
    TRUE            shift and go to state 58
    FALSE           shift and go to state 59
    LNOT            shift and go to state 60
    IF              shift and go to state 207
    SWITCH          shift and go to state 208
    RETURN          shift and go to state 209
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39
    FOR             shift and go to state 210

    local_statement                shift and go to state 215
    local_var_dec                  shift and go to state 189
    local_const_dec                shift and go to state 190
    short_assignment               shift and go to state 191
    simple_assignment              shift and go to state 192
    assignment_compound            shift and go to state 193
    expression                     shift and go to state 194
    for_statement                  shift and go to state 195
    if_statement                   shift and go to state 196
    switch_statement               shift and go to state 197
    return_statement               shift and go to state 198
    slice_type                     shift and go to state 53
    map_type                       shift and go to state 61
    type_name                      shift and go to state 62
    array_type                     shift and go to state 63
    for_classic                    shift and go to state 204
    for_condition                  shift and go to state 205
    for_infinite                   shift and go to state 206

state 320

    (196) case_body -> empty .

    RBRACE          reduce using rule 196 (case_body -> empty .)
    CASE            reduce using rule 196 (case_body -> empty .)
    DEFAULT         reduce using rule 196 (case_body -> empty .)


state 321

    (171) switch_statement -> SWITCH switch_assignment SEMICOLON switch_expr LBRACE . case_clause_list RBRACE
    (172) switch_statement -> SWITCH switch_assignment SEMICOLON switch_expr LBRACE . RBRACE
    (186) case_clause_list -> . case_clause
    (187) case_clause_list -> . case_clause_list case_clause
    (191) case_clause -> . CASE case_expression_list COLON case_body
    (192) case_clause -> . DEFAULT COLON case_body

    RBRACE          shift and go to state 331
    CASE            shift and go to state 275
    DEFAULT         shift and go to state 276

    case_clause_list               shift and go to state 330
    case_clause                    shift and go to state 274

state 322

    (173) switch_statement -> SWITCH switch_assignment SEMICOLON LBRACE case_clause_list . RBRACE
    (187) case_clause_list -> case_clause_list . case_clause
    (191) case_clause -> . CASE case_expression_list COLON case_body
    (192) case_clause -> . DEFAULT COLON case_body

    RBRACE          shift and go to state 332
    CASE            shift and go to state 275
    DEFAULT         shift and go to state 276

    case_clause                    shift and go to state 295

state 323

    (174) switch_statement -> SWITCH switch_assignment SEMICOLON LBRACE RBRACE .

    RBRACE          reduce using rule 174 (switch_statement -> SWITCH switch_assignment SEMICOLON LBRACE RBRACE .)
    BREAK           reduce using rule 174 (switch_statement -> SWITCH switch_assignment SEMICOLON LBRACE RBRACE .)
    CONTINUE        reduce using rule 174 (switch_statement -> SWITCH switch_assignment SEMICOLON LBRACE RBRACE .)
    VAR             reduce using rule 174 (switch_statement -> SWITCH switch_assignment SEMICOLON LBRACE RBRACE .)
    CONST           reduce using rule 174 (switch_statement -> SWITCH switch_assignment SEMICOLON LBRACE RBRACE .)
    IDENTIFIER      reduce using rule 174 (switch_statement -> SWITCH switch_assignment SEMICOLON LBRACE RBRACE .)
    LPAREN          reduce using rule 174 (switch_statement -> SWITCH switch_assignment SEMICOLON LBRACE RBRACE .)
    INT             reduce using rule 174 (switch_statement -> SWITCH switch_assignment SEMICOLON LBRACE RBRACE .)
    FLOAT64         reduce using rule 174 (switch_statement -> SWITCH switch_assignment SEMICOLON LBRACE RBRACE .)
    STRING          reduce using rule 174 (switch_statement -> SWITCH switch_assignment SEMICOLON LBRACE RBRACE .)
    TRUE            reduce using rule 174 (switch_statement -> SWITCH switch_assignment SEMICOLON LBRACE RBRACE .)
    FALSE           reduce using rule 174 (switch_statement -> SWITCH switch_assignment SEMICOLON LBRACE RBRACE .)
    LNOT            reduce using rule 174 (switch_statement -> SWITCH switch_assignment SEMICOLON LBRACE RBRACE .)
    IF              reduce using rule 174 (switch_statement -> SWITCH switch_assignment SEMICOLON LBRACE RBRACE .)
    SWITCH          reduce using rule 174 (switch_statement -> SWITCH switch_assignment SEMICOLON LBRACE RBRACE .)
    RETURN          reduce using rule 174 (switch_statement -> SWITCH switch_assignment SEMICOLON LBRACE RBRACE .)
    LBRACKET        reduce using rule 174 (switch_statement -> SWITCH switch_assignment SEMICOLON LBRACE RBRACE .)
    MAP             reduce using rule 174 (switch_statement -> SWITCH switch_assignment SEMICOLON LBRACE RBRACE .)
    FOR             reduce using rule 174 (switch_statement -> SWITCH switch_assignment SEMICOLON LBRACE RBRACE .)
    CASE            reduce using rule 174 (switch_statement -> SWITCH switch_assignment SEMICOLON LBRACE RBRACE .)
    DEFAULT         reduce using rule 174 (switch_statement -> SWITCH switch_assignment SEMICOLON LBRACE RBRACE .)


state 324

    (185) primary_expression -> primary_expression LBRACKET expression RBRACKET .

    DOT             reduce using rule 185 (primary_expression -> primary_expression LBRACKET expression RBRACKET .)
    LBRACKET        reduce using rule 185 (primary_expression -> primary_expression LBRACKET expression RBRACKET .)
    LBRACE          reduce using rule 185 (primary_expression -> primary_expression LBRACKET expression RBRACKET .)


state 325

    (183) primary_expression -> IDENTIFIER LPAREN argument_list RPAREN .

    DOT             reduce using rule 183 (primary_expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    LBRACKET        reduce using rule 183 (primary_expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    LBRACE          reduce using rule 183 (primary_expression -> IDENTIFIER LPAREN argument_list RPAREN .)


state 326

    (97) for_classic -> FOR for_init SEMICOLON for_cond SEMICOLON . for_post block
    (106) for_post -> . simple_assignment
    (107) for_post -> . assignment_compound
    (108) for_post -> . expression
    (109) for_post -> . empty
    (56) simple_assignment -> . IDENTIFIER ASSIGN expression
    (25) assignment_compound -> . IDENTIFIER operator_assign expression
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (125) expression -> . LNOT expression
    (126) expression -> . IDENTIFIER PLUSPLUS
    (127) expression -> . IDENTIFIER MINUSMINUS
    (138) expression -> . map_type LBRACE expression_map_list RBRACE
    (139) expression -> . map_type LBRACE RBRACE
    (161) expression -> . type_name LBRACE keyed_element_list RBRACE
    (162) expression -> . type_name LBRACE RBRACE
    (198) expression -> . array_type LBRACE expression_list RBRACE
    (199) expression -> . array_type LBRACE RBRACE
    (200) expression -> . expression DOT IDENTIFIER
    (201) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> . expression LBRACKET expression RBRACKET
    (203) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (7) empty -> .
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (137) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (163) type_name -> . IDENTIFIER
    (164) type_name -> . slice_type
    (165) type_name -> . array_type
    (166) type_name -> . map_type
    (197) array_type -> . LBRACKET INT RBRACKET primitive_type

    IDENTIFIER      shift and go to state 338
    LPAREN          shift and go to state 54
    INT             shift and go to state 55
    FLOAT64         shift and go to state 56
    STRING          shift and go to state 57
    TRUE            shift and go to state 58
    FALSE           shift and go to state 59
    LNOT            shift and go to state 60
    LBRACE          reduce using rule 7 (empty -> .)
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    for_post                       shift and go to state 333
    simple_assignment              shift and go to state 334
    assignment_compound            shift and go to state 335
    expression                     shift and go to state 336
    empty                          shift and go to state 337
    slice_type                     shift and go to state 53
    map_type                       shift and go to state 61
    type_name                      shift and go to state 62
    array_type                     shift and go to state 63

state 327

    (132) if_statement -> IF if_assignment SEMICOLON expression block ELSE . block
    (133) if_statement -> IF if_assignment SEMICOLON expression block ELSE . if_statement
    (90) block -> . LBRACE local_statement_list RBRACE
    (91) block -> . LBRACE RBRACE
    (128) if_statement -> . IF expression block
    (129) if_statement -> . IF expression block ELSE block
    (130) if_statement -> . IF expression block ELSE if_statement
    (131) if_statement -> . IF if_assignment SEMICOLON expression block
    (132) if_statement -> . IF if_assignment SEMICOLON expression block ELSE block
    (133) if_statement -> . IF if_assignment SEMICOLON expression block ELSE if_statement

    LBRACE          shift and go to state 175
    IF              shift and go to state 207

    block                          shift and go to state 339
    if_statement                   shift and go to state 340

state 328

    (191) case_clause -> CASE case_expression_list COLON case_body .

    RBRACE          reduce using rule 191 (case_clause -> CASE case_expression_list COLON case_body .)
    CASE            reduce using rule 191 (case_clause -> CASE case_expression_list COLON case_body .)
    DEFAULT         reduce using rule 191 (case_clause -> CASE case_expression_list COLON case_body .)


state 329

    (194) case_expression_list -> case_expression_list COMMA expression .
    (36) expression -> expression . binary_operator expression
    (200) expression -> expression . DOT IDENTIFIER
    (201) expression -> expression . DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> expression . LBRACKET expression RBRACKET
    (37) binary_operator -> . PLUS
    (38) binary_operator -> . MINUS
    (39) binary_operator -> . TIMES
    (40) binary_operator -> . DIVIDE
    (41) binary_operator -> . MODULE
    (42) binary_operator -> . EQ
    (43) binary_operator -> . NEQ
    (44) binary_operator -> . LT
    (45) binary_operator -> . LE
    (46) binary_operator -> . GT
    (47) binary_operator -> . GE
    (48) binary_operator -> . LAND
    (49) binary_operator -> . LOR
    (50) binary_operator -> . AND
    (51) binary_operator -> . OR
    (52) binary_operator -> . XOR
    (53) binary_operator -> . AND_NOT
    (54) binary_operator -> . LSHIFT
    (55) binary_operator -> . RSHIFT

    COLON           reduce using rule 194 (case_expression_list -> case_expression_list COMMA expression .)
    COMMA           reduce using rule 194 (case_expression_list -> case_expression_list COMMA expression .)
    DOT             shift and go to state 82
    LBRACKET        shift and go to state 83
    PLUS            shift and go to state 84
    MINUS           shift and go to state 85
    TIMES           shift and go to state 86
    DIVIDE          shift and go to state 87
    MODULE          shift and go to state 88
    EQ              shift and go to state 89
    NEQ             shift and go to state 90
    LT              shift and go to state 91
    LE              shift and go to state 92
    GT              shift and go to state 93
    GE              shift and go to state 94
    LAND            shift and go to state 95
    LOR             shift and go to state 96
    AND             shift and go to state 97
    OR              shift and go to state 98
    XOR             shift and go to state 99
    AND_NOT         shift and go to state 100
    LSHIFT          shift and go to state 101
    RSHIFT          shift and go to state 102

    binary_operator                shift and go to state 81

state 330

    (171) switch_statement -> SWITCH switch_assignment SEMICOLON switch_expr LBRACE case_clause_list . RBRACE
    (187) case_clause_list -> case_clause_list . case_clause
    (191) case_clause -> . CASE case_expression_list COLON case_body
    (192) case_clause -> . DEFAULT COLON case_body

    RBRACE          shift and go to state 341
    CASE            shift and go to state 275
    DEFAULT         shift and go to state 276

    case_clause                    shift and go to state 295

state 331

    (172) switch_statement -> SWITCH switch_assignment SEMICOLON switch_expr LBRACE RBRACE .

    RBRACE          reduce using rule 172 (switch_statement -> SWITCH switch_assignment SEMICOLON switch_expr LBRACE RBRACE .)
    BREAK           reduce using rule 172 (switch_statement -> SWITCH switch_assignment SEMICOLON switch_expr LBRACE RBRACE .)
    CONTINUE        reduce using rule 172 (switch_statement -> SWITCH switch_assignment SEMICOLON switch_expr LBRACE RBRACE .)
    VAR             reduce using rule 172 (switch_statement -> SWITCH switch_assignment SEMICOLON switch_expr LBRACE RBRACE .)
    CONST           reduce using rule 172 (switch_statement -> SWITCH switch_assignment SEMICOLON switch_expr LBRACE RBRACE .)
    IDENTIFIER      reduce using rule 172 (switch_statement -> SWITCH switch_assignment SEMICOLON switch_expr LBRACE RBRACE .)
    LPAREN          reduce using rule 172 (switch_statement -> SWITCH switch_assignment SEMICOLON switch_expr LBRACE RBRACE .)
    INT             reduce using rule 172 (switch_statement -> SWITCH switch_assignment SEMICOLON switch_expr LBRACE RBRACE .)
    FLOAT64         reduce using rule 172 (switch_statement -> SWITCH switch_assignment SEMICOLON switch_expr LBRACE RBRACE .)
    STRING          reduce using rule 172 (switch_statement -> SWITCH switch_assignment SEMICOLON switch_expr LBRACE RBRACE .)
    TRUE            reduce using rule 172 (switch_statement -> SWITCH switch_assignment SEMICOLON switch_expr LBRACE RBRACE .)
    FALSE           reduce using rule 172 (switch_statement -> SWITCH switch_assignment SEMICOLON switch_expr LBRACE RBRACE .)
    LNOT            reduce using rule 172 (switch_statement -> SWITCH switch_assignment SEMICOLON switch_expr LBRACE RBRACE .)
    IF              reduce using rule 172 (switch_statement -> SWITCH switch_assignment SEMICOLON switch_expr LBRACE RBRACE .)
    SWITCH          reduce using rule 172 (switch_statement -> SWITCH switch_assignment SEMICOLON switch_expr LBRACE RBRACE .)
    RETURN          reduce using rule 172 (switch_statement -> SWITCH switch_assignment SEMICOLON switch_expr LBRACE RBRACE .)
    LBRACKET        reduce using rule 172 (switch_statement -> SWITCH switch_assignment SEMICOLON switch_expr LBRACE RBRACE .)
    MAP             reduce using rule 172 (switch_statement -> SWITCH switch_assignment SEMICOLON switch_expr LBRACE RBRACE .)
    FOR             reduce using rule 172 (switch_statement -> SWITCH switch_assignment SEMICOLON switch_expr LBRACE RBRACE .)
    CASE            reduce using rule 172 (switch_statement -> SWITCH switch_assignment SEMICOLON switch_expr LBRACE RBRACE .)
    DEFAULT         reduce using rule 172 (switch_statement -> SWITCH switch_assignment SEMICOLON switch_expr LBRACE RBRACE .)


state 332

    (173) switch_statement -> SWITCH switch_assignment SEMICOLON LBRACE case_clause_list RBRACE .

    RBRACE          reduce using rule 173 (switch_statement -> SWITCH switch_assignment SEMICOLON LBRACE case_clause_list RBRACE .)
    BREAK           reduce using rule 173 (switch_statement -> SWITCH switch_assignment SEMICOLON LBRACE case_clause_list RBRACE .)
    CONTINUE        reduce using rule 173 (switch_statement -> SWITCH switch_assignment SEMICOLON LBRACE case_clause_list RBRACE .)
    VAR             reduce using rule 173 (switch_statement -> SWITCH switch_assignment SEMICOLON LBRACE case_clause_list RBRACE .)
    CONST           reduce using rule 173 (switch_statement -> SWITCH switch_assignment SEMICOLON LBRACE case_clause_list RBRACE .)
    IDENTIFIER      reduce using rule 173 (switch_statement -> SWITCH switch_assignment SEMICOLON LBRACE case_clause_list RBRACE .)
    LPAREN          reduce using rule 173 (switch_statement -> SWITCH switch_assignment SEMICOLON LBRACE case_clause_list RBRACE .)
    INT             reduce using rule 173 (switch_statement -> SWITCH switch_assignment SEMICOLON LBRACE case_clause_list RBRACE .)
    FLOAT64         reduce using rule 173 (switch_statement -> SWITCH switch_assignment SEMICOLON LBRACE case_clause_list RBRACE .)
    STRING          reduce using rule 173 (switch_statement -> SWITCH switch_assignment SEMICOLON LBRACE case_clause_list RBRACE .)
    TRUE            reduce using rule 173 (switch_statement -> SWITCH switch_assignment SEMICOLON LBRACE case_clause_list RBRACE .)
    FALSE           reduce using rule 173 (switch_statement -> SWITCH switch_assignment SEMICOLON LBRACE case_clause_list RBRACE .)
    LNOT            reduce using rule 173 (switch_statement -> SWITCH switch_assignment SEMICOLON LBRACE case_clause_list RBRACE .)
    IF              reduce using rule 173 (switch_statement -> SWITCH switch_assignment SEMICOLON LBRACE case_clause_list RBRACE .)
    SWITCH          reduce using rule 173 (switch_statement -> SWITCH switch_assignment SEMICOLON LBRACE case_clause_list RBRACE .)
    RETURN          reduce using rule 173 (switch_statement -> SWITCH switch_assignment SEMICOLON LBRACE case_clause_list RBRACE .)
    LBRACKET        reduce using rule 173 (switch_statement -> SWITCH switch_assignment SEMICOLON LBRACE case_clause_list RBRACE .)
    MAP             reduce using rule 173 (switch_statement -> SWITCH switch_assignment SEMICOLON LBRACE case_clause_list RBRACE .)
    FOR             reduce using rule 173 (switch_statement -> SWITCH switch_assignment SEMICOLON LBRACE case_clause_list RBRACE .)
    CASE            reduce using rule 173 (switch_statement -> SWITCH switch_assignment SEMICOLON LBRACE case_clause_list RBRACE .)
    DEFAULT         reduce using rule 173 (switch_statement -> SWITCH switch_assignment SEMICOLON LBRACE case_clause_list RBRACE .)


state 333

    (97) for_classic -> FOR for_init SEMICOLON for_cond SEMICOLON for_post . block
    (90) block -> . LBRACE local_statement_list RBRACE
    (91) block -> . LBRACE RBRACE

    LBRACE          shift and go to state 175

    block                          shift and go to state 342

state 334

    (106) for_post -> simple_assignment .

    LBRACE          reduce using rule 106 (for_post -> simple_assignment .)


state 335

    (107) for_post -> assignment_compound .

    LBRACE          reduce using rule 107 (for_post -> assignment_compound .)


state 336

    (108) for_post -> expression .
    (36) expression -> expression . binary_operator expression
    (200) expression -> expression . DOT IDENTIFIER
    (201) expression -> expression . DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> expression . LBRACKET expression RBRACKET
    (37) binary_operator -> . PLUS
    (38) binary_operator -> . MINUS
    (39) binary_operator -> . TIMES
    (40) binary_operator -> . DIVIDE
    (41) binary_operator -> . MODULE
    (42) binary_operator -> . EQ
    (43) binary_operator -> . NEQ
    (44) binary_operator -> . LT
    (45) binary_operator -> . LE
    (46) binary_operator -> . GT
    (47) binary_operator -> . GE
    (48) binary_operator -> . LAND
    (49) binary_operator -> . LOR
    (50) binary_operator -> . AND
    (51) binary_operator -> . OR
    (52) binary_operator -> . XOR
    (53) binary_operator -> . AND_NOT
    (54) binary_operator -> . LSHIFT
    (55) binary_operator -> . RSHIFT

    LBRACE          reduce using rule 108 (for_post -> expression .)
    DOT             shift and go to state 82
    LBRACKET        shift and go to state 83
    PLUS            shift and go to state 84
    MINUS           shift and go to state 85
    TIMES           shift and go to state 86
    DIVIDE          shift and go to state 87
    MODULE          shift and go to state 88
    EQ              shift and go to state 89
    NEQ             shift and go to state 90
    LT              shift and go to state 91
    LE              shift and go to state 92
    GT              shift and go to state 93
    GE              shift and go to state 94
    LAND            shift and go to state 95
    LOR             shift and go to state 96
    AND             shift and go to state 97
    OR              shift and go to state 98
    XOR             shift and go to state 99
    AND_NOT         shift and go to state 100
    LSHIFT          shift and go to state 101
    RSHIFT          shift and go to state 102

    binary_operator                shift and go to state 81

state 337

    (109) for_post -> empty .

    LBRACE          reduce using rule 109 (for_post -> empty .)


state 338

    (56) simple_assignment -> IDENTIFIER . ASSIGN expression
    (25) assignment_compound -> IDENTIFIER . operator_assign expression
    (73) expression -> IDENTIFIER .
    (126) expression -> IDENTIFIER . PLUSPLUS
    (127) expression -> IDENTIFIER . MINUSMINUS
    (203) expression -> IDENTIFIER . LPAREN argument_list RPAREN
    (163) type_name -> IDENTIFIER .
    (26) operator_assign -> . PLUS_ASSIGN
    (27) operator_assign -> . MINUS_ASSIGN
    (28) operator_assign -> . MULT_ASSIGN
    (29) operator_assign -> . DIV_ASSIGN
    (30) operator_assign -> . MOD_ASSIGN
    (31) operator_assign -> . AND_ASSIGN
    (32) operator_assign -> . OR_ASSIGN
    (33) operator_assign -> . XOR_ASSIGN
    (34) operator_assign -> . LSHIFT_ASSIGN
    (35) operator_assign -> . RSHIFT_ASSIGN

  ! reduce/reduce conflict for LBRACE resolved using rule 73 (expression -> IDENTIFIER .)
    ASSIGN          shift and go to state 218
    DOT             reduce using rule 73 (expression -> IDENTIFIER .)
    LBRACKET        reduce using rule 73 (expression -> IDENTIFIER .)
    PLUS            reduce using rule 73 (expression -> IDENTIFIER .)
    MINUS           reduce using rule 73 (expression -> IDENTIFIER .)
    TIMES           reduce using rule 73 (expression -> IDENTIFIER .)
    DIVIDE          reduce using rule 73 (expression -> IDENTIFIER .)
    MODULE          reduce using rule 73 (expression -> IDENTIFIER .)
    EQ              reduce using rule 73 (expression -> IDENTIFIER .)
    NEQ             reduce using rule 73 (expression -> IDENTIFIER .)
    LT              reduce using rule 73 (expression -> IDENTIFIER .)
    LE              reduce using rule 73 (expression -> IDENTIFIER .)
    GT              reduce using rule 73 (expression -> IDENTIFIER .)
    GE              reduce using rule 73 (expression -> IDENTIFIER .)
    LAND            reduce using rule 73 (expression -> IDENTIFIER .)
    LOR             reduce using rule 73 (expression -> IDENTIFIER .)
    AND             reduce using rule 73 (expression -> IDENTIFIER .)
    OR              reduce using rule 73 (expression -> IDENTIFIER .)
    XOR             reduce using rule 73 (expression -> IDENTIFIER .)
    AND_NOT         reduce using rule 73 (expression -> IDENTIFIER .)
    LSHIFT          reduce using rule 73 (expression -> IDENTIFIER .)
    RSHIFT          reduce using rule 73 (expression -> IDENTIFIER .)
    LBRACE          reduce using rule 73 (expression -> IDENTIFIER .)
    PLUSPLUS        shift and go to state 78
    MINUSMINUS      shift and go to state 79
    LPAREN          shift and go to state 80
    PLUS_ASSIGN     shift and go to state 220
    MINUS_ASSIGN    shift and go to state 221
    MULT_ASSIGN     shift and go to state 222
    DIV_ASSIGN      shift and go to state 223
    MOD_ASSIGN      shift and go to state 224
    AND_ASSIGN      shift and go to state 225
    OR_ASSIGN       shift and go to state 226
    XOR_ASSIGN      shift and go to state 227
    LSHIFT_ASSIGN   shift and go to state 228
    RSHIFT_ASSIGN   shift and go to state 229

  ! LBRACE          [ reduce using rule 163 (type_name -> IDENTIFIER .) ]

    operator_assign                shift and go to state 219

state 339

    (132) if_statement -> IF if_assignment SEMICOLON expression block ELSE block .

    RBRACE          reduce using rule 132 (if_statement -> IF if_assignment SEMICOLON expression block ELSE block .)
    BREAK           reduce using rule 132 (if_statement -> IF if_assignment SEMICOLON expression block ELSE block .)
    CONTINUE        reduce using rule 132 (if_statement -> IF if_assignment SEMICOLON expression block ELSE block .)
    VAR             reduce using rule 132 (if_statement -> IF if_assignment SEMICOLON expression block ELSE block .)
    CONST           reduce using rule 132 (if_statement -> IF if_assignment SEMICOLON expression block ELSE block .)
    IDENTIFIER      reduce using rule 132 (if_statement -> IF if_assignment SEMICOLON expression block ELSE block .)
    LPAREN          reduce using rule 132 (if_statement -> IF if_assignment SEMICOLON expression block ELSE block .)
    INT             reduce using rule 132 (if_statement -> IF if_assignment SEMICOLON expression block ELSE block .)
    FLOAT64         reduce using rule 132 (if_statement -> IF if_assignment SEMICOLON expression block ELSE block .)
    STRING          reduce using rule 132 (if_statement -> IF if_assignment SEMICOLON expression block ELSE block .)
    TRUE            reduce using rule 132 (if_statement -> IF if_assignment SEMICOLON expression block ELSE block .)
    FALSE           reduce using rule 132 (if_statement -> IF if_assignment SEMICOLON expression block ELSE block .)
    LNOT            reduce using rule 132 (if_statement -> IF if_assignment SEMICOLON expression block ELSE block .)
    IF              reduce using rule 132 (if_statement -> IF if_assignment SEMICOLON expression block ELSE block .)
    SWITCH          reduce using rule 132 (if_statement -> IF if_assignment SEMICOLON expression block ELSE block .)
    RETURN          reduce using rule 132 (if_statement -> IF if_assignment SEMICOLON expression block ELSE block .)
    LBRACKET        reduce using rule 132 (if_statement -> IF if_assignment SEMICOLON expression block ELSE block .)
    MAP             reduce using rule 132 (if_statement -> IF if_assignment SEMICOLON expression block ELSE block .)
    FOR             reduce using rule 132 (if_statement -> IF if_assignment SEMICOLON expression block ELSE block .)
    CASE            reduce using rule 132 (if_statement -> IF if_assignment SEMICOLON expression block ELSE block .)
    DEFAULT         reduce using rule 132 (if_statement -> IF if_assignment SEMICOLON expression block ELSE block .)


state 340

    (133) if_statement -> IF if_assignment SEMICOLON expression block ELSE if_statement .

    RBRACE          reduce using rule 133 (if_statement -> IF if_assignment SEMICOLON expression block ELSE if_statement .)
    BREAK           reduce using rule 133 (if_statement -> IF if_assignment SEMICOLON expression block ELSE if_statement .)
    CONTINUE        reduce using rule 133 (if_statement -> IF if_assignment SEMICOLON expression block ELSE if_statement .)
    VAR             reduce using rule 133 (if_statement -> IF if_assignment SEMICOLON expression block ELSE if_statement .)
    CONST           reduce using rule 133 (if_statement -> IF if_assignment SEMICOLON expression block ELSE if_statement .)
    IDENTIFIER      reduce using rule 133 (if_statement -> IF if_assignment SEMICOLON expression block ELSE if_statement .)
    LPAREN          reduce using rule 133 (if_statement -> IF if_assignment SEMICOLON expression block ELSE if_statement .)
    INT             reduce using rule 133 (if_statement -> IF if_assignment SEMICOLON expression block ELSE if_statement .)
    FLOAT64         reduce using rule 133 (if_statement -> IF if_assignment SEMICOLON expression block ELSE if_statement .)
    STRING          reduce using rule 133 (if_statement -> IF if_assignment SEMICOLON expression block ELSE if_statement .)
    TRUE            reduce using rule 133 (if_statement -> IF if_assignment SEMICOLON expression block ELSE if_statement .)
    FALSE           reduce using rule 133 (if_statement -> IF if_assignment SEMICOLON expression block ELSE if_statement .)
    LNOT            reduce using rule 133 (if_statement -> IF if_assignment SEMICOLON expression block ELSE if_statement .)
    IF              reduce using rule 133 (if_statement -> IF if_assignment SEMICOLON expression block ELSE if_statement .)
    SWITCH          reduce using rule 133 (if_statement -> IF if_assignment SEMICOLON expression block ELSE if_statement .)
    RETURN          reduce using rule 133 (if_statement -> IF if_assignment SEMICOLON expression block ELSE if_statement .)
    LBRACKET        reduce using rule 133 (if_statement -> IF if_assignment SEMICOLON expression block ELSE if_statement .)
    MAP             reduce using rule 133 (if_statement -> IF if_assignment SEMICOLON expression block ELSE if_statement .)
    FOR             reduce using rule 133 (if_statement -> IF if_assignment SEMICOLON expression block ELSE if_statement .)
    CASE            reduce using rule 133 (if_statement -> IF if_assignment SEMICOLON expression block ELSE if_statement .)
    DEFAULT         reduce using rule 133 (if_statement -> IF if_assignment SEMICOLON expression block ELSE if_statement .)


state 341

    (171) switch_statement -> SWITCH switch_assignment SEMICOLON switch_expr LBRACE case_clause_list RBRACE .

    RBRACE          reduce using rule 171 (switch_statement -> SWITCH switch_assignment SEMICOLON switch_expr LBRACE case_clause_list RBRACE .)
    BREAK           reduce using rule 171 (switch_statement -> SWITCH switch_assignment SEMICOLON switch_expr LBRACE case_clause_list RBRACE .)
    CONTINUE        reduce using rule 171 (switch_statement -> SWITCH switch_assignment SEMICOLON switch_expr LBRACE case_clause_list RBRACE .)
    VAR             reduce using rule 171 (switch_statement -> SWITCH switch_assignment SEMICOLON switch_expr LBRACE case_clause_list RBRACE .)
    CONST           reduce using rule 171 (switch_statement -> SWITCH switch_assignment SEMICOLON switch_expr LBRACE case_clause_list RBRACE .)
    IDENTIFIER      reduce using rule 171 (switch_statement -> SWITCH switch_assignment SEMICOLON switch_expr LBRACE case_clause_list RBRACE .)
    LPAREN          reduce using rule 171 (switch_statement -> SWITCH switch_assignment SEMICOLON switch_expr LBRACE case_clause_list RBRACE .)
    INT             reduce using rule 171 (switch_statement -> SWITCH switch_assignment SEMICOLON switch_expr LBRACE case_clause_list RBRACE .)
    FLOAT64         reduce using rule 171 (switch_statement -> SWITCH switch_assignment SEMICOLON switch_expr LBRACE case_clause_list RBRACE .)
    STRING          reduce using rule 171 (switch_statement -> SWITCH switch_assignment SEMICOLON switch_expr LBRACE case_clause_list RBRACE .)
    TRUE            reduce using rule 171 (switch_statement -> SWITCH switch_assignment SEMICOLON switch_expr LBRACE case_clause_list RBRACE .)
    FALSE           reduce using rule 171 (switch_statement -> SWITCH switch_assignment SEMICOLON switch_expr LBRACE case_clause_list RBRACE .)
    LNOT            reduce using rule 171 (switch_statement -> SWITCH switch_assignment SEMICOLON switch_expr LBRACE case_clause_list RBRACE .)
    IF              reduce using rule 171 (switch_statement -> SWITCH switch_assignment SEMICOLON switch_expr LBRACE case_clause_list RBRACE .)
    SWITCH          reduce using rule 171 (switch_statement -> SWITCH switch_assignment SEMICOLON switch_expr LBRACE case_clause_list RBRACE .)
    RETURN          reduce using rule 171 (switch_statement -> SWITCH switch_assignment SEMICOLON switch_expr LBRACE case_clause_list RBRACE .)
    LBRACKET        reduce using rule 171 (switch_statement -> SWITCH switch_assignment SEMICOLON switch_expr LBRACE case_clause_list RBRACE .)
    MAP             reduce using rule 171 (switch_statement -> SWITCH switch_assignment SEMICOLON switch_expr LBRACE case_clause_list RBRACE .)
    FOR             reduce using rule 171 (switch_statement -> SWITCH switch_assignment SEMICOLON switch_expr LBRACE case_clause_list RBRACE .)
    CASE            reduce using rule 171 (switch_statement -> SWITCH switch_assignment SEMICOLON switch_expr LBRACE case_clause_list RBRACE .)
    DEFAULT         reduce using rule 171 (switch_statement -> SWITCH switch_assignment SEMICOLON switch_expr LBRACE case_clause_list RBRACE .)


state 342

    (97) for_classic -> FOR for_init SEMICOLON for_cond SEMICOLON for_post block .

    RBRACE          reduce using rule 97 (for_classic -> FOR for_init SEMICOLON for_cond SEMICOLON for_post block .)
    BREAK           reduce using rule 97 (for_classic -> FOR for_init SEMICOLON for_cond SEMICOLON for_post block .)
    CONTINUE        reduce using rule 97 (for_classic -> FOR for_init SEMICOLON for_cond SEMICOLON for_post block .)
    VAR             reduce using rule 97 (for_classic -> FOR for_init SEMICOLON for_cond SEMICOLON for_post block .)
    CONST           reduce using rule 97 (for_classic -> FOR for_init SEMICOLON for_cond SEMICOLON for_post block .)
    IDENTIFIER      reduce using rule 97 (for_classic -> FOR for_init SEMICOLON for_cond SEMICOLON for_post block .)
    LPAREN          reduce using rule 97 (for_classic -> FOR for_init SEMICOLON for_cond SEMICOLON for_post block .)
    INT             reduce using rule 97 (for_classic -> FOR for_init SEMICOLON for_cond SEMICOLON for_post block .)
    FLOAT64         reduce using rule 97 (for_classic -> FOR for_init SEMICOLON for_cond SEMICOLON for_post block .)
    STRING          reduce using rule 97 (for_classic -> FOR for_init SEMICOLON for_cond SEMICOLON for_post block .)
    TRUE            reduce using rule 97 (for_classic -> FOR for_init SEMICOLON for_cond SEMICOLON for_post block .)
    FALSE           reduce using rule 97 (for_classic -> FOR for_init SEMICOLON for_cond SEMICOLON for_post block .)
    LNOT            reduce using rule 97 (for_classic -> FOR for_init SEMICOLON for_cond SEMICOLON for_post block .)
    IF              reduce using rule 97 (for_classic -> FOR for_init SEMICOLON for_cond SEMICOLON for_post block .)
    SWITCH          reduce using rule 97 (for_classic -> FOR for_init SEMICOLON for_cond SEMICOLON for_post block .)
    RETURN          reduce using rule 97 (for_classic -> FOR for_init SEMICOLON for_cond SEMICOLON for_post block .)
    LBRACKET        reduce using rule 97 (for_classic -> FOR for_init SEMICOLON for_cond SEMICOLON for_post block .)
    MAP             reduce using rule 97 (for_classic -> FOR for_init SEMICOLON for_cond SEMICOLON for_post block .)
    FOR             reduce using rule 97 (for_classic -> FOR for_init SEMICOLON for_cond SEMICOLON for_post block .)
    CASE            reduce using rule 97 (for_classic -> FOR for_init SEMICOLON for_cond SEMICOLON for_post block .)
    DEFAULT         reduce using rule 97 (for_classic -> FOR for_init SEMICOLON for_cond SEMICOLON for_post block .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for IMPORT in state 2 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 51 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 53 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 61 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 63 resolved as shift
WARNING: shift/reduce conflict for DOT in state 105 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 105 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 105 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 105 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 105 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 105 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 105 resolved as shift
WARNING: shift/reduce conflict for EQ in state 105 resolved as shift
WARNING: shift/reduce conflict for NEQ in state 105 resolved as shift
WARNING: shift/reduce conflict for LT in state 105 resolved as shift
WARNING: shift/reduce conflict for LE in state 105 resolved as shift
WARNING: shift/reduce conflict for GT in state 105 resolved as shift
WARNING: shift/reduce conflict for GE in state 105 resolved as shift
WARNING: shift/reduce conflict for LAND in state 105 resolved as shift
WARNING: shift/reduce conflict for LOR in state 105 resolved as shift
WARNING: shift/reduce conflict for AND in state 105 resolved as shift
WARNING: shift/reduce conflict for OR in state 105 resolved as shift
WARNING: shift/reduce conflict for XOR in state 105 resolved as shift
WARNING: shift/reduce conflict for AND_NOT in state 105 resolved as shift
WARNING: shift/reduce conflict for LSHIFT in state 105 resolved as shift
WARNING: shift/reduce conflict for RSHIFT in state 105 resolved as shift
WARNING: shift/reduce conflict for DOT in state 128 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 128 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 128 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 128 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 128 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 128 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 128 resolved as shift
WARNING: shift/reduce conflict for EQ in state 128 resolved as shift
WARNING: shift/reduce conflict for NEQ in state 128 resolved as shift
WARNING: shift/reduce conflict for LT in state 128 resolved as shift
WARNING: shift/reduce conflict for LE in state 128 resolved as shift
WARNING: shift/reduce conflict for GT in state 128 resolved as shift
WARNING: shift/reduce conflict for GE in state 128 resolved as shift
WARNING: shift/reduce conflict for LAND in state 128 resolved as shift
WARNING: shift/reduce conflict for LOR in state 128 resolved as shift
WARNING: shift/reduce conflict for AND in state 128 resolved as shift
WARNING: shift/reduce conflict for OR in state 128 resolved as shift
WARNING: shift/reduce conflict for XOR in state 128 resolved as shift
WARNING: shift/reduce conflict for AND_NOT in state 128 resolved as shift
WARNING: shift/reduce conflict for LSHIFT in state 128 resolved as shift
WARNING: shift/reduce conflict for RSHIFT in state 128 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 129 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 194 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 202 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 209 resolved as shift
WARNING: shift/reduce conflict for INT in state 209 resolved as shift
WARNING: shift/reduce conflict for FLOAT64 in state 209 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 209 resolved as shift
WARNING: shift/reduce conflict for STRING in state 209 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 209 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 209 resolved as shift
WARNING: shift/reduce conflict for LNOT in state 209 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 209 resolved as shift
WARNING: shift/reduce conflict for MAP in state 209 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 252 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 264 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 265 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 266 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 287 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 289 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 306 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 310 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 311 resolved as shift
WARNING: reduce/reduce conflict in state 51 resolved using rule (expression -> IDENTIFIER)
WARNING: rejected rule (type_name -> IDENTIFIER) in state 51
WARNING: reduce/reduce conflict in state 233 resolved using rule (expression -> IDENTIFIER)
WARNING: rejected rule (type_name -> IDENTIFIER) in state 233
WARNING: reduce/reduce conflict in state 260 resolved using rule (expression -> IDENTIFIER)
WARNING: rejected rule (type_name -> IDENTIFIER) in state 260
WARNING: reduce/reduce conflict in state 338 resolved using rule (expression -> IDENTIFIER)
WARNING: rejected rule (type_name -> IDENTIFIER) in state 338
