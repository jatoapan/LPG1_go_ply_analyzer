Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    INTERFACE

Grammar

Rule 0     S' -> program
Rule 1     program -> package_declaration import global_statement_list
Rule 2     package_declaration -> PACKAGE IDENTIFIER
Rule 3     import -> simple_import
Rule 4     import -> import simple_import
Rule 5     import -> empty
Rule 6     simple_import -> IMPORT STRING
Rule 7     empty -> <empty>
Rule 8     global_statement_list -> global_statement
Rule 9     global_statement_list -> global_statement_list global_statement
Rule 10    global_statement -> simple_global_statement SEMICOLON
Rule 11    global_statement -> simple_global_statement
Rule 12    global_statement -> function_declaration
Rule 13    global_statement -> method_declaration
Rule 14    global_statement -> type_declaration
Rule 15    simple_global_statement -> var_dec
Rule 16    simple_global_statement -> var_dec simple_assign
Rule 17    simple_global_statement -> simple_assignment
Rule 18    simple_global_statement -> assignment_compound
Rule 19    simple_global_statement -> expression
Rule 20    var_dec -> VAR IDENTIFIER type
Rule 21    var_dec -> CONST IDENTIFIER type
Rule 22    var_dec -> VAR IDENTIFIER
Rule 23    var_dec -> CONST IDENTIFIER
Rule 24    simple_assign -> ASSIGN expression
Rule 25    assignment_compound -> IDENTIFIER operator_assign expression
Rule 26    operator_assign -> PLUS_ASSIGN
Rule 27    operator_assign -> MINUS_ASSIGN
Rule 28    operator_assign -> MULT_ASSIGN
Rule 29    operator_assign -> DIV_ASSIGN
Rule 30    operator_assign -> MOD_ASSIGN
Rule 31    operator_assign -> AND_ASSIGN
Rule 32    operator_assign -> OR_ASSIGN
Rule 33    operator_assign -> XOR_ASSIGN
Rule 34    operator_assign -> LSHIFT_ASSIGN
Rule 35    operator_assign -> RSHIFT_ASSIGN
Rule 36    expression -> expression binary_operator expression
Rule 37    binary_operator -> PLUS
Rule 38    binary_operator -> MINUS
Rule 39    binary_operator -> TIMES
Rule 40    binary_operator -> DIVIDE
Rule 41    binary_operator -> MODULE
Rule 42    binary_operator -> EQ
Rule 43    binary_operator -> NEQ
Rule 44    binary_operator -> LT
Rule 45    binary_operator -> LE
Rule 46    binary_operator -> GT
Rule 47    binary_operator -> GE
Rule 48    binary_operator -> LAND
Rule 49    binary_operator -> LOR
Rule 50    binary_operator -> AND
Rule 51    binary_operator -> OR
Rule 52    binary_operator -> XOR
Rule 53    binary_operator -> AND_NOT
Rule 54    binary_operator -> LSHIFT
Rule 55    binary_operator -> RSHIFT
Rule 56    simple_assignment -> IDENTIFIER simple_assign
Rule 57    type -> primitive_type
Rule 58    type -> slice_type
Rule 59    type -> array_type
Rule 60    type -> map_type
Rule 61    primitive_type -> INT_TYPE
Rule 62    primitive_type -> FLOAT64_TYPE
Rule 63    primitive_type -> STRING_TYPE
Rule 64    primitive_type -> BOOL_TYPE
Rule 65    slice_type -> LBRACKET RBRACKET primitive_type
Rule 66    expression -> slice_type LBRACE expression_list RBRACE
Rule 67    expression -> slice_type LBRACE RBRACE
Rule 68    expression_list -> expression
Rule 69    expression_list -> expression_list COMMA expression
Rule 70    expression -> LPAREN expression RPAREN
Rule 71    expression -> INT
Rule 72    expression -> FLOAT64
Rule 73    expression -> IDENTIFIER
Rule 74    expression -> STRING
Rule 75    expression -> TRUE
Rule 76    expression -> FALSE
Rule 77    short_assign -> SHORT_ASSIGN expression
Rule 78    short_assignment -> IDENTIFIER short_assign
Rule 79    local_statement -> var_dec
Rule 80    local_statement -> var_dec simple_assign
Rule 81    local_statement -> assignment_compound
Rule 82    local_statement -> expression
Rule 83    local_statement -> for_statement
Rule 84    local_statement -> if_statement
Rule 85    local_statement -> switch_statement
Rule 86    local_statement -> return_statement
Rule 87    block -> LBRACE local_statement_list RBRACE
Rule 88    block -> LBRACE RBRACE
Rule 89    local_statement_list -> local_statement
Rule 90    local_statement_list -> local_statement_list SEMICOLON local_statement
Rule 91    for_statement -> FOR for_init for_condition for_incr LBRACE for_body_list RBRACE
Rule 92    for_statement -> FOR for_init for_condition for_incr LBRACE RBRACE
Rule 93    for_init -> simple_assignment SEMICOLON
Rule 94    for_init -> short_assignment SEMICOLON
Rule 95    for_init -> SEMICOLON
Rule 96    for_init -> empty
Rule 97    for_condition -> expression SEMICOLON
Rule 98    for_condition -> SEMICOLON
Rule 99    for_condition -> empty
Rule 100   for_incr -> simple_assignment
Rule 101   for_incr -> short_assignment
Rule 102   for_incr -> empty
Rule 103   for_body_list -> for_body
Rule 104   for_body_list -> for_body_list SEMICOLON for_body
Rule 105   for_body -> local_statement
Rule 106   for_body -> BREAK
Rule 107   for_body -> CONTINUE
Rule 108   return_list -> expression
Rule 109   return_list -> return_list COMMA expression
Rule 110   function_declaration -> FUNC IDENTIFIER LPAREN parameter_list RPAREN return_type block
Rule 111   parameter_list -> parameter_list COMMA parameter
Rule 112   parameter_list -> parameter
Rule 113   parameter_list -> empty
Rule 114   parameter -> IDENTIFIER type
Rule 115   parameter -> IDENTIFIER ELLIPSIS primitive_type
Rule 116   return_type -> type
Rule 117   return_type -> LPAREN type_list RPAREN
Rule 118   return_type -> empty
Rule 119   type_list -> type
Rule 120   type_list -> type_list COMMA type
Rule 121   return_statement -> RETURN
Rule 122   return_statement -> RETURN return_list
Rule 123   expression -> LNOT expression
Rule 124   expression -> IDENTIFIER PLUSPLUS
Rule 125   expression -> IDENTIFIER MINUSMINUS
Rule 126   if_statement -> IF if_init if_condition block if_else_clause
Rule 127   if_init -> short_assignment SEMICOLON
Rule 128   if_init -> simple_assignment SEMICOLON
Rule 129   if_init -> empty
Rule 130   if_condition -> expression
Rule 131   if_else_clause -> ELSE block
Rule 132   if_else_clause -> ELSE if_statement
Rule 133   if_else_clause -> empty
Rule 134   map_type -> MAP LBRACKET primitive_type RBRACKET primitive_type
Rule 135   expression -> map_type LBRACE expression_map_list RBRACE
Rule 136   expression -> map_type LBRACE RBRACE
Rule 137   expression_map_list -> key_value
Rule 138   expression_map_list -> expression_map_list COMMA key_value
Rule 139   key_value -> expression COLON expression
Rule 140   field_list -> field_declaration
Rule 141   field_list -> field_list SEMICOLON field_declaration
Rule 142   field_declaration -> IDENTIFIER type
Rule 143   method_declaration -> FUNC LPAREN receiver RPAREN IDENTIFIER LPAREN parameter_list RPAREN return_type block
Rule 144   receiver -> IDENTIFIER IDENTIFIER
Rule 145   receiver -> IDENTIFIER TIMES IDENTIFIER
Rule 146   receiver -> IDENTIFIER TIMES type
Rule 147   type_declaration -> TYPE IDENTIFIER type_alias
Rule 148   type_alias -> struct_type
Rule 149   type_alias -> type
Rule 150   type_alias -> IDENTIFIER
Rule 151   struct_type -> STRUCT LBRACE RBRACE
Rule 152   struct_type -> STRUCT LBRACE field_list RBRACE
Rule 153   keyed_element_list -> keyed_element
Rule 154   keyed_element_list -> keyed_element_list COMMA keyed_element
Rule 155   keyed_element -> IDENTIFIER COLON expression
Rule 156   keyed_element -> INT COLON expression
Rule 157   keyed_element -> expression
Rule 158   expression -> IDENTIFIER LBRACE keyed_element_list RBRACE
Rule 159   expression -> IDENTIFIER LBRACE RBRACE
Rule 160   switch_statement -> SWITCH switch_init switch_expression LBRACE case_clauses RBRACE
Rule 161   switch_init -> short_assignment SEMICOLON
Rule 162   switch_init -> simple_assignment SEMICOLON
Rule 163   switch_init -> empty
Rule 164   switch_expression -> expression
Rule 165   switch_expression -> empty
Rule 166   case_clauses -> case_clause
Rule 167   case_clauses -> case_clauses case_clause
Rule 168   case_clause -> CASE expression_list COLON case_body
Rule 169   case_clause -> DEFAULT COLON case_body
Rule 170   case_body -> local_statement_list
Rule 171   case_body -> BREAK
Rule 172   case_body -> empty
Rule 173   array_type -> LBRACKET INT RBRACKET primitive_type
Rule 174   expression -> array_type LBRACE expression_list RBRACE
Rule 175   expression -> array_type LBRACE RBRACE
Rule 176   expression -> expression DOT IDENTIFIER
Rule 177   expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN
Rule 178   expression -> IDENTIFIER LPAREN argument_list RPAREN
Rule 179   argument_list -> expression_list
Rule 180   argument_list -> empty

Terminals, with rules where they appear

AND                  : 50
AND_ASSIGN           : 31
AND_NOT              : 53
ASSIGN               : 24
BOOL_TYPE            : 64
BREAK                : 106 171
CASE                 : 168
COLON                : 139 155 156 168 169
COMMA                : 69 109 111 120 138 154
CONST                : 21 23
CONTINUE             : 107
DEFAULT              : 169
DIVIDE               : 40
DIV_ASSIGN           : 29
DOT                  : 176 177
ELLIPSIS             : 115
ELSE                 : 131 132
EQ                   : 42
FALSE                : 76
FLOAT64              : 72
FLOAT64_TYPE         : 62
FOR                  : 91 92
FUNC                 : 110 143
GE                   : 47
GT                   : 46
IDENTIFIER           : 2 20 21 22 23 25 56 73 78 110 114 115 124 125 142 143 144 144 145 145 146 147 150 155 158 159 176 177 178
IF                   : 126
IMPORT               : 6
INT                  : 71 156 173
INTERFACE            : 
INT_TYPE             : 61
LAND                 : 48
LBRACE               : 66 67 87 88 91 92 135 136 151 152 158 159 160 174 175
LBRACKET             : 65 134 173
LE                   : 45
LNOT                 : 123
LOR                  : 49
LPAREN               : 70 110 117 143 143 177 178
LSHIFT               : 54
LSHIFT_ASSIGN        : 34
LT                   : 44
MAP                  : 134
MINUS                : 38
MINUSMINUS           : 125
MINUS_ASSIGN         : 27
MODULE               : 41
MOD_ASSIGN           : 30
MULT_ASSIGN          : 28
NEQ                  : 43
OR                   : 51
OR_ASSIGN            : 32
PACKAGE              : 2
PLUS                 : 37
PLUSPLUS             : 124
PLUS_ASSIGN          : 26
RBRACE               : 66 67 87 88 91 92 135 136 151 152 158 159 160 174 175
RBRACKET             : 65 134 173
RETURN               : 121 122
RPAREN               : 70 110 117 143 143 177 178
RSHIFT               : 55
RSHIFT_ASSIGN        : 35
SEMICOLON            : 10 90 93 94 95 97 98 104 127 128 141 161 162
SHORT_ASSIGN         : 77
STRING               : 6 74
STRING_TYPE          : 63
STRUCT               : 151 152
SWITCH               : 160
TIMES                : 39 145 146
TRUE                 : 75
TYPE                 : 147
VAR                  : 20 22
XOR                  : 52
XOR_ASSIGN           : 33
error                : 

Nonterminals, with rules where they appear

argument_list        : 177 178
array_type           : 59 174 175
assignment_compound  : 18 81
binary_operator      : 36
block                : 110 126 131 143
case_body            : 168 169
case_clause          : 166 167
case_clauses         : 160 167
empty                : 5 96 99 102 113 118 129 133 163 165 172 180
expression           : 19 24 25 36 36 68 69 70 77 82 97 108 109 123 130 139 139 155 156 157 164 176 177
expression_list      : 66 69 168 174 179
expression_map_list  : 135 138
field_declaration    : 140 141
field_list           : 141 152
for_body             : 103 104
for_body_list        : 91 104
for_condition        : 91 92
for_incr             : 91 92
for_init             : 91 92
for_statement        : 83
function_declaration : 12
global_statement     : 8 9
global_statement_list : 1 9
if_condition         : 126
if_else_clause       : 126
if_init              : 126
if_statement         : 84 132
import               : 1 4
key_value            : 137 138
keyed_element        : 153 154
keyed_element_list   : 154 158
local_statement      : 89 90 105
local_statement_list : 87 90 170
map_type             : 60 135 136
method_declaration   : 13
operator_assign      : 25
package_declaration  : 1
parameter            : 111 112
parameter_list       : 110 111 143
primitive_type       : 57 65 115 134 134 173
program              : 0
receiver             : 143
return_list          : 109 122
return_statement     : 86
return_type          : 110 143
short_assign         : 78
short_assignment     : 94 101 127 161
simple_assign        : 16 56 80
simple_assignment    : 17 93 100 128 162
simple_global_statement : 10 11
simple_import        : 3 4
slice_type           : 58 66 67
struct_type          : 148
switch_expression    : 160
switch_init          : 160
switch_statement     : 85
type                 : 20 21 114 116 119 120 142 146 149
type_alias           : 147
type_declaration     : 14
type_list            : 117 120
var_dec              : 15 16 79 80

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . package_declaration import global_statement_list
    (2) package_declaration -> . PACKAGE IDENTIFIER

    PACKAGE         shift and go to state 3

    program                        shift and go to state 1
    package_declaration            shift and go to state 2

state 1

    (0) S' -> program .



state 2

    (1) program -> package_declaration . import global_statement_list
    (3) import -> . simple_import
    (4) import -> . import simple_import
    (5) import -> . empty
    (6) simple_import -> . IMPORT STRING
    (7) empty -> .

  ! shift/reduce conflict for IMPORT resolved as shift
    IMPORT          shift and go to state 7
    FUNC            reduce using rule 7 (empty -> .)
    TYPE            reduce using rule 7 (empty -> .)
    VAR             reduce using rule 7 (empty -> .)
    CONST           reduce using rule 7 (empty -> .)
    IDENTIFIER      reduce using rule 7 (empty -> .)
    LPAREN          reduce using rule 7 (empty -> .)
    INT             reduce using rule 7 (empty -> .)
    FLOAT64         reduce using rule 7 (empty -> .)
    STRING          reduce using rule 7 (empty -> .)
    TRUE            reduce using rule 7 (empty -> .)
    FALSE           reduce using rule 7 (empty -> .)
    LNOT            reduce using rule 7 (empty -> .)
    LBRACKET        reduce using rule 7 (empty -> .)
    MAP             reduce using rule 7 (empty -> .)

  ! IMPORT          [ reduce using rule 7 (empty -> .) ]

    import                         shift and go to state 4
    simple_import                  shift and go to state 5
    empty                          shift and go to state 6

state 3

    (2) package_declaration -> PACKAGE . IDENTIFIER

    IDENTIFIER      shift and go to state 8


state 4

    (1) program -> package_declaration import . global_statement_list
    (4) import -> import . simple_import
    (8) global_statement_list -> . global_statement
    (9) global_statement_list -> . global_statement_list global_statement
    (6) simple_import -> . IMPORT STRING
    (10) global_statement -> . simple_global_statement SEMICOLON
    (11) global_statement -> . simple_global_statement
    (12) global_statement -> . function_declaration
    (13) global_statement -> . method_declaration
    (14) global_statement -> . type_declaration
    (15) simple_global_statement -> . var_dec
    (16) simple_global_statement -> . var_dec simple_assign
    (17) simple_global_statement -> . simple_assignment
    (18) simple_global_statement -> . assignment_compound
    (19) simple_global_statement -> . expression
    (110) function_declaration -> . FUNC IDENTIFIER LPAREN parameter_list RPAREN return_type block
    (143) method_declaration -> . FUNC LPAREN receiver RPAREN IDENTIFIER LPAREN parameter_list RPAREN return_type block
    (147) type_declaration -> . TYPE IDENTIFIER type_alias
    (20) var_dec -> . VAR IDENTIFIER type
    (21) var_dec -> . CONST IDENTIFIER type
    (22) var_dec -> . VAR IDENTIFIER
    (23) var_dec -> . CONST IDENTIFIER
    (56) simple_assignment -> . IDENTIFIER simple_assign
    (25) assignment_compound -> . IDENTIFIER operator_assign expression
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (123) expression -> . LNOT expression
    (124) expression -> . IDENTIFIER PLUSPLUS
    (125) expression -> . IDENTIFIER MINUSMINUS
    (135) expression -> . map_type LBRACE expression_map_list RBRACE
    (136) expression -> . map_type LBRACE RBRACE
    (158) expression -> . IDENTIFIER LBRACE keyed_element_list RBRACE
    (159) expression -> . IDENTIFIER LBRACE RBRACE
    (174) expression -> . array_type LBRACE expression_list RBRACE
    (175) expression -> . array_type LBRACE RBRACE
    (176) expression -> . expression DOT IDENTIFIER
    (177) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (178) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (134) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (173) array_type -> . LBRACKET INT RBRACKET primitive_type

    IMPORT          shift and go to state 7
    FUNC            shift and go to state 21
    TYPE            shift and go to state 24
    VAR             shift and go to state 25
    CONST           shift and go to state 26
    IDENTIFIER      shift and go to state 22
    LPAREN          shift and go to state 23
    INT             shift and go to state 28
    FLOAT64         shift and go to state 29
    STRING          shift and go to state 12
    TRUE            shift and go to state 30
    FALSE           shift and go to state 31
    LNOT            shift and go to state 32
    LBRACKET        shift and go to state 35
    MAP             shift and go to state 36

    global_statement_list          shift and go to state 9
    simple_import                  shift and go to state 10
    global_statement               shift and go to state 11
    simple_global_statement        shift and go to state 13
    function_declaration           shift and go to state 14
    method_declaration             shift and go to state 15
    type_declaration               shift and go to state 16
    var_dec                        shift and go to state 17
    simple_assignment              shift and go to state 18
    assignment_compound            shift and go to state 19
    expression                     shift and go to state 20
    slice_type                     shift and go to state 27
    map_type                       shift and go to state 33
    array_type                     shift and go to state 34

state 5

    (3) import -> simple_import .

    IMPORT          reduce using rule 3 (import -> simple_import .)
    FUNC            reduce using rule 3 (import -> simple_import .)
    TYPE            reduce using rule 3 (import -> simple_import .)
    VAR             reduce using rule 3 (import -> simple_import .)
    CONST           reduce using rule 3 (import -> simple_import .)
    IDENTIFIER      reduce using rule 3 (import -> simple_import .)
    LPAREN          reduce using rule 3 (import -> simple_import .)
    INT             reduce using rule 3 (import -> simple_import .)
    FLOAT64         reduce using rule 3 (import -> simple_import .)
    STRING          reduce using rule 3 (import -> simple_import .)
    TRUE            reduce using rule 3 (import -> simple_import .)
    FALSE           reduce using rule 3 (import -> simple_import .)
    LNOT            reduce using rule 3 (import -> simple_import .)
    LBRACKET        reduce using rule 3 (import -> simple_import .)
    MAP             reduce using rule 3 (import -> simple_import .)


state 6

    (5) import -> empty .

    IMPORT          reduce using rule 5 (import -> empty .)
    FUNC            reduce using rule 5 (import -> empty .)
    TYPE            reduce using rule 5 (import -> empty .)
    VAR             reduce using rule 5 (import -> empty .)
    CONST           reduce using rule 5 (import -> empty .)
    IDENTIFIER      reduce using rule 5 (import -> empty .)
    LPAREN          reduce using rule 5 (import -> empty .)
    INT             reduce using rule 5 (import -> empty .)
    FLOAT64         reduce using rule 5 (import -> empty .)
    STRING          reduce using rule 5 (import -> empty .)
    TRUE            reduce using rule 5 (import -> empty .)
    FALSE           reduce using rule 5 (import -> empty .)
    LNOT            reduce using rule 5 (import -> empty .)
    LBRACKET        reduce using rule 5 (import -> empty .)
    MAP             reduce using rule 5 (import -> empty .)


state 7

    (6) simple_import -> IMPORT . STRING

    STRING          shift and go to state 37


state 8

    (2) package_declaration -> PACKAGE IDENTIFIER .

    IMPORT          reduce using rule 2 (package_declaration -> PACKAGE IDENTIFIER .)
    FUNC            reduce using rule 2 (package_declaration -> PACKAGE IDENTIFIER .)
    TYPE            reduce using rule 2 (package_declaration -> PACKAGE IDENTIFIER .)
    VAR             reduce using rule 2 (package_declaration -> PACKAGE IDENTIFIER .)
    CONST           reduce using rule 2 (package_declaration -> PACKAGE IDENTIFIER .)
    IDENTIFIER      reduce using rule 2 (package_declaration -> PACKAGE IDENTIFIER .)
    LPAREN          reduce using rule 2 (package_declaration -> PACKAGE IDENTIFIER .)
    INT             reduce using rule 2 (package_declaration -> PACKAGE IDENTIFIER .)
    FLOAT64         reduce using rule 2 (package_declaration -> PACKAGE IDENTIFIER .)
    STRING          reduce using rule 2 (package_declaration -> PACKAGE IDENTIFIER .)
    TRUE            reduce using rule 2 (package_declaration -> PACKAGE IDENTIFIER .)
    FALSE           reduce using rule 2 (package_declaration -> PACKAGE IDENTIFIER .)
    LNOT            reduce using rule 2 (package_declaration -> PACKAGE IDENTIFIER .)
    LBRACKET        reduce using rule 2 (package_declaration -> PACKAGE IDENTIFIER .)
    MAP             reduce using rule 2 (package_declaration -> PACKAGE IDENTIFIER .)


state 9

    (1) program -> package_declaration import global_statement_list .
    (9) global_statement_list -> global_statement_list . global_statement
    (10) global_statement -> . simple_global_statement SEMICOLON
    (11) global_statement -> . simple_global_statement
    (12) global_statement -> . function_declaration
    (13) global_statement -> . method_declaration
    (14) global_statement -> . type_declaration
    (15) simple_global_statement -> . var_dec
    (16) simple_global_statement -> . var_dec simple_assign
    (17) simple_global_statement -> . simple_assignment
    (18) simple_global_statement -> . assignment_compound
    (19) simple_global_statement -> . expression
    (110) function_declaration -> . FUNC IDENTIFIER LPAREN parameter_list RPAREN return_type block
    (143) method_declaration -> . FUNC LPAREN receiver RPAREN IDENTIFIER LPAREN parameter_list RPAREN return_type block
    (147) type_declaration -> . TYPE IDENTIFIER type_alias
    (20) var_dec -> . VAR IDENTIFIER type
    (21) var_dec -> . CONST IDENTIFIER type
    (22) var_dec -> . VAR IDENTIFIER
    (23) var_dec -> . CONST IDENTIFIER
    (56) simple_assignment -> . IDENTIFIER simple_assign
    (25) assignment_compound -> . IDENTIFIER operator_assign expression
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (123) expression -> . LNOT expression
    (124) expression -> . IDENTIFIER PLUSPLUS
    (125) expression -> . IDENTIFIER MINUSMINUS
    (135) expression -> . map_type LBRACE expression_map_list RBRACE
    (136) expression -> . map_type LBRACE RBRACE
    (158) expression -> . IDENTIFIER LBRACE keyed_element_list RBRACE
    (159) expression -> . IDENTIFIER LBRACE RBRACE
    (174) expression -> . array_type LBRACE expression_list RBRACE
    (175) expression -> . array_type LBRACE RBRACE
    (176) expression -> . expression DOT IDENTIFIER
    (177) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (178) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (134) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (173) array_type -> . LBRACKET INT RBRACKET primitive_type

    $end            reduce using rule 1 (program -> package_declaration import global_statement_list .)
    FUNC            shift and go to state 21
    TYPE            shift and go to state 24
    VAR             shift and go to state 25
    CONST           shift and go to state 26
    IDENTIFIER      shift and go to state 22
    LPAREN          shift and go to state 23
    INT             shift and go to state 28
    FLOAT64         shift and go to state 29
    STRING          shift and go to state 12
    TRUE            shift and go to state 30
    FALSE           shift and go to state 31
    LNOT            shift and go to state 32
    LBRACKET        shift and go to state 35
    MAP             shift and go to state 36

    global_statement               shift and go to state 38
    simple_global_statement        shift and go to state 13
    function_declaration           shift and go to state 14
    method_declaration             shift and go to state 15
    type_declaration               shift and go to state 16
    var_dec                        shift and go to state 17
    simple_assignment              shift and go to state 18
    assignment_compound            shift and go to state 19
    expression                     shift and go to state 20
    slice_type                     shift and go to state 27
    map_type                       shift and go to state 33
    array_type                     shift and go to state 34

state 10

    (4) import -> import simple_import .

    IMPORT          reduce using rule 4 (import -> import simple_import .)
    FUNC            reduce using rule 4 (import -> import simple_import .)
    TYPE            reduce using rule 4 (import -> import simple_import .)
    VAR             reduce using rule 4 (import -> import simple_import .)
    CONST           reduce using rule 4 (import -> import simple_import .)
    IDENTIFIER      reduce using rule 4 (import -> import simple_import .)
    LPAREN          reduce using rule 4 (import -> import simple_import .)
    INT             reduce using rule 4 (import -> import simple_import .)
    FLOAT64         reduce using rule 4 (import -> import simple_import .)
    STRING          reduce using rule 4 (import -> import simple_import .)
    TRUE            reduce using rule 4 (import -> import simple_import .)
    FALSE           reduce using rule 4 (import -> import simple_import .)
    LNOT            reduce using rule 4 (import -> import simple_import .)
    LBRACKET        reduce using rule 4 (import -> import simple_import .)
    MAP             reduce using rule 4 (import -> import simple_import .)


state 11

    (8) global_statement_list -> global_statement .

    FUNC            reduce using rule 8 (global_statement_list -> global_statement .)
    TYPE            reduce using rule 8 (global_statement_list -> global_statement .)
    VAR             reduce using rule 8 (global_statement_list -> global_statement .)
    CONST           reduce using rule 8 (global_statement_list -> global_statement .)
    IDENTIFIER      reduce using rule 8 (global_statement_list -> global_statement .)
    LPAREN          reduce using rule 8 (global_statement_list -> global_statement .)
    INT             reduce using rule 8 (global_statement_list -> global_statement .)
    FLOAT64         reduce using rule 8 (global_statement_list -> global_statement .)
    STRING          reduce using rule 8 (global_statement_list -> global_statement .)
    TRUE            reduce using rule 8 (global_statement_list -> global_statement .)
    FALSE           reduce using rule 8 (global_statement_list -> global_statement .)
    LNOT            reduce using rule 8 (global_statement_list -> global_statement .)
    LBRACKET        reduce using rule 8 (global_statement_list -> global_statement .)
    MAP             reduce using rule 8 (global_statement_list -> global_statement .)
    $end            reduce using rule 8 (global_statement_list -> global_statement .)


state 12

    (74) expression -> STRING .

    DOT             reduce using rule 74 (expression -> STRING .)
    PLUS            reduce using rule 74 (expression -> STRING .)
    MINUS           reduce using rule 74 (expression -> STRING .)
    TIMES           reduce using rule 74 (expression -> STRING .)
    DIVIDE          reduce using rule 74 (expression -> STRING .)
    MODULE          reduce using rule 74 (expression -> STRING .)
    EQ              reduce using rule 74 (expression -> STRING .)
    NEQ             reduce using rule 74 (expression -> STRING .)
    LT              reduce using rule 74 (expression -> STRING .)
    LE              reduce using rule 74 (expression -> STRING .)
    GT              reduce using rule 74 (expression -> STRING .)
    GE              reduce using rule 74 (expression -> STRING .)
    LAND            reduce using rule 74 (expression -> STRING .)
    LOR             reduce using rule 74 (expression -> STRING .)
    AND             reduce using rule 74 (expression -> STRING .)
    OR              reduce using rule 74 (expression -> STRING .)
    XOR             reduce using rule 74 (expression -> STRING .)
    AND_NOT         reduce using rule 74 (expression -> STRING .)
    LSHIFT          reduce using rule 74 (expression -> STRING .)
    RSHIFT          reduce using rule 74 (expression -> STRING .)
    SEMICOLON       reduce using rule 74 (expression -> STRING .)
    FUNC            reduce using rule 74 (expression -> STRING .)
    TYPE            reduce using rule 74 (expression -> STRING .)
    VAR             reduce using rule 74 (expression -> STRING .)
    CONST           reduce using rule 74 (expression -> STRING .)
    IDENTIFIER      reduce using rule 74 (expression -> STRING .)
    LPAREN          reduce using rule 74 (expression -> STRING .)
    INT             reduce using rule 74 (expression -> STRING .)
    FLOAT64         reduce using rule 74 (expression -> STRING .)
    STRING          reduce using rule 74 (expression -> STRING .)
    TRUE            reduce using rule 74 (expression -> STRING .)
    FALSE           reduce using rule 74 (expression -> STRING .)
    LNOT            reduce using rule 74 (expression -> STRING .)
    LBRACKET        reduce using rule 74 (expression -> STRING .)
    MAP             reduce using rule 74 (expression -> STRING .)
    $end            reduce using rule 74 (expression -> STRING .)
    RPAREN          reduce using rule 74 (expression -> STRING .)
    RBRACE          reduce using rule 74 (expression -> STRING .)
    CASE            reduce using rule 74 (expression -> STRING .)
    DEFAULT         reduce using rule 74 (expression -> STRING .)
    LBRACE          reduce using rule 74 (expression -> STRING .)
    COMMA           reduce using rule 74 (expression -> STRING .)
    COLON           reduce using rule 74 (expression -> STRING .)


state 13

    (10) global_statement -> simple_global_statement . SEMICOLON
    (11) global_statement -> simple_global_statement .

    SEMICOLON       shift and go to state 39
    FUNC            reduce using rule 11 (global_statement -> simple_global_statement .)
    TYPE            reduce using rule 11 (global_statement -> simple_global_statement .)
    VAR             reduce using rule 11 (global_statement -> simple_global_statement .)
    CONST           reduce using rule 11 (global_statement -> simple_global_statement .)
    IDENTIFIER      reduce using rule 11 (global_statement -> simple_global_statement .)
    LPAREN          reduce using rule 11 (global_statement -> simple_global_statement .)
    INT             reduce using rule 11 (global_statement -> simple_global_statement .)
    FLOAT64         reduce using rule 11 (global_statement -> simple_global_statement .)
    STRING          reduce using rule 11 (global_statement -> simple_global_statement .)
    TRUE            reduce using rule 11 (global_statement -> simple_global_statement .)
    FALSE           reduce using rule 11 (global_statement -> simple_global_statement .)
    LNOT            reduce using rule 11 (global_statement -> simple_global_statement .)
    LBRACKET        reduce using rule 11 (global_statement -> simple_global_statement .)
    MAP             reduce using rule 11 (global_statement -> simple_global_statement .)
    $end            reduce using rule 11 (global_statement -> simple_global_statement .)


state 14

    (12) global_statement -> function_declaration .

    FUNC            reduce using rule 12 (global_statement -> function_declaration .)
    TYPE            reduce using rule 12 (global_statement -> function_declaration .)
    VAR             reduce using rule 12 (global_statement -> function_declaration .)
    CONST           reduce using rule 12 (global_statement -> function_declaration .)
    IDENTIFIER      reduce using rule 12 (global_statement -> function_declaration .)
    LPAREN          reduce using rule 12 (global_statement -> function_declaration .)
    INT             reduce using rule 12 (global_statement -> function_declaration .)
    FLOAT64         reduce using rule 12 (global_statement -> function_declaration .)
    STRING          reduce using rule 12 (global_statement -> function_declaration .)
    TRUE            reduce using rule 12 (global_statement -> function_declaration .)
    FALSE           reduce using rule 12 (global_statement -> function_declaration .)
    LNOT            reduce using rule 12 (global_statement -> function_declaration .)
    LBRACKET        reduce using rule 12 (global_statement -> function_declaration .)
    MAP             reduce using rule 12 (global_statement -> function_declaration .)
    $end            reduce using rule 12 (global_statement -> function_declaration .)


state 15

    (13) global_statement -> method_declaration .

    FUNC            reduce using rule 13 (global_statement -> method_declaration .)
    TYPE            reduce using rule 13 (global_statement -> method_declaration .)
    VAR             reduce using rule 13 (global_statement -> method_declaration .)
    CONST           reduce using rule 13 (global_statement -> method_declaration .)
    IDENTIFIER      reduce using rule 13 (global_statement -> method_declaration .)
    LPAREN          reduce using rule 13 (global_statement -> method_declaration .)
    INT             reduce using rule 13 (global_statement -> method_declaration .)
    FLOAT64         reduce using rule 13 (global_statement -> method_declaration .)
    STRING          reduce using rule 13 (global_statement -> method_declaration .)
    TRUE            reduce using rule 13 (global_statement -> method_declaration .)
    FALSE           reduce using rule 13 (global_statement -> method_declaration .)
    LNOT            reduce using rule 13 (global_statement -> method_declaration .)
    LBRACKET        reduce using rule 13 (global_statement -> method_declaration .)
    MAP             reduce using rule 13 (global_statement -> method_declaration .)
    $end            reduce using rule 13 (global_statement -> method_declaration .)


state 16

    (14) global_statement -> type_declaration .

    FUNC            reduce using rule 14 (global_statement -> type_declaration .)
    TYPE            reduce using rule 14 (global_statement -> type_declaration .)
    VAR             reduce using rule 14 (global_statement -> type_declaration .)
    CONST           reduce using rule 14 (global_statement -> type_declaration .)
    IDENTIFIER      reduce using rule 14 (global_statement -> type_declaration .)
    LPAREN          reduce using rule 14 (global_statement -> type_declaration .)
    INT             reduce using rule 14 (global_statement -> type_declaration .)
    FLOAT64         reduce using rule 14 (global_statement -> type_declaration .)
    STRING          reduce using rule 14 (global_statement -> type_declaration .)
    TRUE            reduce using rule 14 (global_statement -> type_declaration .)
    FALSE           reduce using rule 14 (global_statement -> type_declaration .)
    LNOT            reduce using rule 14 (global_statement -> type_declaration .)
    LBRACKET        reduce using rule 14 (global_statement -> type_declaration .)
    MAP             reduce using rule 14 (global_statement -> type_declaration .)
    $end            reduce using rule 14 (global_statement -> type_declaration .)


state 17

    (15) simple_global_statement -> var_dec .
    (16) simple_global_statement -> var_dec . simple_assign
    (24) simple_assign -> . ASSIGN expression

    SEMICOLON       reduce using rule 15 (simple_global_statement -> var_dec .)
    FUNC            reduce using rule 15 (simple_global_statement -> var_dec .)
    TYPE            reduce using rule 15 (simple_global_statement -> var_dec .)
    VAR             reduce using rule 15 (simple_global_statement -> var_dec .)
    CONST           reduce using rule 15 (simple_global_statement -> var_dec .)
    IDENTIFIER      reduce using rule 15 (simple_global_statement -> var_dec .)
    LPAREN          reduce using rule 15 (simple_global_statement -> var_dec .)
    INT             reduce using rule 15 (simple_global_statement -> var_dec .)
    FLOAT64         reduce using rule 15 (simple_global_statement -> var_dec .)
    STRING          reduce using rule 15 (simple_global_statement -> var_dec .)
    TRUE            reduce using rule 15 (simple_global_statement -> var_dec .)
    FALSE           reduce using rule 15 (simple_global_statement -> var_dec .)
    LNOT            reduce using rule 15 (simple_global_statement -> var_dec .)
    LBRACKET        reduce using rule 15 (simple_global_statement -> var_dec .)
    MAP             reduce using rule 15 (simple_global_statement -> var_dec .)
    $end            reduce using rule 15 (simple_global_statement -> var_dec .)
    ASSIGN          shift and go to state 41

    simple_assign                  shift and go to state 40

state 18

    (17) simple_global_statement -> simple_assignment .

    SEMICOLON       reduce using rule 17 (simple_global_statement -> simple_assignment .)
    FUNC            reduce using rule 17 (simple_global_statement -> simple_assignment .)
    TYPE            reduce using rule 17 (simple_global_statement -> simple_assignment .)
    VAR             reduce using rule 17 (simple_global_statement -> simple_assignment .)
    CONST           reduce using rule 17 (simple_global_statement -> simple_assignment .)
    IDENTIFIER      reduce using rule 17 (simple_global_statement -> simple_assignment .)
    LPAREN          reduce using rule 17 (simple_global_statement -> simple_assignment .)
    INT             reduce using rule 17 (simple_global_statement -> simple_assignment .)
    FLOAT64         reduce using rule 17 (simple_global_statement -> simple_assignment .)
    STRING          reduce using rule 17 (simple_global_statement -> simple_assignment .)
    TRUE            reduce using rule 17 (simple_global_statement -> simple_assignment .)
    FALSE           reduce using rule 17 (simple_global_statement -> simple_assignment .)
    LNOT            reduce using rule 17 (simple_global_statement -> simple_assignment .)
    LBRACKET        reduce using rule 17 (simple_global_statement -> simple_assignment .)
    MAP             reduce using rule 17 (simple_global_statement -> simple_assignment .)
    $end            reduce using rule 17 (simple_global_statement -> simple_assignment .)


state 19

    (18) simple_global_statement -> assignment_compound .

    SEMICOLON       reduce using rule 18 (simple_global_statement -> assignment_compound .)
    FUNC            reduce using rule 18 (simple_global_statement -> assignment_compound .)
    TYPE            reduce using rule 18 (simple_global_statement -> assignment_compound .)
    VAR             reduce using rule 18 (simple_global_statement -> assignment_compound .)
    CONST           reduce using rule 18 (simple_global_statement -> assignment_compound .)
    IDENTIFIER      reduce using rule 18 (simple_global_statement -> assignment_compound .)
    LPAREN          reduce using rule 18 (simple_global_statement -> assignment_compound .)
    INT             reduce using rule 18 (simple_global_statement -> assignment_compound .)
    FLOAT64         reduce using rule 18 (simple_global_statement -> assignment_compound .)
    STRING          reduce using rule 18 (simple_global_statement -> assignment_compound .)
    TRUE            reduce using rule 18 (simple_global_statement -> assignment_compound .)
    FALSE           reduce using rule 18 (simple_global_statement -> assignment_compound .)
    LNOT            reduce using rule 18 (simple_global_statement -> assignment_compound .)
    LBRACKET        reduce using rule 18 (simple_global_statement -> assignment_compound .)
    MAP             reduce using rule 18 (simple_global_statement -> assignment_compound .)
    $end            reduce using rule 18 (simple_global_statement -> assignment_compound .)


state 20

    (19) simple_global_statement -> expression .
    (36) expression -> expression . binary_operator expression
    (176) expression -> expression . DOT IDENTIFIER
    (177) expression -> expression . DOT IDENTIFIER LPAREN argument_list RPAREN
    (37) binary_operator -> . PLUS
    (38) binary_operator -> . MINUS
    (39) binary_operator -> . TIMES
    (40) binary_operator -> . DIVIDE
    (41) binary_operator -> . MODULE
    (42) binary_operator -> . EQ
    (43) binary_operator -> . NEQ
    (44) binary_operator -> . LT
    (45) binary_operator -> . LE
    (46) binary_operator -> . GT
    (47) binary_operator -> . GE
    (48) binary_operator -> . LAND
    (49) binary_operator -> . LOR
    (50) binary_operator -> . AND
    (51) binary_operator -> . OR
    (52) binary_operator -> . XOR
    (53) binary_operator -> . AND_NOT
    (54) binary_operator -> . LSHIFT
    (55) binary_operator -> . RSHIFT

    SEMICOLON       reduce using rule 19 (simple_global_statement -> expression .)
    FUNC            reduce using rule 19 (simple_global_statement -> expression .)
    TYPE            reduce using rule 19 (simple_global_statement -> expression .)
    VAR             reduce using rule 19 (simple_global_statement -> expression .)
    CONST           reduce using rule 19 (simple_global_statement -> expression .)
    IDENTIFIER      reduce using rule 19 (simple_global_statement -> expression .)
    LPAREN          reduce using rule 19 (simple_global_statement -> expression .)
    INT             reduce using rule 19 (simple_global_statement -> expression .)
    FLOAT64         reduce using rule 19 (simple_global_statement -> expression .)
    STRING          reduce using rule 19 (simple_global_statement -> expression .)
    TRUE            reduce using rule 19 (simple_global_statement -> expression .)
    FALSE           reduce using rule 19 (simple_global_statement -> expression .)
    LNOT            reduce using rule 19 (simple_global_statement -> expression .)
    LBRACKET        reduce using rule 19 (simple_global_statement -> expression .)
    MAP             reduce using rule 19 (simple_global_statement -> expression .)
    $end            reduce using rule 19 (simple_global_statement -> expression .)
    DOT             shift and go to state 43
    PLUS            shift and go to state 44
    MINUS           shift and go to state 45
    TIMES           shift and go to state 46
    DIVIDE          shift and go to state 47
    MODULE          shift and go to state 48
    EQ              shift and go to state 49
    NEQ             shift and go to state 50
    LT              shift and go to state 51
    LE              shift and go to state 52
    GT              shift and go to state 53
    GE              shift and go to state 54
    LAND            shift and go to state 55
    LOR             shift and go to state 56
    AND             shift and go to state 57
    OR              shift and go to state 58
    XOR             shift and go to state 59
    AND_NOT         shift and go to state 60
    LSHIFT          shift and go to state 61
    RSHIFT          shift and go to state 62

    binary_operator                shift and go to state 42

state 21

    (110) function_declaration -> FUNC . IDENTIFIER LPAREN parameter_list RPAREN return_type block
    (143) method_declaration -> FUNC . LPAREN receiver RPAREN IDENTIFIER LPAREN parameter_list RPAREN return_type block

    IDENTIFIER      shift and go to state 63
    LPAREN          shift and go to state 64


state 22

    (56) simple_assignment -> IDENTIFIER . simple_assign
    (25) assignment_compound -> IDENTIFIER . operator_assign expression
    (73) expression -> IDENTIFIER .
    (124) expression -> IDENTIFIER . PLUSPLUS
    (125) expression -> IDENTIFIER . MINUSMINUS
    (158) expression -> IDENTIFIER . LBRACE keyed_element_list RBRACE
    (159) expression -> IDENTIFIER . LBRACE RBRACE
    (178) expression -> IDENTIFIER . LPAREN argument_list RPAREN
    (24) simple_assign -> . ASSIGN expression
    (26) operator_assign -> . PLUS_ASSIGN
    (27) operator_assign -> . MINUS_ASSIGN
    (28) operator_assign -> . MULT_ASSIGN
    (29) operator_assign -> . DIV_ASSIGN
    (30) operator_assign -> . MOD_ASSIGN
    (31) operator_assign -> . AND_ASSIGN
    (32) operator_assign -> . OR_ASSIGN
    (33) operator_assign -> . XOR_ASSIGN
    (34) operator_assign -> . LSHIFT_ASSIGN
    (35) operator_assign -> . RSHIFT_ASSIGN

  ! shift/reduce conflict for LPAREN resolved as shift
    DOT             reduce using rule 73 (expression -> IDENTIFIER .)
    PLUS            reduce using rule 73 (expression -> IDENTIFIER .)
    MINUS           reduce using rule 73 (expression -> IDENTIFIER .)
    TIMES           reduce using rule 73 (expression -> IDENTIFIER .)
    DIVIDE          reduce using rule 73 (expression -> IDENTIFIER .)
    MODULE          reduce using rule 73 (expression -> IDENTIFIER .)
    EQ              reduce using rule 73 (expression -> IDENTIFIER .)
    NEQ             reduce using rule 73 (expression -> IDENTIFIER .)
    LT              reduce using rule 73 (expression -> IDENTIFIER .)
    LE              reduce using rule 73 (expression -> IDENTIFIER .)
    GT              reduce using rule 73 (expression -> IDENTIFIER .)
    GE              reduce using rule 73 (expression -> IDENTIFIER .)
    LAND            reduce using rule 73 (expression -> IDENTIFIER .)
    LOR             reduce using rule 73 (expression -> IDENTIFIER .)
    AND             reduce using rule 73 (expression -> IDENTIFIER .)
    OR              reduce using rule 73 (expression -> IDENTIFIER .)
    XOR             reduce using rule 73 (expression -> IDENTIFIER .)
    AND_NOT         reduce using rule 73 (expression -> IDENTIFIER .)
    LSHIFT          reduce using rule 73 (expression -> IDENTIFIER .)
    RSHIFT          reduce using rule 73 (expression -> IDENTIFIER .)
    SEMICOLON       reduce using rule 73 (expression -> IDENTIFIER .)
    FUNC            reduce using rule 73 (expression -> IDENTIFIER .)
    TYPE            reduce using rule 73 (expression -> IDENTIFIER .)
    VAR             reduce using rule 73 (expression -> IDENTIFIER .)
    CONST           reduce using rule 73 (expression -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 73 (expression -> IDENTIFIER .)
    INT             reduce using rule 73 (expression -> IDENTIFIER .)
    FLOAT64         reduce using rule 73 (expression -> IDENTIFIER .)
    STRING          reduce using rule 73 (expression -> IDENTIFIER .)
    TRUE            reduce using rule 73 (expression -> IDENTIFIER .)
    FALSE           reduce using rule 73 (expression -> IDENTIFIER .)
    LNOT            reduce using rule 73 (expression -> IDENTIFIER .)
    LBRACKET        reduce using rule 73 (expression -> IDENTIFIER .)
    MAP             reduce using rule 73 (expression -> IDENTIFIER .)
    $end            reduce using rule 73 (expression -> IDENTIFIER .)
    PLUSPLUS        shift and go to state 67
    MINUSMINUS      shift and go to state 68
    LBRACE          shift and go to state 69
    LPAREN          shift and go to state 70
    ASSIGN          shift and go to state 41
    PLUS_ASSIGN     shift and go to state 71
    MINUS_ASSIGN    shift and go to state 72
    MULT_ASSIGN     shift and go to state 73
    DIV_ASSIGN      shift and go to state 74
    MOD_ASSIGN      shift and go to state 75
    AND_ASSIGN      shift and go to state 76
    OR_ASSIGN       shift and go to state 77
    XOR_ASSIGN      shift and go to state 78
    LSHIFT_ASSIGN   shift and go to state 79
    RSHIFT_ASSIGN   shift and go to state 80

  ! LPAREN          [ reduce using rule 73 (expression -> IDENTIFIER .) ]

    simple_assign                  shift and go to state 65
    operator_assign                shift and go to state 66

state 23

    (70) expression -> LPAREN . expression RPAREN
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (123) expression -> . LNOT expression
    (124) expression -> . IDENTIFIER PLUSPLUS
    (125) expression -> . IDENTIFIER MINUSMINUS
    (135) expression -> . map_type LBRACE expression_map_list RBRACE
    (136) expression -> . map_type LBRACE RBRACE
    (158) expression -> . IDENTIFIER LBRACE keyed_element_list RBRACE
    (159) expression -> . IDENTIFIER LBRACE RBRACE
    (174) expression -> . array_type LBRACE expression_list RBRACE
    (175) expression -> . array_type LBRACE RBRACE
    (176) expression -> . expression DOT IDENTIFIER
    (177) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (178) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (134) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (173) array_type -> . LBRACKET INT RBRACKET primitive_type

    LPAREN          shift and go to state 23
    INT             shift and go to state 28
    FLOAT64         shift and go to state 29
    IDENTIFIER      shift and go to state 82
    STRING          shift and go to state 12
    TRUE            shift and go to state 30
    FALSE           shift and go to state 31
    LNOT            shift and go to state 32
    LBRACKET        shift and go to state 35
    MAP             shift and go to state 36

    expression                     shift and go to state 81
    slice_type                     shift and go to state 27
    map_type                       shift and go to state 33
    array_type                     shift and go to state 34

state 24

    (147) type_declaration -> TYPE . IDENTIFIER type_alias

    IDENTIFIER      shift and go to state 83


state 25

    (20) var_dec -> VAR . IDENTIFIER type
    (22) var_dec -> VAR . IDENTIFIER

    IDENTIFIER      shift and go to state 84


state 26

    (21) var_dec -> CONST . IDENTIFIER type
    (23) var_dec -> CONST . IDENTIFIER

    IDENTIFIER      shift and go to state 85


state 27

    (66) expression -> slice_type . LBRACE expression_list RBRACE
    (67) expression -> slice_type . LBRACE RBRACE

    LBRACE          shift and go to state 86


state 28

    (71) expression -> INT .

    DOT             reduce using rule 71 (expression -> INT .)
    PLUS            reduce using rule 71 (expression -> INT .)
    MINUS           reduce using rule 71 (expression -> INT .)
    TIMES           reduce using rule 71 (expression -> INT .)
    DIVIDE          reduce using rule 71 (expression -> INT .)
    MODULE          reduce using rule 71 (expression -> INT .)
    EQ              reduce using rule 71 (expression -> INT .)
    NEQ             reduce using rule 71 (expression -> INT .)
    LT              reduce using rule 71 (expression -> INT .)
    LE              reduce using rule 71 (expression -> INT .)
    GT              reduce using rule 71 (expression -> INT .)
    GE              reduce using rule 71 (expression -> INT .)
    LAND            reduce using rule 71 (expression -> INT .)
    LOR             reduce using rule 71 (expression -> INT .)
    AND             reduce using rule 71 (expression -> INT .)
    OR              reduce using rule 71 (expression -> INT .)
    XOR             reduce using rule 71 (expression -> INT .)
    AND_NOT         reduce using rule 71 (expression -> INT .)
    LSHIFT          reduce using rule 71 (expression -> INT .)
    RSHIFT          reduce using rule 71 (expression -> INT .)
    SEMICOLON       reduce using rule 71 (expression -> INT .)
    FUNC            reduce using rule 71 (expression -> INT .)
    TYPE            reduce using rule 71 (expression -> INT .)
    VAR             reduce using rule 71 (expression -> INT .)
    CONST           reduce using rule 71 (expression -> INT .)
    IDENTIFIER      reduce using rule 71 (expression -> INT .)
    LPAREN          reduce using rule 71 (expression -> INT .)
    INT             reduce using rule 71 (expression -> INT .)
    FLOAT64         reduce using rule 71 (expression -> INT .)
    STRING          reduce using rule 71 (expression -> INT .)
    TRUE            reduce using rule 71 (expression -> INT .)
    FALSE           reduce using rule 71 (expression -> INT .)
    LNOT            reduce using rule 71 (expression -> INT .)
    LBRACKET        reduce using rule 71 (expression -> INT .)
    MAP             reduce using rule 71 (expression -> INT .)
    $end            reduce using rule 71 (expression -> INT .)
    RPAREN          reduce using rule 71 (expression -> INT .)
    RBRACE          reduce using rule 71 (expression -> INT .)
    CASE            reduce using rule 71 (expression -> INT .)
    DEFAULT         reduce using rule 71 (expression -> INT .)
    LBRACE          reduce using rule 71 (expression -> INT .)
    COMMA           reduce using rule 71 (expression -> INT .)
    COLON           reduce using rule 71 (expression -> INT .)


state 29

    (72) expression -> FLOAT64 .

    DOT             reduce using rule 72 (expression -> FLOAT64 .)
    PLUS            reduce using rule 72 (expression -> FLOAT64 .)
    MINUS           reduce using rule 72 (expression -> FLOAT64 .)
    TIMES           reduce using rule 72 (expression -> FLOAT64 .)
    DIVIDE          reduce using rule 72 (expression -> FLOAT64 .)
    MODULE          reduce using rule 72 (expression -> FLOAT64 .)
    EQ              reduce using rule 72 (expression -> FLOAT64 .)
    NEQ             reduce using rule 72 (expression -> FLOAT64 .)
    LT              reduce using rule 72 (expression -> FLOAT64 .)
    LE              reduce using rule 72 (expression -> FLOAT64 .)
    GT              reduce using rule 72 (expression -> FLOAT64 .)
    GE              reduce using rule 72 (expression -> FLOAT64 .)
    LAND            reduce using rule 72 (expression -> FLOAT64 .)
    LOR             reduce using rule 72 (expression -> FLOAT64 .)
    AND             reduce using rule 72 (expression -> FLOAT64 .)
    OR              reduce using rule 72 (expression -> FLOAT64 .)
    XOR             reduce using rule 72 (expression -> FLOAT64 .)
    AND_NOT         reduce using rule 72 (expression -> FLOAT64 .)
    LSHIFT          reduce using rule 72 (expression -> FLOAT64 .)
    RSHIFT          reduce using rule 72 (expression -> FLOAT64 .)
    SEMICOLON       reduce using rule 72 (expression -> FLOAT64 .)
    FUNC            reduce using rule 72 (expression -> FLOAT64 .)
    TYPE            reduce using rule 72 (expression -> FLOAT64 .)
    VAR             reduce using rule 72 (expression -> FLOAT64 .)
    CONST           reduce using rule 72 (expression -> FLOAT64 .)
    IDENTIFIER      reduce using rule 72 (expression -> FLOAT64 .)
    LPAREN          reduce using rule 72 (expression -> FLOAT64 .)
    INT             reduce using rule 72 (expression -> FLOAT64 .)
    FLOAT64         reduce using rule 72 (expression -> FLOAT64 .)
    STRING          reduce using rule 72 (expression -> FLOAT64 .)
    TRUE            reduce using rule 72 (expression -> FLOAT64 .)
    FALSE           reduce using rule 72 (expression -> FLOAT64 .)
    LNOT            reduce using rule 72 (expression -> FLOAT64 .)
    LBRACKET        reduce using rule 72 (expression -> FLOAT64 .)
    MAP             reduce using rule 72 (expression -> FLOAT64 .)
    $end            reduce using rule 72 (expression -> FLOAT64 .)
    RPAREN          reduce using rule 72 (expression -> FLOAT64 .)
    RBRACE          reduce using rule 72 (expression -> FLOAT64 .)
    CASE            reduce using rule 72 (expression -> FLOAT64 .)
    DEFAULT         reduce using rule 72 (expression -> FLOAT64 .)
    LBRACE          reduce using rule 72 (expression -> FLOAT64 .)
    COMMA           reduce using rule 72 (expression -> FLOAT64 .)
    COLON           reduce using rule 72 (expression -> FLOAT64 .)


state 30

    (75) expression -> TRUE .

    DOT             reduce using rule 75 (expression -> TRUE .)
    PLUS            reduce using rule 75 (expression -> TRUE .)
    MINUS           reduce using rule 75 (expression -> TRUE .)
    TIMES           reduce using rule 75 (expression -> TRUE .)
    DIVIDE          reduce using rule 75 (expression -> TRUE .)
    MODULE          reduce using rule 75 (expression -> TRUE .)
    EQ              reduce using rule 75 (expression -> TRUE .)
    NEQ             reduce using rule 75 (expression -> TRUE .)
    LT              reduce using rule 75 (expression -> TRUE .)
    LE              reduce using rule 75 (expression -> TRUE .)
    GT              reduce using rule 75 (expression -> TRUE .)
    GE              reduce using rule 75 (expression -> TRUE .)
    LAND            reduce using rule 75 (expression -> TRUE .)
    LOR             reduce using rule 75 (expression -> TRUE .)
    AND             reduce using rule 75 (expression -> TRUE .)
    OR              reduce using rule 75 (expression -> TRUE .)
    XOR             reduce using rule 75 (expression -> TRUE .)
    AND_NOT         reduce using rule 75 (expression -> TRUE .)
    LSHIFT          reduce using rule 75 (expression -> TRUE .)
    RSHIFT          reduce using rule 75 (expression -> TRUE .)
    SEMICOLON       reduce using rule 75 (expression -> TRUE .)
    FUNC            reduce using rule 75 (expression -> TRUE .)
    TYPE            reduce using rule 75 (expression -> TRUE .)
    VAR             reduce using rule 75 (expression -> TRUE .)
    CONST           reduce using rule 75 (expression -> TRUE .)
    IDENTIFIER      reduce using rule 75 (expression -> TRUE .)
    LPAREN          reduce using rule 75 (expression -> TRUE .)
    INT             reduce using rule 75 (expression -> TRUE .)
    FLOAT64         reduce using rule 75 (expression -> TRUE .)
    STRING          reduce using rule 75 (expression -> TRUE .)
    TRUE            reduce using rule 75 (expression -> TRUE .)
    FALSE           reduce using rule 75 (expression -> TRUE .)
    LNOT            reduce using rule 75 (expression -> TRUE .)
    LBRACKET        reduce using rule 75 (expression -> TRUE .)
    MAP             reduce using rule 75 (expression -> TRUE .)
    $end            reduce using rule 75 (expression -> TRUE .)
    RPAREN          reduce using rule 75 (expression -> TRUE .)
    RBRACE          reduce using rule 75 (expression -> TRUE .)
    CASE            reduce using rule 75 (expression -> TRUE .)
    DEFAULT         reduce using rule 75 (expression -> TRUE .)
    LBRACE          reduce using rule 75 (expression -> TRUE .)
    COMMA           reduce using rule 75 (expression -> TRUE .)
    COLON           reduce using rule 75 (expression -> TRUE .)


state 31

    (76) expression -> FALSE .

    DOT             reduce using rule 76 (expression -> FALSE .)
    PLUS            reduce using rule 76 (expression -> FALSE .)
    MINUS           reduce using rule 76 (expression -> FALSE .)
    TIMES           reduce using rule 76 (expression -> FALSE .)
    DIVIDE          reduce using rule 76 (expression -> FALSE .)
    MODULE          reduce using rule 76 (expression -> FALSE .)
    EQ              reduce using rule 76 (expression -> FALSE .)
    NEQ             reduce using rule 76 (expression -> FALSE .)
    LT              reduce using rule 76 (expression -> FALSE .)
    LE              reduce using rule 76 (expression -> FALSE .)
    GT              reduce using rule 76 (expression -> FALSE .)
    GE              reduce using rule 76 (expression -> FALSE .)
    LAND            reduce using rule 76 (expression -> FALSE .)
    LOR             reduce using rule 76 (expression -> FALSE .)
    AND             reduce using rule 76 (expression -> FALSE .)
    OR              reduce using rule 76 (expression -> FALSE .)
    XOR             reduce using rule 76 (expression -> FALSE .)
    AND_NOT         reduce using rule 76 (expression -> FALSE .)
    LSHIFT          reduce using rule 76 (expression -> FALSE .)
    RSHIFT          reduce using rule 76 (expression -> FALSE .)
    SEMICOLON       reduce using rule 76 (expression -> FALSE .)
    FUNC            reduce using rule 76 (expression -> FALSE .)
    TYPE            reduce using rule 76 (expression -> FALSE .)
    VAR             reduce using rule 76 (expression -> FALSE .)
    CONST           reduce using rule 76 (expression -> FALSE .)
    IDENTIFIER      reduce using rule 76 (expression -> FALSE .)
    LPAREN          reduce using rule 76 (expression -> FALSE .)
    INT             reduce using rule 76 (expression -> FALSE .)
    FLOAT64         reduce using rule 76 (expression -> FALSE .)
    STRING          reduce using rule 76 (expression -> FALSE .)
    TRUE            reduce using rule 76 (expression -> FALSE .)
    FALSE           reduce using rule 76 (expression -> FALSE .)
    LNOT            reduce using rule 76 (expression -> FALSE .)
    LBRACKET        reduce using rule 76 (expression -> FALSE .)
    MAP             reduce using rule 76 (expression -> FALSE .)
    $end            reduce using rule 76 (expression -> FALSE .)
    RPAREN          reduce using rule 76 (expression -> FALSE .)
    RBRACE          reduce using rule 76 (expression -> FALSE .)
    CASE            reduce using rule 76 (expression -> FALSE .)
    DEFAULT         reduce using rule 76 (expression -> FALSE .)
    LBRACE          reduce using rule 76 (expression -> FALSE .)
    COMMA           reduce using rule 76 (expression -> FALSE .)
    COLON           reduce using rule 76 (expression -> FALSE .)


state 32

    (123) expression -> LNOT . expression
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (123) expression -> . LNOT expression
    (124) expression -> . IDENTIFIER PLUSPLUS
    (125) expression -> . IDENTIFIER MINUSMINUS
    (135) expression -> . map_type LBRACE expression_map_list RBRACE
    (136) expression -> . map_type LBRACE RBRACE
    (158) expression -> . IDENTIFIER LBRACE keyed_element_list RBRACE
    (159) expression -> . IDENTIFIER LBRACE RBRACE
    (174) expression -> . array_type LBRACE expression_list RBRACE
    (175) expression -> . array_type LBRACE RBRACE
    (176) expression -> . expression DOT IDENTIFIER
    (177) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (178) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (134) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (173) array_type -> . LBRACKET INT RBRACKET primitive_type

    LPAREN          shift and go to state 23
    INT             shift and go to state 28
    FLOAT64         shift and go to state 29
    IDENTIFIER      shift and go to state 82
    STRING          shift and go to state 12
    TRUE            shift and go to state 30
    FALSE           shift and go to state 31
    LNOT            shift and go to state 32
    LBRACKET        shift and go to state 35
    MAP             shift and go to state 36

    expression                     shift and go to state 87
    slice_type                     shift and go to state 27
    map_type                       shift and go to state 33
    array_type                     shift and go to state 34

state 33

    (135) expression -> map_type . LBRACE expression_map_list RBRACE
    (136) expression -> map_type . LBRACE RBRACE

    LBRACE          shift and go to state 88


state 34

    (174) expression -> array_type . LBRACE expression_list RBRACE
    (175) expression -> array_type . LBRACE RBRACE

    LBRACE          shift and go to state 89


state 35

    (65) slice_type -> LBRACKET . RBRACKET primitive_type
    (173) array_type -> LBRACKET . INT RBRACKET primitive_type

    RBRACKET        shift and go to state 90
    INT             shift and go to state 91


state 36

    (134) map_type -> MAP . LBRACKET primitive_type RBRACKET primitive_type

    LBRACKET        shift and go to state 92


state 37

    (6) simple_import -> IMPORT STRING .

    IMPORT          reduce using rule 6 (simple_import -> IMPORT STRING .)
    FUNC            reduce using rule 6 (simple_import -> IMPORT STRING .)
    TYPE            reduce using rule 6 (simple_import -> IMPORT STRING .)
    VAR             reduce using rule 6 (simple_import -> IMPORT STRING .)
    CONST           reduce using rule 6 (simple_import -> IMPORT STRING .)
    IDENTIFIER      reduce using rule 6 (simple_import -> IMPORT STRING .)
    LPAREN          reduce using rule 6 (simple_import -> IMPORT STRING .)
    INT             reduce using rule 6 (simple_import -> IMPORT STRING .)
    FLOAT64         reduce using rule 6 (simple_import -> IMPORT STRING .)
    STRING          reduce using rule 6 (simple_import -> IMPORT STRING .)
    TRUE            reduce using rule 6 (simple_import -> IMPORT STRING .)
    FALSE           reduce using rule 6 (simple_import -> IMPORT STRING .)
    LNOT            reduce using rule 6 (simple_import -> IMPORT STRING .)
    LBRACKET        reduce using rule 6 (simple_import -> IMPORT STRING .)
    MAP             reduce using rule 6 (simple_import -> IMPORT STRING .)


state 38

    (9) global_statement_list -> global_statement_list global_statement .

    FUNC            reduce using rule 9 (global_statement_list -> global_statement_list global_statement .)
    TYPE            reduce using rule 9 (global_statement_list -> global_statement_list global_statement .)
    VAR             reduce using rule 9 (global_statement_list -> global_statement_list global_statement .)
    CONST           reduce using rule 9 (global_statement_list -> global_statement_list global_statement .)
    IDENTIFIER      reduce using rule 9 (global_statement_list -> global_statement_list global_statement .)
    LPAREN          reduce using rule 9 (global_statement_list -> global_statement_list global_statement .)
    INT             reduce using rule 9 (global_statement_list -> global_statement_list global_statement .)
    FLOAT64         reduce using rule 9 (global_statement_list -> global_statement_list global_statement .)
    STRING          reduce using rule 9 (global_statement_list -> global_statement_list global_statement .)
    TRUE            reduce using rule 9 (global_statement_list -> global_statement_list global_statement .)
    FALSE           reduce using rule 9 (global_statement_list -> global_statement_list global_statement .)
    LNOT            reduce using rule 9 (global_statement_list -> global_statement_list global_statement .)
    LBRACKET        reduce using rule 9 (global_statement_list -> global_statement_list global_statement .)
    MAP             reduce using rule 9 (global_statement_list -> global_statement_list global_statement .)
    $end            reduce using rule 9 (global_statement_list -> global_statement_list global_statement .)


state 39

    (10) global_statement -> simple_global_statement SEMICOLON .

    FUNC            reduce using rule 10 (global_statement -> simple_global_statement SEMICOLON .)
    TYPE            reduce using rule 10 (global_statement -> simple_global_statement SEMICOLON .)
    VAR             reduce using rule 10 (global_statement -> simple_global_statement SEMICOLON .)
    CONST           reduce using rule 10 (global_statement -> simple_global_statement SEMICOLON .)
    IDENTIFIER      reduce using rule 10 (global_statement -> simple_global_statement SEMICOLON .)
    LPAREN          reduce using rule 10 (global_statement -> simple_global_statement SEMICOLON .)
    INT             reduce using rule 10 (global_statement -> simple_global_statement SEMICOLON .)
    FLOAT64         reduce using rule 10 (global_statement -> simple_global_statement SEMICOLON .)
    STRING          reduce using rule 10 (global_statement -> simple_global_statement SEMICOLON .)
    TRUE            reduce using rule 10 (global_statement -> simple_global_statement SEMICOLON .)
    FALSE           reduce using rule 10 (global_statement -> simple_global_statement SEMICOLON .)
    LNOT            reduce using rule 10 (global_statement -> simple_global_statement SEMICOLON .)
    LBRACKET        reduce using rule 10 (global_statement -> simple_global_statement SEMICOLON .)
    MAP             reduce using rule 10 (global_statement -> simple_global_statement SEMICOLON .)
    $end            reduce using rule 10 (global_statement -> simple_global_statement SEMICOLON .)


state 40

    (16) simple_global_statement -> var_dec simple_assign .

    SEMICOLON       reduce using rule 16 (simple_global_statement -> var_dec simple_assign .)
    FUNC            reduce using rule 16 (simple_global_statement -> var_dec simple_assign .)
    TYPE            reduce using rule 16 (simple_global_statement -> var_dec simple_assign .)
    VAR             reduce using rule 16 (simple_global_statement -> var_dec simple_assign .)
    CONST           reduce using rule 16 (simple_global_statement -> var_dec simple_assign .)
    IDENTIFIER      reduce using rule 16 (simple_global_statement -> var_dec simple_assign .)
    LPAREN          reduce using rule 16 (simple_global_statement -> var_dec simple_assign .)
    INT             reduce using rule 16 (simple_global_statement -> var_dec simple_assign .)
    FLOAT64         reduce using rule 16 (simple_global_statement -> var_dec simple_assign .)
    STRING          reduce using rule 16 (simple_global_statement -> var_dec simple_assign .)
    TRUE            reduce using rule 16 (simple_global_statement -> var_dec simple_assign .)
    FALSE           reduce using rule 16 (simple_global_statement -> var_dec simple_assign .)
    LNOT            reduce using rule 16 (simple_global_statement -> var_dec simple_assign .)
    LBRACKET        reduce using rule 16 (simple_global_statement -> var_dec simple_assign .)
    MAP             reduce using rule 16 (simple_global_statement -> var_dec simple_assign .)
    $end            reduce using rule 16 (simple_global_statement -> var_dec simple_assign .)


state 41

    (24) simple_assign -> ASSIGN . expression
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (123) expression -> . LNOT expression
    (124) expression -> . IDENTIFIER PLUSPLUS
    (125) expression -> . IDENTIFIER MINUSMINUS
    (135) expression -> . map_type LBRACE expression_map_list RBRACE
    (136) expression -> . map_type LBRACE RBRACE
    (158) expression -> . IDENTIFIER LBRACE keyed_element_list RBRACE
    (159) expression -> . IDENTIFIER LBRACE RBRACE
    (174) expression -> . array_type LBRACE expression_list RBRACE
    (175) expression -> . array_type LBRACE RBRACE
    (176) expression -> . expression DOT IDENTIFIER
    (177) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (178) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (134) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (173) array_type -> . LBRACKET INT RBRACKET primitive_type

    LPAREN          shift and go to state 23
    INT             shift and go to state 28
    FLOAT64         shift and go to state 29
    IDENTIFIER      shift and go to state 82
    STRING          shift and go to state 12
    TRUE            shift and go to state 30
    FALSE           shift and go to state 31
    LNOT            shift and go to state 32
    LBRACKET        shift and go to state 35
    MAP             shift and go to state 36

    expression                     shift and go to state 93
    slice_type                     shift and go to state 27
    map_type                       shift and go to state 33
    array_type                     shift and go to state 34

state 42

    (36) expression -> expression binary_operator . expression
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (123) expression -> . LNOT expression
    (124) expression -> . IDENTIFIER PLUSPLUS
    (125) expression -> . IDENTIFIER MINUSMINUS
    (135) expression -> . map_type LBRACE expression_map_list RBRACE
    (136) expression -> . map_type LBRACE RBRACE
    (158) expression -> . IDENTIFIER LBRACE keyed_element_list RBRACE
    (159) expression -> . IDENTIFIER LBRACE RBRACE
    (174) expression -> . array_type LBRACE expression_list RBRACE
    (175) expression -> . array_type LBRACE RBRACE
    (176) expression -> . expression DOT IDENTIFIER
    (177) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (178) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (134) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (173) array_type -> . LBRACKET INT RBRACKET primitive_type

    LPAREN          shift and go to state 23
    INT             shift and go to state 28
    FLOAT64         shift and go to state 29
    IDENTIFIER      shift and go to state 82
    STRING          shift and go to state 12
    TRUE            shift and go to state 30
    FALSE           shift and go to state 31
    LNOT            shift and go to state 32
    LBRACKET        shift and go to state 35
    MAP             shift and go to state 36

    expression                     shift and go to state 94
    slice_type                     shift and go to state 27
    map_type                       shift and go to state 33
    array_type                     shift and go to state 34

state 43

    (176) expression -> expression DOT . IDENTIFIER
    (177) expression -> expression DOT . IDENTIFIER LPAREN argument_list RPAREN

    IDENTIFIER      shift and go to state 95


state 44

    (37) binary_operator -> PLUS .

    LPAREN          reduce using rule 37 (binary_operator -> PLUS .)
    INT             reduce using rule 37 (binary_operator -> PLUS .)
    FLOAT64         reduce using rule 37 (binary_operator -> PLUS .)
    IDENTIFIER      reduce using rule 37 (binary_operator -> PLUS .)
    STRING          reduce using rule 37 (binary_operator -> PLUS .)
    TRUE            reduce using rule 37 (binary_operator -> PLUS .)
    FALSE           reduce using rule 37 (binary_operator -> PLUS .)
    LNOT            reduce using rule 37 (binary_operator -> PLUS .)
    LBRACKET        reduce using rule 37 (binary_operator -> PLUS .)
    MAP             reduce using rule 37 (binary_operator -> PLUS .)


state 45

    (38) binary_operator -> MINUS .

    LPAREN          reduce using rule 38 (binary_operator -> MINUS .)
    INT             reduce using rule 38 (binary_operator -> MINUS .)
    FLOAT64         reduce using rule 38 (binary_operator -> MINUS .)
    IDENTIFIER      reduce using rule 38 (binary_operator -> MINUS .)
    STRING          reduce using rule 38 (binary_operator -> MINUS .)
    TRUE            reduce using rule 38 (binary_operator -> MINUS .)
    FALSE           reduce using rule 38 (binary_operator -> MINUS .)
    LNOT            reduce using rule 38 (binary_operator -> MINUS .)
    LBRACKET        reduce using rule 38 (binary_operator -> MINUS .)
    MAP             reduce using rule 38 (binary_operator -> MINUS .)


state 46

    (39) binary_operator -> TIMES .

    LPAREN          reduce using rule 39 (binary_operator -> TIMES .)
    INT             reduce using rule 39 (binary_operator -> TIMES .)
    FLOAT64         reduce using rule 39 (binary_operator -> TIMES .)
    IDENTIFIER      reduce using rule 39 (binary_operator -> TIMES .)
    STRING          reduce using rule 39 (binary_operator -> TIMES .)
    TRUE            reduce using rule 39 (binary_operator -> TIMES .)
    FALSE           reduce using rule 39 (binary_operator -> TIMES .)
    LNOT            reduce using rule 39 (binary_operator -> TIMES .)
    LBRACKET        reduce using rule 39 (binary_operator -> TIMES .)
    MAP             reduce using rule 39 (binary_operator -> TIMES .)


state 47

    (40) binary_operator -> DIVIDE .

    LPAREN          reduce using rule 40 (binary_operator -> DIVIDE .)
    INT             reduce using rule 40 (binary_operator -> DIVIDE .)
    FLOAT64         reduce using rule 40 (binary_operator -> DIVIDE .)
    IDENTIFIER      reduce using rule 40 (binary_operator -> DIVIDE .)
    STRING          reduce using rule 40 (binary_operator -> DIVIDE .)
    TRUE            reduce using rule 40 (binary_operator -> DIVIDE .)
    FALSE           reduce using rule 40 (binary_operator -> DIVIDE .)
    LNOT            reduce using rule 40 (binary_operator -> DIVIDE .)
    LBRACKET        reduce using rule 40 (binary_operator -> DIVIDE .)
    MAP             reduce using rule 40 (binary_operator -> DIVIDE .)


state 48

    (41) binary_operator -> MODULE .

    LPAREN          reduce using rule 41 (binary_operator -> MODULE .)
    INT             reduce using rule 41 (binary_operator -> MODULE .)
    FLOAT64         reduce using rule 41 (binary_operator -> MODULE .)
    IDENTIFIER      reduce using rule 41 (binary_operator -> MODULE .)
    STRING          reduce using rule 41 (binary_operator -> MODULE .)
    TRUE            reduce using rule 41 (binary_operator -> MODULE .)
    FALSE           reduce using rule 41 (binary_operator -> MODULE .)
    LNOT            reduce using rule 41 (binary_operator -> MODULE .)
    LBRACKET        reduce using rule 41 (binary_operator -> MODULE .)
    MAP             reduce using rule 41 (binary_operator -> MODULE .)


state 49

    (42) binary_operator -> EQ .

    LPAREN          reduce using rule 42 (binary_operator -> EQ .)
    INT             reduce using rule 42 (binary_operator -> EQ .)
    FLOAT64         reduce using rule 42 (binary_operator -> EQ .)
    IDENTIFIER      reduce using rule 42 (binary_operator -> EQ .)
    STRING          reduce using rule 42 (binary_operator -> EQ .)
    TRUE            reduce using rule 42 (binary_operator -> EQ .)
    FALSE           reduce using rule 42 (binary_operator -> EQ .)
    LNOT            reduce using rule 42 (binary_operator -> EQ .)
    LBRACKET        reduce using rule 42 (binary_operator -> EQ .)
    MAP             reduce using rule 42 (binary_operator -> EQ .)


state 50

    (43) binary_operator -> NEQ .

    LPAREN          reduce using rule 43 (binary_operator -> NEQ .)
    INT             reduce using rule 43 (binary_operator -> NEQ .)
    FLOAT64         reduce using rule 43 (binary_operator -> NEQ .)
    IDENTIFIER      reduce using rule 43 (binary_operator -> NEQ .)
    STRING          reduce using rule 43 (binary_operator -> NEQ .)
    TRUE            reduce using rule 43 (binary_operator -> NEQ .)
    FALSE           reduce using rule 43 (binary_operator -> NEQ .)
    LNOT            reduce using rule 43 (binary_operator -> NEQ .)
    LBRACKET        reduce using rule 43 (binary_operator -> NEQ .)
    MAP             reduce using rule 43 (binary_operator -> NEQ .)


state 51

    (44) binary_operator -> LT .

    LPAREN          reduce using rule 44 (binary_operator -> LT .)
    INT             reduce using rule 44 (binary_operator -> LT .)
    FLOAT64         reduce using rule 44 (binary_operator -> LT .)
    IDENTIFIER      reduce using rule 44 (binary_operator -> LT .)
    STRING          reduce using rule 44 (binary_operator -> LT .)
    TRUE            reduce using rule 44 (binary_operator -> LT .)
    FALSE           reduce using rule 44 (binary_operator -> LT .)
    LNOT            reduce using rule 44 (binary_operator -> LT .)
    LBRACKET        reduce using rule 44 (binary_operator -> LT .)
    MAP             reduce using rule 44 (binary_operator -> LT .)


state 52

    (45) binary_operator -> LE .

    LPAREN          reduce using rule 45 (binary_operator -> LE .)
    INT             reduce using rule 45 (binary_operator -> LE .)
    FLOAT64         reduce using rule 45 (binary_operator -> LE .)
    IDENTIFIER      reduce using rule 45 (binary_operator -> LE .)
    STRING          reduce using rule 45 (binary_operator -> LE .)
    TRUE            reduce using rule 45 (binary_operator -> LE .)
    FALSE           reduce using rule 45 (binary_operator -> LE .)
    LNOT            reduce using rule 45 (binary_operator -> LE .)
    LBRACKET        reduce using rule 45 (binary_operator -> LE .)
    MAP             reduce using rule 45 (binary_operator -> LE .)


state 53

    (46) binary_operator -> GT .

    LPAREN          reduce using rule 46 (binary_operator -> GT .)
    INT             reduce using rule 46 (binary_operator -> GT .)
    FLOAT64         reduce using rule 46 (binary_operator -> GT .)
    IDENTIFIER      reduce using rule 46 (binary_operator -> GT .)
    STRING          reduce using rule 46 (binary_operator -> GT .)
    TRUE            reduce using rule 46 (binary_operator -> GT .)
    FALSE           reduce using rule 46 (binary_operator -> GT .)
    LNOT            reduce using rule 46 (binary_operator -> GT .)
    LBRACKET        reduce using rule 46 (binary_operator -> GT .)
    MAP             reduce using rule 46 (binary_operator -> GT .)


state 54

    (47) binary_operator -> GE .

    LPAREN          reduce using rule 47 (binary_operator -> GE .)
    INT             reduce using rule 47 (binary_operator -> GE .)
    FLOAT64         reduce using rule 47 (binary_operator -> GE .)
    IDENTIFIER      reduce using rule 47 (binary_operator -> GE .)
    STRING          reduce using rule 47 (binary_operator -> GE .)
    TRUE            reduce using rule 47 (binary_operator -> GE .)
    FALSE           reduce using rule 47 (binary_operator -> GE .)
    LNOT            reduce using rule 47 (binary_operator -> GE .)
    LBRACKET        reduce using rule 47 (binary_operator -> GE .)
    MAP             reduce using rule 47 (binary_operator -> GE .)


state 55

    (48) binary_operator -> LAND .

    LPAREN          reduce using rule 48 (binary_operator -> LAND .)
    INT             reduce using rule 48 (binary_operator -> LAND .)
    FLOAT64         reduce using rule 48 (binary_operator -> LAND .)
    IDENTIFIER      reduce using rule 48 (binary_operator -> LAND .)
    STRING          reduce using rule 48 (binary_operator -> LAND .)
    TRUE            reduce using rule 48 (binary_operator -> LAND .)
    FALSE           reduce using rule 48 (binary_operator -> LAND .)
    LNOT            reduce using rule 48 (binary_operator -> LAND .)
    LBRACKET        reduce using rule 48 (binary_operator -> LAND .)
    MAP             reduce using rule 48 (binary_operator -> LAND .)


state 56

    (49) binary_operator -> LOR .

    LPAREN          reduce using rule 49 (binary_operator -> LOR .)
    INT             reduce using rule 49 (binary_operator -> LOR .)
    FLOAT64         reduce using rule 49 (binary_operator -> LOR .)
    IDENTIFIER      reduce using rule 49 (binary_operator -> LOR .)
    STRING          reduce using rule 49 (binary_operator -> LOR .)
    TRUE            reduce using rule 49 (binary_operator -> LOR .)
    FALSE           reduce using rule 49 (binary_operator -> LOR .)
    LNOT            reduce using rule 49 (binary_operator -> LOR .)
    LBRACKET        reduce using rule 49 (binary_operator -> LOR .)
    MAP             reduce using rule 49 (binary_operator -> LOR .)


state 57

    (50) binary_operator -> AND .

    LPAREN          reduce using rule 50 (binary_operator -> AND .)
    INT             reduce using rule 50 (binary_operator -> AND .)
    FLOAT64         reduce using rule 50 (binary_operator -> AND .)
    IDENTIFIER      reduce using rule 50 (binary_operator -> AND .)
    STRING          reduce using rule 50 (binary_operator -> AND .)
    TRUE            reduce using rule 50 (binary_operator -> AND .)
    FALSE           reduce using rule 50 (binary_operator -> AND .)
    LNOT            reduce using rule 50 (binary_operator -> AND .)
    LBRACKET        reduce using rule 50 (binary_operator -> AND .)
    MAP             reduce using rule 50 (binary_operator -> AND .)


state 58

    (51) binary_operator -> OR .

    LPAREN          reduce using rule 51 (binary_operator -> OR .)
    INT             reduce using rule 51 (binary_operator -> OR .)
    FLOAT64         reduce using rule 51 (binary_operator -> OR .)
    IDENTIFIER      reduce using rule 51 (binary_operator -> OR .)
    STRING          reduce using rule 51 (binary_operator -> OR .)
    TRUE            reduce using rule 51 (binary_operator -> OR .)
    FALSE           reduce using rule 51 (binary_operator -> OR .)
    LNOT            reduce using rule 51 (binary_operator -> OR .)
    LBRACKET        reduce using rule 51 (binary_operator -> OR .)
    MAP             reduce using rule 51 (binary_operator -> OR .)


state 59

    (52) binary_operator -> XOR .

    LPAREN          reduce using rule 52 (binary_operator -> XOR .)
    INT             reduce using rule 52 (binary_operator -> XOR .)
    FLOAT64         reduce using rule 52 (binary_operator -> XOR .)
    IDENTIFIER      reduce using rule 52 (binary_operator -> XOR .)
    STRING          reduce using rule 52 (binary_operator -> XOR .)
    TRUE            reduce using rule 52 (binary_operator -> XOR .)
    FALSE           reduce using rule 52 (binary_operator -> XOR .)
    LNOT            reduce using rule 52 (binary_operator -> XOR .)
    LBRACKET        reduce using rule 52 (binary_operator -> XOR .)
    MAP             reduce using rule 52 (binary_operator -> XOR .)


state 60

    (53) binary_operator -> AND_NOT .

    LPAREN          reduce using rule 53 (binary_operator -> AND_NOT .)
    INT             reduce using rule 53 (binary_operator -> AND_NOT .)
    FLOAT64         reduce using rule 53 (binary_operator -> AND_NOT .)
    IDENTIFIER      reduce using rule 53 (binary_operator -> AND_NOT .)
    STRING          reduce using rule 53 (binary_operator -> AND_NOT .)
    TRUE            reduce using rule 53 (binary_operator -> AND_NOT .)
    FALSE           reduce using rule 53 (binary_operator -> AND_NOT .)
    LNOT            reduce using rule 53 (binary_operator -> AND_NOT .)
    LBRACKET        reduce using rule 53 (binary_operator -> AND_NOT .)
    MAP             reduce using rule 53 (binary_operator -> AND_NOT .)


state 61

    (54) binary_operator -> LSHIFT .

    LPAREN          reduce using rule 54 (binary_operator -> LSHIFT .)
    INT             reduce using rule 54 (binary_operator -> LSHIFT .)
    FLOAT64         reduce using rule 54 (binary_operator -> LSHIFT .)
    IDENTIFIER      reduce using rule 54 (binary_operator -> LSHIFT .)
    STRING          reduce using rule 54 (binary_operator -> LSHIFT .)
    TRUE            reduce using rule 54 (binary_operator -> LSHIFT .)
    FALSE           reduce using rule 54 (binary_operator -> LSHIFT .)
    LNOT            reduce using rule 54 (binary_operator -> LSHIFT .)
    LBRACKET        reduce using rule 54 (binary_operator -> LSHIFT .)
    MAP             reduce using rule 54 (binary_operator -> LSHIFT .)


state 62

    (55) binary_operator -> RSHIFT .

    LPAREN          reduce using rule 55 (binary_operator -> RSHIFT .)
    INT             reduce using rule 55 (binary_operator -> RSHIFT .)
    FLOAT64         reduce using rule 55 (binary_operator -> RSHIFT .)
    IDENTIFIER      reduce using rule 55 (binary_operator -> RSHIFT .)
    STRING          reduce using rule 55 (binary_operator -> RSHIFT .)
    TRUE            reduce using rule 55 (binary_operator -> RSHIFT .)
    FALSE           reduce using rule 55 (binary_operator -> RSHIFT .)
    LNOT            reduce using rule 55 (binary_operator -> RSHIFT .)
    LBRACKET        reduce using rule 55 (binary_operator -> RSHIFT .)
    MAP             reduce using rule 55 (binary_operator -> RSHIFT .)


state 63

    (110) function_declaration -> FUNC IDENTIFIER . LPAREN parameter_list RPAREN return_type block

    LPAREN          shift and go to state 96


state 64

    (143) method_declaration -> FUNC LPAREN . receiver RPAREN IDENTIFIER LPAREN parameter_list RPAREN return_type block
    (144) receiver -> . IDENTIFIER IDENTIFIER
    (145) receiver -> . IDENTIFIER TIMES IDENTIFIER
    (146) receiver -> . IDENTIFIER TIMES type

    IDENTIFIER      shift and go to state 98

    receiver                       shift and go to state 97

state 65

    (56) simple_assignment -> IDENTIFIER simple_assign .

    SEMICOLON       reduce using rule 56 (simple_assignment -> IDENTIFIER simple_assign .)
    FUNC            reduce using rule 56 (simple_assignment -> IDENTIFIER simple_assign .)
    TYPE            reduce using rule 56 (simple_assignment -> IDENTIFIER simple_assign .)
    VAR             reduce using rule 56 (simple_assignment -> IDENTIFIER simple_assign .)
    CONST           reduce using rule 56 (simple_assignment -> IDENTIFIER simple_assign .)
    IDENTIFIER      reduce using rule 56 (simple_assignment -> IDENTIFIER simple_assign .)
    LPAREN          reduce using rule 56 (simple_assignment -> IDENTIFIER simple_assign .)
    INT             reduce using rule 56 (simple_assignment -> IDENTIFIER simple_assign .)
    FLOAT64         reduce using rule 56 (simple_assignment -> IDENTIFIER simple_assign .)
    STRING          reduce using rule 56 (simple_assignment -> IDENTIFIER simple_assign .)
    TRUE            reduce using rule 56 (simple_assignment -> IDENTIFIER simple_assign .)
    FALSE           reduce using rule 56 (simple_assignment -> IDENTIFIER simple_assign .)
    LNOT            reduce using rule 56 (simple_assignment -> IDENTIFIER simple_assign .)
    LBRACKET        reduce using rule 56 (simple_assignment -> IDENTIFIER simple_assign .)
    MAP             reduce using rule 56 (simple_assignment -> IDENTIFIER simple_assign .)
    $end            reduce using rule 56 (simple_assignment -> IDENTIFIER simple_assign .)
    LBRACE          reduce using rule 56 (simple_assignment -> IDENTIFIER simple_assign .)


state 66

    (25) assignment_compound -> IDENTIFIER operator_assign . expression
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (123) expression -> . LNOT expression
    (124) expression -> . IDENTIFIER PLUSPLUS
    (125) expression -> . IDENTIFIER MINUSMINUS
    (135) expression -> . map_type LBRACE expression_map_list RBRACE
    (136) expression -> . map_type LBRACE RBRACE
    (158) expression -> . IDENTIFIER LBRACE keyed_element_list RBRACE
    (159) expression -> . IDENTIFIER LBRACE RBRACE
    (174) expression -> . array_type LBRACE expression_list RBRACE
    (175) expression -> . array_type LBRACE RBRACE
    (176) expression -> . expression DOT IDENTIFIER
    (177) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (178) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (134) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (173) array_type -> . LBRACKET INT RBRACKET primitive_type

    LPAREN          shift and go to state 23
    INT             shift and go to state 28
    FLOAT64         shift and go to state 29
    IDENTIFIER      shift and go to state 82
    STRING          shift and go to state 12
    TRUE            shift and go to state 30
    FALSE           shift and go to state 31
    LNOT            shift and go to state 32
    LBRACKET        shift and go to state 35
    MAP             shift and go to state 36

    expression                     shift and go to state 99
    slice_type                     shift and go to state 27
    map_type                       shift and go to state 33
    array_type                     shift and go to state 34

state 67

    (124) expression -> IDENTIFIER PLUSPLUS .

    DOT             reduce using rule 124 (expression -> IDENTIFIER PLUSPLUS .)
    PLUS            reduce using rule 124 (expression -> IDENTIFIER PLUSPLUS .)
    MINUS           reduce using rule 124 (expression -> IDENTIFIER PLUSPLUS .)
    TIMES           reduce using rule 124 (expression -> IDENTIFIER PLUSPLUS .)
    DIVIDE          reduce using rule 124 (expression -> IDENTIFIER PLUSPLUS .)
    MODULE          reduce using rule 124 (expression -> IDENTIFIER PLUSPLUS .)
    EQ              reduce using rule 124 (expression -> IDENTIFIER PLUSPLUS .)
    NEQ             reduce using rule 124 (expression -> IDENTIFIER PLUSPLUS .)
    LT              reduce using rule 124 (expression -> IDENTIFIER PLUSPLUS .)
    LE              reduce using rule 124 (expression -> IDENTIFIER PLUSPLUS .)
    GT              reduce using rule 124 (expression -> IDENTIFIER PLUSPLUS .)
    GE              reduce using rule 124 (expression -> IDENTIFIER PLUSPLUS .)
    LAND            reduce using rule 124 (expression -> IDENTIFIER PLUSPLUS .)
    LOR             reduce using rule 124 (expression -> IDENTIFIER PLUSPLUS .)
    AND             reduce using rule 124 (expression -> IDENTIFIER PLUSPLUS .)
    OR              reduce using rule 124 (expression -> IDENTIFIER PLUSPLUS .)
    XOR             reduce using rule 124 (expression -> IDENTIFIER PLUSPLUS .)
    AND_NOT         reduce using rule 124 (expression -> IDENTIFIER PLUSPLUS .)
    LSHIFT          reduce using rule 124 (expression -> IDENTIFIER PLUSPLUS .)
    RSHIFT          reduce using rule 124 (expression -> IDENTIFIER PLUSPLUS .)
    SEMICOLON       reduce using rule 124 (expression -> IDENTIFIER PLUSPLUS .)
    FUNC            reduce using rule 124 (expression -> IDENTIFIER PLUSPLUS .)
    TYPE            reduce using rule 124 (expression -> IDENTIFIER PLUSPLUS .)
    VAR             reduce using rule 124 (expression -> IDENTIFIER PLUSPLUS .)
    CONST           reduce using rule 124 (expression -> IDENTIFIER PLUSPLUS .)
    IDENTIFIER      reduce using rule 124 (expression -> IDENTIFIER PLUSPLUS .)
    LPAREN          reduce using rule 124 (expression -> IDENTIFIER PLUSPLUS .)
    INT             reduce using rule 124 (expression -> IDENTIFIER PLUSPLUS .)
    FLOAT64         reduce using rule 124 (expression -> IDENTIFIER PLUSPLUS .)
    STRING          reduce using rule 124 (expression -> IDENTIFIER PLUSPLUS .)
    TRUE            reduce using rule 124 (expression -> IDENTIFIER PLUSPLUS .)
    FALSE           reduce using rule 124 (expression -> IDENTIFIER PLUSPLUS .)
    LNOT            reduce using rule 124 (expression -> IDENTIFIER PLUSPLUS .)
    LBRACKET        reduce using rule 124 (expression -> IDENTIFIER PLUSPLUS .)
    MAP             reduce using rule 124 (expression -> IDENTIFIER PLUSPLUS .)
    $end            reduce using rule 124 (expression -> IDENTIFIER PLUSPLUS .)
    RPAREN          reduce using rule 124 (expression -> IDENTIFIER PLUSPLUS .)
    RBRACE          reduce using rule 124 (expression -> IDENTIFIER PLUSPLUS .)
    CASE            reduce using rule 124 (expression -> IDENTIFIER PLUSPLUS .)
    DEFAULT         reduce using rule 124 (expression -> IDENTIFIER PLUSPLUS .)
    LBRACE          reduce using rule 124 (expression -> IDENTIFIER PLUSPLUS .)
    COMMA           reduce using rule 124 (expression -> IDENTIFIER PLUSPLUS .)
    COLON           reduce using rule 124 (expression -> IDENTIFIER PLUSPLUS .)


state 68

    (125) expression -> IDENTIFIER MINUSMINUS .

    DOT             reduce using rule 125 (expression -> IDENTIFIER MINUSMINUS .)
    PLUS            reduce using rule 125 (expression -> IDENTIFIER MINUSMINUS .)
    MINUS           reduce using rule 125 (expression -> IDENTIFIER MINUSMINUS .)
    TIMES           reduce using rule 125 (expression -> IDENTIFIER MINUSMINUS .)
    DIVIDE          reduce using rule 125 (expression -> IDENTIFIER MINUSMINUS .)
    MODULE          reduce using rule 125 (expression -> IDENTIFIER MINUSMINUS .)
    EQ              reduce using rule 125 (expression -> IDENTIFIER MINUSMINUS .)
    NEQ             reduce using rule 125 (expression -> IDENTIFIER MINUSMINUS .)
    LT              reduce using rule 125 (expression -> IDENTIFIER MINUSMINUS .)
    LE              reduce using rule 125 (expression -> IDENTIFIER MINUSMINUS .)
    GT              reduce using rule 125 (expression -> IDENTIFIER MINUSMINUS .)
    GE              reduce using rule 125 (expression -> IDENTIFIER MINUSMINUS .)
    LAND            reduce using rule 125 (expression -> IDENTIFIER MINUSMINUS .)
    LOR             reduce using rule 125 (expression -> IDENTIFIER MINUSMINUS .)
    AND             reduce using rule 125 (expression -> IDENTIFIER MINUSMINUS .)
    OR              reduce using rule 125 (expression -> IDENTIFIER MINUSMINUS .)
    XOR             reduce using rule 125 (expression -> IDENTIFIER MINUSMINUS .)
    AND_NOT         reduce using rule 125 (expression -> IDENTIFIER MINUSMINUS .)
    LSHIFT          reduce using rule 125 (expression -> IDENTIFIER MINUSMINUS .)
    RSHIFT          reduce using rule 125 (expression -> IDENTIFIER MINUSMINUS .)
    SEMICOLON       reduce using rule 125 (expression -> IDENTIFIER MINUSMINUS .)
    FUNC            reduce using rule 125 (expression -> IDENTIFIER MINUSMINUS .)
    TYPE            reduce using rule 125 (expression -> IDENTIFIER MINUSMINUS .)
    VAR             reduce using rule 125 (expression -> IDENTIFIER MINUSMINUS .)
    CONST           reduce using rule 125 (expression -> IDENTIFIER MINUSMINUS .)
    IDENTIFIER      reduce using rule 125 (expression -> IDENTIFIER MINUSMINUS .)
    LPAREN          reduce using rule 125 (expression -> IDENTIFIER MINUSMINUS .)
    INT             reduce using rule 125 (expression -> IDENTIFIER MINUSMINUS .)
    FLOAT64         reduce using rule 125 (expression -> IDENTIFIER MINUSMINUS .)
    STRING          reduce using rule 125 (expression -> IDENTIFIER MINUSMINUS .)
    TRUE            reduce using rule 125 (expression -> IDENTIFIER MINUSMINUS .)
    FALSE           reduce using rule 125 (expression -> IDENTIFIER MINUSMINUS .)
    LNOT            reduce using rule 125 (expression -> IDENTIFIER MINUSMINUS .)
    LBRACKET        reduce using rule 125 (expression -> IDENTIFIER MINUSMINUS .)
    MAP             reduce using rule 125 (expression -> IDENTIFIER MINUSMINUS .)
    $end            reduce using rule 125 (expression -> IDENTIFIER MINUSMINUS .)
    RPAREN          reduce using rule 125 (expression -> IDENTIFIER MINUSMINUS .)
    RBRACE          reduce using rule 125 (expression -> IDENTIFIER MINUSMINUS .)
    CASE            reduce using rule 125 (expression -> IDENTIFIER MINUSMINUS .)
    DEFAULT         reduce using rule 125 (expression -> IDENTIFIER MINUSMINUS .)
    LBRACE          reduce using rule 125 (expression -> IDENTIFIER MINUSMINUS .)
    COMMA           reduce using rule 125 (expression -> IDENTIFIER MINUSMINUS .)
    COLON           reduce using rule 125 (expression -> IDENTIFIER MINUSMINUS .)


state 69

    (158) expression -> IDENTIFIER LBRACE . keyed_element_list RBRACE
    (159) expression -> IDENTIFIER LBRACE . RBRACE
    (153) keyed_element_list -> . keyed_element
    (154) keyed_element_list -> . keyed_element_list COMMA keyed_element
    (155) keyed_element -> . IDENTIFIER COLON expression
    (156) keyed_element -> . INT COLON expression
    (157) keyed_element -> . expression
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (123) expression -> . LNOT expression
    (124) expression -> . IDENTIFIER PLUSPLUS
    (125) expression -> . IDENTIFIER MINUSMINUS
    (135) expression -> . map_type LBRACE expression_map_list RBRACE
    (136) expression -> . map_type LBRACE RBRACE
    (158) expression -> . IDENTIFIER LBRACE keyed_element_list RBRACE
    (159) expression -> . IDENTIFIER LBRACE RBRACE
    (174) expression -> . array_type LBRACE expression_list RBRACE
    (175) expression -> . array_type LBRACE RBRACE
    (176) expression -> . expression DOT IDENTIFIER
    (177) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (178) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (134) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (173) array_type -> . LBRACKET INT RBRACKET primitive_type

    RBRACE          shift and go to state 102
    IDENTIFIER      shift and go to state 100
    INT             shift and go to state 105
    LPAREN          shift and go to state 23
    FLOAT64         shift and go to state 29
    STRING          shift and go to state 12
    TRUE            shift and go to state 30
    FALSE           shift and go to state 31
    LNOT            shift and go to state 32
    LBRACKET        shift and go to state 35
    MAP             shift and go to state 36

    keyed_element_list             shift and go to state 101
    keyed_element                  shift and go to state 103
    expression                     shift and go to state 104
    slice_type                     shift and go to state 27
    map_type                       shift and go to state 33
    array_type                     shift and go to state 34

state 70

    (178) expression -> IDENTIFIER LPAREN . argument_list RPAREN
    (179) argument_list -> . expression_list
    (180) argument_list -> . empty
    (68) expression_list -> . expression
    (69) expression_list -> . expression_list COMMA expression
    (7) empty -> .
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (123) expression -> . LNOT expression
    (124) expression -> . IDENTIFIER PLUSPLUS
    (125) expression -> . IDENTIFIER MINUSMINUS
    (135) expression -> . map_type LBRACE expression_map_list RBRACE
    (136) expression -> . map_type LBRACE RBRACE
    (158) expression -> . IDENTIFIER LBRACE keyed_element_list RBRACE
    (159) expression -> . IDENTIFIER LBRACE RBRACE
    (174) expression -> . array_type LBRACE expression_list RBRACE
    (175) expression -> . array_type LBRACE RBRACE
    (176) expression -> . expression DOT IDENTIFIER
    (177) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (178) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (134) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (173) array_type -> . LBRACKET INT RBRACKET primitive_type

    RPAREN          reduce using rule 7 (empty -> .)
    LPAREN          shift and go to state 23
    INT             shift and go to state 28
    FLOAT64         shift and go to state 29
    IDENTIFIER      shift and go to state 82
    STRING          shift and go to state 12
    TRUE            shift and go to state 30
    FALSE           shift and go to state 31
    LNOT            shift and go to state 32
    LBRACKET        shift and go to state 35
    MAP             shift and go to state 36

    argument_list                  shift and go to state 106
    expression_list                shift and go to state 107
    empty                          shift and go to state 108
    expression                     shift and go to state 109
    slice_type                     shift and go to state 27
    map_type                       shift and go to state 33
    array_type                     shift and go to state 34

state 71

    (26) operator_assign -> PLUS_ASSIGN .

    LPAREN          reduce using rule 26 (operator_assign -> PLUS_ASSIGN .)
    INT             reduce using rule 26 (operator_assign -> PLUS_ASSIGN .)
    FLOAT64         reduce using rule 26 (operator_assign -> PLUS_ASSIGN .)
    IDENTIFIER      reduce using rule 26 (operator_assign -> PLUS_ASSIGN .)
    STRING          reduce using rule 26 (operator_assign -> PLUS_ASSIGN .)
    TRUE            reduce using rule 26 (operator_assign -> PLUS_ASSIGN .)
    FALSE           reduce using rule 26 (operator_assign -> PLUS_ASSIGN .)
    LNOT            reduce using rule 26 (operator_assign -> PLUS_ASSIGN .)
    LBRACKET        reduce using rule 26 (operator_assign -> PLUS_ASSIGN .)
    MAP             reduce using rule 26 (operator_assign -> PLUS_ASSIGN .)


state 72

    (27) operator_assign -> MINUS_ASSIGN .

    LPAREN          reduce using rule 27 (operator_assign -> MINUS_ASSIGN .)
    INT             reduce using rule 27 (operator_assign -> MINUS_ASSIGN .)
    FLOAT64         reduce using rule 27 (operator_assign -> MINUS_ASSIGN .)
    IDENTIFIER      reduce using rule 27 (operator_assign -> MINUS_ASSIGN .)
    STRING          reduce using rule 27 (operator_assign -> MINUS_ASSIGN .)
    TRUE            reduce using rule 27 (operator_assign -> MINUS_ASSIGN .)
    FALSE           reduce using rule 27 (operator_assign -> MINUS_ASSIGN .)
    LNOT            reduce using rule 27 (operator_assign -> MINUS_ASSIGN .)
    LBRACKET        reduce using rule 27 (operator_assign -> MINUS_ASSIGN .)
    MAP             reduce using rule 27 (operator_assign -> MINUS_ASSIGN .)


state 73

    (28) operator_assign -> MULT_ASSIGN .

    LPAREN          reduce using rule 28 (operator_assign -> MULT_ASSIGN .)
    INT             reduce using rule 28 (operator_assign -> MULT_ASSIGN .)
    FLOAT64         reduce using rule 28 (operator_assign -> MULT_ASSIGN .)
    IDENTIFIER      reduce using rule 28 (operator_assign -> MULT_ASSIGN .)
    STRING          reduce using rule 28 (operator_assign -> MULT_ASSIGN .)
    TRUE            reduce using rule 28 (operator_assign -> MULT_ASSIGN .)
    FALSE           reduce using rule 28 (operator_assign -> MULT_ASSIGN .)
    LNOT            reduce using rule 28 (operator_assign -> MULT_ASSIGN .)
    LBRACKET        reduce using rule 28 (operator_assign -> MULT_ASSIGN .)
    MAP             reduce using rule 28 (operator_assign -> MULT_ASSIGN .)


state 74

    (29) operator_assign -> DIV_ASSIGN .

    LPAREN          reduce using rule 29 (operator_assign -> DIV_ASSIGN .)
    INT             reduce using rule 29 (operator_assign -> DIV_ASSIGN .)
    FLOAT64         reduce using rule 29 (operator_assign -> DIV_ASSIGN .)
    IDENTIFIER      reduce using rule 29 (operator_assign -> DIV_ASSIGN .)
    STRING          reduce using rule 29 (operator_assign -> DIV_ASSIGN .)
    TRUE            reduce using rule 29 (operator_assign -> DIV_ASSIGN .)
    FALSE           reduce using rule 29 (operator_assign -> DIV_ASSIGN .)
    LNOT            reduce using rule 29 (operator_assign -> DIV_ASSIGN .)
    LBRACKET        reduce using rule 29 (operator_assign -> DIV_ASSIGN .)
    MAP             reduce using rule 29 (operator_assign -> DIV_ASSIGN .)


state 75

    (30) operator_assign -> MOD_ASSIGN .

    LPAREN          reduce using rule 30 (operator_assign -> MOD_ASSIGN .)
    INT             reduce using rule 30 (operator_assign -> MOD_ASSIGN .)
    FLOAT64         reduce using rule 30 (operator_assign -> MOD_ASSIGN .)
    IDENTIFIER      reduce using rule 30 (operator_assign -> MOD_ASSIGN .)
    STRING          reduce using rule 30 (operator_assign -> MOD_ASSIGN .)
    TRUE            reduce using rule 30 (operator_assign -> MOD_ASSIGN .)
    FALSE           reduce using rule 30 (operator_assign -> MOD_ASSIGN .)
    LNOT            reduce using rule 30 (operator_assign -> MOD_ASSIGN .)
    LBRACKET        reduce using rule 30 (operator_assign -> MOD_ASSIGN .)
    MAP             reduce using rule 30 (operator_assign -> MOD_ASSIGN .)


state 76

    (31) operator_assign -> AND_ASSIGN .

    LPAREN          reduce using rule 31 (operator_assign -> AND_ASSIGN .)
    INT             reduce using rule 31 (operator_assign -> AND_ASSIGN .)
    FLOAT64         reduce using rule 31 (operator_assign -> AND_ASSIGN .)
    IDENTIFIER      reduce using rule 31 (operator_assign -> AND_ASSIGN .)
    STRING          reduce using rule 31 (operator_assign -> AND_ASSIGN .)
    TRUE            reduce using rule 31 (operator_assign -> AND_ASSIGN .)
    FALSE           reduce using rule 31 (operator_assign -> AND_ASSIGN .)
    LNOT            reduce using rule 31 (operator_assign -> AND_ASSIGN .)
    LBRACKET        reduce using rule 31 (operator_assign -> AND_ASSIGN .)
    MAP             reduce using rule 31 (operator_assign -> AND_ASSIGN .)


state 77

    (32) operator_assign -> OR_ASSIGN .

    LPAREN          reduce using rule 32 (operator_assign -> OR_ASSIGN .)
    INT             reduce using rule 32 (operator_assign -> OR_ASSIGN .)
    FLOAT64         reduce using rule 32 (operator_assign -> OR_ASSIGN .)
    IDENTIFIER      reduce using rule 32 (operator_assign -> OR_ASSIGN .)
    STRING          reduce using rule 32 (operator_assign -> OR_ASSIGN .)
    TRUE            reduce using rule 32 (operator_assign -> OR_ASSIGN .)
    FALSE           reduce using rule 32 (operator_assign -> OR_ASSIGN .)
    LNOT            reduce using rule 32 (operator_assign -> OR_ASSIGN .)
    LBRACKET        reduce using rule 32 (operator_assign -> OR_ASSIGN .)
    MAP             reduce using rule 32 (operator_assign -> OR_ASSIGN .)


state 78

    (33) operator_assign -> XOR_ASSIGN .

    LPAREN          reduce using rule 33 (operator_assign -> XOR_ASSIGN .)
    INT             reduce using rule 33 (operator_assign -> XOR_ASSIGN .)
    FLOAT64         reduce using rule 33 (operator_assign -> XOR_ASSIGN .)
    IDENTIFIER      reduce using rule 33 (operator_assign -> XOR_ASSIGN .)
    STRING          reduce using rule 33 (operator_assign -> XOR_ASSIGN .)
    TRUE            reduce using rule 33 (operator_assign -> XOR_ASSIGN .)
    FALSE           reduce using rule 33 (operator_assign -> XOR_ASSIGN .)
    LNOT            reduce using rule 33 (operator_assign -> XOR_ASSIGN .)
    LBRACKET        reduce using rule 33 (operator_assign -> XOR_ASSIGN .)
    MAP             reduce using rule 33 (operator_assign -> XOR_ASSIGN .)


state 79

    (34) operator_assign -> LSHIFT_ASSIGN .

    LPAREN          reduce using rule 34 (operator_assign -> LSHIFT_ASSIGN .)
    INT             reduce using rule 34 (operator_assign -> LSHIFT_ASSIGN .)
    FLOAT64         reduce using rule 34 (operator_assign -> LSHIFT_ASSIGN .)
    IDENTIFIER      reduce using rule 34 (operator_assign -> LSHIFT_ASSIGN .)
    STRING          reduce using rule 34 (operator_assign -> LSHIFT_ASSIGN .)
    TRUE            reduce using rule 34 (operator_assign -> LSHIFT_ASSIGN .)
    FALSE           reduce using rule 34 (operator_assign -> LSHIFT_ASSIGN .)
    LNOT            reduce using rule 34 (operator_assign -> LSHIFT_ASSIGN .)
    LBRACKET        reduce using rule 34 (operator_assign -> LSHIFT_ASSIGN .)
    MAP             reduce using rule 34 (operator_assign -> LSHIFT_ASSIGN .)


state 80

    (35) operator_assign -> RSHIFT_ASSIGN .

    LPAREN          reduce using rule 35 (operator_assign -> RSHIFT_ASSIGN .)
    INT             reduce using rule 35 (operator_assign -> RSHIFT_ASSIGN .)
    FLOAT64         reduce using rule 35 (operator_assign -> RSHIFT_ASSIGN .)
    IDENTIFIER      reduce using rule 35 (operator_assign -> RSHIFT_ASSIGN .)
    STRING          reduce using rule 35 (operator_assign -> RSHIFT_ASSIGN .)
    TRUE            reduce using rule 35 (operator_assign -> RSHIFT_ASSIGN .)
    FALSE           reduce using rule 35 (operator_assign -> RSHIFT_ASSIGN .)
    LNOT            reduce using rule 35 (operator_assign -> RSHIFT_ASSIGN .)
    LBRACKET        reduce using rule 35 (operator_assign -> RSHIFT_ASSIGN .)
    MAP             reduce using rule 35 (operator_assign -> RSHIFT_ASSIGN .)


state 81

    (70) expression -> LPAREN expression . RPAREN
    (36) expression -> expression . binary_operator expression
    (176) expression -> expression . DOT IDENTIFIER
    (177) expression -> expression . DOT IDENTIFIER LPAREN argument_list RPAREN
    (37) binary_operator -> . PLUS
    (38) binary_operator -> . MINUS
    (39) binary_operator -> . TIMES
    (40) binary_operator -> . DIVIDE
    (41) binary_operator -> . MODULE
    (42) binary_operator -> . EQ
    (43) binary_operator -> . NEQ
    (44) binary_operator -> . LT
    (45) binary_operator -> . LE
    (46) binary_operator -> . GT
    (47) binary_operator -> . GE
    (48) binary_operator -> . LAND
    (49) binary_operator -> . LOR
    (50) binary_operator -> . AND
    (51) binary_operator -> . OR
    (52) binary_operator -> . XOR
    (53) binary_operator -> . AND_NOT
    (54) binary_operator -> . LSHIFT
    (55) binary_operator -> . RSHIFT

    RPAREN          shift and go to state 110
    DOT             shift and go to state 43
    PLUS            shift and go to state 44
    MINUS           shift and go to state 45
    TIMES           shift and go to state 46
    DIVIDE          shift and go to state 47
    MODULE          shift and go to state 48
    EQ              shift and go to state 49
    NEQ             shift and go to state 50
    LT              shift and go to state 51
    LE              shift and go to state 52
    GT              shift and go to state 53
    GE              shift and go to state 54
    LAND            shift and go to state 55
    LOR             shift and go to state 56
    AND             shift and go to state 57
    OR              shift and go to state 58
    XOR             shift and go to state 59
    AND_NOT         shift and go to state 60
    LSHIFT          shift and go to state 61
    RSHIFT          shift and go to state 62

    binary_operator                shift and go to state 42

state 82

    (73) expression -> IDENTIFIER .
    (124) expression -> IDENTIFIER . PLUSPLUS
    (125) expression -> IDENTIFIER . MINUSMINUS
    (158) expression -> IDENTIFIER . LBRACE keyed_element_list RBRACE
    (159) expression -> IDENTIFIER . LBRACE RBRACE
    (178) expression -> IDENTIFIER . LPAREN argument_list RPAREN

  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
    RPAREN          reduce using rule 73 (expression -> IDENTIFIER .)
    DOT             reduce using rule 73 (expression -> IDENTIFIER .)
    PLUS            reduce using rule 73 (expression -> IDENTIFIER .)
    MINUS           reduce using rule 73 (expression -> IDENTIFIER .)
    TIMES           reduce using rule 73 (expression -> IDENTIFIER .)
    DIVIDE          reduce using rule 73 (expression -> IDENTIFIER .)
    MODULE          reduce using rule 73 (expression -> IDENTIFIER .)
    EQ              reduce using rule 73 (expression -> IDENTIFIER .)
    NEQ             reduce using rule 73 (expression -> IDENTIFIER .)
    LT              reduce using rule 73 (expression -> IDENTIFIER .)
    LE              reduce using rule 73 (expression -> IDENTIFIER .)
    GT              reduce using rule 73 (expression -> IDENTIFIER .)
    GE              reduce using rule 73 (expression -> IDENTIFIER .)
    LAND            reduce using rule 73 (expression -> IDENTIFIER .)
    LOR             reduce using rule 73 (expression -> IDENTIFIER .)
    AND             reduce using rule 73 (expression -> IDENTIFIER .)
    OR              reduce using rule 73 (expression -> IDENTIFIER .)
    XOR             reduce using rule 73 (expression -> IDENTIFIER .)
    AND_NOT         reduce using rule 73 (expression -> IDENTIFIER .)
    LSHIFT          reduce using rule 73 (expression -> IDENTIFIER .)
    RSHIFT          reduce using rule 73 (expression -> IDENTIFIER .)
    SEMICOLON       reduce using rule 73 (expression -> IDENTIFIER .)
    FUNC            reduce using rule 73 (expression -> IDENTIFIER .)
    TYPE            reduce using rule 73 (expression -> IDENTIFIER .)
    VAR             reduce using rule 73 (expression -> IDENTIFIER .)
    CONST           reduce using rule 73 (expression -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 73 (expression -> IDENTIFIER .)
    INT             reduce using rule 73 (expression -> IDENTIFIER .)
    FLOAT64         reduce using rule 73 (expression -> IDENTIFIER .)
    STRING          reduce using rule 73 (expression -> IDENTIFIER .)
    TRUE            reduce using rule 73 (expression -> IDENTIFIER .)
    FALSE           reduce using rule 73 (expression -> IDENTIFIER .)
    LNOT            reduce using rule 73 (expression -> IDENTIFIER .)
    LBRACKET        reduce using rule 73 (expression -> IDENTIFIER .)
    MAP             reduce using rule 73 (expression -> IDENTIFIER .)
    $end            reduce using rule 73 (expression -> IDENTIFIER .)
    RBRACE          reduce using rule 73 (expression -> IDENTIFIER .)
    CASE            reduce using rule 73 (expression -> IDENTIFIER .)
    DEFAULT         reduce using rule 73 (expression -> IDENTIFIER .)
    COMMA           reduce using rule 73 (expression -> IDENTIFIER .)
    COLON           reduce using rule 73 (expression -> IDENTIFIER .)
    PLUSPLUS        shift and go to state 67
    MINUSMINUS      shift and go to state 68
    LBRACE          shift and go to state 69
    LPAREN          shift and go to state 70

  ! LPAREN          [ reduce using rule 73 (expression -> IDENTIFIER .) ]
  ! LBRACE          [ reduce using rule 73 (expression -> IDENTIFIER .) ]


state 83

    (147) type_declaration -> TYPE IDENTIFIER . type_alias
    (148) type_alias -> . struct_type
    (149) type_alias -> . type
    (150) type_alias -> . IDENTIFIER
    (151) struct_type -> . STRUCT LBRACE RBRACE
    (152) struct_type -> . STRUCT LBRACE field_list RBRACE
    (57) type -> . primitive_type
    (58) type -> . slice_type
    (59) type -> . array_type
    (60) type -> . map_type
    (61) primitive_type -> . INT_TYPE
    (62) primitive_type -> . FLOAT64_TYPE
    (63) primitive_type -> . STRING_TYPE
    (64) primitive_type -> . BOOL_TYPE
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (173) array_type -> . LBRACKET INT RBRACKET primitive_type
    (134) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type

    IDENTIFIER      shift and go to state 111
    STRUCT          shift and go to state 115
    INT_TYPE        shift and go to state 120
    FLOAT64_TYPE    shift and go to state 121
    STRING_TYPE     shift and go to state 122
    BOOL_TYPE       shift and go to state 123
    LBRACKET        shift and go to state 35
    MAP             shift and go to state 36

    type_alias                     shift and go to state 112
    struct_type                    shift and go to state 113
    type                           shift and go to state 114
    primitive_type                 shift and go to state 116
    slice_type                     shift and go to state 117
    array_type                     shift and go to state 118
    map_type                       shift and go to state 119

state 84

    (20) var_dec -> VAR IDENTIFIER . type
    (22) var_dec -> VAR IDENTIFIER .
    (57) type -> . primitive_type
    (58) type -> . slice_type
    (59) type -> . array_type
    (60) type -> . map_type
    (61) primitive_type -> . INT_TYPE
    (62) primitive_type -> . FLOAT64_TYPE
    (63) primitive_type -> . STRING_TYPE
    (64) primitive_type -> . BOOL_TYPE
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (173) array_type -> . LBRACKET INT RBRACKET primitive_type
    (134) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type

  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for MAP resolved as shift
    ASSIGN          reduce using rule 22 (var_dec -> VAR IDENTIFIER .)
    SEMICOLON       reduce using rule 22 (var_dec -> VAR IDENTIFIER .)
    FUNC            reduce using rule 22 (var_dec -> VAR IDENTIFIER .)
    TYPE            reduce using rule 22 (var_dec -> VAR IDENTIFIER .)
    VAR             reduce using rule 22 (var_dec -> VAR IDENTIFIER .)
    CONST           reduce using rule 22 (var_dec -> VAR IDENTIFIER .)
    IDENTIFIER      reduce using rule 22 (var_dec -> VAR IDENTIFIER .)
    LPAREN          reduce using rule 22 (var_dec -> VAR IDENTIFIER .)
    INT             reduce using rule 22 (var_dec -> VAR IDENTIFIER .)
    FLOAT64         reduce using rule 22 (var_dec -> VAR IDENTIFIER .)
    STRING          reduce using rule 22 (var_dec -> VAR IDENTIFIER .)
    TRUE            reduce using rule 22 (var_dec -> VAR IDENTIFIER .)
    FALSE           reduce using rule 22 (var_dec -> VAR IDENTIFIER .)
    LNOT            reduce using rule 22 (var_dec -> VAR IDENTIFIER .)
    $end            reduce using rule 22 (var_dec -> VAR IDENTIFIER .)
    RBRACE          reduce using rule 22 (var_dec -> VAR IDENTIFIER .)
    CASE            reduce using rule 22 (var_dec -> VAR IDENTIFIER .)
    DEFAULT         reduce using rule 22 (var_dec -> VAR IDENTIFIER .)
    INT_TYPE        shift and go to state 120
    FLOAT64_TYPE    shift and go to state 121
    STRING_TYPE     shift and go to state 122
    BOOL_TYPE       shift and go to state 123
    LBRACKET        shift and go to state 35
    MAP             shift and go to state 36

  ! LBRACKET        [ reduce using rule 22 (var_dec -> VAR IDENTIFIER .) ]
  ! MAP             [ reduce using rule 22 (var_dec -> VAR IDENTIFIER .) ]

    type                           shift and go to state 124
    primitive_type                 shift and go to state 116
    slice_type                     shift and go to state 117
    array_type                     shift and go to state 118
    map_type                       shift and go to state 119

state 85

    (21) var_dec -> CONST IDENTIFIER . type
    (23) var_dec -> CONST IDENTIFIER .
    (57) type -> . primitive_type
    (58) type -> . slice_type
    (59) type -> . array_type
    (60) type -> . map_type
    (61) primitive_type -> . INT_TYPE
    (62) primitive_type -> . FLOAT64_TYPE
    (63) primitive_type -> . STRING_TYPE
    (64) primitive_type -> . BOOL_TYPE
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (173) array_type -> . LBRACKET INT RBRACKET primitive_type
    (134) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type

  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for MAP resolved as shift
    ASSIGN          reduce using rule 23 (var_dec -> CONST IDENTIFIER .)
    SEMICOLON       reduce using rule 23 (var_dec -> CONST IDENTIFIER .)
    FUNC            reduce using rule 23 (var_dec -> CONST IDENTIFIER .)
    TYPE            reduce using rule 23 (var_dec -> CONST IDENTIFIER .)
    VAR             reduce using rule 23 (var_dec -> CONST IDENTIFIER .)
    CONST           reduce using rule 23 (var_dec -> CONST IDENTIFIER .)
    IDENTIFIER      reduce using rule 23 (var_dec -> CONST IDENTIFIER .)
    LPAREN          reduce using rule 23 (var_dec -> CONST IDENTIFIER .)
    INT             reduce using rule 23 (var_dec -> CONST IDENTIFIER .)
    FLOAT64         reduce using rule 23 (var_dec -> CONST IDENTIFIER .)
    STRING          reduce using rule 23 (var_dec -> CONST IDENTIFIER .)
    TRUE            reduce using rule 23 (var_dec -> CONST IDENTIFIER .)
    FALSE           reduce using rule 23 (var_dec -> CONST IDENTIFIER .)
    LNOT            reduce using rule 23 (var_dec -> CONST IDENTIFIER .)
    $end            reduce using rule 23 (var_dec -> CONST IDENTIFIER .)
    RBRACE          reduce using rule 23 (var_dec -> CONST IDENTIFIER .)
    CASE            reduce using rule 23 (var_dec -> CONST IDENTIFIER .)
    DEFAULT         reduce using rule 23 (var_dec -> CONST IDENTIFIER .)
    INT_TYPE        shift and go to state 120
    FLOAT64_TYPE    shift and go to state 121
    STRING_TYPE     shift and go to state 122
    BOOL_TYPE       shift and go to state 123
    LBRACKET        shift and go to state 35
    MAP             shift and go to state 36

  ! LBRACKET        [ reduce using rule 23 (var_dec -> CONST IDENTIFIER .) ]
  ! MAP             [ reduce using rule 23 (var_dec -> CONST IDENTIFIER .) ]

    type                           shift and go to state 125
    primitive_type                 shift and go to state 116
    slice_type                     shift and go to state 117
    array_type                     shift and go to state 118
    map_type                       shift and go to state 119

state 86

    (66) expression -> slice_type LBRACE . expression_list RBRACE
    (67) expression -> slice_type LBRACE . RBRACE
    (68) expression_list -> . expression
    (69) expression_list -> . expression_list COMMA expression
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (123) expression -> . LNOT expression
    (124) expression -> . IDENTIFIER PLUSPLUS
    (125) expression -> . IDENTIFIER MINUSMINUS
    (135) expression -> . map_type LBRACE expression_map_list RBRACE
    (136) expression -> . map_type LBRACE RBRACE
    (158) expression -> . IDENTIFIER LBRACE keyed_element_list RBRACE
    (159) expression -> . IDENTIFIER LBRACE RBRACE
    (174) expression -> . array_type LBRACE expression_list RBRACE
    (175) expression -> . array_type LBRACE RBRACE
    (176) expression -> . expression DOT IDENTIFIER
    (177) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (178) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (134) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (173) array_type -> . LBRACKET INT RBRACKET primitive_type

    RBRACE          shift and go to state 127
    LPAREN          shift and go to state 23
    INT             shift and go to state 28
    FLOAT64         shift and go to state 29
    IDENTIFIER      shift and go to state 82
    STRING          shift and go to state 12
    TRUE            shift and go to state 30
    FALSE           shift and go to state 31
    LNOT            shift and go to state 32
    LBRACKET        shift and go to state 35
    MAP             shift and go to state 36

    slice_type                     shift and go to state 27
    expression_list                shift and go to state 126
    expression                     shift and go to state 109
    map_type                       shift and go to state 33
    array_type                     shift and go to state 34

state 87

    (123) expression -> LNOT expression .
    (36) expression -> expression . binary_operator expression
    (176) expression -> expression . DOT IDENTIFIER
    (177) expression -> expression . DOT IDENTIFIER LPAREN argument_list RPAREN
    (37) binary_operator -> . PLUS
    (38) binary_operator -> . MINUS
    (39) binary_operator -> . TIMES
    (40) binary_operator -> . DIVIDE
    (41) binary_operator -> . MODULE
    (42) binary_operator -> . EQ
    (43) binary_operator -> . NEQ
    (44) binary_operator -> . LT
    (45) binary_operator -> . LE
    (46) binary_operator -> . GT
    (47) binary_operator -> . GE
    (48) binary_operator -> . LAND
    (49) binary_operator -> . LOR
    (50) binary_operator -> . AND
    (51) binary_operator -> . OR
    (52) binary_operator -> . XOR
    (53) binary_operator -> . AND_NOT
    (54) binary_operator -> . LSHIFT
    (55) binary_operator -> . RSHIFT

  ! shift/reduce conflict for DOT resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NEQ resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for LAND resolved as shift
  ! shift/reduce conflict for LOR resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for XOR resolved as shift
  ! shift/reduce conflict for AND_NOT resolved as shift
  ! shift/reduce conflict for LSHIFT resolved as shift
  ! shift/reduce conflict for RSHIFT resolved as shift
    SEMICOLON       reduce using rule 123 (expression -> LNOT expression .)
    FUNC            reduce using rule 123 (expression -> LNOT expression .)
    TYPE            reduce using rule 123 (expression -> LNOT expression .)
    VAR             reduce using rule 123 (expression -> LNOT expression .)
    CONST           reduce using rule 123 (expression -> LNOT expression .)
    IDENTIFIER      reduce using rule 123 (expression -> LNOT expression .)
    LPAREN          reduce using rule 123 (expression -> LNOT expression .)
    INT             reduce using rule 123 (expression -> LNOT expression .)
    FLOAT64         reduce using rule 123 (expression -> LNOT expression .)
    STRING          reduce using rule 123 (expression -> LNOT expression .)
    TRUE            reduce using rule 123 (expression -> LNOT expression .)
    FALSE           reduce using rule 123 (expression -> LNOT expression .)
    LNOT            reduce using rule 123 (expression -> LNOT expression .)
    LBRACKET        reduce using rule 123 (expression -> LNOT expression .)
    MAP             reduce using rule 123 (expression -> LNOT expression .)
    $end            reduce using rule 123 (expression -> LNOT expression .)
    RPAREN          reduce using rule 123 (expression -> LNOT expression .)
    RBRACE          reduce using rule 123 (expression -> LNOT expression .)
    CASE            reduce using rule 123 (expression -> LNOT expression .)
    DEFAULT         reduce using rule 123 (expression -> LNOT expression .)
    LBRACE          reduce using rule 123 (expression -> LNOT expression .)
    COMMA           reduce using rule 123 (expression -> LNOT expression .)
    COLON           reduce using rule 123 (expression -> LNOT expression .)
    DOT             shift and go to state 43
    PLUS            shift and go to state 44
    MINUS           shift and go to state 45
    TIMES           shift and go to state 46
    DIVIDE          shift and go to state 47
    MODULE          shift and go to state 48
    EQ              shift and go to state 49
    NEQ             shift and go to state 50
    LT              shift and go to state 51
    LE              shift and go to state 52
    GT              shift and go to state 53
    GE              shift and go to state 54
    LAND            shift and go to state 55
    LOR             shift and go to state 56
    AND             shift and go to state 57
    OR              shift and go to state 58
    XOR             shift and go to state 59
    AND_NOT         shift and go to state 60
    LSHIFT          shift and go to state 61
    RSHIFT          shift and go to state 62

  ! DOT             [ reduce using rule 123 (expression -> LNOT expression .) ]
  ! PLUS            [ reduce using rule 123 (expression -> LNOT expression .) ]
  ! MINUS           [ reduce using rule 123 (expression -> LNOT expression .) ]
  ! TIMES           [ reduce using rule 123 (expression -> LNOT expression .) ]
  ! DIVIDE          [ reduce using rule 123 (expression -> LNOT expression .) ]
  ! MODULE          [ reduce using rule 123 (expression -> LNOT expression .) ]
  ! EQ              [ reduce using rule 123 (expression -> LNOT expression .) ]
  ! NEQ             [ reduce using rule 123 (expression -> LNOT expression .) ]
  ! LT              [ reduce using rule 123 (expression -> LNOT expression .) ]
  ! LE              [ reduce using rule 123 (expression -> LNOT expression .) ]
  ! GT              [ reduce using rule 123 (expression -> LNOT expression .) ]
  ! GE              [ reduce using rule 123 (expression -> LNOT expression .) ]
  ! LAND            [ reduce using rule 123 (expression -> LNOT expression .) ]
  ! LOR             [ reduce using rule 123 (expression -> LNOT expression .) ]
  ! AND             [ reduce using rule 123 (expression -> LNOT expression .) ]
  ! OR              [ reduce using rule 123 (expression -> LNOT expression .) ]
  ! XOR             [ reduce using rule 123 (expression -> LNOT expression .) ]
  ! AND_NOT         [ reduce using rule 123 (expression -> LNOT expression .) ]
  ! LSHIFT          [ reduce using rule 123 (expression -> LNOT expression .) ]
  ! RSHIFT          [ reduce using rule 123 (expression -> LNOT expression .) ]

    binary_operator                shift and go to state 42

state 88

    (135) expression -> map_type LBRACE . expression_map_list RBRACE
    (136) expression -> map_type LBRACE . RBRACE
    (137) expression_map_list -> . key_value
    (138) expression_map_list -> . expression_map_list COMMA key_value
    (139) key_value -> . expression COLON expression
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (123) expression -> . LNOT expression
    (124) expression -> . IDENTIFIER PLUSPLUS
    (125) expression -> . IDENTIFIER MINUSMINUS
    (135) expression -> . map_type LBRACE expression_map_list RBRACE
    (136) expression -> . map_type LBRACE RBRACE
    (158) expression -> . IDENTIFIER LBRACE keyed_element_list RBRACE
    (159) expression -> . IDENTIFIER LBRACE RBRACE
    (174) expression -> . array_type LBRACE expression_list RBRACE
    (175) expression -> . array_type LBRACE RBRACE
    (176) expression -> . expression DOT IDENTIFIER
    (177) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (178) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (134) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (173) array_type -> . LBRACKET INT RBRACKET primitive_type

    RBRACE          shift and go to state 129
    LPAREN          shift and go to state 23
    INT             shift and go to state 28
    FLOAT64         shift and go to state 29
    IDENTIFIER      shift and go to state 82
    STRING          shift and go to state 12
    TRUE            shift and go to state 30
    FALSE           shift and go to state 31
    LNOT            shift and go to state 32
    LBRACKET        shift and go to state 35
    MAP             shift and go to state 36

    map_type                       shift and go to state 33
    expression_map_list            shift and go to state 128
    key_value                      shift and go to state 130
    expression                     shift and go to state 131
    slice_type                     shift and go to state 27
    array_type                     shift and go to state 34

state 89

    (174) expression -> array_type LBRACE . expression_list RBRACE
    (175) expression -> array_type LBRACE . RBRACE
    (68) expression_list -> . expression
    (69) expression_list -> . expression_list COMMA expression
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (123) expression -> . LNOT expression
    (124) expression -> . IDENTIFIER PLUSPLUS
    (125) expression -> . IDENTIFIER MINUSMINUS
    (135) expression -> . map_type LBRACE expression_map_list RBRACE
    (136) expression -> . map_type LBRACE RBRACE
    (158) expression -> . IDENTIFIER LBRACE keyed_element_list RBRACE
    (159) expression -> . IDENTIFIER LBRACE RBRACE
    (174) expression -> . array_type LBRACE expression_list RBRACE
    (175) expression -> . array_type LBRACE RBRACE
    (176) expression -> . expression DOT IDENTIFIER
    (177) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (178) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (134) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (173) array_type -> . LBRACKET INT RBRACKET primitive_type

    RBRACE          shift and go to state 133
    LPAREN          shift and go to state 23
    INT             shift and go to state 28
    FLOAT64         shift and go to state 29
    IDENTIFIER      shift and go to state 82
    STRING          shift and go to state 12
    TRUE            shift and go to state 30
    FALSE           shift and go to state 31
    LNOT            shift and go to state 32
    LBRACKET        shift and go to state 35
    MAP             shift and go to state 36

    array_type                     shift and go to state 34
    expression_list                shift and go to state 132
    expression                     shift and go to state 109
    slice_type                     shift and go to state 27
    map_type                       shift and go to state 33

state 90

    (65) slice_type -> LBRACKET RBRACKET . primitive_type
    (61) primitive_type -> . INT_TYPE
    (62) primitive_type -> . FLOAT64_TYPE
    (63) primitive_type -> . STRING_TYPE
    (64) primitive_type -> . BOOL_TYPE

    INT_TYPE        shift and go to state 120
    FLOAT64_TYPE    shift and go to state 121
    STRING_TYPE     shift and go to state 122
    BOOL_TYPE       shift and go to state 123

    primitive_type                 shift and go to state 134

state 91

    (173) array_type -> LBRACKET INT . RBRACKET primitive_type

    RBRACKET        shift and go to state 135


state 92

    (134) map_type -> MAP LBRACKET . primitive_type RBRACKET primitive_type
    (61) primitive_type -> . INT_TYPE
    (62) primitive_type -> . FLOAT64_TYPE
    (63) primitive_type -> . STRING_TYPE
    (64) primitive_type -> . BOOL_TYPE

    INT_TYPE        shift and go to state 120
    FLOAT64_TYPE    shift and go to state 121
    STRING_TYPE     shift and go to state 122
    BOOL_TYPE       shift and go to state 123

    primitive_type                 shift and go to state 136

state 93

    (24) simple_assign -> ASSIGN expression .
    (36) expression -> expression . binary_operator expression
    (176) expression -> expression . DOT IDENTIFIER
    (177) expression -> expression . DOT IDENTIFIER LPAREN argument_list RPAREN
    (37) binary_operator -> . PLUS
    (38) binary_operator -> . MINUS
    (39) binary_operator -> . TIMES
    (40) binary_operator -> . DIVIDE
    (41) binary_operator -> . MODULE
    (42) binary_operator -> . EQ
    (43) binary_operator -> . NEQ
    (44) binary_operator -> . LT
    (45) binary_operator -> . LE
    (46) binary_operator -> . GT
    (47) binary_operator -> . GE
    (48) binary_operator -> . LAND
    (49) binary_operator -> . LOR
    (50) binary_operator -> . AND
    (51) binary_operator -> . OR
    (52) binary_operator -> . XOR
    (53) binary_operator -> . AND_NOT
    (54) binary_operator -> . LSHIFT
    (55) binary_operator -> . RSHIFT

    SEMICOLON       reduce using rule 24 (simple_assign -> ASSIGN expression .)
    FUNC            reduce using rule 24 (simple_assign -> ASSIGN expression .)
    TYPE            reduce using rule 24 (simple_assign -> ASSIGN expression .)
    VAR             reduce using rule 24 (simple_assign -> ASSIGN expression .)
    CONST           reduce using rule 24 (simple_assign -> ASSIGN expression .)
    IDENTIFIER      reduce using rule 24 (simple_assign -> ASSIGN expression .)
    LPAREN          reduce using rule 24 (simple_assign -> ASSIGN expression .)
    INT             reduce using rule 24 (simple_assign -> ASSIGN expression .)
    FLOAT64         reduce using rule 24 (simple_assign -> ASSIGN expression .)
    STRING          reduce using rule 24 (simple_assign -> ASSIGN expression .)
    TRUE            reduce using rule 24 (simple_assign -> ASSIGN expression .)
    FALSE           reduce using rule 24 (simple_assign -> ASSIGN expression .)
    LNOT            reduce using rule 24 (simple_assign -> ASSIGN expression .)
    LBRACKET        reduce using rule 24 (simple_assign -> ASSIGN expression .)
    MAP             reduce using rule 24 (simple_assign -> ASSIGN expression .)
    $end            reduce using rule 24 (simple_assign -> ASSIGN expression .)
    RBRACE          reduce using rule 24 (simple_assign -> ASSIGN expression .)
    CASE            reduce using rule 24 (simple_assign -> ASSIGN expression .)
    DEFAULT         reduce using rule 24 (simple_assign -> ASSIGN expression .)
    LBRACE          reduce using rule 24 (simple_assign -> ASSIGN expression .)
    DOT             shift and go to state 43
    PLUS            shift and go to state 44
    MINUS           shift and go to state 45
    TIMES           shift and go to state 46
    DIVIDE          shift and go to state 47
    MODULE          shift and go to state 48
    EQ              shift and go to state 49
    NEQ             shift and go to state 50
    LT              shift and go to state 51
    LE              shift and go to state 52
    GT              shift and go to state 53
    GE              shift and go to state 54
    LAND            shift and go to state 55
    LOR             shift and go to state 56
    AND             shift and go to state 57
    OR              shift and go to state 58
    XOR             shift and go to state 59
    AND_NOT         shift and go to state 60
    LSHIFT          shift and go to state 61
    RSHIFT          shift and go to state 62

    binary_operator                shift and go to state 42

state 94

    (36) expression -> expression binary_operator expression .
    (36) expression -> expression . binary_operator expression
    (176) expression -> expression . DOT IDENTIFIER
    (177) expression -> expression . DOT IDENTIFIER LPAREN argument_list RPAREN
    (37) binary_operator -> . PLUS
    (38) binary_operator -> . MINUS
    (39) binary_operator -> . TIMES
    (40) binary_operator -> . DIVIDE
    (41) binary_operator -> . MODULE
    (42) binary_operator -> . EQ
    (43) binary_operator -> . NEQ
    (44) binary_operator -> . LT
    (45) binary_operator -> . LE
    (46) binary_operator -> . GT
    (47) binary_operator -> . GE
    (48) binary_operator -> . LAND
    (49) binary_operator -> . LOR
    (50) binary_operator -> . AND
    (51) binary_operator -> . OR
    (52) binary_operator -> . XOR
    (53) binary_operator -> . AND_NOT
    (54) binary_operator -> . LSHIFT
    (55) binary_operator -> . RSHIFT

  ! shift/reduce conflict for DOT resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NEQ resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for LAND resolved as shift
  ! shift/reduce conflict for LOR resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for XOR resolved as shift
  ! shift/reduce conflict for AND_NOT resolved as shift
  ! shift/reduce conflict for LSHIFT resolved as shift
  ! shift/reduce conflict for RSHIFT resolved as shift
    SEMICOLON       reduce using rule 36 (expression -> expression binary_operator expression .)
    FUNC            reduce using rule 36 (expression -> expression binary_operator expression .)
    TYPE            reduce using rule 36 (expression -> expression binary_operator expression .)
    VAR             reduce using rule 36 (expression -> expression binary_operator expression .)
    CONST           reduce using rule 36 (expression -> expression binary_operator expression .)
    IDENTIFIER      reduce using rule 36 (expression -> expression binary_operator expression .)
    LPAREN          reduce using rule 36 (expression -> expression binary_operator expression .)
    INT             reduce using rule 36 (expression -> expression binary_operator expression .)
    FLOAT64         reduce using rule 36 (expression -> expression binary_operator expression .)
    STRING          reduce using rule 36 (expression -> expression binary_operator expression .)
    TRUE            reduce using rule 36 (expression -> expression binary_operator expression .)
    FALSE           reduce using rule 36 (expression -> expression binary_operator expression .)
    LNOT            reduce using rule 36 (expression -> expression binary_operator expression .)
    LBRACKET        reduce using rule 36 (expression -> expression binary_operator expression .)
    MAP             reduce using rule 36 (expression -> expression binary_operator expression .)
    $end            reduce using rule 36 (expression -> expression binary_operator expression .)
    RPAREN          reduce using rule 36 (expression -> expression binary_operator expression .)
    RBRACE          reduce using rule 36 (expression -> expression binary_operator expression .)
    CASE            reduce using rule 36 (expression -> expression binary_operator expression .)
    DEFAULT         reduce using rule 36 (expression -> expression binary_operator expression .)
    LBRACE          reduce using rule 36 (expression -> expression binary_operator expression .)
    COMMA           reduce using rule 36 (expression -> expression binary_operator expression .)
    COLON           reduce using rule 36 (expression -> expression binary_operator expression .)
    DOT             shift and go to state 43
    PLUS            shift and go to state 44
    MINUS           shift and go to state 45
    TIMES           shift and go to state 46
    DIVIDE          shift and go to state 47
    MODULE          shift and go to state 48
    EQ              shift and go to state 49
    NEQ             shift and go to state 50
    LT              shift and go to state 51
    LE              shift and go to state 52
    GT              shift and go to state 53
    GE              shift and go to state 54
    LAND            shift and go to state 55
    LOR             shift and go to state 56
    AND             shift and go to state 57
    OR              shift and go to state 58
    XOR             shift and go to state 59
    AND_NOT         shift and go to state 60
    LSHIFT          shift and go to state 61
    RSHIFT          shift and go to state 62

  ! DOT             [ reduce using rule 36 (expression -> expression binary_operator expression .) ]
  ! PLUS            [ reduce using rule 36 (expression -> expression binary_operator expression .) ]
  ! MINUS           [ reduce using rule 36 (expression -> expression binary_operator expression .) ]
  ! TIMES           [ reduce using rule 36 (expression -> expression binary_operator expression .) ]
  ! DIVIDE          [ reduce using rule 36 (expression -> expression binary_operator expression .) ]
  ! MODULE          [ reduce using rule 36 (expression -> expression binary_operator expression .) ]
  ! EQ              [ reduce using rule 36 (expression -> expression binary_operator expression .) ]
  ! NEQ             [ reduce using rule 36 (expression -> expression binary_operator expression .) ]
  ! LT              [ reduce using rule 36 (expression -> expression binary_operator expression .) ]
  ! LE              [ reduce using rule 36 (expression -> expression binary_operator expression .) ]
  ! GT              [ reduce using rule 36 (expression -> expression binary_operator expression .) ]
  ! GE              [ reduce using rule 36 (expression -> expression binary_operator expression .) ]
  ! LAND            [ reduce using rule 36 (expression -> expression binary_operator expression .) ]
  ! LOR             [ reduce using rule 36 (expression -> expression binary_operator expression .) ]
  ! AND             [ reduce using rule 36 (expression -> expression binary_operator expression .) ]
  ! OR              [ reduce using rule 36 (expression -> expression binary_operator expression .) ]
  ! XOR             [ reduce using rule 36 (expression -> expression binary_operator expression .) ]
  ! AND_NOT         [ reduce using rule 36 (expression -> expression binary_operator expression .) ]
  ! LSHIFT          [ reduce using rule 36 (expression -> expression binary_operator expression .) ]
  ! RSHIFT          [ reduce using rule 36 (expression -> expression binary_operator expression .) ]

    binary_operator                shift and go to state 42

state 95

    (176) expression -> expression DOT IDENTIFIER .
    (177) expression -> expression DOT IDENTIFIER . LPAREN argument_list RPAREN

  ! shift/reduce conflict for LPAREN resolved as shift
    DOT             reduce using rule 176 (expression -> expression DOT IDENTIFIER .)
    PLUS            reduce using rule 176 (expression -> expression DOT IDENTIFIER .)
    MINUS           reduce using rule 176 (expression -> expression DOT IDENTIFIER .)
    TIMES           reduce using rule 176 (expression -> expression DOT IDENTIFIER .)
    DIVIDE          reduce using rule 176 (expression -> expression DOT IDENTIFIER .)
    MODULE          reduce using rule 176 (expression -> expression DOT IDENTIFIER .)
    EQ              reduce using rule 176 (expression -> expression DOT IDENTIFIER .)
    NEQ             reduce using rule 176 (expression -> expression DOT IDENTIFIER .)
    LT              reduce using rule 176 (expression -> expression DOT IDENTIFIER .)
    LE              reduce using rule 176 (expression -> expression DOT IDENTIFIER .)
    GT              reduce using rule 176 (expression -> expression DOT IDENTIFIER .)
    GE              reduce using rule 176 (expression -> expression DOT IDENTIFIER .)
    LAND            reduce using rule 176 (expression -> expression DOT IDENTIFIER .)
    LOR             reduce using rule 176 (expression -> expression DOT IDENTIFIER .)
    AND             reduce using rule 176 (expression -> expression DOT IDENTIFIER .)
    OR              reduce using rule 176 (expression -> expression DOT IDENTIFIER .)
    XOR             reduce using rule 176 (expression -> expression DOT IDENTIFIER .)
    AND_NOT         reduce using rule 176 (expression -> expression DOT IDENTIFIER .)
    LSHIFT          reduce using rule 176 (expression -> expression DOT IDENTIFIER .)
    RSHIFT          reduce using rule 176 (expression -> expression DOT IDENTIFIER .)
    SEMICOLON       reduce using rule 176 (expression -> expression DOT IDENTIFIER .)
    FUNC            reduce using rule 176 (expression -> expression DOT IDENTIFIER .)
    TYPE            reduce using rule 176 (expression -> expression DOT IDENTIFIER .)
    VAR             reduce using rule 176 (expression -> expression DOT IDENTIFIER .)
    CONST           reduce using rule 176 (expression -> expression DOT IDENTIFIER .)
    IDENTIFIER      reduce using rule 176 (expression -> expression DOT IDENTIFIER .)
    INT             reduce using rule 176 (expression -> expression DOT IDENTIFIER .)
    FLOAT64         reduce using rule 176 (expression -> expression DOT IDENTIFIER .)
    STRING          reduce using rule 176 (expression -> expression DOT IDENTIFIER .)
    TRUE            reduce using rule 176 (expression -> expression DOT IDENTIFIER .)
    FALSE           reduce using rule 176 (expression -> expression DOT IDENTIFIER .)
    LNOT            reduce using rule 176 (expression -> expression DOT IDENTIFIER .)
    LBRACKET        reduce using rule 176 (expression -> expression DOT IDENTIFIER .)
    MAP             reduce using rule 176 (expression -> expression DOT IDENTIFIER .)
    $end            reduce using rule 176 (expression -> expression DOT IDENTIFIER .)
    RPAREN          reduce using rule 176 (expression -> expression DOT IDENTIFIER .)
    RBRACE          reduce using rule 176 (expression -> expression DOT IDENTIFIER .)
    CASE            reduce using rule 176 (expression -> expression DOT IDENTIFIER .)
    DEFAULT         reduce using rule 176 (expression -> expression DOT IDENTIFIER .)
    LBRACE          reduce using rule 176 (expression -> expression DOT IDENTIFIER .)
    COMMA           reduce using rule 176 (expression -> expression DOT IDENTIFIER .)
    COLON           reduce using rule 176 (expression -> expression DOT IDENTIFIER .)
    LPAREN          shift and go to state 137

  ! LPAREN          [ reduce using rule 176 (expression -> expression DOT IDENTIFIER .) ]


state 96

    (110) function_declaration -> FUNC IDENTIFIER LPAREN . parameter_list RPAREN return_type block
    (111) parameter_list -> . parameter_list COMMA parameter
    (112) parameter_list -> . parameter
    (113) parameter_list -> . empty
    (114) parameter -> . IDENTIFIER type
    (115) parameter -> . IDENTIFIER ELLIPSIS primitive_type
    (7) empty -> .

    IDENTIFIER      shift and go to state 138
    RPAREN          reduce using rule 7 (empty -> .)
    COMMA           reduce using rule 7 (empty -> .)

    parameter_list                 shift and go to state 139
    parameter                      shift and go to state 140
    empty                          shift and go to state 141

state 97

    (143) method_declaration -> FUNC LPAREN receiver . RPAREN IDENTIFIER LPAREN parameter_list RPAREN return_type block

    RPAREN          shift and go to state 142


state 98

    (144) receiver -> IDENTIFIER . IDENTIFIER
    (145) receiver -> IDENTIFIER . TIMES IDENTIFIER
    (146) receiver -> IDENTIFIER . TIMES type

    IDENTIFIER      shift and go to state 143
    TIMES           shift and go to state 144


state 99

    (25) assignment_compound -> IDENTIFIER operator_assign expression .
    (36) expression -> expression . binary_operator expression
    (176) expression -> expression . DOT IDENTIFIER
    (177) expression -> expression . DOT IDENTIFIER LPAREN argument_list RPAREN
    (37) binary_operator -> . PLUS
    (38) binary_operator -> . MINUS
    (39) binary_operator -> . TIMES
    (40) binary_operator -> . DIVIDE
    (41) binary_operator -> . MODULE
    (42) binary_operator -> . EQ
    (43) binary_operator -> . NEQ
    (44) binary_operator -> . LT
    (45) binary_operator -> . LE
    (46) binary_operator -> . GT
    (47) binary_operator -> . GE
    (48) binary_operator -> . LAND
    (49) binary_operator -> . LOR
    (50) binary_operator -> . AND
    (51) binary_operator -> . OR
    (52) binary_operator -> . XOR
    (53) binary_operator -> . AND_NOT
    (54) binary_operator -> . LSHIFT
    (55) binary_operator -> . RSHIFT

    SEMICOLON       reduce using rule 25 (assignment_compound -> IDENTIFIER operator_assign expression .)
    FUNC            reduce using rule 25 (assignment_compound -> IDENTIFIER operator_assign expression .)
    TYPE            reduce using rule 25 (assignment_compound -> IDENTIFIER operator_assign expression .)
    VAR             reduce using rule 25 (assignment_compound -> IDENTIFIER operator_assign expression .)
    CONST           reduce using rule 25 (assignment_compound -> IDENTIFIER operator_assign expression .)
    IDENTIFIER      reduce using rule 25 (assignment_compound -> IDENTIFIER operator_assign expression .)
    LPAREN          reduce using rule 25 (assignment_compound -> IDENTIFIER operator_assign expression .)
    INT             reduce using rule 25 (assignment_compound -> IDENTIFIER operator_assign expression .)
    FLOAT64         reduce using rule 25 (assignment_compound -> IDENTIFIER operator_assign expression .)
    STRING          reduce using rule 25 (assignment_compound -> IDENTIFIER operator_assign expression .)
    TRUE            reduce using rule 25 (assignment_compound -> IDENTIFIER operator_assign expression .)
    FALSE           reduce using rule 25 (assignment_compound -> IDENTIFIER operator_assign expression .)
    LNOT            reduce using rule 25 (assignment_compound -> IDENTIFIER operator_assign expression .)
    LBRACKET        reduce using rule 25 (assignment_compound -> IDENTIFIER operator_assign expression .)
    MAP             reduce using rule 25 (assignment_compound -> IDENTIFIER operator_assign expression .)
    $end            reduce using rule 25 (assignment_compound -> IDENTIFIER operator_assign expression .)
    RBRACE          reduce using rule 25 (assignment_compound -> IDENTIFIER operator_assign expression .)
    CASE            reduce using rule 25 (assignment_compound -> IDENTIFIER operator_assign expression .)
    DEFAULT         reduce using rule 25 (assignment_compound -> IDENTIFIER operator_assign expression .)
    DOT             shift and go to state 43
    PLUS            shift and go to state 44
    MINUS           shift and go to state 45
    TIMES           shift and go to state 46
    DIVIDE          shift and go to state 47
    MODULE          shift and go to state 48
    EQ              shift and go to state 49
    NEQ             shift and go to state 50
    LT              shift and go to state 51
    LE              shift and go to state 52
    GT              shift and go to state 53
    GE              shift and go to state 54
    LAND            shift and go to state 55
    LOR             shift and go to state 56
    AND             shift and go to state 57
    OR              shift and go to state 58
    XOR             shift and go to state 59
    AND_NOT         shift and go to state 60
    LSHIFT          shift and go to state 61
    RSHIFT          shift and go to state 62

    binary_operator                shift and go to state 42

state 100

    (155) keyed_element -> IDENTIFIER . COLON expression
    (73) expression -> IDENTIFIER .
    (124) expression -> IDENTIFIER . PLUSPLUS
    (125) expression -> IDENTIFIER . MINUSMINUS
    (158) expression -> IDENTIFIER . LBRACE keyed_element_list RBRACE
    (159) expression -> IDENTIFIER . LBRACE RBRACE
    (178) expression -> IDENTIFIER . LPAREN argument_list RPAREN

    COLON           shift and go to state 145
    DOT             reduce using rule 73 (expression -> IDENTIFIER .)
    PLUS            reduce using rule 73 (expression -> IDENTIFIER .)
    MINUS           reduce using rule 73 (expression -> IDENTIFIER .)
    TIMES           reduce using rule 73 (expression -> IDENTIFIER .)
    DIVIDE          reduce using rule 73 (expression -> IDENTIFIER .)
    MODULE          reduce using rule 73 (expression -> IDENTIFIER .)
    EQ              reduce using rule 73 (expression -> IDENTIFIER .)
    NEQ             reduce using rule 73 (expression -> IDENTIFIER .)
    LT              reduce using rule 73 (expression -> IDENTIFIER .)
    LE              reduce using rule 73 (expression -> IDENTIFIER .)
    GT              reduce using rule 73 (expression -> IDENTIFIER .)
    GE              reduce using rule 73 (expression -> IDENTIFIER .)
    LAND            reduce using rule 73 (expression -> IDENTIFIER .)
    LOR             reduce using rule 73 (expression -> IDENTIFIER .)
    AND             reduce using rule 73 (expression -> IDENTIFIER .)
    OR              reduce using rule 73 (expression -> IDENTIFIER .)
    XOR             reduce using rule 73 (expression -> IDENTIFIER .)
    AND_NOT         reduce using rule 73 (expression -> IDENTIFIER .)
    LSHIFT          reduce using rule 73 (expression -> IDENTIFIER .)
    RSHIFT          reduce using rule 73 (expression -> IDENTIFIER .)
    RBRACE          reduce using rule 73 (expression -> IDENTIFIER .)
    COMMA           reduce using rule 73 (expression -> IDENTIFIER .)
    PLUSPLUS        shift and go to state 67
    MINUSMINUS      shift and go to state 68
    LBRACE          shift and go to state 69
    LPAREN          shift and go to state 70


state 101

    (158) expression -> IDENTIFIER LBRACE keyed_element_list . RBRACE
    (154) keyed_element_list -> keyed_element_list . COMMA keyed_element

    RBRACE          shift and go to state 146
    COMMA           shift and go to state 147


state 102

    (159) expression -> IDENTIFIER LBRACE RBRACE .

    DOT             reduce using rule 159 (expression -> IDENTIFIER LBRACE RBRACE .)
    PLUS            reduce using rule 159 (expression -> IDENTIFIER LBRACE RBRACE .)
    MINUS           reduce using rule 159 (expression -> IDENTIFIER LBRACE RBRACE .)
    TIMES           reduce using rule 159 (expression -> IDENTIFIER LBRACE RBRACE .)
    DIVIDE          reduce using rule 159 (expression -> IDENTIFIER LBRACE RBRACE .)
    MODULE          reduce using rule 159 (expression -> IDENTIFIER LBRACE RBRACE .)
    EQ              reduce using rule 159 (expression -> IDENTIFIER LBRACE RBRACE .)
    NEQ             reduce using rule 159 (expression -> IDENTIFIER LBRACE RBRACE .)
    LT              reduce using rule 159 (expression -> IDENTIFIER LBRACE RBRACE .)
    LE              reduce using rule 159 (expression -> IDENTIFIER LBRACE RBRACE .)
    GT              reduce using rule 159 (expression -> IDENTIFIER LBRACE RBRACE .)
    GE              reduce using rule 159 (expression -> IDENTIFIER LBRACE RBRACE .)
    LAND            reduce using rule 159 (expression -> IDENTIFIER LBRACE RBRACE .)
    LOR             reduce using rule 159 (expression -> IDENTIFIER LBRACE RBRACE .)
    AND             reduce using rule 159 (expression -> IDENTIFIER LBRACE RBRACE .)
    OR              reduce using rule 159 (expression -> IDENTIFIER LBRACE RBRACE .)
    XOR             reduce using rule 159 (expression -> IDENTIFIER LBRACE RBRACE .)
    AND_NOT         reduce using rule 159 (expression -> IDENTIFIER LBRACE RBRACE .)
    LSHIFT          reduce using rule 159 (expression -> IDENTIFIER LBRACE RBRACE .)
    RSHIFT          reduce using rule 159 (expression -> IDENTIFIER LBRACE RBRACE .)
    SEMICOLON       reduce using rule 159 (expression -> IDENTIFIER LBRACE RBRACE .)
    FUNC            reduce using rule 159 (expression -> IDENTIFIER LBRACE RBRACE .)
    TYPE            reduce using rule 159 (expression -> IDENTIFIER LBRACE RBRACE .)
    VAR             reduce using rule 159 (expression -> IDENTIFIER LBRACE RBRACE .)
    CONST           reduce using rule 159 (expression -> IDENTIFIER LBRACE RBRACE .)
    IDENTIFIER      reduce using rule 159 (expression -> IDENTIFIER LBRACE RBRACE .)
    LPAREN          reduce using rule 159 (expression -> IDENTIFIER LBRACE RBRACE .)
    INT             reduce using rule 159 (expression -> IDENTIFIER LBRACE RBRACE .)
    FLOAT64         reduce using rule 159 (expression -> IDENTIFIER LBRACE RBRACE .)
    STRING          reduce using rule 159 (expression -> IDENTIFIER LBRACE RBRACE .)
    TRUE            reduce using rule 159 (expression -> IDENTIFIER LBRACE RBRACE .)
    FALSE           reduce using rule 159 (expression -> IDENTIFIER LBRACE RBRACE .)
    LNOT            reduce using rule 159 (expression -> IDENTIFIER LBRACE RBRACE .)
    LBRACKET        reduce using rule 159 (expression -> IDENTIFIER LBRACE RBRACE .)
    MAP             reduce using rule 159 (expression -> IDENTIFIER LBRACE RBRACE .)
    $end            reduce using rule 159 (expression -> IDENTIFIER LBRACE RBRACE .)
    RPAREN          reduce using rule 159 (expression -> IDENTIFIER LBRACE RBRACE .)
    RBRACE          reduce using rule 159 (expression -> IDENTIFIER LBRACE RBRACE .)
    CASE            reduce using rule 159 (expression -> IDENTIFIER LBRACE RBRACE .)
    DEFAULT         reduce using rule 159 (expression -> IDENTIFIER LBRACE RBRACE .)
    LBRACE          reduce using rule 159 (expression -> IDENTIFIER LBRACE RBRACE .)
    COMMA           reduce using rule 159 (expression -> IDENTIFIER LBRACE RBRACE .)
    COLON           reduce using rule 159 (expression -> IDENTIFIER LBRACE RBRACE .)


state 103

    (153) keyed_element_list -> keyed_element .

    RBRACE          reduce using rule 153 (keyed_element_list -> keyed_element .)
    COMMA           reduce using rule 153 (keyed_element_list -> keyed_element .)


state 104

    (157) keyed_element -> expression .
    (36) expression -> expression . binary_operator expression
    (176) expression -> expression . DOT IDENTIFIER
    (177) expression -> expression . DOT IDENTIFIER LPAREN argument_list RPAREN
    (37) binary_operator -> . PLUS
    (38) binary_operator -> . MINUS
    (39) binary_operator -> . TIMES
    (40) binary_operator -> . DIVIDE
    (41) binary_operator -> . MODULE
    (42) binary_operator -> . EQ
    (43) binary_operator -> . NEQ
    (44) binary_operator -> . LT
    (45) binary_operator -> . LE
    (46) binary_operator -> . GT
    (47) binary_operator -> . GE
    (48) binary_operator -> . LAND
    (49) binary_operator -> . LOR
    (50) binary_operator -> . AND
    (51) binary_operator -> . OR
    (52) binary_operator -> . XOR
    (53) binary_operator -> . AND_NOT
    (54) binary_operator -> . LSHIFT
    (55) binary_operator -> . RSHIFT

    RBRACE          reduce using rule 157 (keyed_element -> expression .)
    COMMA           reduce using rule 157 (keyed_element -> expression .)
    DOT             shift and go to state 43
    PLUS            shift and go to state 44
    MINUS           shift and go to state 45
    TIMES           shift and go to state 46
    DIVIDE          shift and go to state 47
    MODULE          shift and go to state 48
    EQ              shift and go to state 49
    NEQ             shift and go to state 50
    LT              shift and go to state 51
    LE              shift and go to state 52
    GT              shift and go to state 53
    GE              shift and go to state 54
    LAND            shift and go to state 55
    LOR             shift and go to state 56
    AND             shift and go to state 57
    OR              shift and go to state 58
    XOR             shift and go to state 59
    AND_NOT         shift and go to state 60
    LSHIFT          shift and go to state 61
    RSHIFT          shift and go to state 62

    binary_operator                shift and go to state 42

state 105

    (156) keyed_element -> INT . COLON expression
    (71) expression -> INT .

    COLON           shift and go to state 148
    DOT             reduce using rule 71 (expression -> INT .)
    PLUS            reduce using rule 71 (expression -> INT .)
    MINUS           reduce using rule 71 (expression -> INT .)
    TIMES           reduce using rule 71 (expression -> INT .)
    DIVIDE          reduce using rule 71 (expression -> INT .)
    MODULE          reduce using rule 71 (expression -> INT .)
    EQ              reduce using rule 71 (expression -> INT .)
    NEQ             reduce using rule 71 (expression -> INT .)
    LT              reduce using rule 71 (expression -> INT .)
    LE              reduce using rule 71 (expression -> INT .)
    GT              reduce using rule 71 (expression -> INT .)
    GE              reduce using rule 71 (expression -> INT .)
    LAND            reduce using rule 71 (expression -> INT .)
    LOR             reduce using rule 71 (expression -> INT .)
    AND             reduce using rule 71 (expression -> INT .)
    OR              reduce using rule 71 (expression -> INT .)
    XOR             reduce using rule 71 (expression -> INT .)
    AND_NOT         reduce using rule 71 (expression -> INT .)
    LSHIFT          reduce using rule 71 (expression -> INT .)
    RSHIFT          reduce using rule 71 (expression -> INT .)
    RBRACE          reduce using rule 71 (expression -> INT .)
    COMMA           reduce using rule 71 (expression -> INT .)


state 106

    (178) expression -> IDENTIFIER LPAREN argument_list . RPAREN

    RPAREN          shift and go to state 149


state 107

    (179) argument_list -> expression_list .
    (69) expression_list -> expression_list . COMMA expression

    RPAREN          reduce using rule 179 (argument_list -> expression_list .)
    COMMA           shift and go to state 150


state 108

    (180) argument_list -> empty .

    RPAREN          reduce using rule 180 (argument_list -> empty .)


state 109

    (68) expression_list -> expression .
    (36) expression -> expression . binary_operator expression
    (176) expression -> expression . DOT IDENTIFIER
    (177) expression -> expression . DOT IDENTIFIER LPAREN argument_list RPAREN
    (37) binary_operator -> . PLUS
    (38) binary_operator -> . MINUS
    (39) binary_operator -> . TIMES
    (40) binary_operator -> . DIVIDE
    (41) binary_operator -> . MODULE
    (42) binary_operator -> . EQ
    (43) binary_operator -> . NEQ
    (44) binary_operator -> . LT
    (45) binary_operator -> . LE
    (46) binary_operator -> . GT
    (47) binary_operator -> . GE
    (48) binary_operator -> . LAND
    (49) binary_operator -> . LOR
    (50) binary_operator -> . AND
    (51) binary_operator -> . OR
    (52) binary_operator -> . XOR
    (53) binary_operator -> . AND_NOT
    (54) binary_operator -> . LSHIFT
    (55) binary_operator -> . RSHIFT

    COMMA           reduce using rule 68 (expression_list -> expression .)
    RPAREN          reduce using rule 68 (expression_list -> expression .)
    RBRACE          reduce using rule 68 (expression_list -> expression .)
    COLON           reduce using rule 68 (expression_list -> expression .)
    DOT             shift and go to state 43
    PLUS            shift and go to state 44
    MINUS           shift and go to state 45
    TIMES           shift and go to state 46
    DIVIDE          shift and go to state 47
    MODULE          shift and go to state 48
    EQ              shift and go to state 49
    NEQ             shift and go to state 50
    LT              shift and go to state 51
    LE              shift and go to state 52
    GT              shift and go to state 53
    GE              shift and go to state 54
    LAND            shift and go to state 55
    LOR             shift and go to state 56
    AND             shift and go to state 57
    OR              shift and go to state 58
    XOR             shift and go to state 59
    AND_NOT         shift and go to state 60
    LSHIFT          shift and go to state 61
    RSHIFT          shift and go to state 62

    binary_operator                shift and go to state 42

state 110

    (70) expression -> LPAREN expression RPAREN .

    DOT             reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    PLUS            reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    TIMES           reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    MODULE          reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    EQ              reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    NEQ             reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    LT              reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    LE              reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    GT              reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    GE              reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    LAND            reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    LOR             reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    AND             reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    OR              reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    XOR             reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    AND_NOT         reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    LSHIFT          reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    RSHIFT          reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    SEMICOLON       reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    FUNC            reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    TYPE            reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    VAR             reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    CONST           reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    IDENTIFIER      reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    LPAREN          reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    INT             reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    FLOAT64         reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    STRING          reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    TRUE            reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    FALSE           reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    LNOT            reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    LBRACKET        reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    MAP             reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    $end            reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    RBRACE          reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    CASE            reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    DEFAULT         reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    LBRACE          reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    COMMA           reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    COLON           reduce using rule 70 (expression -> LPAREN expression RPAREN .)


state 111

    (150) type_alias -> IDENTIFIER .

    FUNC            reduce using rule 150 (type_alias -> IDENTIFIER .)
    TYPE            reduce using rule 150 (type_alias -> IDENTIFIER .)
    VAR             reduce using rule 150 (type_alias -> IDENTIFIER .)
    CONST           reduce using rule 150 (type_alias -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 150 (type_alias -> IDENTIFIER .)
    LPAREN          reduce using rule 150 (type_alias -> IDENTIFIER .)
    INT             reduce using rule 150 (type_alias -> IDENTIFIER .)
    FLOAT64         reduce using rule 150 (type_alias -> IDENTIFIER .)
    STRING          reduce using rule 150 (type_alias -> IDENTIFIER .)
    TRUE            reduce using rule 150 (type_alias -> IDENTIFIER .)
    FALSE           reduce using rule 150 (type_alias -> IDENTIFIER .)
    LNOT            reduce using rule 150 (type_alias -> IDENTIFIER .)
    LBRACKET        reduce using rule 150 (type_alias -> IDENTIFIER .)
    MAP             reduce using rule 150 (type_alias -> IDENTIFIER .)
    $end            reduce using rule 150 (type_alias -> IDENTIFIER .)


state 112

    (147) type_declaration -> TYPE IDENTIFIER type_alias .

    FUNC            reduce using rule 147 (type_declaration -> TYPE IDENTIFIER type_alias .)
    TYPE            reduce using rule 147 (type_declaration -> TYPE IDENTIFIER type_alias .)
    VAR             reduce using rule 147 (type_declaration -> TYPE IDENTIFIER type_alias .)
    CONST           reduce using rule 147 (type_declaration -> TYPE IDENTIFIER type_alias .)
    IDENTIFIER      reduce using rule 147 (type_declaration -> TYPE IDENTIFIER type_alias .)
    LPAREN          reduce using rule 147 (type_declaration -> TYPE IDENTIFIER type_alias .)
    INT             reduce using rule 147 (type_declaration -> TYPE IDENTIFIER type_alias .)
    FLOAT64         reduce using rule 147 (type_declaration -> TYPE IDENTIFIER type_alias .)
    STRING          reduce using rule 147 (type_declaration -> TYPE IDENTIFIER type_alias .)
    TRUE            reduce using rule 147 (type_declaration -> TYPE IDENTIFIER type_alias .)
    FALSE           reduce using rule 147 (type_declaration -> TYPE IDENTIFIER type_alias .)
    LNOT            reduce using rule 147 (type_declaration -> TYPE IDENTIFIER type_alias .)
    LBRACKET        reduce using rule 147 (type_declaration -> TYPE IDENTIFIER type_alias .)
    MAP             reduce using rule 147 (type_declaration -> TYPE IDENTIFIER type_alias .)
    $end            reduce using rule 147 (type_declaration -> TYPE IDENTIFIER type_alias .)


state 113

    (148) type_alias -> struct_type .

    FUNC            reduce using rule 148 (type_alias -> struct_type .)
    TYPE            reduce using rule 148 (type_alias -> struct_type .)
    VAR             reduce using rule 148 (type_alias -> struct_type .)
    CONST           reduce using rule 148 (type_alias -> struct_type .)
    IDENTIFIER      reduce using rule 148 (type_alias -> struct_type .)
    LPAREN          reduce using rule 148 (type_alias -> struct_type .)
    INT             reduce using rule 148 (type_alias -> struct_type .)
    FLOAT64         reduce using rule 148 (type_alias -> struct_type .)
    STRING          reduce using rule 148 (type_alias -> struct_type .)
    TRUE            reduce using rule 148 (type_alias -> struct_type .)
    FALSE           reduce using rule 148 (type_alias -> struct_type .)
    LNOT            reduce using rule 148 (type_alias -> struct_type .)
    LBRACKET        reduce using rule 148 (type_alias -> struct_type .)
    MAP             reduce using rule 148 (type_alias -> struct_type .)
    $end            reduce using rule 148 (type_alias -> struct_type .)


state 114

    (149) type_alias -> type .

    FUNC            reduce using rule 149 (type_alias -> type .)
    TYPE            reduce using rule 149 (type_alias -> type .)
    VAR             reduce using rule 149 (type_alias -> type .)
    CONST           reduce using rule 149 (type_alias -> type .)
    IDENTIFIER      reduce using rule 149 (type_alias -> type .)
    LPAREN          reduce using rule 149 (type_alias -> type .)
    INT             reduce using rule 149 (type_alias -> type .)
    FLOAT64         reduce using rule 149 (type_alias -> type .)
    STRING          reduce using rule 149 (type_alias -> type .)
    TRUE            reduce using rule 149 (type_alias -> type .)
    FALSE           reduce using rule 149 (type_alias -> type .)
    LNOT            reduce using rule 149 (type_alias -> type .)
    LBRACKET        reduce using rule 149 (type_alias -> type .)
    MAP             reduce using rule 149 (type_alias -> type .)
    $end            reduce using rule 149 (type_alias -> type .)


state 115

    (151) struct_type -> STRUCT . LBRACE RBRACE
    (152) struct_type -> STRUCT . LBRACE field_list RBRACE

    LBRACE          shift and go to state 151


state 116

    (57) type -> primitive_type .

    FUNC            reduce using rule 57 (type -> primitive_type .)
    TYPE            reduce using rule 57 (type -> primitive_type .)
    VAR             reduce using rule 57 (type -> primitive_type .)
    CONST           reduce using rule 57 (type -> primitive_type .)
    IDENTIFIER      reduce using rule 57 (type -> primitive_type .)
    LPAREN          reduce using rule 57 (type -> primitive_type .)
    INT             reduce using rule 57 (type -> primitive_type .)
    FLOAT64         reduce using rule 57 (type -> primitive_type .)
    STRING          reduce using rule 57 (type -> primitive_type .)
    TRUE            reduce using rule 57 (type -> primitive_type .)
    FALSE           reduce using rule 57 (type -> primitive_type .)
    LNOT            reduce using rule 57 (type -> primitive_type .)
    LBRACKET        reduce using rule 57 (type -> primitive_type .)
    MAP             reduce using rule 57 (type -> primitive_type .)
    $end            reduce using rule 57 (type -> primitive_type .)
    ASSIGN          reduce using rule 57 (type -> primitive_type .)
    SEMICOLON       reduce using rule 57 (type -> primitive_type .)
    RBRACE          reduce using rule 57 (type -> primitive_type .)
    CASE            reduce using rule 57 (type -> primitive_type .)
    DEFAULT         reduce using rule 57 (type -> primitive_type .)
    RPAREN          reduce using rule 57 (type -> primitive_type .)
    COMMA           reduce using rule 57 (type -> primitive_type .)
    LBRACE          reduce using rule 57 (type -> primitive_type .)


state 117

    (58) type -> slice_type .

    FUNC            reduce using rule 58 (type -> slice_type .)
    TYPE            reduce using rule 58 (type -> slice_type .)
    VAR             reduce using rule 58 (type -> slice_type .)
    CONST           reduce using rule 58 (type -> slice_type .)
    IDENTIFIER      reduce using rule 58 (type -> slice_type .)
    LPAREN          reduce using rule 58 (type -> slice_type .)
    INT             reduce using rule 58 (type -> slice_type .)
    FLOAT64         reduce using rule 58 (type -> slice_type .)
    STRING          reduce using rule 58 (type -> slice_type .)
    TRUE            reduce using rule 58 (type -> slice_type .)
    FALSE           reduce using rule 58 (type -> slice_type .)
    LNOT            reduce using rule 58 (type -> slice_type .)
    LBRACKET        reduce using rule 58 (type -> slice_type .)
    MAP             reduce using rule 58 (type -> slice_type .)
    $end            reduce using rule 58 (type -> slice_type .)
    ASSIGN          reduce using rule 58 (type -> slice_type .)
    SEMICOLON       reduce using rule 58 (type -> slice_type .)
    RBRACE          reduce using rule 58 (type -> slice_type .)
    CASE            reduce using rule 58 (type -> slice_type .)
    DEFAULT         reduce using rule 58 (type -> slice_type .)
    RPAREN          reduce using rule 58 (type -> slice_type .)
    COMMA           reduce using rule 58 (type -> slice_type .)
    LBRACE          reduce using rule 58 (type -> slice_type .)


state 118

    (59) type -> array_type .

    FUNC            reduce using rule 59 (type -> array_type .)
    TYPE            reduce using rule 59 (type -> array_type .)
    VAR             reduce using rule 59 (type -> array_type .)
    CONST           reduce using rule 59 (type -> array_type .)
    IDENTIFIER      reduce using rule 59 (type -> array_type .)
    LPAREN          reduce using rule 59 (type -> array_type .)
    INT             reduce using rule 59 (type -> array_type .)
    FLOAT64         reduce using rule 59 (type -> array_type .)
    STRING          reduce using rule 59 (type -> array_type .)
    TRUE            reduce using rule 59 (type -> array_type .)
    FALSE           reduce using rule 59 (type -> array_type .)
    LNOT            reduce using rule 59 (type -> array_type .)
    LBRACKET        reduce using rule 59 (type -> array_type .)
    MAP             reduce using rule 59 (type -> array_type .)
    $end            reduce using rule 59 (type -> array_type .)
    ASSIGN          reduce using rule 59 (type -> array_type .)
    SEMICOLON       reduce using rule 59 (type -> array_type .)
    RBRACE          reduce using rule 59 (type -> array_type .)
    CASE            reduce using rule 59 (type -> array_type .)
    DEFAULT         reduce using rule 59 (type -> array_type .)
    RPAREN          reduce using rule 59 (type -> array_type .)
    COMMA           reduce using rule 59 (type -> array_type .)
    LBRACE          reduce using rule 59 (type -> array_type .)


state 119

    (60) type -> map_type .

    FUNC            reduce using rule 60 (type -> map_type .)
    TYPE            reduce using rule 60 (type -> map_type .)
    VAR             reduce using rule 60 (type -> map_type .)
    CONST           reduce using rule 60 (type -> map_type .)
    IDENTIFIER      reduce using rule 60 (type -> map_type .)
    LPAREN          reduce using rule 60 (type -> map_type .)
    INT             reduce using rule 60 (type -> map_type .)
    FLOAT64         reduce using rule 60 (type -> map_type .)
    STRING          reduce using rule 60 (type -> map_type .)
    TRUE            reduce using rule 60 (type -> map_type .)
    FALSE           reduce using rule 60 (type -> map_type .)
    LNOT            reduce using rule 60 (type -> map_type .)
    LBRACKET        reduce using rule 60 (type -> map_type .)
    MAP             reduce using rule 60 (type -> map_type .)
    $end            reduce using rule 60 (type -> map_type .)
    ASSIGN          reduce using rule 60 (type -> map_type .)
    SEMICOLON       reduce using rule 60 (type -> map_type .)
    RBRACE          reduce using rule 60 (type -> map_type .)
    CASE            reduce using rule 60 (type -> map_type .)
    DEFAULT         reduce using rule 60 (type -> map_type .)
    RPAREN          reduce using rule 60 (type -> map_type .)
    COMMA           reduce using rule 60 (type -> map_type .)
    LBRACE          reduce using rule 60 (type -> map_type .)


state 120

    (61) primitive_type -> INT_TYPE .

    FUNC            reduce using rule 61 (primitive_type -> INT_TYPE .)
    TYPE            reduce using rule 61 (primitive_type -> INT_TYPE .)
    VAR             reduce using rule 61 (primitive_type -> INT_TYPE .)
    CONST           reduce using rule 61 (primitive_type -> INT_TYPE .)
    IDENTIFIER      reduce using rule 61 (primitive_type -> INT_TYPE .)
    LPAREN          reduce using rule 61 (primitive_type -> INT_TYPE .)
    INT             reduce using rule 61 (primitive_type -> INT_TYPE .)
    FLOAT64         reduce using rule 61 (primitive_type -> INT_TYPE .)
    STRING          reduce using rule 61 (primitive_type -> INT_TYPE .)
    TRUE            reduce using rule 61 (primitive_type -> INT_TYPE .)
    FALSE           reduce using rule 61 (primitive_type -> INT_TYPE .)
    LNOT            reduce using rule 61 (primitive_type -> INT_TYPE .)
    LBRACKET        reduce using rule 61 (primitive_type -> INT_TYPE .)
    MAP             reduce using rule 61 (primitive_type -> INT_TYPE .)
    $end            reduce using rule 61 (primitive_type -> INT_TYPE .)
    ASSIGN          reduce using rule 61 (primitive_type -> INT_TYPE .)
    SEMICOLON       reduce using rule 61 (primitive_type -> INT_TYPE .)
    RBRACE          reduce using rule 61 (primitive_type -> INT_TYPE .)
    CASE            reduce using rule 61 (primitive_type -> INT_TYPE .)
    DEFAULT         reduce using rule 61 (primitive_type -> INT_TYPE .)
    LBRACE          reduce using rule 61 (primitive_type -> INT_TYPE .)
    RPAREN          reduce using rule 61 (primitive_type -> INT_TYPE .)
    COMMA           reduce using rule 61 (primitive_type -> INT_TYPE .)
    RBRACKET        reduce using rule 61 (primitive_type -> INT_TYPE .)


state 121

    (62) primitive_type -> FLOAT64_TYPE .

    FUNC            reduce using rule 62 (primitive_type -> FLOAT64_TYPE .)
    TYPE            reduce using rule 62 (primitive_type -> FLOAT64_TYPE .)
    VAR             reduce using rule 62 (primitive_type -> FLOAT64_TYPE .)
    CONST           reduce using rule 62 (primitive_type -> FLOAT64_TYPE .)
    IDENTIFIER      reduce using rule 62 (primitive_type -> FLOAT64_TYPE .)
    LPAREN          reduce using rule 62 (primitive_type -> FLOAT64_TYPE .)
    INT             reduce using rule 62 (primitive_type -> FLOAT64_TYPE .)
    FLOAT64         reduce using rule 62 (primitive_type -> FLOAT64_TYPE .)
    STRING          reduce using rule 62 (primitive_type -> FLOAT64_TYPE .)
    TRUE            reduce using rule 62 (primitive_type -> FLOAT64_TYPE .)
    FALSE           reduce using rule 62 (primitive_type -> FLOAT64_TYPE .)
    LNOT            reduce using rule 62 (primitive_type -> FLOAT64_TYPE .)
    LBRACKET        reduce using rule 62 (primitive_type -> FLOAT64_TYPE .)
    MAP             reduce using rule 62 (primitive_type -> FLOAT64_TYPE .)
    $end            reduce using rule 62 (primitive_type -> FLOAT64_TYPE .)
    ASSIGN          reduce using rule 62 (primitive_type -> FLOAT64_TYPE .)
    SEMICOLON       reduce using rule 62 (primitive_type -> FLOAT64_TYPE .)
    RBRACE          reduce using rule 62 (primitive_type -> FLOAT64_TYPE .)
    CASE            reduce using rule 62 (primitive_type -> FLOAT64_TYPE .)
    DEFAULT         reduce using rule 62 (primitive_type -> FLOAT64_TYPE .)
    LBRACE          reduce using rule 62 (primitive_type -> FLOAT64_TYPE .)
    RPAREN          reduce using rule 62 (primitive_type -> FLOAT64_TYPE .)
    COMMA           reduce using rule 62 (primitive_type -> FLOAT64_TYPE .)
    RBRACKET        reduce using rule 62 (primitive_type -> FLOAT64_TYPE .)


state 122

    (63) primitive_type -> STRING_TYPE .

    FUNC            reduce using rule 63 (primitive_type -> STRING_TYPE .)
    TYPE            reduce using rule 63 (primitive_type -> STRING_TYPE .)
    VAR             reduce using rule 63 (primitive_type -> STRING_TYPE .)
    CONST           reduce using rule 63 (primitive_type -> STRING_TYPE .)
    IDENTIFIER      reduce using rule 63 (primitive_type -> STRING_TYPE .)
    LPAREN          reduce using rule 63 (primitive_type -> STRING_TYPE .)
    INT             reduce using rule 63 (primitive_type -> STRING_TYPE .)
    FLOAT64         reduce using rule 63 (primitive_type -> STRING_TYPE .)
    STRING          reduce using rule 63 (primitive_type -> STRING_TYPE .)
    TRUE            reduce using rule 63 (primitive_type -> STRING_TYPE .)
    FALSE           reduce using rule 63 (primitive_type -> STRING_TYPE .)
    LNOT            reduce using rule 63 (primitive_type -> STRING_TYPE .)
    LBRACKET        reduce using rule 63 (primitive_type -> STRING_TYPE .)
    MAP             reduce using rule 63 (primitive_type -> STRING_TYPE .)
    $end            reduce using rule 63 (primitive_type -> STRING_TYPE .)
    ASSIGN          reduce using rule 63 (primitive_type -> STRING_TYPE .)
    SEMICOLON       reduce using rule 63 (primitive_type -> STRING_TYPE .)
    RBRACE          reduce using rule 63 (primitive_type -> STRING_TYPE .)
    CASE            reduce using rule 63 (primitive_type -> STRING_TYPE .)
    DEFAULT         reduce using rule 63 (primitive_type -> STRING_TYPE .)
    LBRACE          reduce using rule 63 (primitive_type -> STRING_TYPE .)
    RPAREN          reduce using rule 63 (primitive_type -> STRING_TYPE .)
    COMMA           reduce using rule 63 (primitive_type -> STRING_TYPE .)
    RBRACKET        reduce using rule 63 (primitive_type -> STRING_TYPE .)


state 123

    (64) primitive_type -> BOOL_TYPE .

    FUNC            reduce using rule 64 (primitive_type -> BOOL_TYPE .)
    TYPE            reduce using rule 64 (primitive_type -> BOOL_TYPE .)
    VAR             reduce using rule 64 (primitive_type -> BOOL_TYPE .)
    CONST           reduce using rule 64 (primitive_type -> BOOL_TYPE .)
    IDENTIFIER      reduce using rule 64 (primitive_type -> BOOL_TYPE .)
    LPAREN          reduce using rule 64 (primitive_type -> BOOL_TYPE .)
    INT             reduce using rule 64 (primitive_type -> BOOL_TYPE .)
    FLOAT64         reduce using rule 64 (primitive_type -> BOOL_TYPE .)
    STRING          reduce using rule 64 (primitive_type -> BOOL_TYPE .)
    TRUE            reduce using rule 64 (primitive_type -> BOOL_TYPE .)
    FALSE           reduce using rule 64 (primitive_type -> BOOL_TYPE .)
    LNOT            reduce using rule 64 (primitive_type -> BOOL_TYPE .)
    LBRACKET        reduce using rule 64 (primitive_type -> BOOL_TYPE .)
    MAP             reduce using rule 64 (primitive_type -> BOOL_TYPE .)
    $end            reduce using rule 64 (primitive_type -> BOOL_TYPE .)
    ASSIGN          reduce using rule 64 (primitive_type -> BOOL_TYPE .)
    SEMICOLON       reduce using rule 64 (primitive_type -> BOOL_TYPE .)
    RBRACE          reduce using rule 64 (primitive_type -> BOOL_TYPE .)
    CASE            reduce using rule 64 (primitive_type -> BOOL_TYPE .)
    DEFAULT         reduce using rule 64 (primitive_type -> BOOL_TYPE .)
    LBRACE          reduce using rule 64 (primitive_type -> BOOL_TYPE .)
    RPAREN          reduce using rule 64 (primitive_type -> BOOL_TYPE .)
    COMMA           reduce using rule 64 (primitive_type -> BOOL_TYPE .)
    RBRACKET        reduce using rule 64 (primitive_type -> BOOL_TYPE .)


state 124

    (20) var_dec -> VAR IDENTIFIER type .

    ASSIGN          reduce using rule 20 (var_dec -> VAR IDENTIFIER type .)
    SEMICOLON       reduce using rule 20 (var_dec -> VAR IDENTIFIER type .)
    FUNC            reduce using rule 20 (var_dec -> VAR IDENTIFIER type .)
    TYPE            reduce using rule 20 (var_dec -> VAR IDENTIFIER type .)
    VAR             reduce using rule 20 (var_dec -> VAR IDENTIFIER type .)
    CONST           reduce using rule 20 (var_dec -> VAR IDENTIFIER type .)
    IDENTIFIER      reduce using rule 20 (var_dec -> VAR IDENTIFIER type .)
    LPAREN          reduce using rule 20 (var_dec -> VAR IDENTIFIER type .)
    INT             reduce using rule 20 (var_dec -> VAR IDENTIFIER type .)
    FLOAT64         reduce using rule 20 (var_dec -> VAR IDENTIFIER type .)
    STRING          reduce using rule 20 (var_dec -> VAR IDENTIFIER type .)
    TRUE            reduce using rule 20 (var_dec -> VAR IDENTIFIER type .)
    FALSE           reduce using rule 20 (var_dec -> VAR IDENTIFIER type .)
    LNOT            reduce using rule 20 (var_dec -> VAR IDENTIFIER type .)
    LBRACKET        reduce using rule 20 (var_dec -> VAR IDENTIFIER type .)
    MAP             reduce using rule 20 (var_dec -> VAR IDENTIFIER type .)
    $end            reduce using rule 20 (var_dec -> VAR IDENTIFIER type .)
    RBRACE          reduce using rule 20 (var_dec -> VAR IDENTIFIER type .)
    CASE            reduce using rule 20 (var_dec -> VAR IDENTIFIER type .)
    DEFAULT         reduce using rule 20 (var_dec -> VAR IDENTIFIER type .)


state 125

    (21) var_dec -> CONST IDENTIFIER type .

    ASSIGN          reduce using rule 21 (var_dec -> CONST IDENTIFIER type .)
    SEMICOLON       reduce using rule 21 (var_dec -> CONST IDENTIFIER type .)
    FUNC            reduce using rule 21 (var_dec -> CONST IDENTIFIER type .)
    TYPE            reduce using rule 21 (var_dec -> CONST IDENTIFIER type .)
    VAR             reduce using rule 21 (var_dec -> CONST IDENTIFIER type .)
    CONST           reduce using rule 21 (var_dec -> CONST IDENTIFIER type .)
    IDENTIFIER      reduce using rule 21 (var_dec -> CONST IDENTIFIER type .)
    LPAREN          reduce using rule 21 (var_dec -> CONST IDENTIFIER type .)
    INT             reduce using rule 21 (var_dec -> CONST IDENTIFIER type .)
    FLOAT64         reduce using rule 21 (var_dec -> CONST IDENTIFIER type .)
    STRING          reduce using rule 21 (var_dec -> CONST IDENTIFIER type .)
    TRUE            reduce using rule 21 (var_dec -> CONST IDENTIFIER type .)
    FALSE           reduce using rule 21 (var_dec -> CONST IDENTIFIER type .)
    LNOT            reduce using rule 21 (var_dec -> CONST IDENTIFIER type .)
    LBRACKET        reduce using rule 21 (var_dec -> CONST IDENTIFIER type .)
    MAP             reduce using rule 21 (var_dec -> CONST IDENTIFIER type .)
    $end            reduce using rule 21 (var_dec -> CONST IDENTIFIER type .)
    RBRACE          reduce using rule 21 (var_dec -> CONST IDENTIFIER type .)
    CASE            reduce using rule 21 (var_dec -> CONST IDENTIFIER type .)
    DEFAULT         reduce using rule 21 (var_dec -> CONST IDENTIFIER type .)


state 126

    (66) expression -> slice_type LBRACE expression_list . RBRACE
    (69) expression_list -> expression_list . COMMA expression

    RBRACE          shift and go to state 152
    COMMA           shift and go to state 150


state 127

    (67) expression -> slice_type LBRACE RBRACE .

    DOT             reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    PLUS            reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    MINUS           reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    TIMES           reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    DIVIDE          reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    MODULE          reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    EQ              reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    NEQ             reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    LT              reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    LE              reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    GT              reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    GE              reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    LAND            reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    LOR             reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    AND             reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    OR              reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    XOR             reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    AND_NOT         reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    LSHIFT          reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    RSHIFT          reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    SEMICOLON       reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    FUNC            reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    TYPE            reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    VAR             reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    CONST           reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    IDENTIFIER      reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    LPAREN          reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    INT             reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    FLOAT64         reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    STRING          reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    TRUE            reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    FALSE           reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    LNOT            reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    LBRACKET        reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    MAP             reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    $end            reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    RPAREN          reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    RBRACE          reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    CASE            reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    DEFAULT         reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    LBRACE          reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    COMMA           reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    COLON           reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)


state 128

    (135) expression -> map_type LBRACE expression_map_list . RBRACE
    (138) expression_map_list -> expression_map_list . COMMA key_value

    RBRACE          shift and go to state 153
    COMMA           shift and go to state 154


state 129

    (136) expression -> map_type LBRACE RBRACE .

    DOT             reduce using rule 136 (expression -> map_type LBRACE RBRACE .)
    PLUS            reduce using rule 136 (expression -> map_type LBRACE RBRACE .)
    MINUS           reduce using rule 136 (expression -> map_type LBRACE RBRACE .)
    TIMES           reduce using rule 136 (expression -> map_type LBRACE RBRACE .)
    DIVIDE          reduce using rule 136 (expression -> map_type LBRACE RBRACE .)
    MODULE          reduce using rule 136 (expression -> map_type LBRACE RBRACE .)
    EQ              reduce using rule 136 (expression -> map_type LBRACE RBRACE .)
    NEQ             reduce using rule 136 (expression -> map_type LBRACE RBRACE .)
    LT              reduce using rule 136 (expression -> map_type LBRACE RBRACE .)
    LE              reduce using rule 136 (expression -> map_type LBRACE RBRACE .)
    GT              reduce using rule 136 (expression -> map_type LBRACE RBRACE .)
    GE              reduce using rule 136 (expression -> map_type LBRACE RBRACE .)
    LAND            reduce using rule 136 (expression -> map_type LBRACE RBRACE .)
    LOR             reduce using rule 136 (expression -> map_type LBRACE RBRACE .)
    AND             reduce using rule 136 (expression -> map_type LBRACE RBRACE .)
    OR              reduce using rule 136 (expression -> map_type LBRACE RBRACE .)
    XOR             reduce using rule 136 (expression -> map_type LBRACE RBRACE .)
    AND_NOT         reduce using rule 136 (expression -> map_type LBRACE RBRACE .)
    LSHIFT          reduce using rule 136 (expression -> map_type LBRACE RBRACE .)
    RSHIFT          reduce using rule 136 (expression -> map_type LBRACE RBRACE .)
    SEMICOLON       reduce using rule 136 (expression -> map_type LBRACE RBRACE .)
    FUNC            reduce using rule 136 (expression -> map_type LBRACE RBRACE .)
    TYPE            reduce using rule 136 (expression -> map_type LBRACE RBRACE .)
    VAR             reduce using rule 136 (expression -> map_type LBRACE RBRACE .)
    CONST           reduce using rule 136 (expression -> map_type LBRACE RBRACE .)
    IDENTIFIER      reduce using rule 136 (expression -> map_type LBRACE RBRACE .)
    LPAREN          reduce using rule 136 (expression -> map_type LBRACE RBRACE .)
    INT             reduce using rule 136 (expression -> map_type LBRACE RBRACE .)
    FLOAT64         reduce using rule 136 (expression -> map_type LBRACE RBRACE .)
    STRING          reduce using rule 136 (expression -> map_type LBRACE RBRACE .)
    TRUE            reduce using rule 136 (expression -> map_type LBRACE RBRACE .)
    FALSE           reduce using rule 136 (expression -> map_type LBRACE RBRACE .)
    LNOT            reduce using rule 136 (expression -> map_type LBRACE RBRACE .)
    LBRACKET        reduce using rule 136 (expression -> map_type LBRACE RBRACE .)
    MAP             reduce using rule 136 (expression -> map_type LBRACE RBRACE .)
    $end            reduce using rule 136 (expression -> map_type LBRACE RBRACE .)
    RPAREN          reduce using rule 136 (expression -> map_type LBRACE RBRACE .)
    RBRACE          reduce using rule 136 (expression -> map_type LBRACE RBRACE .)
    CASE            reduce using rule 136 (expression -> map_type LBRACE RBRACE .)
    DEFAULT         reduce using rule 136 (expression -> map_type LBRACE RBRACE .)
    LBRACE          reduce using rule 136 (expression -> map_type LBRACE RBRACE .)
    COMMA           reduce using rule 136 (expression -> map_type LBRACE RBRACE .)
    COLON           reduce using rule 136 (expression -> map_type LBRACE RBRACE .)


state 130

    (137) expression_map_list -> key_value .

    RBRACE          reduce using rule 137 (expression_map_list -> key_value .)
    COMMA           reduce using rule 137 (expression_map_list -> key_value .)


state 131

    (139) key_value -> expression . COLON expression
    (36) expression -> expression . binary_operator expression
    (176) expression -> expression . DOT IDENTIFIER
    (177) expression -> expression . DOT IDENTIFIER LPAREN argument_list RPAREN
    (37) binary_operator -> . PLUS
    (38) binary_operator -> . MINUS
    (39) binary_operator -> . TIMES
    (40) binary_operator -> . DIVIDE
    (41) binary_operator -> . MODULE
    (42) binary_operator -> . EQ
    (43) binary_operator -> . NEQ
    (44) binary_operator -> . LT
    (45) binary_operator -> . LE
    (46) binary_operator -> . GT
    (47) binary_operator -> . GE
    (48) binary_operator -> . LAND
    (49) binary_operator -> . LOR
    (50) binary_operator -> . AND
    (51) binary_operator -> . OR
    (52) binary_operator -> . XOR
    (53) binary_operator -> . AND_NOT
    (54) binary_operator -> . LSHIFT
    (55) binary_operator -> . RSHIFT

    COLON           shift and go to state 155
    DOT             shift and go to state 43
    PLUS            shift and go to state 44
    MINUS           shift and go to state 45
    TIMES           shift and go to state 46
    DIVIDE          shift and go to state 47
    MODULE          shift and go to state 48
    EQ              shift and go to state 49
    NEQ             shift and go to state 50
    LT              shift and go to state 51
    LE              shift and go to state 52
    GT              shift and go to state 53
    GE              shift and go to state 54
    LAND            shift and go to state 55
    LOR             shift and go to state 56
    AND             shift and go to state 57
    OR              shift and go to state 58
    XOR             shift and go to state 59
    AND_NOT         shift and go to state 60
    LSHIFT          shift and go to state 61
    RSHIFT          shift and go to state 62

    binary_operator                shift and go to state 42

state 132

    (174) expression -> array_type LBRACE expression_list . RBRACE
    (69) expression_list -> expression_list . COMMA expression

    RBRACE          shift and go to state 156
    COMMA           shift and go to state 150


state 133

    (175) expression -> array_type LBRACE RBRACE .

    DOT             reduce using rule 175 (expression -> array_type LBRACE RBRACE .)
    PLUS            reduce using rule 175 (expression -> array_type LBRACE RBRACE .)
    MINUS           reduce using rule 175 (expression -> array_type LBRACE RBRACE .)
    TIMES           reduce using rule 175 (expression -> array_type LBRACE RBRACE .)
    DIVIDE          reduce using rule 175 (expression -> array_type LBRACE RBRACE .)
    MODULE          reduce using rule 175 (expression -> array_type LBRACE RBRACE .)
    EQ              reduce using rule 175 (expression -> array_type LBRACE RBRACE .)
    NEQ             reduce using rule 175 (expression -> array_type LBRACE RBRACE .)
    LT              reduce using rule 175 (expression -> array_type LBRACE RBRACE .)
    LE              reduce using rule 175 (expression -> array_type LBRACE RBRACE .)
    GT              reduce using rule 175 (expression -> array_type LBRACE RBRACE .)
    GE              reduce using rule 175 (expression -> array_type LBRACE RBRACE .)
    LAND            reduce using rule 175 (expression -> array_type LBRACE RBRACE .)
    LOR             reduce using rule 175 (expression -> array_type LBRACE RBRACE .)
    AND             reduce using rule 175 (expression -> array_type LBRACE RBRACE .)
    OR              reduce using rule 175 (expression -> array_type LBRACE RBRACE .)
    XOR             reduce using rule 175 (expression -> array_type LBRACE RBRACE .)
    AND_NOT         reduce using rule 175 (expression -> array_type LBRACE RBRACE .)
    LSHIFT          reduce using rule 175 (expression -> array_type LBRACE RBRACE .)
    RSHIFT          reduce using rule 175 (expression -> array_type LBRACE RBRACE .)
    SEMICOLON       reduce using rule 175 (expression -> array_type LBRACE RBRACE .)
    FUNC            reduce using rule 175 (expression -> array_type LBRACE RBRACE .)
    TYPE            reduce using rule 175 (expression -> array_type LBRACE RBRACE .)
    VAR             reduce using rule 175 (expression -> array_type LBRACE RBRACE .)
    CONST           reduce using rule 175 (expression -> array_type LBRACE RBRACE .)
    IDENTIFIER      reduce using rule 175 (expression -> array_type LBRACE RBRACE .)
    LPAREN          reduce using rule 175 (expression -> array_type LBRACE RBRACE .)
    INT             reduce using rule 175 (expression -> array_type LBRACE RBRACE .)
    FLOAT64         reduce using rule 175 (expression -> array_type LBRACE RBRACE .)
    STRING          reduce using rule 175 (expression -> array_type LBRACE RBRACE .)
    TRUE            reduce using rule 175 (expression -> array_type LBRACE RBRACE .)
    FALSE           reduce using rule 175 (expression -> array_type LBRACE RBRACE .)
    LNOT            reduce using rule 175 (expression -> array_type LBRACE RBRACE .)
    LBRACKET        reduce using rule 175 (expression -> array_type LBRACE RBRACE .)
    MAP             reduce using rule 175 (expression -> array_type LBRACE RBRACE .)
    $end            reduce using rule 175 (expression -> array_type LBRACE RBRACE .)
    RPAREN          reduce using rule 175 (expression -> array_type LBRACE RBRACE .)
    RBRACE          reduce using rule 175 (expression -> array_type LBRACE RBRACE .)
    CASE            reduce using rule 175 (expression -> array_type LBRACE RBRACE .)
    DEFAULT         reduce using rule 175 (expression -> array_type LBRACE RBRACE .)
    LBRACE          reduce using rule 175 (expression -> array_type LBRACE RBRACE .)
    COMMA           reduce using rule 175 (expression -> array_type LBRACE RBRACE .)
    COLON           reduce using rule 175 (expression -> array_type LBRACE RBRACE .)


state 134

    (65) slice_type -> LBRACKET RBRACKET primitive_type .

    LBRACE          reduce using rule 65 (slice_type -> LBRACKET RBRACKET primitive_type .)
    FUNC            reduce using rule 65 (slice_type -> LBRACKET RBRACKET primitive_type .)
    TYPE            reduce using rule 65 (slice_type -> LBRACKET RBRACKET primitive_type .)
    VAR             reduce using rule 65 (slice_type -> LBRACKET RBRACKET primitive_type .)
    CONST           reduce using rule 65 (slice_type -> LBRACKET RBRACKET primitive_type .)
    IDENTIFIER      reduce using rule 65 (slice_type -> LBRACKET RBRACKET primitive_type .)
    LPAREN          reduce using rule 65 (slice_type -> LBRACKET RBRACKET primitive_type .)
    INT             reduce using rule 65 (slice_type -> LBRACKET RBRACKET primitive_type .)
    FLOAT64         reduce using rule 65 (slice_type -> LBRACKET RBRACKET primitive_type .)
    STRING          reduce using rule 65 (slice_type -> LBRACKET RBRACKET primitive_type .)
    TRUE            reduce using rule 65 (slice_type -> LBRACKET RBRACKET primitive_type .)
    FALSE           reduce using rule 65 (slice_type -> LBRACKET RBRACKET primitive_type .)
    LNOT            reduce using rule 65 (slice_type -> LBRACKET RBRACKET primitive_type .)
    LBRACKET        reduce using rule 65 (slice_type -> LBRACKET RBRACKET primitive_type .)
    MAP             reduce using rule 65 (slice_type -> LBRACKET RBRACKET primitive_type .)
    $end            reduce using rule 65 (slice_type -> LBRACKET RBRACKET primitive_type .)
    ASSIGN          reduce using rule 65 (slice_type -> LBRACKET RBRACKET primitive_type .)
    SEMICOLON       reduce using rule 65 (slice_type -> LBRACKET RBRACKET primitive_type .)
    RBRACE          reduce using rule 65 (slice_type -> LBRACKET RBRACKET primitive_type .)
    CASE            reduce using rule 65 (slice_type -> LBRACKET RBRACKET primitive_type .)
    DEFAULT         reduce using rule 65 (slice_type -> LBRACKET RBRACKET primitive_type .)
    RPAREN          reduce using rule 65 (slice_type -> LBRACKET RBRACKET primitive_type .)
    COMMA           reduce using rule 65 (slice_type -> LBRACKET RBRACKET primitive_type .)


state 135

    (173) array_type -> LBRACKET INT RBRACKET . primitive_type
    (61) primitive_type -> . INT_TYPE
    (62) primitive_type -> . FLOAT64_TYPE
    (63) primitive_type -> . STRING_TYPE
    (64) primitive_type -> . BOOL_TYPE

    INT_TYPE        shift and go to state 120
    FLOAT64_TYPE    shift and go to state 121
    STRING_TYPE     shift and go to state 122
    BOOL_TYPE       shift and go to state 123

    primitive_type                 shift and go to state 157

state 136

    (134) map_type -> MAP LBRACKET primitive_type . RBRACKET primitive_type

    RBRACKET        shift and go to state 158


state 137

    (177) expression -> expression DOT IDENTIFIER LPAREN . argument_list RPAREN
    (179) argument_list -> . expression_list
    (180) argument_list -> . empty
    (68) expression_list -> . expression
    (69) expression_list -> . expression_list COMMA expression
    (7) empty -> .
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (123) expression -> . LNOT expression
    (124) expression -> . IDENTIFIER PLUSPLUS
    (125) expression -> . IDENTIFIER MINUSMINUS
    (135) expression -> . map_type LBRACE expression_map_list RBRACE
    (136) expression -> . map_type LBRACE RBRACE
    (158) expression -> . IDENTIFIER LBRACE keyed_element_list RBRACE
    (159) expression -> . IDENTIFIER LBRACE RBRACE
    (174) expression -> . array_type LBRACE expression_list RBRACE
    (175) expression -> . array_type LBRACE RBRACE
    (176) expression -> . expression DOT IDENTIFIER
    (177) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (178) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (134) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (173) array_type -> . LBRACKET INT RBRACKET primitive_type

    RPAREN          reduce using rule 7 (empty -> .)
    LPAREN          shift and go to state 23
    INT             shift and go to state 28
    FLOAT64         shift and go to state 29
    IDENTIFIER      shift and go to state 82
    STRING          shift and go to state 12
    TRUE            shift and go to state 30
    FALSE           shift and go to state 31
    LNOT            shift and go to state 32
    LBRACKET        shift and go to state 35
    MAP             shift and go to state 36

    expression                     shift and go to state 109
    argument_list                  shift and go to state 159
    expression_list                shift and go to state 107
    empty                          shift and go to state 108
    slice_type                     shift and go to state 27
    map_type                       shift and go to state 33
    array_type                     shift and go to state 34

state 138

    (114) parameter -> IDENTIFIER . type
    (115) parameter -> IDENTIFIER . ELLIPSIS primitive_type
    (57) type -> . primitive_type
    (58) type -> . slice_type
    (59) type -> . array_type
    (60) type -> . map_type
    (61) primitive_type -> . INT_TYPE
    (62) primitive_type -> . FLOAT64_TYPE
    (63) primitive_type -> . STRING_TYPE
    (64) primitive_type -> . BOOL_TYPE
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (173) array_type -> . LBRACKET INT RBRACKET primitive_type
    (134) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type

    ELLIPSIS        shift and go to state 161
    INT_TYPE        shift and go to state 120
    FLOAT64_TYPE    shift and go to state 121
    STRING_TYPE     shift and go to state 122
    BOOL_TYPE       shift and go to state 123
    LBRACKET        shift and go to state 35
    MAP             shift and go to state 36

    type                           shift and go to state 160
    primitive_type                 shift and go to state 116
    slice_type                     shift and go to state 117
    array_type                     shift and go to state 118
    map_type                       shift and go to state 119

state 139

    (110) function_declaration -> FUNC IDENTIFIER LPAREN parameter_list . RPAREN return_type block
    (111) parameter_list -> parameter_list . COMMA parameter

    RPAREN          shift and go to state 162
    COMMA           shift and go to state 163


state 140

    (112) parameter_list -> parameter .

    RPAREN          reduce using rule 112 (parameter_list -> parameter .)
    COMMA           reduce using rule 112 (parameter_list -> parameter .)


state 141

    (113) parameter_list -> empty .

    RPAREN          reduce using rule 113 (parameter_list -> empty .)
    COMMA           reduce using rule 113 (parameter_list -> empty .)


state 142

    (143) method_declaration -> FUNC LPAREN receiver RPAREN . IDENTIFIER LPAREN parameter_list RPAREN return_type block

    IDENTIFIER      shift and go to state 164


state 143

    (144) receiver -> IDENTIFIER IDENTIFIER .

    RPAREN          reduce using rule 144 (receiver -> IDENTIFIER IDENTIFIER .)


state 144

    (145) receiver -> IDENTIFIER TIMES . IDENTIFIER
    (146) receiver -> IDENTIFIER TIMES . type
    (57) type -> . primitive_type
    (58) type -> . slice_type
    (59) type -> . array_type
    (60) type -> . map_type
    (61) primitive_type -> . INT_TYPE
    (62) primitive_type -> . FLOAT64_TYPE
    (63) primitive_type -> . STRING_TYPE
    (64) primitive_type -> . BOOL_TYPE
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (173) array_type -> . LBRACKET INT RBRACKET primitive_type
    (134) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type

    IDENTIFIER      shift and go to state 165
    INT_TYPE        shift and go to state 120
    FLOAT64_TYPE    shift and go to state 121
    STRING_TYPE     shift and go to state 122
    BOOL_TYPE       shift and go to state 123
    LBRACKET        shift and go to state 35
    MAP             shift and go to state 36

    type                           shift and go to state 166
    primitive_type                 shift and go to state 116
    slice_type                     shift and go to state 117
    array_type                     shift and go to state 118
    map_type                       shift and go to state 119

state 145

    (155) keyed_element -> IDENTIFIER COLON . expression
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (123) expression -> . LNOT expression
    (124) expression -> . IDENTIFIER PLUSPLUS
    (125) expression -> . IDENTIFIER MINUSMINUS
    (135) expression -> . map_type LBRACE expression_map_list RBRACE
    (136) expression -> . map_type LBRACE RBRACE
    (158) expression -> . IDENTIFIER LBRACE keyed_element_list RBRACE
    (159) expression -> . IDENTIFIER LBRACE RBRACE
    (174) expression -> . array_type LBRACE expression_list RBRACE
    (175) expression -> . array_type LBRACE RBRACE
    (176) expression -> . expression DOT IDENTIFIER
    (177) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (178) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (134) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (173) array_type -> . LBRACKET INT RBRACKET primitive_type

    LPAREN          shift and go to state 23
    INT             shift and go to state 28
    FLOAT64         shift and go to state 29
    IDENTIFIER      shift and go to state 82
    STRING          shift and go to state 12
    TRUE            shift and go to state 30
    FALSE           shift and go to state 31
    LNOT            shift and go to state 32
    LBRACKET        shift and go to state 35
    MAP             shift and go to state 36

    expression                     shift and go to state 167
    slice_type                     shift and go to state 27
    map_type                       shift and go to state 33
    array_type                     shift and go to state 34

state 146

    (158) expression -> IDENTIFIER LBRACE keyed_element_list RBRACE .

    DOT             reduce using rule 158 (expression -> IDENTIFIER LBRACE keyed_element_list RBRACE .)
    PLUS            reduce using rule 158 (expression -> IDENTIFIER LBRACE keyed_element_list RBRACE .)
    MINUS           reduce using rule 158 (expression -> IDENTIFIER LBRACE keyed_element_list RBRACE .)
    TIMES           reduce using rule 158 (expression -> IDENTIFIER LBRACE keyed_element_list RBRACE .)
    DIVIDE          reduce using rule 158 (expression -> IDENTIFIER LBRACE keyed_element_list RBRACE .)
    MODULE          reduce using rule 158 (expression -> IDENTIFIER LBRACE keyed_element_list RBRACE .)
    EQ              reduce using rule 158 (expression -> IDENTIFIER LBRACE keyed_element_list RBRACE .)
    NEQ             reduce using rule 158 (expression -> IDENTIFIER LBRACE keyed_element_list RBRACE .)
    LT              reduce using rule 158 (expression -> IDENTIFIER LBRACE keyed_element_list RBRACE .)
    LE              reduce using rule 158 (expression -> IDENTIFIER LBRACE keyed_element_list RBRACE .)
    GT              reduce using rule 158 (expression -> IDENTIFIER LBRACE keyed_element_list RBRACE .)
    GE              reduce using rule 158 (expression -> IDENTIFIER LBRACE keyed_element_list RBRACE .)
    LAND            reduce using rule 158 (expression -> IDENTIFIER LBRACE keyed_element_list RBRACE .)
    LOR             reduce using rule 158 (expression -> IDENTIFIER LBRACE keyed_element_list RBRACE .)
    AND             reduce using rule 158 (expression -> IDENTIFIER LBRACE keyed_element_list RBRACE .)
    OR              reduce using rule 158 (expression -> IDENTIFIER LBRACE keyed_element_list RBRACE .)
    XOR             reduce using rule 158 (expression -> IDENTIFIER LBRACE keyed_element_list RBRACE .)
    AND_NOT         reduce using rule 158 (expression -> IDENTIFIER LBRACE keyed_element_list RBRACE .)
    LSHIFT          reduce using rule 158 (expression -> IDENTIFIER LBRACE keyed_element_list RBRACE .)
    RSHIFT          reduce using rule 158 (expression -> IDENTIFIER LBRACE keyed_element_list RBRACE .)
    SEMICOLON       reduce using rule 158 (expression -> IDENTIFIER LBRACE keyed_element_list RBRACE .)
    FUNC            reduce using rule 158 (expression -> IDENTIFIER LBRACE keyed_element_list RBRACE .)
    TYPE            reduce using rule 158 (expression -> IDENTIFIER LBRACE keyed_element_list RBRACE .)
    VAR             reduce using rule 158 (expression -> IDENTIFIER LBRACE keyed_element_list RBRACE .)
    CONST           reduce using rule 158 (expression -> IDENTIFIER LBRACE keyed_element_list RBRACE .)
    IDENTIFIER      reduce using rule 158 (expression -> IDENTIFIER LBRACE keyed_element_list RBRACE .)
    LPAREN          reduce using rule 158 (expression -> IDENTIFIER LBRACE keyed_element_list RBRACE .)
    INT             reduce using rule 158 (expression -> IDENTIFIER LBRACE keyed_element_list RBRACE .)
    FLOAT64         reduce using rule 158 (expression -> IDENTIFIER LBRACE keyed_element_list RBRACE .)
    STRING          reduce using rule 158 (expression -> IDENTIFIER LBRACE keyed_element_list RBRACE .)
    TRUE            reduce using rule 158 (expression -> IDENTIFIER LBRACE keyed_element_list RBRACE .)
    FALSE           reduce using rule 158 (expression -> IDENTIFIER LBRACE keyed_element_list RBRACE .)
    LNOT            reduce using rule 158 (expression -> IDENTIFIER LBRACE keyed_element_list RBRACE .)
    LBRACKET        reduce using rule 158 (expression -> IDENTIFIER LBRACE keyed_element_list RBRACE .)
    MAP             reduce using rule 158 (expression -> IDENTIFIER LBRACE keyed_element_list RBRACE .)
    $end            reduce using rule 158 (expression -> IDENTIFIER LBRACE keyed_element_list RBRACE .)
    RPAREN          reduce using rule 158 (expression -> IDENTIFIER LBRACE keyed_element_list RBRACE .)
    RBRACE          reduce using rule 158 (expression -> IDENTIFIER LBRACE keyed_element_list RBRACE .)
    CASE            reduce using rule 158 (expression -> IDENTIFIER LBRACE keyed_element_list RBRACE .)
    DEFAULT         reduce using rule 158 (expression -> IDENTIFIER LBRACE keyed_element_list RBRACE .)
    LBRACE          reduce using rule 158 (expression -> IDENTIFIER LBRACE keyed_element_list RBRACE .)
    COMMA           reduce using rule 158 (expression -> IDENTIFIER LBRACE keyed_element_list RBRACE .)
    COLON           reduce using rule 158 (expression -> IDENTIFIER LBRACE keyed_element_list RBRACE .)


state 147

    (154) keyed_element_list -> keyed_element_list COMMA . keyed_element
    (155) keyed_element -> . IDENTIFIER COLON expression
    (156) keyed_element -> . INT COLON expression
    (157) keyed_element -> . expression
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (123) expression -> . LNOT expression
    (124) expression -> . IDENTIFIER PLUSPLUS
    (125) expression -> . IDENTIFIER MINUSMINUS
    (135) expression -> . map_type LBRACE expression_map_list RBRACE
    (136) expression -> . map_type LBRACE RBRACE
    (158) expression -> . IDENTIFIER LBRACE keyed_element_list RBRACE
    (159) expression -> . IDENTIFIER LBRACE RBRACE
    (174) expression -> . array_type LBRACE expression_list RBRACE
    (175) expression -> . array_type LBRACE RBRACE
    (176) expression -> . expression DOT IDENTIFIER
    (177) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (178) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (134) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (173) array_type -> . LBRACKET INT RBRACKET primitive_type

    IDENTIFIER      shift and go to state 100
    INT             shift and go to state 105
    LPAREN          shift and go to state 23
    FLOAT64         shift and go to state 29
    STRING          shift and go to state 12
    TRUE            shift and go to state 30
    FALSE           shift and go to state 31
    LNOT            shift and go to state 32
    LBRACKET        shift and go to state 35
    MAP             shift and go to state 36

    keyed_element                  shift and go to state 168
    expression                     shift and go to state 104
    slice_type                     shift and go to state 27
    map_type                       shift and go to state 33
    array_type                     shift and go to state 34

state 148

    (156) keyed_element -> INT COLON . expression
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (123) expression -> . LNOT expression
    (124) expression -> . IDENTIFIER PLUSPLUS
    (125) expression -> . IDENTIFIER MINUSMINUS
    (135) expression -> . map_type LBRACE expression_map_list RBRACE
    (136) expression -> . map_type LBRACE RBRACE
    (158) expression -> . IDENTIFIER LBRACE keyed_element_list RBRACE
    (159) expression -> . IDENTIFIER LBRACE RBRACE
    (174) expression -> . array_type LBRACE expression_list RBRACE
    (175) expression -> . array_type LBRACE RBRACE
    (176) expression -> . expression DOT IDENTIFIER
    (177) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (178) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (134) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (173) array_type -> . LBRACKET INT RBRACKET primitive_type

    LPAREN          shift and go to state 23
    INT             shift and go to state 28
    FLOAT64         shift and go to state 29
    IDENTIFIER      shift and go to state 82
    STRING          shift and go to state 12
    TRUE            shift and go to state 30
    FALSE           shift and go to state 31
    LNOT            shift and go to state 32
    LBRACKET        shift and go to state 35
    MAP             shift and go to state 36

    expression                     shift and go to state 169
    slice_type                     shift and go to state 27
    map_type                       shift and go to state 33
    array_type                     shift and go to state 34

state 149

    (178) expression -> IDENTIFIER LPAREN argument_list RPAREN .

    DOT             reduce using rule 178 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    PLUS            reduce using rule 178 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    MINUS           reduce using rule 178 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    TIMES           reduce using rule 178 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    DIVIDE          reduce using rule 178 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    MODULE          reduce using rule 178 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    EQ              reduce using rule 178 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    NEQ             reduce using rule 178 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    LT              reduce using rule 178 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    LE              reduce using rule 178 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    GT              reduce using rule 178 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    GE              reduce using rule 178 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    LAND            reduce using rule 178 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    LOR             reduce using rule 178 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    AND             reduce using rule 178 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    OR              reduce using rule 178 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    XOR             reduce using rule 178 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    AND_NOT         reduce using rule 178 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    LSHIFT          reduce using rule 178 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    RSHIFT          reduce using rule 178 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    SEMICOLON       reduce using rule 178 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    FUNC            reduce using rule 178 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    TYPE            reduce using rule 178 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    VAR             reduce using rule 178 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    CONST           reduce using rule 178 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    IDENTIFIER      reduce using rule 178 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    LPAREN          reduce using rule 178 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    INT             reduce using rule 178 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    FLOAT64         reduce using rule 178 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    STRING          reduce using rule 178 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    TRUE            reduce using rule 178 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    FALSE           reduce using rule 178 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    LNOT            reduce using rule 178 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    LBRACKET        reduce using rule 178 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    MAP             reduce using rule 178 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    $end            reduce using rule 178 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    RPAREN          reduce using rule 178 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    RBRACE          reduce using rule 178 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    CASE            reduce using rule 178 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    DEFAULT         reduce using rule 178 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    LBRACE          reduce using rule 178 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    COMMA           reduce using rule 178 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    COLON           reduce using rule 178 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)


state 150

    (69) expression_list -> expression_list COMMA . expression
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (123) expression -> . LNOT expression
    (124) expression -> . IDENTIFIER PLUSPLUS
    (125) expression -> . IDENTIFIER MINUSMINUS
    (135) expression -> . map_type LBRACE expression_map_list RBRACE
    (136) expression -> . map_type LBRACE RBRACE
    (158) expression -> . IDENTIFIER LBRACE keyed_element_list RBRACE
    (159) expression -> . IDENTIFIER LBRACE RBRACE
    (174) expression -> . array_type LBRACE expression_list RBRACE
    (175) expression -> . array_type LBRACE RBRACE
    (176) expression -> . expression DOT IDENTIFIER
    (177) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (178) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (134) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (173) array_type -> . LBRACKET INT RBRACKET primitive_type

    LPAREN          shift and go to state 23
    INT             shift and go to state 28
    FLOAT64         shift and go to state 29
    IDENTIFIER      shift and go to state 82
    STRING          shift and go to state 12
    TRUE            shift and go to state 30
    FALSE           shift and go to state 31
    LNOT            shift and go to state 32
    LBRACKET        shift and go to state 35
    MAP             shift and go to state 36

    expression                     shift and go to state 170
    slice_type                     shift and go to state 27
    map_type                       shift and go to state 33
    array_type                     shift and go to state 34

state 151

    (151) struct_type -> STRUCT LBRACE . RBRACE
    (152) struct_type -> STRUCT LBRACE . field_list RBRACE
    (140) field_list -> . field_declaration
    (141) field_list -> . field_list SEMICOLON field_declaration
    (142) field_declaration -> . IDENTIFIER type

    RBRACE          shift and go to state 171
    IDENTIFIER      shift and go to state 174

    field_list                     shift and go to state 172
    field_declaration              shift and go to state 173

state 152

    (66) expression -> slice_type LBRACE expression_list RBRACE .

    DOT             reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    PLUS            reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    MINUS           reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    TIMES           reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    DIVIDE          reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    MODULE          reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    EQ              reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    NEQ             reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    LT              reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    LE              reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    GT              reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    GE              reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    LAND            reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    LOR             reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    AND             reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    OR              reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    XOR             reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    AND_NOT         reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    LSHIFT          reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    RSHIFT          reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    SEMICOLON       reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    FUNC            reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    TYPE            reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    VAR             reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    CONST           reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    IDENTIFIER      reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    LPAREN          reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    INT             reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    FLOAT64         reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    STRING          reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    TRUE            reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    FALSE           reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    LNOT            reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    LBRACKET        reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    MAP             reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    $end            reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    RPAREN          reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    RBRACE          reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    CASE            reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    DEFAULT         reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    LBRACE          reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    COMMA           reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    COLON           reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)


state 153

    (135) expression -> map_type LBRACE expression_map_list RBRACE .

    DOT             reduce using rule 135 (expression -> map_type LBRACE expression_map_list RBRACE .)
    PLUS            reduce using rule 135 (expression -> map_type LBRACE expression_map_list RBRACE .)
    MINUS           reduce using rule 135 (expression -> map_type LBRACE expression_map_list RBRACE .)
    TIMES           reduce using rule 135 (expression -> map_type LBRACE expression_map_list RBRACE .)
    DIVIDE          reduce using rule 135 (expression -> map_type LBRACE expression_map_list RBRACE .)
    MODULE          reduce using rule 135 (expression -> map_type LBRACE expression_map_list RBRACE .)
    EQ              reduce using rule 135 (expression -> map_type LBRACE expression_map_list RBRACE .)
    NEQ             reduce using rule 135 (expression -> map_type LBRACE expression_map_list RBRACE .)
    LT              reduce using rule 135 (expression -> map_type LBRACE expression_map_list RBRACE .)
    LE              reduce using rule 135 (expression -> map_type LBRACE expression_map_list RBRACE .)
    GT              reduce using rule 135 (expression -> map_type LBRACE expression_map_list RBRACE .)
    GE              reduce using rule 135 (expression -> map_type LBRACE expression_map_list RBRACE .)
    LAND            reduce using rule 135 (expression -> map_type LBRACE expression_map_list RBRACE .)
    LOR             reduce using rule 135 (expression -> map_type LBRACE expression_map_list RBRACE .)
    AND             reduce using rule 135 (expression -> map_type LBRACE expression_map_list RBRACE .)
    OR              reduce using rule 135 (expression -> map_type LBRACE expression_map_list RBRACE .)
    XOR             reduce using rule 135 (expression -> map_type LBRACE expression_map_list RBRACE .)
    AND_NOT         reduce using rule 135 (expression -> map_type LBRACE expression_map_list RBRACE .)
    LSHIFT          reduce using rule 135 (expression -> map_type LBRACE expression_map_list RBRACE .)
    RSHIFT          reduce using rule 135 (expression -> map_type LBRACE expression_map_list RBRACE .)
    SEMICOLON       reduce using rule 135 (expression -> map_type LBRACE expression_map_list RBRACE .)
    FUNC            reduce using rule 135 (expression -> map_type LBRACE expression_map_list RBRACE .)
    TYPE            reduce using rule 135 (expression -> map_type LBRACE expression_map_list RBRACE .)
    VAR             reduce using rule 135 (expression -> map_type LBRACE expression_map_list RBRACE .)
    CONST           reduce using rule 135 (expression -> map_type LBRACE expression_map_list RBRACE .)
    IDENTIFIER      reduce using rule 135 (expression -> map_type LBRACE expression_map_list RBRACE .)
    LPAREN          reduce using rule 135 (expression -> map_type LBRACE expression_map_list RBRACE .)
    INT             reduce using rule 135 (expression -> map_type LBRACE expression_map_list RBRACE .)
    FLOAT64         reduce using rule 135 (expression -> map_type LBRACE expression_map_list RBRACE .)
    STRING          reduce using rule 135 (expression -> map_type LBRACE expression_map_list RBRACE .)
    TRUE            reduce using rule 135 (expression -> map_type LBRACE expression_map_list RBRACE .)
    FALSE           reduce using rule 135 (expression -> map_type LBRACE expression_map_list RBRACE .)
    LNOT            reduce using rule 135 (expression -> map_type LBRACE expression_map_list RBRACE .)
    LBRACKET        reduce using rule 135 (expression -> map_type LBRACE expression_map_list RBRACE .)
    MAP             reduce using rule 135 (expression -> map_type LBRACE expression_map_list RBRACE .)
    $end            reduce using rule 135 (expression -> map_type LBRACE expression_map_list RBRACE .)
    RPAREN          reduce using rule 135 (expression -> map_type LBRACE expression_map_list RBRACE .)
    RBRACE          reduce using rule 135 (expression -> map_type LBRACE expression_map_list RBRACE .)
    CASE            reduce using rule 135 (expression -> map_type LBRACE expression_map_list RBRACE .)
    DEFAULT         reduce using rule 135 (expression -> map_type LBRACE expression_map_list RBRACE .)
    LBRACE          reduce using rule 135 (expression -> map_type LBRACE expression_map_list RBRACE .)
    COMMA           reduce using rule 135 (expression -> map_type LBRACE expression_map_list RBRACE .)
    COLON           reduce using rule 135 (expression -> map_type LBRACE expression_map_list RBRACE .)


state 154

    (138) expression_map_list -> expression_map_list COMMA . key_value
    (139) key_value -> . expression COLON expression
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (123) expression -> . LNOT expression
    (124) expression -> . IDENTIFIER PLUSPLUS
    (125) expression -> . IDENTIFIER MINUSMINUS
    (135) expression -> . map_type LBRACE expression_map_list RBRACE
    (136) expression -> . map_type LBRACE RBRACE
    (158) expression -> . IDENTIFIER LBRACE keyed_element_list RBRACE
    (159) expression -> . IDENTIFIER LBRACE RBRACE
    (174) expression -> . array_type LBRACE expression_list RBRACE
    (175) expression -> . array_type LBRACE RBRACE
    (176) expression -> . expression DOT IDENTIFIER
    (177) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (178) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (134) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (173) array_type -> . LBRACKET INT RBRACKET primitive_type

    LPAREN          shift and go to state 23
    INT             shift and go to state 28
    FLOAT64         shift and go to state 29
    IDENTIFIER      shift and go to state 82
    STRING          shift and go to state 12
    TRUE            shift and go to state 30
    FALSE           shift and go to state 31
    LNOT            shift and go to state 32
    LBRACKET        shift and go to state 35
    MAP             shift and go to state 36

    key_value                      shift and go to state 175
    expression                     shift and go to state 131
    slice_type                     shift and go to state 27
    map_type                       shift and go to state 33
    array_type                     shift and go to state 34

state 155

    (139) key_value -> expression COLON . expression
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (123) expression -> . LNOT expression
    (124) expression -> . IDENTIFIER PLUSPLUS
    (125) expression -> . IDENTIFIER MINUSMINUS
    (135) expression -> . map_type LBRACE expression_map_list RBRACE
    (136) expression -> . map_type LBRACE RBRACE
    (158) expression -> . IDENTIFIER LBRACE keyed_element_list RBRACE
    (159) expression -> . IDENTIFIER LBRACE RBRACE
    (174) expression -> . array_type LBRACE expression_list RBRACE
    (175) expression -> . array_type LBRACE RBRACE
    (176) expression -> . expression DOT IDENTIFIER
    (177) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (178) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (134) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (173) array_type -> . LBRACKET INT RBRACKET primitive_type

    LPAREN          shift and go to state 23
    INT             shift and go to state 28
    FLOAT64         shift and go to state 29
    IDENTIFIER      shift and go to state 82
    STRING          shift and go to state 12
    TRUE            shift and go to state 30
    FALSE           shift and go to state 31
    LNOT            shift and go to state 32
    LBRACKET        shift and go to state 35
    MAP             shift and go to state 36

    expression                     shift and go to state 176
    slice_type                     shift and go to state 27
    map_type                       shift and go to state 33
    array_type                     shift and go to state 34

state 156

    (174) expression -> array_type LBRACE expression_list RBRACE .

    DOT             reduce using rule 174 (expression -> array_type LBRACE expression_list RBRACE .)
    PLUS            reduce using rule 174 (expression -> array_type LBRACE expression_list RBRACE .)
    MINUS           reduce using rule 174 (expression -> array_type LBRACE expression_list RBRACE .)
    TIMES           reduce using rule 174 (expression -> array_type LBRACE expression_list RBRACE .)
    DIVIDE          reduce using rule 174 (expression -> array_type LBRACE expression_list RBRACE .)
    MODULE          reduce using rule 174 (expression -> array_type LBRACE expression_list RBRACE .)
    EQ              reduce using rule 174 (expression -> array_type LBRACE expression_list RBRACE .)
    NEQ             reduce using rule 174 (expression -> array_type LBRACE expression_list RBRACE .)
    LT              reduce using rule 174 (expression -> array_type LBRACE expression_list RBRACE .)
    LE              reduce using rule 174 (expression -> array_type LBRACE expression_list RBRACE .)
    GT              reduce using rule 174 (expression -> array_type LBRACE expression_list RBRACE .)
    GE              reduce using rule 174 (expression -> array_type LBRACE expression_list RBRACE .)
    LAND            reduce using rule 174 (expression -> array_type LBRACE expression_list RBRACE .)
    LOR             reduce using rule 174 (expression -> array_type LBRACE expression_list RBRACE .)
    AND             reduce using rule 174 (expression -> array_type LBRACE expression_list RBRACE .)
    OR              reduce using rule 174 (expression -> array_type LBRACE expression_list RBRACE .)
    XOR             reduce using rule 174 (expression -> array_type LBRACE expression_list RBRACE .)
    AND_NOT         reduce using rule 174 (expression -> array_type LBRACE expression_list RBRACE .)
    LSHIFT          reduce using rule 174 (expression -> array_type LBRACE expression_list RBRACE .)
    RSHIFT          reduce using rule 174 (expression -> array_type LBRACE expression_list RBRACE .)
    SEMICOLON       reduce using rule 174 (expression -> array_type LBRACE expression_list RBRACE .)
    FUNC            reduce using rule 174 (expression -> array_type LBRACE expression_list RBRACE .)
    TYPE            reduce using rule 174 (expression -> array_type LBRACE expression_list RBRACE .)
    VAR             reduce using rule 174 (expression -> array_type LBRACE expression_list RBRACE .)
    CONST           reduce using rule 174 (expression -> array_type LBRACE expression_list RBRACE .)
    IDENTIFIER      reduce using rule 174 (expression -> array_type LBRACE expression_list RBRACE .)
    LPAREN          reduce using rule 174 (expression -> array_type LBRACE expression_list RBRACE .)
    INT             reduce using rule 174 (expression -> array_type LBRACE expression_list RBRACE .)
    FLOAT64         reduce using rule 174 (expression -> array_type LBRACE expression_list RBRACE .)
    STRING          reduce using rule 174 (expression -> array_type LBRACE expression_list RBRACE .)
    TRUE            reduce using rule 174 (expression -> array_type LBRACE expression_list RBRACE .)
    FALSE           reduce using rule 174 (expression -> array_type LBRACE expression_list RBRACE .)
    LNOT            reduce using rule 174 (expression -> array_type LBRACE expression_list RBRACE .)
    LBRACKET        reduce using rule 174 (expression -> array_type LBRACE expression_list RBRACE .)
    MAP             reduce using rule 174 (expression -> array_type LBRACE expression_list RBRACE .)
    $end            reduce using rule 174 (expression -> array_type LBRACE expression_list RBRACE .)
    RPAREN          reduce using rule 174 (expression -> array_type LBRACE expression_list RBRACE .)
    RBRACE          reduce using rule 174 (expression -> array_type LBRACE expression_list RBRACE .)
    CASE            reduce using rule 174 (expression -> array_type LBRACE expression_list RBRACE .)
    DEFAULT         reduce using rule 174 (expression -> array_type LBRACE expression_list RBRACE .)
    LBRACE          reduce using rule 174 (expression -> array_type LBRACE expression_list RBRACE .)
    COMMA           reduce using rule 174 (expression -> array_type LBRACE expression_list RBRACE .)
    COLON           reduce using rule 174 (expression -> array_type LBRACE expression_list RBRACE .)


state 157

    (173) array_type -> LBRACKET INT RBRACKET primitive_type .

    LBRACE          reduce using rule 173 (array_type -> LBRACKET INT RBRACKET primitive_type .)
    FUNC            reduce using rule 173 (array_type -> LBRACKET INT RBRACKET primitive_type .)
    TYPE            reduce using rule 173 (array_type -> LBRACKET INT RBRACKET primitive_type .)
    VAR             reduce using rule 173 (array_type -> LBRACKET INT RBRACKET primitive_type .)
    CONST           reduce using rule 173 (array_type -> LBRACKET INT RBRACKET primitive_type .)
    IDENTIFIER      reduce using rule 173 (array_type -> LBRACKET INT RBRACKET primitive_type .)
    LPAREN          reduce using rule 173 (array_type -> LBRACKET INT RBRACKET primitive_type .)
    INT             reduce using rule 173 (array_type -> LBRACKET INT RBRACKET primitive_type .)
    FLOAT64         reduce using rule 173 (array_type -> LBRACKET INT RBRACKET primitive_type .)
    STRING          reduce using rule 173 (array_type -> LBRACKET INT RBRACKET primitive_type .)
    TRUE            reduce using rule 173 (array_type -> LBRACKET INT RBRACKET primitive_type .)
    FALSE           reduce using rule 173 (array_type -> LBRACKET INT RBRACKET primitive_type .)
    LNOT            reduce using rule 173 (array_type -> LBRACKET INT RBRACKET primitive_type .)
    LBRACKET        reduce using rule 173 (array_type -> LBRACKET INT RBRACKET primitive_type .)
    MAP             reduce using rule 173 (array_type -> LBRACKET INT RBRACKET primitive_type .)
    $end            reduce using rule 173 (array_type -> LBRACKET INT RBRACKET primitive_type .)
    ASSIGN          reduce using rule 173 (array_type -> LBRACKET INT RBRACKET primitive_type .)
    SEMICOLON       reduce using rule 173 (array_type -> LBRACKET INT RBRACKET primitive_type .)
    RBRACE          reduce using rule 173 (array_type -> LBRACKET INT RBRACKET primitive_type .)
    CASE            reduce using rule 173 (array_type -> LBRACKET INT RBRACKET primitive_type .)
    DEFAULT         reduce using rule 173 (array_type -> LBRACKET INT RBRACKET primitive_type .)
    RPAREN          reduce using rule 173 (array_type -> LBRACKET INT RBRACKET primitive_type .)
    COMMA           reduce using rule 173 (array_type -> LBRACKET INT RBRACKET primitive_type .)


state 158

    (134) map_type -> MAP LBRACKET primitive_type RBRACKET . primitive_type
    (61) primitive_type -> . INT_TYPE
    (62) primitive_type -> . FLOAT64_TYPE
    (63) primitive_type -> . STRING_TYPE
    (64) primitive_type -> . BOOL_TYPE

    INT_TYPE        shift and go to state 120
    FLOAT64_TYPE    shift and go to state 121
    STRING_TYPE     shift and go to state 122
    BOOL_TYPE       shift and go to state 123

    primitive_type                 shift and go to state 177

state 159

    (177) expression -> expression DOT IDENTIFIER LPAREN argument_list . RPAREN

    RPAREN          shift and go to state 178


state 160

    (114) parameter -> IDENTIFIER type .

    RPAREN          reduce using rule 114 (parameter -> IDENTIFIER type .)
    COMMA           reduce using rule 114 (parameter -> IDENTIFIER type .)


state 161

    (115) parameter -> IDENTIFIER ELLIPSIS . primitive_type
    (61) primitive_type -> . INT_TYPE
    (62) primitive_type -> . FLOAT64_TYPE
    (63) primitive_type -> . STRING_TYPE
    (64) primitive_type -> . BOOL_TYPE

    INT_TYPE        shift and go to state 120
    FLOAT64_TYPE    shift and go to state 121
    STRING_TYPE     shift and go to state 122
    BOOL_TYPE       shift and go to state 123

    primitive_type                 shift and go to state 179

state 162

    (110) function_declaration -> FUNC IDENTIFIER LPAREN parameter_list RPAREN . return_type block
    (116) return_type -> . type
    (117) return_type -> . LPAREN type_list RPAREN
    (118) return_type -> . empty
    (57) type -> . primitive_type
    (58) type -> . slice_type
    (59) type -> . array_type
    (60) type -> . map_type
    (7) empty -> .
    (61) primitive_type -> . INT_TYPE
    (62) primitive_type -> . FLOAT64_TYPE
    (63) primitive_type -> . STRING_TYPE
    (64) primitive_type -> . BOOL_TYPE
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (173) array_type -> . LBRACKET INT RBRACKET primitive_type
    (134) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type

    LPAREN          shift and go to state 180
    LBRACE          reduce using rule 7 (empty -> .)
    INT_TYPE        shift and go to state 120
    FLOAT64_TYPE    shift and go to state 121
    STRING_TYPE     shift and go to state 122
    BOOL_TYPE       shift and go to state 123
    LBRACKET        shift and go to state 35
    MAP             shift and go to state 36

    return_type                    shift and go to state 181
    type                           shift and go to state 182
    empty                          shift and go to state 183
    primitive_type                 shift and go to state 116
    slice_type                     shift and go to state 117
    array_type                     shift and go to state 118
    map_type                       shift and go to state 119

state 163

    (111) parameter_list -> parameter_list COMMA . parameter
    (114) parameter -> . IDENTIFIER type
    (115) parameter -> . IDENTIFIER ELLIPSIS primitive_type

    IDENTIFIER      shift and go to state 138

    parameter                      shift and go to state 184

state 164

    (143) method_declaration -> FUNC LPAREN receiver RPAREN IDENTIFIER . LPAREN parameter_list RPAREN return_type block

    LPAREN          shift and go to state 185


state 165

    (145) receiver -> IDENTIFIER TIMES IDENTIFIER .

    RPAREN          reduce using rule 145 (receiver -> IDENTIFIER TIMES IDENTIFIER .)


state 166

    (146) receiver -> IDENTIFIER TIMES type .

    RPAREN          reduce using rule 146 (receiver -> IDENTIFIER TIMES type .)


state 167

    (155) keyed_element -> IDENTIFIER COLON expression .
    (36) expression -> expression . binary_operator expression
    (176) expression -> expression . DOT IDENTIFIER
    (177) expression -> expression . DOT IDENTIFIER LPAREN argument_list RPAREN
    (37) binary_operator -> . PLUS
    (38) binary_operator -> . MINUS
    (39) binary_operator -> . TIMES
    (40) binary_operator -> . DIVIDE
    (41) binary_operator -> . MODULE
    (42) binary_operator -> . EQ
    (43) binary_operator -> . NEQ
    (44) binary_operator -> . LT
    (45) binary_operator -> . LE
    (46) binary_operator -> . GT
    (47) binary_operator -> . GE
    (48) binary_operator -> . LAND
    (49) binary_operator -> . LOR
    (50) binary_operator -> . AND
    (51) binary_operator -> . OR
    (52) binary_operator -> . XOR
    (53) binary_operator -> . AND_NOT
    (54) binary_operator -> . LSHIFT
    (55) binary_operator -> . RSHIFT

    RBRACE          reduce using rule 155 (keyed_element -> IDENTIFIER COLON expression .)
    COMMA           reduce using rule 155 (keyed_element -> IDENTIFIER COLON expression .)
    DOT             shift and go to state 43
    PLUS            shift and go to state 44
    MINUS           shift and go to state 45
    TIMES           shift and go to state 46
    DIVIDE          shift and go to state 47
    MODULE          shift and go to state 48
    EQ              shift and go to state 49
    NEQ             shift and go to state 50
    LT              shift and go to state 51
    LE              shift and go to state 52
    GT              shift and go to state 53
    GE              shift and go to state 54
    LAND            shift and go to state 55
    LOR             shift and go to state 56
    AND             shift and go to state 57
    OR              shift and go to state 58
    XOR             shift and go to state 59
    AND_NOT         shift and go to state 60
    LSHIFT          shift and go to state 61
    RSHIFT          shift and go to state 62

    binary_operator                shift and go to state 42

state 168

    (154) keyed_element_list -> keyed_element_list COMMA keyed_element .

    RBRACE          reduce using rule 154 (keyed_element_list -> keyed_element_list COMMA keyed_element .)
    COMMA           reduce using rule 154 (keyed_element_list -> keyed_element_list COMMA keyed_element .)


state 169

    (156) keyed_element -> INT COLON expression .
    (36) expression -> expression . binary_operator expression
    (176) expression -> expression . DOT IDENTIFIER
    (177) expression -> expression . DOT IDENTIFIER LPAREN argument_list RPAREN
    (37) binary_operator -> . PLUS
    (38) binary_operator -> . MINUS
    (39) binary_operator -> . TIMES
    (40) binary_operator -> . DIVIDE
    (41) binary_operator -> . MODULE
    (42) binary_operator -> . EQ
    (43) binary_operator -> . NEQ
    (44) binary_operator -> . LT
    (45) binary_operator -> . LE
    (46) binary_operator -> . GT
    (47) binary_operator -> . GE
    (48) binary_operator -> . LAND
    (49) binary_operator -> . LOR
    (50) binary_operator -> . AND
    (51) binary_operator -> . OR
    (52) binary_operator -> . XOR
    (53) binary_operator -> . AND_NOT
    (54) binary_operator -> . LSHIFT
    (55) binary_operator -> . RSHIFT

    RBRACE          reduce using rule 156 (keyed_element -> INT COLON expression .)
    COMMA           reduce using rule 156 (keyed_element -> INT COLON expression .)
    DOT             shift and go to state 43
    PLUS            shift and go to state 44
    MINUS           shift and go to state 45
    TIMES           shift and go to state 46
    DIVIDE          shift and go to state 47
    MODULE          shift and go to state 48
    EQ              shift and go to state 49
    NEQ             shift and go to state 50
    LT              shift and go to state 51
    LE              shift and go to state 52
    GT              shift and go to state 53
    GE              shift and go to state 54
    LAND            shift and go to state 55
    LOR             shift and go to state 56
    AND             shift and go to state 57
    OR              shift and go to state 58
    XOR             shift and go to state 59
    AND_NOT         shift and go to state 60
    LSHIFT          shift and go to state 61
    RSHIFT          shift and go to state 62

    binary_operator                shift and go to state 42

state 170

    (69) expression_list -> expression_list COMMA expression .
    (36) expression -> expression . binary_operator expression
    (176) expression -> expression . DOT IDENTIFIER
    (177) expression -> expression . DOT IDENTIFIER LPAREN argument_list RPAREN
    (37) binary_operator -> . PLUS
    (38) binary_operator -> . MINUS
    (39) binary_operator -> . TIMES
    (40) binary_operator -> . DIVIDE
    (41) binary_operator -> . MODULE
    (42) binary_operator -> . EQ
    (43) binary_operator -> . NEQ
    (44) binary_operator -> . LT
    (45) binary_operator -> . LE
    (46) binary_operator -> . GT
    (47) binary_operator -> . GE
    (48) binary_operator -> . LAND
    (49) binary_operator -> . LOR
    (50) binary_operator -> . AND
    (51) binary_operator -> . OR
    (52) binary_operator -> . XOR
    (53) binary_operator -> . AND_NOT
    (54) binary_operator -> . LSHIFT
    (55) binary_operator -> . RSHIFT

    COMMA           reduce using rule 69 (expression_list -> expression_list COMMA expression .)
    RPAREN          reduce using rule 69 (expression_list -> expression_list COMMA expression .)
    RBRACE          reduce using rule 69 (expression_list -> expression_list COMMA expression .)
    COLON           reduce using rule 69 (expression_list -> expression_list COMMA expression .)
    DOT             shift and go to state 43
    PLUS            shift and go to state 44
    MINUS           shift and go to state 45
    TIMES           shift and go to state 46
    DIVIDE          shift and go to state 47
    MODULE          shift and go to state 48
    EQ              shift and go to state 49
    NEQ             shift and go to state 50
    LT              shift and go to state 51
    LE              shift and go to state 52
    GT              shift and go to state 53
    GE              shift and go to state 54
    LAND            shift and go to state 55
    LOR             shift and go to state 56
    AND             shift and go to state 57
    OR              shift and go to state 58
    XOR             shift and go to state 59
    AND_NOT         shift and go to state 60
    LSHIFT          shift and go to state 61
    RSHIFT          shift and go to state 62

    binary_operator                shift and go to state 42

state 171

    (151) struct_type -> STRUCT LBRACE RBRACE .

    FUNC            reduce using rule 151 (struct_type -> STRUCT LBRACE RBRACE .)
    TYPE            reduce using rule 151 (struct_type -> STRUCT LBRACE RBRACE .)
    VAR             reduce using rule 151 (struct_type -> STRUCT LBRACE RBRACE .)
    CONST           reduce using rule 151 (struct_type -> STRUCT LBRACE RBRACE .)
    IDENTIFIER      reduce using rule 151 (struct_type -> STRUCT LBRACE RBRACE .)
    LPAREN          reduce using rule 151 (struct_type -> STRUCT LBRACE RBRACE .)
    INT             reduce using rule 151 (struct_type -> STRUCT LBRACE RBRACE .)
    FLOAT64         reduce using rule 151 (struct_type -> STRUCT LBRACE RBRACE .)
    STRING          reduce using rule 151 (struct_type -> STRUCT LBRACE RBRACE .)
    TRUE            reduce using rule 151 (struct_type -> STRUCT LBRACE RBRACE .)
    FALSE           reduce using rule 151 (struct_type -> STRUCT LBRACE RBRACE .)
    LNOT            reduce using rule 151 (struct_type -> STRUCT LBRACE RBRACE .)
    LBRACKET        reduce using rule 151 (struct_type -> STRUCT LBRACE RBRACE .)
    MAP             reduce using rule 151 (struct_type -> STRUCT LBRACE RBRACE .)
    $end            reduce using rule 151 (struct_type -> STRUCT LBRACE RBRACE .)


state 172

    (152) struct_type -> STRUCT LBRACE field_list . RBRACE
    (141) field_list -> field_list . SEMICOLON field_declaration

    RBRACE          shift and go to state 186
    SEMICOLON       shift and go to state 187


state 173

    (140) field_list -> field_declaration .

    RBRACE          reduce using rule 140 (field_list -> field_declaration .)
    SEMICOLON       reduce using rule 140 (field_list -> field_declaration .)


state 174

    (142) field_declaration -> IDENTIFIER . type
    (57) type -> . primitive_type
    (58) type -> . slice_type
    (59) type -> . array_type
    (60) type -> . map_type
    (61) primitive_type -> . INT_TYPE
    (62) primitive_type -> . FLOAT64_TYPE
    (63) primitive_type -> . STRING_TYPE
    (64) primitive_type -> . BOOL_TYPE
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (173) array_type -> . LBRACKET INT RBRACKET primitive_type
    (134) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type

    INT_TYPE        shift and go to state 120
    FLOAT64_TYPE    shift and go to state 121
    STRING_TYPE     shift and go to state 122
    BOOL_TYPE       shift and go to state 123
    LBRACKET        shift and go to state 35
    MAP             shift and go to state 36

    type                           shift and go to state 188
    primitive_type                 shift and go to state 116
    slice_type                     shift and go to state 117
    array_type                     shift and go to state 118
    map_type                       shift and go to state 119

state 175

    (138) expression_map_list -> expression_map_list COMMA key_value .

    RBRACE          reduce using rule 138 (expression_map_list -> expression_map_list COMMA key_value .)
    COMMA           reduce using rule 138 (expression_map_list -> expression_map_list COMMA key_value .)


state 176

    (139) key_value -> expression COLON expression .
    (36) expression -> expression . binary_operator expression
    (176) expression -> expression . DOT IDENTIFIER
    (177) expression -> expression . DOT IDENTIFIER LPAREN argument_list RPAREN
    (37) binary_operator -> . PLUS
    (38) binary_operator -> . MINUS
    (39) binary_operator -> . TIMES
    (40) binary_operator -> . DIVIDE
    (41) binary_operator -> . MODULE
    (42) binary_operator -> . EQ
    (43) binary_operator -> . NEQ
    (44) binary_operator -> . LT
    (45) binary_operator -> . LE
    (46) binary_operator -> . GT
    (47) binary_operator -> . GE
    (48) binary_operator -> . LAND
    (49) binary_operator -> . LOR
    (50) binary_operator -> . AND
    (51) binary_operator -> . OR
    (52) binary_operator -> . XOR
    (53) binary_operator -> . AND_NOT
    (54) binary_operator -> . LSHIFT
    (55) binary_operator -> . RSHIFT

    RBRACE          reduce using rule 139 (key_value -> expression COLON expression .)
    COMMA           reduce using rule 139 (key_value -> expression COLON expression .)
    DOT             shift and go to state 43
    PLUS            shift and go to state 44
    MINUS           shift and go to state 45
    TIMES           shift and go to state 46
    DIVIDE          shift and go to state 47
    MODULE          shift and go to state 48
    EQ              shift and go to state 49
    NEQ             shift and go to state 50
    LT              shift and go to state 51
    LE              shift and go to state 52
    GT              shift and go to state 53
    GE              shift and go to state 54
    LAND            shift and go to state 55
    LOR             shift and go to state 56
    AND             shift and go to state 57
    OR              shift and go to state 58
    XOR             shift and go to state 59
    AND_NOT         shift and go to state 60
    LSHIFT          shift and go to state 61
    RSHIFT          shift and go to state 62

    binary_operator                shift and go to state 42

state 177

    (134) map_type -> MAP LBRACKET primitive_type RBRACKET primitive_type .

    LBRACE          reduce using rule 134 (map_type -> MAP LBRACKET primitive_type RBRACKET primitive_type .)
    FUNC            reduce using rule 134 (map_type -> MAP LBRACKET primitive_type RBRACKET primitive_type .)
    TYPE            reduce using rule 134 (map_type -> MAP LBRACKET primitive_type RBRACKET primitive_type .)
    VAR             reduce using rule 134 (map_type -> MAP LBRACKET primitive_type RBRACKET primitive_type .)
    CONST           reduce using rule 134 (map_type -> MAP LBRACKET primitive_type RBRACKET primitive_type .)
    IDENTIFIER      reduce using rule 134 (map_type -> MAP LBRACKET primitive_type RBRACKET primitive_type .)
    LPAREN          reduce using rule 134 (map_type -> MAP LBRACKET primitive_type RBRACKET primitive_type .)
    INT             reduce using rule 134 (map_type -> MAP LBRACKET primitive_type RBRACKET primitive_type .)
    FLOAT64         reduce using rule 134 (map_type -> MAP LBRACKET primitive_type RBRACKET primitive_type .)
    STRING          reduce using rule 134 (map_type -> MAP LBRACKET primitive_type RBRACKET primitive_type .)
    TRUE            reduce using rule 134 (map_type -> MAP LBRACKET primitive_type RBRACKET primitive_type .)
    FALSE           reduce using rule 134 (map_type -> MAP LBRACKET primitive_type RBRACKET primitive_type .)
    LNOT            reduce using rule 134 (map_type -> MAP LBRACKET primitive_type RBRACKET primitive_type .)
    LBRACKET        reduce using rule 134 (map_type -> MAP LBRACKET primitive_type RBRACKET primitive_type .)
    MAP             reduce using rule 134 (map_type -> MAP LBRACKET primitive_type RBRACKET primitive_type .)
    $end            reduce using rule 134 (map_type -> MAP LBRACKET primitive_type RBRACKET primitive_type .)
    ASSIGN          reduce using rule 134 (map_type -> MAP LBRACKET primitive_type RBRACKET primitive_type .)
    SEMICOLON       reduce using rule 134 (map_type -> MAP LBRACKET primitive_type RBRACKET primitive_type .)
    RBRACE          reduce using rule 134 (map_type -> MAP LBRACKET primitive_type RBRACKET primitive_type .)
    CASE            reduce using rule 134 (map_type -> MAP LBRACKET primitive_type RBRACKET primitive_type .)
    DEFAULT         reduce using rule 134 (map_type -> MAP LBRACKET primitive_type RBRACKET primitive_type .)
    RPAREN          reduce using rule 134 (map_type -> MAP LBRACKET primitive_type RBRACKET primitive_type .)
    COMMA           reduce using rule 134 (map_type -> MAP LBRACKET primitive_type RBRACKET primitive_type .)


state 178

    (177) expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .

    DOT             reduce using rule 177 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    PLUS            reduce using rule 177 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    MINUS           reduce using rule 177 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    TIMES           reduce using rule 177 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    DIVIDE          reduce using rule 177 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    MODULE          reduce using rule 177 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    EQ              reduce using rule 177 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    NEQ             reduce using rule 177 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    LT              reduce using rule 177 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    LE              reduce using rule 177 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    GT              reduce using rule 177 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    GE              reduce using rule 177 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    LAND            reduce using rule 177 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    LOR             reduce using rule 177 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    AND             reduce using rule 177 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    OR              reduce using rule 177 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    XOR             reduce using rule 177 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    AND_NOT         reduce using rule 177 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    LSHIFT          reduce using rule 177 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    RSHIFT          reduce using rule 177 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    SEMICOLON       reduce using rule 177 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    FUNC            reduce using rule 177 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    TYPE            reduce using rule 177 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    VAR             reduce using rule 177 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    CONST           reduce using rule 177 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    IDENTIFIER      reduce using rule 177 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    LPAREN          reduce using rule 177 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    INT             reduce using rule 177 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    FLOAT64         reduce using rule 177 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    STRING          reduce using rule 177 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    TRUE            reduce using rule 177 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    FALSE           reduce using rule 177 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    LNOT            reduce using rule 177 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    LBRACKET        reduce using rule 177 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    MAP             reduce using rule 177 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    $end            reduce using rule 177 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    RPAREN          reduce using rule 177 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    RBRACE          reduce using rule 177 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    CASE            reduce using rule 177 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    DEFAULT         reduce using rule 177 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    LBRACE          reduce using rule 177 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    COMMA           reduce using rule 177 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    COLON           reduce using rule 177 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)


state 179

    (115) parameter -> IDENTIFIER ELLIPSIS primitive_type .

    RPAREN          reduce using rule 115 (parameter -> IDENTIFIER ELLIPSIS primitive_type .)
    COMMA           reduce using rule 115 (parameter -> IDENTIFIER ELLIPSIS primitive_type .)


state 180

    (117) return_type -> LPAREN . type_list RPAREN
    (119) type_list -> . type
    (120) type_list -> . type_list COMMA type
    (57) type -> . primitive_type
    (58) type -> . slice_type
    (59) type -> . array_type
    (60) type -> . map_type
    (61) primitive_type -> . INT_TYPE
    (62) primitive_type -> . FLOAT64_TYPE
    (63) primitive_type -> . STRING_TYPE
    (64) primitive_type -> . BOOL_TYPE
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (173) array_type -> . LBRACKET INT RBRACKET primitive_type
    (134) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type

    INT_TYPE        shift and go to state 120
    FLOAT64_TYPE    shift and go to state 121
    STRING_TYPE     shift and go to state 122
    BOOL_TYPE       shift and go to state 123
    LBRACKET        shift and go to state 35
    MAP             shift and go to state 36

    type_list                      shift and go to state 189
    type                           shift and go to state 190
    primitive_type                 shift and go to state 116
    slice_type                     shift and go to state 117
    array_type                     shift and go to state 118
    map_type                       shift and go to state 119

state 181

    (110) function_declaration -> FUNC IDENTIFIER LPAREN parameter_list RPAREN return_type . block
    (87) block -> . LBRACE local_statement_list RBRACE
    (88) block -> . LBRACE RBRACE

    LBRACE          shift and go to state 192

    block                          shift and go to state 191

state 182

    (116) return_type -> type .

    LBRACE          reduce using rule 116 (return_type -> type .)


state 183

    (118) return_type -> empty .

    LBRACE          reduce using rule 118 (return_type -> empty .)


state 184

    (111) parameter_list -> parameter_list COMMA parameter .

    RPAREN          reduce using rule 111 (parameter_list -> parameter_list COMMA parameter .)
    COMMA           reduce using rule 111 (parameter_list -> parameter_list COMMA parameter .)


state 185

    (143) method_declaration -> FUNC LPAREN receiver RPAREN IDENTIFIER LPAREN . parameter_list RPAREN return_type block
    (111) parameter_list -> . parameter_list COMMA parameter
    (112) parameter_list -> . parameter
    (113) parameter_list -> . empty
    (114) parameter -> . IDENTIFIER type
    (115) parameter -> . IDENTIFIER ELLIPSIS primitive_type
    (7) empty -> .

    IDENTIFIER      shift and go to state 138
    RPAREN          reduce using rule 7 (empty -> .)
    COMMA           reduce using rule 7 (empty -> .)

    parameter_list                 shift and go to state 193
    parameter                      shift and go to state 140
    empty                          shift and go to state 141

state 186

    (152) struct_type -> STRUCT LBRACE field_list RBRACE .

    FUNC            reduce using rule 152 (struct_type -> STRUCT LBRACE field_list RBRACE .)
    TYPE            reduce using rule 152 (struct_type -> STRUCT LBRACE field_list RBRACE .)
    VAR             reduce using rule 152 (struct_type -> STRUCT LBRACE field_list RBRACE .)
    CONST           reduce using rule 152 (struct_type -> STRUCT LBRACE field_list RBRACE .)
    IDENTIFIER      reduce using rule 152 (struct_type -> STRUCT LBRACE field_list RBRACE .)
    LPAREN          reduce using rule 152 (struct_type -> STRUCT LBRACE field_list RBRACE .)
    INT             reduce using rule 152 (struct_type -> STRUCT LBRACE field_list RBRACE .)
    FLOAT64         reduce using rule 152 (struct_type -> STRUCT LBRACE field_list RBRACE .)
    STRING          reduce using rule 152 (struct_type -> STRUCT LBRACE field_list RBRACE .)
    TRUE            reduce using rule 152 (struct_type -> STRUCT LBRACE field_list RBRACE .)
    FALSE           reduce using rule 152 (struct_type -> STRUCT LBRACE field_list RBRACE .)
    LNOT            reduce using rule 152 (struct_type -> STRUCT LBRACE field_list RBRACE .)
    LBRACKET        reduce using rule 152 (struct_type -> STRUCT LBRACE field_list RBRACE .)
    MAP             reduce using rule 152 (struct_type -> STRUCT LBRACE field_list RBRACE .)
    $end            reduce using rule 152 (struct_type -> STRUCT LBRACE field_list RBRACE .)


state 187

    (141) field_list -> field_list SEMICOLON . field_declaration
    (142) field_declaration -> . IDENTIFIER type

    IDENTIFIER      shift and go to state 174

    field_declaration              shift and go to state 194

state 188

    (142) field_declaration -> IDENTIFIER type .

    RBRACE          reduce using rule 142 (field_declaration -> IDENTIFIER type .)
    SEMICOLON       reduce using rule 142 (field_declaration -> IDENTIFIER type .)


state 189

    (117) return_type -> LPAREN type_list . RPAREN
    (120) type_list -> type_list . COMMA type

    RPAREN          shift and go to state 195
    COMMA           shift and go to state 196


state 190

    (119) type_list -> type .

    RPAREN          reduce using rule 119 (type_list -> type .)
    COMMA           reduce using rule 119 (type_list -> type .)


state 191

    (110) function_declaration -> FUNC IDENTIFIER LPAREN parameter_list RPAREN return_type block .

    FUNC            reduce using rule 110 (function_declaration -> FUNC IDENTIFIER LPAREN parameter_list RPAREN return_type block .)
    TYPE            reduce using rule 110 (function_declaration -> FUNC IDENTIFIER LPAREN parameter_list RPAREN return_type block .)
    VAR             reduce using rule 110 (function_declaration -> FUNC IDENTIFIER LPAREN parameter_list RPAREN return_type block .)
    CONST           reduce using rule 110 (function_declaration -> FUNC IDENTIFIER LPAREN parameter_list RPAREN return_type block .)
    IDENTIFIER      reduce using rule 110 (function_declaration -> FUNC IDENTIFIER LPAREN parameter_list RPAREN return_type block .)
    LPAREN          reduce using rule 110 (function_declaration -> FUNC IDENTIFIER LPAREN parameter_list RPAREN return_type block .)
    INT             reduce using rule 110 (function_declaration -> FUNC IDENTIFIER LPAREN parameter_list RPAREN return_type block .)
    FLOAT64         reduce using rule 110 (function_declaration -> FUNC IDENTIFIER LPAREN parameter_list RPAREN return_type block .)
    STRING          reduce using rule 110 (function_declaration -> FUNC IDENTIFIER LPAREN parameter_list RPAREN return_type block .)
    TRUE            reduce using rule 110 (function_declaration -> FUNC IDENTIFIER LPAREN parameter_list RPAREN return_type block .)
    FALSE           reduce using rule 110 (function_declaration -> FUNC IDENTIFIER LPAREN parameter_list RPAREN return_type block .)
    LNOT            reduce using rule 110 (function_declaration -> FUNC IDENTIFIER LPAREN parameter_list RPAREN return_type block .)
    LBRACKET        reduce using rule 110 (function_declaration -> FUNC IDENTIFIER LPAREN parameter_list RPAREN return_type block .)
    MAP             reduce using rule 110 (function_declaration -> FUNC IDENTIFIER LPAREN parameter_list RPAREN return_type block .)
    $end            reduce using rule 110 (function_declaration -> FUNC IDENTIFIER LPAREN parameter_list RPAREN return_type block .)


state 192

    (87) block -> LBRACE . local_statement_list RBRACE
    (88) block -> LBRACE . RBRACE
    (89) local_statement_list -> . local_statement
    (90) local_statement_list -> . local_statement_list SEMICOLON local_statement
    (79) local_statement -> . var_dec
    (80) local_statement -> . var_dec simple_assign
    (81) local_statement -> . assignment_compound
    (82) local_statement -> . expression
    (83) local_statement -> . for_statement
    (84) local_statement -> . if_statement
    (85) local_statement -> . switch_statement
    (86) local_statement -> . return_statement
    (20) var_dec -> . VAR IDENTIFIER type
    (21) var_dec -> . CONST IDENTIFIER type
    (22) var_dec -> . VAR IDENTIFIER
    (23) var_dec -> . CONST IDENTIFIER
    (25) assignment_compound -> . IDENTIFIER operator_assign expression
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (123) expression -> . LNOT expression
    (124) expression -> . IDENTIFIER PLUSPLUS
    (125) expression -> . IDENTIFIER MINUSMINUS
    (135) expression -> . map_type LBRACE expression_map_list RBRACE
    (136) expression -> . map_type LBRACE RBRACE
    (158) expression -> . IDENTIFIER LBRACE keyed_element_list RBRACE
    (159) expression -> . IDENTIFIER LBRACE RBRACE
    (174) expression -> . array_type LBRACE expression_list RBRACE
    (175) expression -> . array_type LBRACE RBRACE
    (176) expression -> . expression DOT IDENTIFIER
    (177) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (178) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (91) for_statement -> . FOR for_init for_condition for_incr LBRACE for_body_list RBRACE
    (92) for_statement -> . FOR for_init for_condition for_incr LBRACE RBRACE
    (126) if_statement -> . IF if_init if_condition block if_else_clause
    (160) switch_statement -> . SWITCH switch_init switch_expression LBRACE case_clauses RBRACE
    (121) return_statement -> . RETURN
    (122) return_statement -> . RETURN return_list
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (134) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (173) array_type -> . LBRACKET INT RBRACKET primitive_type

    RBRACE          shift and go to state 198
    VAR             shift and go to state 25
    CONST           shift and go to state 26
    IDENTIFIER      shift and go to state 207
    LPAREN          shift and go to state 23
    INT             shift and go to state 28
    FLOAT64         shift and go to state 29
    STRING          shift and go to state 12
    TRUE            shift and go to state 30
    FALSE           shift and go to state 31
    LNOT            shift and go to state 32
    FOR             shift and go to state 208
    IF              shift and go to state 209
    SWITCH          shift and go to state 210
    RETURN          shift and go to state 211
    LBRACKET        shift and go to state 35
    MAP             shift and go to state 36

    local_statement_list           shift and go to state 197
    local_statement                shift and go to state 199
    var_dec                        shift and go to state 200
    assignment_compound            shift and go to state 201
    expression                     shift and go to state 202
    for_statement                  shift and go to state 203
    if_statement                   shift and go to state 204
    switch_statement               shift and go to state 205
    return_statement               shift and go to state 206
    slice_type                     shift and go to state 27
    map_type                       shift and go to state 33
    array_type                     shift and go to state 34

state 193

    (143) method_declaration -> FUNC LPAREN receiver RPAREN IDENTIFIER LPAREN parameter_list . RPAREN return_type block
    (111) parameter_list -> parameter_list . COMMA parameter

    RPAREN          shift and go to state 212
    COMMA           shift and go to state 163


state 194

    (141) field_list -> field_list SEMICOLON field_declaration .

    RBRACE          reduce using rule 141 (field_list -> field_list SEMICOLON field_declaration .)
    SEMICOLON       reduce using rule 141 (field_list -> field_list SEMICOLON field_declaration .)


state 195

    (117) return_type -> LPAREN type_list RPAREN .

    LBRACE          reduce using rule 117 (return_type -> LPAREN type_list RPAREN .)


state 196

    (120) type_list -> type_list COMMA . type
    (57) type -> . primitive_type
    (58) type -> . slice_type
    (59) type -> . array_type
    (60) type -> . map_type
    (61) primitive_type -> . INT_TYPE
    (62) primitive_type -> . FLOAT64_TYPE
    (63) primitive_type -> . STRING_TYPE
    (64) primitive_type -> . BOOL_TYPE
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (173) array_type -> . LBRACKET INT RBRACKET primitive_type
    (134) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type

    INT_TYPE        shift and go to state 120
    FLOAT64_TYPE    shift and go to state 121
    STRING_TYPE     shift and go to state 122
    BOOL_TYPE       shift and go to state 123
    LBRACKET        shift and go to state 35
    MAP             shift and go to state 36

    type                           shift and go to state 213
    primitive_type                 shift and go to state 116
    slice_type                     shift and go to state 117
    array_type                     shift and go to state 118
    map_type                       shift and go to state 119

state 197

    (87) block -> LBRACE local_statement_list . RBRACE
    (90) local_statement_list -> local_statement_list . SEMICOLON local_statement

    RBRACE          shift and go to state 214
    SEMICOLON       shift and go to state 215


state 198

    (88) block -> LBRACE RBRACE .

    FUNC            reduce using rule 88 (block -> LBRACE RBRACE .)
    TYPE            reduce using rule 88 (block -> LBRACE RBRACE .)
    VAR             reduce using rule 88 (block -> LBRACE RBRACE .)
    CONST           reduce using rule 88 (block -> LBRACE RBRACE .)
    IDENTIFIER      reduce using rule 88 (block -> LBRACE RBRACE .)
    LPAREN          reduce using rule 88 (block -> LBRACE RBRACE .)
    INT             reduce using rule 88 (block -> LBRACE RBRACE .)
    FLOAT64         reduce using rule 88 (block -> LBRACE RBRACE .)
    STRING          reduce using rule 88 (block -> LBRACE RBRACE .)
    TRUE            reduce using rule 88 (block -> LBRACE RBRACE .)
    FALSE           reduce using rule 88 (block -> LBRACE RBRACE .)
    LNOT            reduce using rule 88 (block -> LBRACE RBRACE .)
    LBRACKET        reduce using rule 88 (block -> LBRACE RBRACE .)
    MAP             reduce using rule 88 (block -> LBRACE RBRACE .)
    $end            reduce using rule 88 (block -> LBRACE RBRACE .)
    ELSE            reduce using rule 88 (block -> LBRACE RBRACE .)
    RBRACE          reduce using rule 88 (block -> LBRACE RBRACE .)
    SEMICOLON       reduce using rule 88 (block -> LBRACE RBRACE .)
    CASE            reduce using rule 88 (block -> LBRACE RBRACE .)
    DEFAULT         reduce using rule 88 (block -> LBRACE RBRACE .)


state 199

    (89) local_statement_list -> local_statement .

    RBRACE          reduce using rule 89 (local_statement_list -> local_statement .)
    SEMICOLON       reduce using rule 89 (local_statement_list -> local_statement .)
    CASE            reduce using rule 89 (local_statement_list -> local_statement .)
    DEFAULT         reduce using rule 89 (local_statement_list -> local_statement .)


state 200

    (79) local_statement -> var_dec .
    (80) local_statement -> var_dec . simple_assign
    (24) simple_assign -> . ASSIGN expression

    RBRACE          reduce using rule 79 (local_statement -> var_dec .)
    SEMICOLON       reduce using rule 79 (local_statement -> var_dec .)
    CASE            reduce using rule 79 (local_statement -> var_dec .)
    DEFAULT         reduce using rule 79 (local_statement -> var_dec .)
    ASSIGN          shift and go to state 41

    simple_assign                  shift and go to state 216

state 201

    (81) local_statement -> assignment_compound .

    RBRACE          reduce using rule 81 (local_statement -> assignment_compound .)
    SEMICOLON       reduce using rule 81 (local_statement -> assignment_compound .)
    CASE            reduce using rule 81 (local_statement -> assignment_compound .)
    DEFAULT         reduce using rule 81 (local_statement -> assignment_compound .)


state 202

    (82) local_statement -> expression .
    (36) expression -> expression . binary_operator expression
    (176) expression -> expression . DOT IDENTIFIER
    (177) expression -> expression . DOT IDENTIFIER LPAREN argument_list RPAREN
    (37) binary_operator -> . PLUS
    (38) binary_operator -> . MINUS
    (39) binary_operator -> . TIMES
    (40) binary_operator -> . DIVIDE
    (41) binary_operator -> . MODULE
    (42) binary_operator -> . EQ
    (43) binary_operator -> . NEQ
    (44) binary_operator -> . LT
    (45) binary_operator -> . LE
    (46) binary_operator -> . GT
    (47) binary_operator -> . GE
    (48) binary_operator -> . LAND
    (49) binary_operator -> . LOR
    (50) binary_operator -> . AND
    (51) binary_operator -> . OR
    (52) binary_operator -> . XOR
    (53) binary_operator -> . AND_NOT
    (54) binary_operator -> . LSHIFT
    (55) binary_operator -> . RSHIFT

    RBRACE          reduce using rule 82 (local_statement -> expression .)
    SEMICOLON       reduce using rule 82 (local_statement -> expression .)
    CASE            reduce using rule 82 (local_statement -> expression .)
    DEFAULT         reduce using rule 82 (local_statement -> expression .)
    DOT             shift and go to state 43
    PLUS            shift and go to state 44
    MINUS           shift and go to state 45
    TIMES           shift and go to state 46
    DIVIDE          shift and go to state 47
    MODULE          shift and go to state 48
    EQ              shift and go to state 49
    NEQ             shift and go to state 50
    LT              shift and go to state 51
    LE              shift and go to state 52
    GT              shift and go to state 53
    GE              shift and go to state 54
    LAND            shift and go to state 55
    LOR             shift and go to state 56
    AND             shift and go to state 57
    OR              shift and go to state 58
    XOR             shift and go to state 59
    AND_NOT         shift and go to state 60
    LSHIFT          shift and go to state 61
    RSHIFT          shift and go to state 62

    binary_operator                shift and go to state 42

state 203

    (83) local_statement -> for_statement .

    RBRACE          reduce using rule 83 (local_statement -> for_statement .)
    SEMICOLON       reduce using rule 83 (local_statement -> for_statement .)
    CASE            reduce using rule 83 (local_statement -> for_statement .)
    DEFAULT         reduce using rule 83 (local_statement -> for_statement .)


state 204

    (84) local_statement -> if_statement .

    RBRACE          reduce using rule 84 (local_statement -> if_statement .)
    SEMICOLON       reduce using rule 84 (local_statement -> if_statement .)
    CASE            reduce using rule 84 (local_statement -> if_statement .)
    DEFAULT         reduce using rule 84 (local_statement -> if_statement .)


state 205

    (85) local_statement -> switch_statement .

    RBRACE          reduce using rule 85 (local_statement -> switch_statement .)
    SEMICOLON       reduce using rule 85 (local_statement -> switch_statement .)
    CASE            reduce using rule 85 (local_statement -> switch_statement .)
    DEFAULT         reduce using rule 85 (local_statement -> switch_statement .)


state 206

    (86) local_statement -> return_statement .

    RBRACE          reduce using rule 86 (local_statement -> return_statement .)
    SEMICOLON       reduce using rule 86 (local_statement -> return_statement .)
    CASE            reduce using rule 86 (local_statement -> return_statement .)
    DEFAULT         reduce using rule 86 (local_statement -> return_statement .)


state 207

    (25) assignment_compound -> IDENTIFIER . operator_assign expression
    (73) expression -> IDENTIFIER .
    (124) expression -> IDENTIFIER . PLUSPLUS
    (125) expression -> IDENTIFIER . MINUSMINUS
    (158) expression -> IDENTIFIER . LBRACE keyed_element_list RBRACE
    (159) expression -> IDENTIFIER . LBRACE RBRACE
    (178) expression -> IDENTIFIER . LPAREN argument_list RPAREN
    (26) operator_assign -> . PLUS_ASSIGN
    (27) operator_assign -> . MINUS_ASSIGN
    (28) operator_assign -> . MULT_ASSIGN
    (29) operator_assign -> . DIV_ASSIGN
    (30) operator_assign -> . MOD_ASSIGN
    (31) operator_assign -> . AND_ASSIGN
    (32) operator_assign -> . OR_ASSIGN
    (33) operator_assign -> . XOR_ASSIGN
    (34) operator_assign -> . LSHIFT_ASSIGN
    (35) operator_assign -> . RSHIFT_ASSIGN

    DOT             reduce using rule 73 (expression -> IDENTIFIER .)
    PLUS            reduce using rule 73 (expression -> IDENTIFIER .)
    MINUS           reduce using rule 73 (expression -> IDENTIFIER .)
    TIMES           reduce using rule 73 (expression -> IDENTIFIER .)
    DIVIDE          reduce using rule 73 (expression -> IDENTIFIER .)
    MODULE          reduce using rule 73 (expression -> IDENTIFIER .)
    EQ              reduce using rule 73 (expression -> IDENTIFIER .)
    NEQ             reduce using rule 73 (expression -> IDENTIFIER .)
    LT              reduce using rule 73 (expression -> IDENTIFIER .)
    LE              reduce using rule 73 (expression -> IDENTIFIER .)
    GT              reduce using rule 73 (expression -> IDENTIFIER .)
    GE              reduce using rule 73 (expression -> IDENTIFIER .)
    LAND            reduce using rule 73 (expression -> IDENTIFIER .)
    LOR             reduce using rule 73 (expression -> IDENTIFIER .)
    AND             reduce using rule 73 (expression -> IDENTIFIER .)
    OR              reduce using rule 73 (expression -> IDENTIFIER .)
    XOR             reduce using rule 73 (expression -> IDENTIFIER .)
    AND_NOT         reduce using rule 73 (expression -> IDENTIFIER .)
    LSHIFT          reduce using rule 73 (expression -> IDENTIFIER .)
    RSHIFT          reduce using rule 73 (expression -> IDENTIFIER .)
    RBRACE          reduce using rule 73 (expression -> IDENTIFIER .)
    SEMICOLON       reduce using rule 73 (expression -> IDENTIFIER .)
    CASE            reduce using rule 73 (expression -> IDENTIFIER .)
    DEFAULT         reduce using rule 73 (expression -> IDENTIFIER .)
    PLUSPLUS        shift and go to state 67
    MINUSMINUS      shift and go to state 68
    LBRACE          shift and go to state 69
    LPAREN          shift and go to state 70
    PLUS_ASSIGN     shift and go to state 71
    MINUS_ASSIGN    shift and go to state 72
    MULT_ASSIGN     shift and go to state 73
    DIV_ASSIGN      shift and go to state 74
    MOD_ASSIGN      shift and go to state 75
    AND_ASSIGN      shift and go to state 76
    OR_ASSIGN       shift and go to state 77
    XOR_ASSIGN      shift and go to state 78
    LSHIFT_ASSIGN   shift and go to state 79
    RSHIFT_ASSIGN   shift and go to state 80

    operator_assign                shift and go to state 66

state 208

    (91) for_statement -> FOR . for_init for_condition for_incr LBRACE for_body_list RBRACE
    (92) for_statement -> FOR . for_init for_condition for_incr LBRACE RBRACE
    (93) for_init -> . simple_assignment SEMICOLON
    (94) for_init -> . short_assignment SEMICOLON
    (95) for_init -> . SEMICOLON
    (96) for_init -> . empty
    (56) simple_assignment -> . IDENTIFIER simple_assign
    (78) short_assignment -> . IDENTIFIER short_assign
    (7) empty -> .

  ! shift/reduce conflict for SEMICOLON resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
    SEMICOLON       shift and go to state 219
    IDENTIFIER      shift and go to state 222
    LPAREN          reduce using rule 7 (empty -> .)
    INT             reduce using rule 7 (empty -> .)
    FLOAT64         reduce using rule 7 (empty -> .)
    STRING          reduce using rule 7 (empty -> .)
    TRUE            reduce using rule 7 (empty -> .)
    FALSE           reduce using rule 7 (empty -> .)
    LNOT            reduce using rule 7 (empty -> .)
    LBRACKET        reduce using rule 7 (empty -> .)
    MAP             reduce using rule 7 (empty -> .)
    LBRACE          reduce using rule 7 (empty -> .)

  ! SEMICOLON       [ reduce using rule 7 (empty -> .) ]
  ! IDENTIFIER      [ reduce using rule 7 (empty -> .) ]

    for_init                       shift and go to state 217
    simple_assignment              shift and go to state 218
    short_assignment               shift and go to state 220
    empty                          shift and go to state 221

state 209

    (126) if_statement -> IF . if_init if_condition block if_else_clause
    (127) if_init -> . short_assignment SEMICOLON
    (128) if_init -> . simple_assignment SEMICOLON
    (129) if_init -> . empty
    (78) short_assignment -> . IDENTIFIER short_assign
    (56) simple_assignment -> . IDENTIFIER simple_assign
    (7) empty -> .

  ! shift/reduce conflict for IDENTIFIER resolved as shift
    IDENTIFIER      shift and go to state 227
    LPAREN          reduce using rule 7 (empty -> .)
    INT             reduce using rule 7 (empty -> .)
    FLOAT64         reduce using rule 7 (empty -> .)
    STRING          reduce using rule 7 (empty -> .)
    TRUE            reduce using rule 7 (empty -> .)
    FALSE           reduce using rule 7 (empty -> .)
    LNOT            reduce using rule 7 (empty -> .)
    LBRACKET        reduce using rule 7 (empty -> .)
    MAP             reduce using rule 7 (empty -> .)

  ! IDENTIFIER      [ reduce using rule 7 (empty -> .) ]

    if_init                        shift and go to state 223
    short_assignment               shift and go to state 224
    simple_assignment              shift and go to state 225
    empty                          shift and go to state 226

state 210

    (160) switch_statement -> SWITCH . switch_init switch_expression LBRACE case_clauses RBRACE
    (161) switch_init -> . short_assignment SEMICOLON
    (162) switch_init -> . simple_assignment SEMICOLON
    (163) switch_init -> . empty
    (78) short_assignment -> . IDENTIFIER short_assign
    (56) simple_assignment -> . IDENTIFIER simple_assign
    (7) empty -> .

  ! shift/reduce conflict for IDENTIFIER resolved as shift
    IDENTIFIER      shift and go to state 227
    LPAREN          reduce using rule 7 (empty -> .)
    INT             reduce using rule 7 (empty -> .)
    FLOAT64         reduce using rule 7 (empty -> .)
    STRING          reduce using rule 7 (empty -> .)
    TRUE            reduce using rule 7 (empty -> .)
    FALSE           reduce using rule 7 (empty -> .)
    LNOT            reduce using rule 7 (empty -> .)
    LBRACKET        reduce using rule 7 (empty -> .)
    MAP             reduce using rule 7 (empty -> .)
    LBRACE          reduce using rule 7 (empty -> .)

  ! IDENTIFIER      [ reduce using rule 7 (empty -> .) ]

    switch_init                    shift and go to state 228
    short_assignment               shift and go to state 229
    simple_assignment              shift and go to state 230
    empty                          shift and go to state 231

state 211

    (121) return_statement -> RETURN .
    (122) return_statement -> RETURN . return_list
    (108) return_list -> . expression
    (109) return_list -> . return_list COMMA expression
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (123) expression -> . LNOT expression
    (124) expression -> . IDENTIFIER PLUSPLUS
    (125) expression -> . IDENTIFIER MINUSMINUS
    (135) expression -> . map_type LBRACE expression_map_list RBRACE
    (136) expression -> . map_type LBRACE RBRACE
    (158) expression -> . IDENTIFIER LBRACE keyed_element_list RBRACE
    (159) expression -> . IDENTIFIER LBRACE RBRACE
    (174) expression -> . array_type LBRACE expression_list RBRACE
    (175) expression -> . array_type LBRACE RBRACE
    (176) expression -> . expression DOT IDENTIFIER
    (177) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (178) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (134) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (173) array_type -> . LBRACKET INT RBRACKET primitive_type

    RBRACE          reduce using rule 121 (return_statement -> RETURN .)
    SEMICOLON       reduce using rule 121 (return_statement -> RETURN .)
    CASE            reduce using rule 121 (return_statement -> RETURN .)
    DEFAULT         reduce using rule 121 (return_statement -> RETURN .)
    LPAREN          shift and go to state 23
    INT             shift and go to state 28
    FLOAT64         shift and go to state 29
    IDENTIFIER      shift and go to state 82
    STRING          shift and go to state 12
    TRUE            shift and go to state 30
    FALSE           shift and go to state 31
    LNOT            shift and go to state 32
    LBRACKET        shift and go to state 35
    MAP             shift and go to state 36

    return_list                    shift and go to state 232
    expression                     shift and go to state 233
    slice_type                     shift and go to state 27
    map_type                       shift and go to state 33
    array_type                     shift and go to state 34

state 212

    (143) method_declaration -> FUNC LPAREN receiver RPAREN IDENTIFIER LPAREN parameter_list RPAREN . return_type block
    (116) return_type -> . type
    (117) return_type -> . LPAREN type_list RPAREN
    (118) return_type -> . empty
    (57) type -> . primitive_type
    (58) type -> . slice_type
    (59) type -> . array_type
    (60) type -> . map_type
    (7) empty -> .
    (61) primitive_type -> . INT_TYPE
    (62) primitive_type -> . FLOAT64_TYPE
    (63) primitive_type -> . STRING_TYPE
    (64) primitive_type -> . BOOL_TYPE
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (173) array_type -> . LBRACKET INT RBRACKET primitive_type
    (134) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type

    LPAREN          shift and go to state 180
    LBRACE          reduce using rule 7 (empty -> .)
    INT_TYPE        shift and go to state 120
    FLOAT64_TYPE    shift and go to state 121
    STRING_TYPE     shift and go to state 122
    BOOL_TYPE       shift and go to state 123
    LBRACKET        shift and go to state 35
    MAP             shift and go to state 36

    return_type                    shift and go to state 234
    type                           shift and go to state 182
    empty                          shift and go to state 183
    primitive_type                 shift and go to state 116
    slice_type                     shift and go to state 117
    array_type                     shift and go to state 118
    map_type                       shift and go to state 119

state 213

    (120) type_list -> type_list COMMA type .

    RPAREN          reduce using rule 120 (type_list -> type_list COMMA type .)
    COMMA           reduce using rule 120 (type_list -> type_list COMMA type .)


state 214

    (87) block -> LBRACE local_statement_list RBRACE .

    FUNC            reduce using rule 87 (block -> LBRACE local_statement_list RBRACE .)
    TYPE            reduce using rule 87 (block -> LBRACE local_statement_list RBRACE .)
    VAR             reduce using rule 87 (block -> LBRACE local_statement_list RBRACE .)
    CONST           reduce using rule 87 (block -> LBRACE local_statement_list RBRACE .)
    IDENTIFIER      reduce using rule 87 (block -> LBRACE local_statement_list RBRACE .)
    LPAREN          reduce using rule 87 (block -> LBRACE local_statement_list RBRACE .)
    INT             reduce using rule 87 (block -> LBRACE local_statement_list RBRACE .)
    FLOAT64         reduce using rule 87 (block -> LBRACE local_statement_list RBRACE .)
    STRING          reduce using rule 87 (block -> LBRACE local_statement_list RBRACE .)
    TRUE            reduce using rule 87 (block -> LBRACE local_statement_list RBRACE .)
    FALSE           reduce using rule 87 (block -> LBRACE local_statement_list RBRACE .)
    LNOT            reduce using rule 87 (block -> LBRACE local_statement_list RBRACE .)
    LBRACKET        reduce using rule 87 (block -> LBRACE local_statement_list RBRACE .)
    MAP             reduce using rule 87 (block -> LBRACE local_statement_list RBRACE .)
    $end            reduce using rule 87 (block -> LBRACE local_statement_list RBRACE .)
    ELSE            reduce using rule 87 (block -> LBRACE local_statement_list RBRACE .)
    RBRACE          reduce using rule 87 (block -> LBRACE local_statement_list RBRACE .)
    SEMICOLON       reduce using rule 87 (block -> LBRACE local_statement_list RBRACE .)
    CASE            reduce using rule 87 (block -> LBRACE local_statement_list RBRACE .)
    DEFAULT         reduce using rule 87 (block -> LBRACE local_statement_list RBRACE .)


state 215

    (90) local_statement_list -> local_statement_list SEMICOLON . local_statement
    (79) local_statement -> . var_dec
    (80) local_statement -> . var_dec simple_assign
    (81) local_statement -> . assignment_compound
    (82) local_statement -> . expression
    (83) local_statement -> . for_statement
    (84) local_statement -> . if_statement
    (85) local_statement -> . switch_statement
    (86) local_statement -> . return_statement
    (20) var_dec -> . VAR IDENTIFIER type
    (21) var_dec -> . CONST IDENTIFIER type
    (22) var_dec -> . VAR IDENTIFIER
    (23) var_dec -> . CONST IDENTIFIER
    (25) assignment_compound -> . IDENTIFIER operator_assign expression
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (123) expression -> . LNOT expression
    (124) expression -> . IDENTIFIER PLUSPLUS
    (125) expression -> . IDENTIFIER MINUSMINUS
    (135) expression -> . map_type LBRACE expression_map_list RBRACE
    (136) expression -> . map_type LBRACE RBRACE
    (158) expression -> . IDENTIFIER LBRACE keyed_element_list RBRACE
    (159) expression -> . IDENTIFIER LBRACE RBRACE
    (174) expression -> . array_type LBRACE expression_list RBRACE
    (175) expression -> . array_type LBRACE RBRACE
    (176) expression -> . expression DOT IDENTIFIER
    (177) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (178) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (91) for_statement -> . FOR for_init for_condition for_incr LBRACE for_body_list RBRACE
    (92) for_statement -> . FOR for_init for_condition for_incr LBRACE RBRACE
    (126) if_statement -> . IF if_init if_condition block if_else_clause
    (160) switch_statement -> . SWITCH switch_init switch_expression LBRACE case_clauses RBRACE
    (121) return_statement -> . RETURN
    (122) return_statement -> . RETURN return_list
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (134) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (173) array_type -> . LBRACKET INT RBRACKET primitive_type

    VAR             shift and go to state 25
    CONST           shift and go to state 26
    IDENTIFIER      shift and go to state 207
    LPAREN          shift and go to state 23
    INT             shift and go to state 28
    FLOAT64         shift and go to state 29
    STRING          shift and go to state 12
    TRUE            shift and go to state 30
    FALSE           shift and go to state 31
    LNOT            shift and go to state 32
    FOR             shift and go to state 208
    IF              shift and go to state 209
    SWITCH          shift and go to state 210
    RETURN          shift and go to state 211
    LBRACKET        shift and go to state 35
    MAP             shift and go to state 36

    local_statement                shift and go to state 235
    var_dec                        shift and go to state 200
    assignment_compound            shift and go to state 201
    expression                     shift and go to state 202
    for_statement                  shift and go to state 203
    if_statement                   shift and go to state 204
    switch_statement               shift and go to state 205
    return_statement               shift and go to state 206
    slice_type                     shift and go to state 27
    map_type                       shift and go to state 33
    array_type                     shift and go to state 34

state 216

    (80) local_statement -> var_dec simple_assign .

    RBRACE          reduce using rule 80 (local_statement -> var_dec simple_assign .)
    SEMICOLON       reduce using rule 80 (local_statement -> var_dec simple_assign .)
    CASE            reduce using rule 80 (local_statement -> var_dec simple_assign .)
    DEFAULT         reduce using rule 80 (local_statement -> var_dec simple_assign .)


state 217

    (91) for_statement -> FOR for_init . for_condition for_incr LBRACE for_body_list RBRACE
    (92) for_statement -> FOR for_init . for_condition for_incr LBRACE RBRACE
    (97) for_condition -> . expression SEMICOLON
    (98) for_condition -> . SEMICOLON
    (99) for_condition -> . empty
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (123) expression -> . LNOT expression
    (124) expression -> . IDENTIFIER PLUSPLUS
    (125) expression -> . IDENTIFIER MINUSMINUS
    (135) expression -> . map_type LBRACE expression_map_list RBRACE
    (136) expression -> . map_type LBRACE RBRACE
    (158) expression -> . IDENTIFIER LBRACE keyed_element_list RBRACE
    (159) expression -> . IDENTIFIER LBRACE RBRACE
    (174) expression -> . array_type LBRACE expression_list RBRACE
    (175) expression -> . array_type LBRACE RBRACE
    (176) expression -> . expression DOT IDENTIFIER
    (177) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (178) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (7) empty -> .
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (134) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (173) array_type -> . LBRACKET INT RBRACKET primitive_type

  ! shift/reduce conflict for IDENTIFIER resolved as shift
    SEMICOLON       shift and go to state 238
    LPAREN          shift and go to state 23
    INT             shift and go to state 28
    FLOAT64         shift and go to state 29
    IDENTIFIER      shift and go to state 82
    STRING          shift and go to state 12
    TRUE            shift and go to state 30
    FALSE           shift and go to state 31
    LNOT            shift and go to state 32
    LBRACE          reduce using rule 7 (empty -> .)
    LBRACKET        shift and go to state 35
    MAP             shift and go to state 36

  ! IDENTIFIER      [ reduce using rule 7 (empty -> .) ]

    for_condition                  shift and go to state 236
    expression                     shift and go to state 237
    empty                          shift and go to state 239
    slice_type                     shift and go to state 27
    map_type                       shift and go to state 33
    array_type                     shift and go to state 34

state 218

    (93) for_init -> simple_assignment . SEMICOLON

    SEMICOLON       shift and go to state 240


state 219

    (95) for_init -> SEMICOLON .

    SEMICOLON       reduce using rule 95 (for_init -> SEMICOLON .)
    LPAREN          reduce using rule 95 (for_init -> SEMICOLON .)
    INT             reduce using rule 95 (for_init -> SEMICOLON .)
    FLOAT64         reduce using rule 95 (for_init -> SEMICOLON .)
    IDENTIFIER      reduce using rule 95 (for_init -> SEMICOLON .)
    STRING          reduce using rule 95 (for_init -> SEMICOLON .)
    TRUE            reduce using rule 95 (for_init -> SEMICOLON .)
    FALSE           reduce using rule 95 (for_init -> SEMICOLON .)
    LNOT            reduce using rule 95 (for_init -> SEMICOLON .)
    LBRACKET        reduce using rule 95 (for_init -> SEMICOLON .)
    MAP             reduce using rule 95 (for_init -> SEMICOLON .)
    LBRACE          reduce using rule 95 (for_init -> SEMICOLON .)


state 220

    (94) for_init -> short_assignment . SEMICOLON

    SEMICOLON       shift and go to state 241


state 221

    (96) for_init -> empty .

    SEMICOLON       reduce using rule 96 (for_init -> empty .)
    LPAREN          reduce using rule 96 (for_init -> empty .)
    INT             reduce using rule 96 (for_init -> empty .)
    FLOAT64         reduce using rule 96 (for_init -> empty .)
    IDENTIFIER      reduce using rule 96 (for_init -> empty .)
    STRING          reduce using rule 96 (for_init -> empty .)
    TRUE            reduce using rule 96 (for_init -> empty .)
    FALSE           reduce using rule 96 (for_init -> empty .)
    LNOT            reduce using rule 96 (for_init -> empty .)
    LBRACKET        reduce using rule 96 (for_init -> empty .)
    MAP             reduce using rule 96 (for_init -> empty .)
    LBRACE          reduce using rule 96 (for_init -> empty .)


state 222

    (56) simple_assignment -> IDENTIFIER . simple_assign
    (78) short_assignment -> IDENTIFIER . short_assign
    (24) simple_assign -> . ASSIGN expression
    (77) short_assign -> . SHORT_ASSIGN expression

    ASSIGN          shift and go to state 41
    SHORT_ASSIGN    shift and go to state 243

    simple_assign                  shift and go to state 65
    short_assign                   shift and go to state 242

state 223

    (126) if_statement -> IF if_init . if_condition block if_else_clause
    (130) if_condition -> . expression
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (123) expression -> . LNOT expression
    (124) expression -> . IDENTIFIER PLUSPLUS
    (125) expression -> . IDENTIFIER MINUSMINUS
    (135) expression -> . map_type LBRACE expression_map_list RBRACE
    (136) expression -> . map_type LBRACE RBRACE
    (158) expression -> . IDENTIFIER LBRACE keyed_element_list RBRACE
    (159) expression -> . IDENTIFIER LBRACE RBRACE
    (174) expression -> . array_type LBRACE expression_list RBRACE
    (175) expression -> . array_type LBRACE RBRACE
    (176) expression -> . expression DOT IDENTIFIER
    (177) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (178) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (134) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (173) array_type -> . LBRACKET INT RBRACKET primitive_type

    LPAREN          shift and go to state 23
    INT             shift and go to state 28
    FLOAT64         shift and go to state 29
    IDENTIFIER      shift and go to state 82
    STRING          shift and go to state 12
    TRUE            shift and go to state 30
    FALSE           shift and go to state 31
    LNOT            shift and go to state 32
    LBRACKET        shift and go to state 35
    MAP             shift and go to state 36

    if_condition                   shift and go to state 244
    expression                     shift and go to state 245
    slice_type                     shift and go to state 27
    map_type                       shift and go to state 33
    array_type                     shift and go to state 34

state 224

    (127) if_init -> short_assignment . SEMICOLON

    SEMICOLON       shift and go to state 246


state 225

    (128) if_init -> simple_assignment . SEMICOLON

    SEMICOLON       shift and go to state 247


state 226

    (129) if_init -> empty .

    LPAREN          reduce using rule 129 (if_init -> empty .)
    INT             reduce using rule 129 (if_init -> empty .)
    FLOAT64         reduce using rule 129 (if_init -> empty .)
    IDENTIFIER      reduce using rule 129 (if_init -> empty .)
    STRING          reduce using rule 129 (if_init -> empty .)
    TRUE            reduce using rule 129 (if_init -> empty .)
    FALSE           reduce using rule 129 (if_init -> empty .)
    LNOT            reduce using rule 129 (if_init -> empty .)
    LBRACKET        reduce using rule 129 (if_init -> empty .)
    MAP             reduce using rule 129 (if_init -> empty .)


state 227

    (78) short_assignment -> IDENTIFIER . short_assign
    (56) simple_assignment -> IDENTIFIER . simple_assign
    (77) short_assign -> . SHORT_ASSIGN expression
    (24) simple_assign -> . ASSIGN expression

    SHORT_ASSIGN    shift and go to state 243
    ASSIGN          shift and go to state 41

    short_assign                   shift and go to state 242
    simple_assign                  shift and go to state 65

state 228

    (160) switch_statement -> SWITCH switch_init . switch_expression LBRACE case_clauses RBRACE
    (164) switch_expression -> . expression
    (165) switch_expression -> . empty
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (123) expression -> . LNOT expression
    (124) expression -> . IDENTIFIER PLUSPLUS
    (125) expression -> . IDENTIFIER MINUSMINUS
    (135) expression -> . map_type LBRACE expression_map_list RBRACE
    (136) expression -> . map_type LBRACE RBRACE
    (158) expression -> . IDENTIFIER LBRACE keyed_element_list RBRACE
    (159) expression -> . IDENTIFIER LBRACE RBRACE
    (174) expression -> . array_type LBRACE expression_list RBRACE
    (175) expression -> . array_type LBRACE RBRACE
    (176) expression -> . expression DOT IDENTIFIER
    (177) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (178) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (7) empty -> .
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (134) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (173) array_type -> . LBRACKET INT RBRACKET primitive_type

    LPAREN          shift and go to state 23
    INT             shift and go to state 28
    FLOAT64         shift and go to state 29
    IDENTIFIER      shift and go to state 82
    STRING          shift and go to state 12
    TRUE            shift and go to state 30
    FALSE           shift and go to state 31
    LNOT            shift and go to state 32
    LBRACE          reduce using rule 7 (empty -> .)
    LBRACKET        shift and go to state 35
    MAP             shift and go to state 36

    switch_expression              shift and go to state 248
    expression                     shift and go to state 249
    empty                          shift and go to state 250
    slice_type                     shift and go to state 27
    map_type                       shift and go to state 33
    array_type                     shift and go to state 34

state 229

    (161) switch_init -> short_assignment . SEMICOLON

    SEMICOLON       shift and go to state 251


state 230

    (162) switch_init -> simple_assignment . SEMICOLON

    SEMICOLON       shift and go to state 252


state 231

    (163) switch_init -> empty .

    LPAREN          reduce using rule 163 (switch_init -> empty .)
    INT             reduce using rule 163 (switch_init -> empty .)
    FLOAT64         reduce using rule 163 (switch_init -> empty .)
    IDENTIFIER      reduce using rule 163 (switch_init -> empty .)
    STRING          reduce using rule 163 (switch_init -> empty .)
    TRUE            reduce using rule 163 (switch_init -> empty .)
    FALSE           reduce using rule 163 (switch_init -> empty .)
    LNOT            reduce using rule 163 (switch_init -> empty .)
    LBRACKET        reduce using rule 163 (switch_init -> empty .)
    MAP             reduce using rule 163 (switch_init -> empty .)
    LBRACE          reduce using rule 163 (switch_init -> empty .)


state 232

    (122) return_statement -> RETURN return_list .
    (109) return_list -> return_list . COMMA expression

    RBRACE          reduce using rule 122 (return_statement -> RETURN return_list .)
    SEMICOLON       reduce using rule 122 (return_statement -> RETURN return_list .)
    CASE            reduce using rule 122 (return_statement -> RETURN return_list .)
    DEFAULT         reduce using rule 122 (return_statement -> RETURN return_list .)
    COMMA           shift and go to state 253


state 233

    (108) return_list -> expression .
    (36) expression -> expression . binary_operator expression
    (176) expression -> expression . DOT IDENTIFIER
    (177) expression -> expression . DOT IDENTIFIER LPAREN argument_list RPAREN
    (37) binary_operator -> . PLUS
    (38) binary_operator -> . MINUS
    (39) binary_operator -> . TIMES
    (40) binary_operator -> . DIVIDE
    (41) binary_operator -> . MODULE
    (42) binary_operator -> . EQ
    (43) binary_operator -> . NEQ
    (44) binary_operator -> . LT
    (45) binary_operator -> . LE
    (46) binary_operator -> . GT
    (47) binary_operator -> . GE
    (48) binary_operator -> . LAND
    (49) binary_operator -> . LOR
    (50) binary_operator -> . AND
    (51) binary_operator -> . OR
    (52) binary_operator -> . XOR
    (53) binary_operator -> . AND_NOT
    (54) binary_operator -> . LSHIFT
    (55) binary_operator -> . RSHIFT

    COMMA           reduce using rule 108 (return_list -> expression .)
    RBRACE          reduce using rule 108 (return_list -> expression .)
    SEMICOLON       reduce using rule 108 (return_list -> expression .)
    CASE            reduce using rule 108 (return_list -> expression .)
    DEFAULT         reduce using rule 108 (return_list -> expression .)
    DOT             shift and go to state 43
    PLUS            shift and go to state 44
    MINUS           shift and go to state 45
    TIMES           shift and go to state 46
    DIVIDE          shift and go to state 47
    MODULE          shift and go to state 48
    EQ              shift and go to state 49
    NEQ             shift and go to state 50
    LT              shift and go to state 51
    LE              shift and go to state 52
    GT              shift and go to state 53
    GE              shift and go to state 54
    LAND            shift and go to state 55
    LOR             shift and go to state 56
    AND             shift and go to state 57
    OR              shift and go to state 58
    XOR             shift and go to state 59
    AND_NOT         shift and go to state 60
    LSHIFT          shift and go to state 61
    RSHIFT          shift and go to state 62

    binary_operator                shift and go to state 42

state 234

    (143) method_declaration -> FUNC LPAREN receiver RPAREN IDENTIFIER LPAREN parameter_list RPAREN return_type . block
    (87) block -> . LBRACE local_statement_list RBRACE
    (88) block -> . LBRACE RBRACE

    LBRACE          shift and go to state 192

    block                          shift and go to state 254

state 235

    (90) local_statement_list -> local_statement_list SEMICOLON local_statement .

    RBRACE          reduce using rule 90 (local_statement_list -> local_statement_list SEMICOLON local_statement .)
    SEMICOLON       reduce using rule 90 (local_statement_list -> local_statement_list SEMICOLON local_statement .)
    CASE            reduce using rule 90 (local_statement_list -> local_statement_list SEMICOLON local_statement .)
    DEFAULT         reduce using rule 90 (local_statement_list -> local_statement_list SEMICOLON local_statement .)


state 236

    (91) for_statement -> FOR for_init for_condition . for_incr LBRACE for_body_list RBRACE
    (92) for_statement -> FOR for_init for_condition . for_incr LBRACE RBRACE
    (100) for_incr -> . simple_assignment
    (101) for_incr -> . short_assignment
    (102) for_incr -> . empty
    (56) simple_assignment -> . IDENTIFIER simple_assign
    (78) short_assignment -> . IDENTIFIER short_assign
    (7) empty -> .

    IDENTIFIER      shift and go to state 222
    LBRACE          reduce using rule 7 (empty -> .)

    for_incr                       shift and go to state 255
    simple_assignment              shift and go to state 256
    short_assignment               shift and go to state 257
    empty                          shift and go to state 258

state 237

    (97) for_condition -> expression . SEMICOLON
    (36) expression -> expression . binary_operator expression
    (176) expression -> expression . DOT IDENTIFIER
    (177) expression -> expression . DOT IDENTIFIER LPAREN argument_list RPAREN
    (37) binary_operator -> . PLUS
    (38) binary_operator -> . MINUS
    (39) binary_operator -> . TIMES
    (40) binary_operator -> . DIVIDE
    (41) binary_operator -> . MODULE
    (42) binary_operator -> . EQ
    (43) binary_operator -> . NEQ
    (44) binary_operator -> . LT
    (45) binary_operator -> . LE
    (46) binary_operator -> . GT
    (47) binary_operator -> . GE
    (48) binary_operator -> . LAND
    (49) binary_operator -> . LOR
    (50) binary_operator -> . AND
    (51) binary_operator -> . OR
    (52) binary_operator -> . XOR
    (53) binary_operator -> . AND_NOT
    (54) binary_operator -> . LSHIFT
    (55) binary_operator -> . RSHIFT

    SEMICOLON       shift and go to state 259
    DOT             shift and go to state 43
    PLUS            shift and go to state 44
    MINUS           shift and go to state 45
    TIMES           shift and go to state 46
    DIVIDE          shift and go to state 47
    MODULE          shift and go to state 48
    EQ              shift and go to state 49
    NEQ             shift and go to state 50
    LT              shift and go to state 51
    LE              shift and go to state 52
    GT              shift and go to state 53
    GE              shift and go to state 54
    LAND            shift and go to state 55
    LOR             shift and go to state 56
    AND             shift and go to state 57
    OR              shift and go to state 58
    XOR             shift and go to state 59
    AND_NOT         shift and go to state 60
    LSHIFT          shift and go to state 61
    RSHIFT          shift and go to state 62

    binary_operator                shift and go to state 42

state 238

    (98) for_condition -> SEMICOLON .

    IDENTIFIER      reduce using rule 98 (for_condition -> SEMICOLON .)
    LBRACE          reduce using rule 98 (for_condition -> SEMICOLON .)


state 239

    (99) for_condition -> empty .

    IDENTIFIER      reduce using rule 99 (for_condition -> empty .)
    LBRACE          reduce using rule 99 (for_condition -> empty .)


state 240

    (93) for_init -> simple_assignment SEMICOLON .

    SEMICOLON       reduce using rule 93 (for_init -> simple_assignment SEMICOLON .)
    LPAREN          reduce using rule 93 (for_init -> simple_assignment SEMICOLON .)
    INT             reduce using rule 93 (for_init -> simple_assignment SEMICOLON .)
    FLOAT64         reduce using rule 93 (for_init -> simple_assignment SEMICOLON .)
    IDENTIFIER      reduce using rule 93 (for_init -> simple_assignment SEMICOLON .)
    STRING          reduce using rule 93 (for_init -> simple_assignment SEMICOLON .)
    TRUE            reduce using rule 93 (for_init -> simple_assignment SEMICOLON .)
    FALSE           reduce using rule 93 (for_init -> simple_assignment SEMICOLON .)
    LNOT            reduce using rule 93 (for_init -> simple_assignment SEMICOLON .)
    LBRACKET        reduce using rule 93 (for_init -> simple_assignment SEMICOLON .)
    MAP             reduce using rule 93 (for_init -> simple_assignment SEMICOLON .)
    LBRACE          reduce using rule 93 (for_init -> simple_assignment SEMICOLON .)


state 241

    (94) for_init -> short_assignment SEMICOLON .

    SEMICOLON       reduce using rule 94 (for_init -> short_assignment SEMICOLON .)
    LPAREN          reduce using rule 94 (for_init -> short_assignment SEMICOLON .)
    INT             reduce using rule 94 (for_init -> short_assignment SEMICOLON .)
    FLOAT64         reduce using rule 94 (for_init -> short_assignment SEMICOLON .)
    IDENTIFIER      reduce using rule 94 (for_init -> short_assignment SEMICOLON .)
    STRING          reduce using rule 94 (for_init -> short_assignment SEMICOLON .)
    TRUE            reduce using rule 94 (for_init -> short_assignment SEMICOLON .)
    FALSE           reduce using rule 94 (for_init -> short_assignment SEMICOLON .)
    LNOT            reduce using rule 94 (for_init -> short_assignment SEMICOLON .)
    LBRACKET        reduce using rule 94 (for_init -> short_assignment SEMICOLON .)
    MAP             reduce using rule 94 (for_init -> short_assignment SEMICOLON .)
    LBRACE          reduce using rule 94 (for_init -> short_assignment SEMICOLON .)


state 242

    (78) short_assignment -> IDENTIFIER short_assign .

    SEMICOLON       reduce using rule 78 (short_assignment -> IDENTIFIER short_assign .)
    LBRACE          reduce using rule 78 (short_assignment -> IDENTIFIER short_assign .)


state 243

    (77) short_assign -> SHORT_ASSIGN . expression
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (123) expression -> . LNOT expression
    (124) expression -> . IDENTIFIER PLUSPLUS
    (125) expression -> . IDENTIFIER MINUSMINUS
    (135) expression -> . map_type LBRACE expression_map_list RBRACE
    (136) expression -> . map_type LBRACE RBRACE
    (158) expression -> . IDENTIFIER LBRACE keyed_element_list RBRACE
    (159) expression -> . IDENTIFIER LBRACE RBRACE
    (174) expression -> . array_type LBRACE expression_list RBRACE
    (175) expression -> . array_type LBRACE RBRACE
    (176) expression -> . expression DOT IDENTIFIER
    (177) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (178) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (134) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (173) array_type -> . LBRACKET INT RBRACKET primitive_type

    LPAREN          shift and go to state 23
    INT             shift and go to state 28
    FLOAT64         shift and go to state 29
    IDENTIFIER      shift and go to state 82
    STRING          shift and go to state 12
    TRUE            shift and go to state 30
    FALSE           shift and go to state 31
    LNOT            shift and go to state 32
    LBRACKET        shift and go to state 35
    MAP             shift and go to state 36

    expression                     shift and go to state 260
    slice_type                     shift and go to state 27
    map_type                       shift and go to state 33
    array_type                     shift and go to state 34

state 244

    (126) if_statement -> IF if_init if_condition . block if_else_clause
    (87) block -> . LBRACE local_statement_list RBRACE
    (88) block -> . LBRACE RBRACE

    LBRACE          shift and go to state 192

    block                          shift and go to state 261

state 245

    (130) if_condition -> expression .
    (36) expression -> expression . binary_operator expression
    (176) expression -> expression . DOT IDENTIFIER
    (177) expression -> expression . DOT IDENTIFIER LPAREN argument_list RPAREN
    (37) binary_operator -> . PLUS
    (38) binary_operator -> . MINUS
    (39) binary_operator -> . TIMES
    (40) binary_operator -> . DIVIDE
    (41) binary_operator -> . MODULE
    (42) binary_operator -> . EQ
    (43) binary_operator -> . NEQ
    (44) binary_operator -> . LT
    (45) binary_operator -> . LE
    (46) binary_operator -> . GT
    (47) binary_operator -> . GE
    (48) binary_operator -> . LAND
    (49) binary_operator -> . LOR
    (50) binary_operator -> . AND
    (51) binary_operator -> . OR
    (52) binary_operator -> . XOR
    (53) binary_operator -> . AND_NOT
    (54) binary_operator -> . LSHIFT
    (55) binary_operator -> . RSHIFT

    LBRACE          reduce using rule 130 (if_condition -> expression .)
    DOT             shift and go to state 43
    PLUS            shift and go to state 44
    MINUS           shift and go to state 45
    TIMES           shift and go to state 46
    DIVIDE          shift and go to state 47
    MODULE          shift and go to state 48
    EQ              shift and go to state 49
    NEQ             shift and go to state 50
    LT              shift and go to state 51
    LE              shift and go to state 52
    GT              shift and go to state 53
    GE              shift and go to state 54
    LAND            shift and go to state 55
    LOR             shift and go to state 56
    AND             shift and go to state 57
    OR              shift and go to state 58
    XOR             shift and go to state 59
    AND_NOT         shift and go to state 60
    LSHIFT          shift and go to state 61
    RSHIFT          shift and go to state 62

    binary_operator                shift and go to state 42

state 246

    (127) if_init -> short_assignment SEMICOLON .

    LPAREN          reduce using rule 127 (if_init -> short_assignment SEMICOLON .)
    INT             reduce using rule 127 (if_init -> short_assignment SEMICOLON .)
    FLOAT64         reduce using rule 127 (if_init -> short_assignment SEMICOLON .)
    IDENTIFIER      reduce using rule 127 (if_init -> short_assignment SEMICOLON .)
    STRING          reduce using rule 127 (if_init -> short_assignment SEMICOLON .)
    TRUE            reduce using rule 127 (if_init -> short_assignment SEMICOLON .)
    FALSE           reduce using rule 127 (if_init -> short_assignment SEMICOLON .)
    LNOT            reduce using rule 127 (if_init -> short_assignment SEMICOLON .)
    LBRACKET        reduce using rule 127 (if_init -> short_assignment SEMICOLON .)
    MAP             reduce using rule 127 (if_init -> short_assignment SEMICOLON .)


state 247

    (128) if_init -> simple_assignment SEMICOLON .

    LPAREN          reduce using rule 128 (if_init -> simple_assignment SEMICOLON .)
    INT             reduce using rule 128 (if_init -> simple_assignment SEMICOLON .)
    FLOAT64         reduce using rule 128 (if_init -> simple_assignment SEMICOLON .)
    IDENTIFIER      reduce using rule 128 (if_init -> simple_assignment SEMICOLON .)
    STRING          reduce using rule 128 (if_init -> simple_assignment SEMICOLON .)
    TRUE            reduce using rule 128 (if_init -> simple_assignment SEMICOLON .)
    FALSE           reduce using rule 128 (if_init -> simple_assignment SEMICOLON .)
    LNOT            reduce using rule 128 (if_init -> simple_assignment SEMICOLON .)
    LBRACKET        reduce using rule 128 (if_init -> simple_assignment SEMICOLON .)
    MAP             reduce using rule 128 (if_init -> simple_assignment SEMICOLON .)


state 248

    (160) switch_statement -> SWITCH switch_init switch_expression . LBRACE case_clauses RBRACE

    LBRACE          shift and go to state 262


state 249

    (164) switch_expression -> expression .
    (36) expression -> expression . binary_operator expression
    (176) expression -> expression . DOT IDENTIFIER
    (177) expression -> expression . DOT IDENTIFIER LPAREN argument_list RPAREN
    (37) binary_operator -> . PLUS
    (38) binary_operator -> . MINUS
    (39) binary_operator -> . TIMES
    (40) binary_operator -> . DIVIDE
    (41) binary_operator -> . MODULE
    (42) binary_operator -> . EQ
    (43) binary_operator -> . NEQ
    (44) binary_operator -> . LT
    (45) binary_operator -> . LE
    (46) binary_operator -> . GT
    (47) binary_operator -> . GE
    (48) binary_operator -> . LAND
    (49) binary_operator -> . LOR
    (50) binary_operator -> . AND
    (51) binary_operator -> . OR
    (52) binary_operator -> . XOR
    (53) binary_operator -> . AND_NOT
    (54) binary_operator -> . LSHIFT
    (55) binary_operator -> . RSHIFT

    LBRACE          reduce using rule 164 (switch_expression -> expression .)
    DOT             shift and go to state 43
    PLUS            shift and go to state 44
    MINUS           shift and go to state 45
    TIMES           shift and go to state 46
    DIVIDE          shift and go to state 47
    MODULE          shift and go to state 48
    EQ              shift and go to state 49
    NEQ             shift and go to state 50
    LT              shift and go to state 51
    LE              shift and go to state 52
    GT              shift and go to state 53
    GE              shift and go to state 54
    LAND            shift and go to state 55
    LOR             shift and go to state 56
    AND             shift and go to state 57
    OR              shift and go to state 58
    XOR             shift and go to state 59
    AND_NOT         shift and go to state 60
    LSHIFT          shift and go to state 61
    RSHIFT          shift and go to state 62

    binary_operator                shift and go to state 42

state 250

    (165) switch_expression -> empty .

    LBRACE          reduce using rule 165 (switch_expression -> empty .)


state 251

    (161) switch_init -> short_assignment SEMICOLON .

    LPAREN          reduce using rule 161 (switch_init -> short_assignment SEMICOLON .)
    INT             reduce using rule 161 (switch_init -> short_assignment SEMICOLON .)
    FLOAT64         reduce using rule 161 (switch_init -> short_assignment SEMICOLON .)
    IDENTIFIER      reduce using rule 161 (switch_init -> short_assignment SEMICOLON .)
    STRING          reduce using rule 161 (switch_init -> short_assignment SEMICOLON .)
    TRUE            reduce using rule 161 (switch_init -> short_assignment SEMICOLON .)
    FALSE           reduce using rule 161 (switch_init -> short_assignment SEMICOLON .)
    LNOT            reduce using rule 161 (switch_init -> short_assignment SEMICOLON .)
    LBRACKET        reduce using rule 161 (switch_init -> short_assignment SEMICOLON .)
    MAP             reduce using rule 161 (switch_init -> short_assignment SEMICOLON .)
    LBRACE          reduce using rule 161 (switch_init -> short_assignment SEMICOLON .)


state 252

    (162) switch_init -> simple_assignment SEMICOLON .

    LPAREN          reduce using rule 162 (switch_init -> simple_assignment SEMICOLON .)
    INT             reduce using rule 162 (switch_init -> simple_assignment SEMICOLON .)
    FLOAT64         reduce using rule 162 (switch_init -> simple_assignment SEMICOLON .)
    IDENTIFIER      reduce using rule 162 (switch_init -> simple_assignment SEMICOLON .)
    STRING          reduce using rule 162 (switch_init -> simple_assignment SEMICOLON .)
    TRUE            reduce using rule 162 (switch_init -> simple_assignment SEMICOLON .)
    FALSE           reduce using rule 162 (switch_init -> simple_assignment SEMICOLON .)
    LNOT            reduce using rule 162 (switch_init -> simple_assignment SEMICOLON .)
    LBRACKET        reduce using rule 162 (switch_init -> simple_assignment SEMICOLON .)
    MAP             reduce using rule 162 (switch_init -> simple_assignment SEMICOLON .)
    LBRACE          reduce using rule 162 (switch_init -> simple_assignment SEMICOLON .)


state 253

    (109) return_list -> return_list COMMA . expression
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (123) expression -> . LNOT expression
    (124) expression -> . IDENTIFIER PLUSPLUS
    (125) expression -> . IDENTIFIER MINUSMINUS
    (135) expression -> . map_type LBRACE expression_map_list RBRACE
    (136) expression -> . map_type LBRACE RBRACE
    (158) expression -> . IDENTIFIER LBRACE keyed_element_list RBRACE
    (159) expression -> . IDENTIFIER LBRACE RBRACE
    (174) expression -> . array_type LBRACE expression_list RBRACE
    (175) expression -> . array_type LBRACE RBRACE
    (176) expression -> . expression DOT IDENTIFIER
    (177) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (178) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (134) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (173) array_type -> . LBRACKET INT RBRACKET primitive_type

    LPAREN          shift and go to state 23
    INT             shift and go to state 28
    FLOAT64         shift and go to state 29
    IDENTIFIER      shift and go to state 82
    STRING          shift and go to state 12
    TRUE            shift and go to state 30
    FALSE           shift and go to state 31
    LNOT            shift and go to state 32
    LBRACKET        shift and go to state 35
    MAP             shift and go to state 36

    expression                     shift and go to state 263
    slice_type                     shift and go to state 27
    map_type                       shift and go to state 33
    array_type                     shift and go to state 34

state 254

    (143) method_declaration -> FUNC LPAREN receiver RPAREN IDENTIFIER LPAREN parameter_list RPAREN return_type block .

    FUNC            reduce using rule 143 (method_declaration -> FUNC LPAREN receiver RPAREN IDENTIFIER LPAREN parameter_list RPAREN return_type block .)
    TYPE            reduce using rule 143 (method_declaration -> FUNC LPAREN receiver RPAREN IDENTIFIER LPAREN parameter_list RPAREN return_type block .)
    VAR             reduce using rule 143 (method_declaration -> FUNC LPAREN receiver RPAREN IDENTIFIER LPAREN parameter_list RPAREN return_type block .)
    CONST           reduce using rule 143 (method_declaration -> FUNC LPAREN receiver RPAREN IDENTIFIER LPAREN parameter_list RPAREN return_type block .)
    IDENTIFIER      reduce using rule 143 (method_declaration -> FUNC LPAREN receiver RPAREN IDENTIFIER LPAREN parameter_list RPAREN return_type block .)
    LPAREN          reduce using rule 143 (method_declaration -> FUNC LPAREN receiver RPAREN IDENTIFIER LPAREN parameter_list RPAREN return_type block .)
    INT             reduce using rule 143 (method_declaration -> FUNC LPAREN receiver RPAREN IDENTIFIER LPAREN parameter_list RPAREN return_type block .)
    FLOAT64         reduce using rule 143 (method_declaration -> FUNC LPAREN receiver RPAREN IDENTIFIER LPAREN parameter_list RPAREN return_type block .)
    STRING          reduce using rule 143 (method_declaration -> FUNC LPAREN receiver RPAREN IDENTIFIER LPAREN parameter_list RPAREN return_type block .)
    TRUE            reduce using rule 143 (method_declaration -> FUNC LPAREN receiver RPAREN IDENTIFIER LPAREN parameter_list RPAREN return_type block .)
    FALSE           reduce using rule 143 (method_declaration -> FUNC LPAREN receiver RPAREN IDENTIFIER LPAREN parameter_list RPAREN return_type block .)
    LNOT            reduce using rule 143 (method_declaration -> FUNC LPAREN receiver RPAREN IDENTIFIER LPAREN parameter_list RPAREN return_type block .)
    LBRACKET        reduce using rule 143 (method_declaration -> FUNC LPAREN receiver RPAREN IDENTIFIER LPAREN parameter_list RPAREN return_type block .)
    MAP             reduce using rule 143 (method_declaration -> FUNC LPAREN receiver RPAREN IDENTIFIER LPAREN parameter_list RPAREN return_type block .)
    $end            reduce using rule 143 (method_declaration -> FUNC LPAREN receiver RPAREN IDENTIFIER LPAREN parameter_list RPAREN return_type block .)


state 255

    (91) for_statement -> FOR for_init for_condition for_incr . LBRACE for_body_list RBRACE
    (92) for_statement -> FOR for_init for_condition for_incr . LBRACE RBRACE

    LBRACE          shift and go to state 264


state 256

    (100) for_incr -> simple_assignment .

    LBRACE          reduce using rule 100 (for_incr -> simple_assignment .)


state 257

    (101) for_incr -> short_assignment .

    LBRACE          reduce using rule 101 (for_incr -> short_assignment .)


state 258

    (102) for_incr -> empty .

    LBRACE          reduce using rule 102 (for_incr -> empty .)


state 259

    (97) for_condition -> expression SEMICOLON .

    IDENTIFIER      reduce using rule 97 (for_condition -> expression SEMICOLON .)
    LBRACE          reduce using rule 97 (for_condition -> expression SEMICOLON .)


state 260

    (77) short_assign -> SHORT_ASSIGN expression .
    (36) expression -> expression . binary_operator expression
    (176) expression -> expression . DOT IDENTIFIER
    (177) expression -> expression . DOT IDENTIFIER LPAREN argument_list RPAREN
    (37) binary_operator -> . PLUS
    (38) binary_operator -> . MINUS
    (39) binary_operator -> . TIMES
    (40) binary_operator -> . DIVIDE
    (41) binary_operator -> . MODULE
    (42) binary_operator -> . EQ
    (43) binary_operator -> . NEQ
    (44) binary_operator -> . LT
    (45) binary_operator -> . LE
    (46) binary_operator -> . GT
    (47) binary_operator -> . GE
    (48) binary_operator -> . LAND
    (49) binary_operator -> . LOR
    (50) binary_operator -> . AND
    (51) binary_operator -> . OR
    (52) binary_operator -> . XOR
    (53) binary_operator -> . AND_NOT
    (54) binary_operator -> . LSHIFT
    (55) binary_operator -> . RSHIFT

    SEMICOLON       reduce using rule 77 (short_assign -> SHORT_ASSIGN expression .)
    LBRACE          reduce using rule 77 (short_assign -> SHORT_ASSIGN expression .)
    DOT             shift and go to state 43
    PLUS            shift and go to state 44
    MINUS           shift and go to state 45
    TIMES           shift and go to state 46
    DIVIDE          shift and go to state 47
    MODULE          shift and go to state 48
    EQ              shift and go to state 49
    NEQ             shift and go to state 50
    LT              shift and go to state 51
    LE              shift and go to state 52
    GT              shift and go to state 53
    GE              shift and go to state 54
    LAND            shift and go to state 55
    LOR             shift and go to state 56
    AND             shift and go to state 57
    OR              shift and go to state 58
    XOR             shift and go to state 59
    AND_NOT         shift and go to state 60
    LSHIFT          shift and go to state 61
    RSHIFT          shift and go to state 62

    binary_operator                shift and go to state 42

state 261

    (126) if_statement -> IF if_init if_condition block . if_else_clause
    (131) if_else_clause -> . ELSE block
    (132) if_else_clause -> . ELSE if_statement
    (133) if_else_clause -> . empty
    (7) empty -> .

    ELSE            shift and go to state 266
    RBRACE          reduce using rule 7 (empty -> .)
    SEMICOLON       reduce using rule 7 (empty -> .)
    CASE            reduce using rule 7 (empty -> .)
    DEFAULT         reduce using rule 7 (empty -> .)

    if_else_clause                 shift and go to state 265
    empty                          shift and go to state 267

state 262

    (160) switch_statement -> SWITCH switch_init switch_expression LBRACE . case_clauses RBRACE
    (166) case_clauses -> . case_clause
    (167) case_clauses -> . case_clauses case_clause
    (168) case_clause -> . CASE expression_list COLON case_body
    (169) case_clause -> . DEFAULT COLON case_body

    CASE            shift and go to state 270
    DEFAULT         shift and go to state 271

    case_clauses                   shift and go to state 268
    case_clause                    shift and go to state 269

state 263

    (109) return_list -> return_list COMMA expression .
    (36) expression -> expression . binary_operator expression
    (176) expression -> expression . DOT IDENTIFIER
    (177) expression -> expression . DOT IDENTIFIER LPAREN argument_list RPAREN
    (37) binary_operator -> . PLUS
    (38) binary_operator -> . MINUS
    (39) binary_operator -> . TIMES
    (40) binary_operator -> . DIVIDE
    (41) binary_operator -> . MODULE
    (42) binary_operator -> . EQ
    (43) binary_operator -> . NEQ
    (44) binary_operator -> . LT
    (45) binary_operator -> . LE
    (46) binary_operator -> . GT
    (47) binary_operator -> . GE
    (48) binary_operator -> . LAND
    (49) binary_operator -> . LOR
    (50) binary_operator -> . AND
    (51) binary_operator -> . OR
    (52) binary_operator -> . XOR
    (53) binary_operator -> . AND_NOT
    (54) binary_operator -> . LSHIFT
    (55) binary_operator -> . RSHIFT

    COMMA           reduce using rule 109 (return_list -> return_list COMMA expression .)
    RBRACE          reduce using rule 109 (return_list -> return_list COMMA expression .)
    SEMICOLON       reduce using rule 109 (return_list -> return_list COMMA expression .)
    CASE            reduce using rule 109 (return_list -> return_list COMMA expression .)
    DEFAULT         reduce using rule 109 (return_list -> return_list COMMA expression .)
    DOT             shift and go to state 43
    PLUS            shift and go to state 44
    MINUS           shift and go to state 45
    TIMES           shift and go to state 46
    DIVIDE          shift and go to state 47
    MODULE          shift and go to state 48
    EQ              shift and go to state 49
    NEQ             shift and go to state 50
    LT              shift and go to state 51
    LE              shift and go to state 52
    GT              shift and go to state 53
    GE              shift and go to state 54
    LAND            shift and go to state 55
    LOR             shift and go to state 56
    AND             shift and go to state 57
    OR              shift and go to state 58
    XOR             shift and go to state 59
    AND_NOT         shift and go to state 60
    LSHIFT          shift and go to state 61
    RSHIFT          shift and go to state 62

    binary_operator                shift and go to state 42

state 264

    (91) for_statement -> FOR for_init for_condition for_incr LBRACE . for_body_list RBRACE
    (92) for_statement -> FOR for_init for_condition for_incr LBRACE . RBRACE
    (103) for_body_list -> . for_body
    (104) for_body_list -> . for_body_list SEMICOLON for_body
    (105) for_body -> . local_statement
    (106) for_body -> . BREAK
    (107) for_body -> . CONTINUE
    (79) local_statement -> . var_dec
    (80) local_statement -> . var_dec simple_assign
    (81) local_statement -> . assignment_compound
    (82) local_statement -> . expression
    (83) local_statement -> . for_statement
    (84) local_statement -> . if_statement
    (85) local_statement -> . switch_statement
    (86) local_statement -> . return_statement
    (20) var_dec -> . VAR IDENTIFIER type
    (21) var_dec -> . CONST IDENTIFIER type
    (22) var_dec -> . VAR IDENTIFIER
    (23) var_dec -> . CONST IDENTIFIER
    (25) assignment_compound -> . IDENTIFIER operator_assign expression
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (123) expression -> . LNOT expression
    (124) expression -> . IDENTIFIER PLUSPLUS
    (125) expression -> . IDENTIFIER MINUSMINUS
    (135) expression -> . map_type LBRACE expression_map_list RBRACE
    (136) expression -> . map_type LBRACE RBRACE
    (158) expression -> . IDENTIFIER LBRACE keyed_element_list RBRACE
    (159) expression -> . IDENTIFIER LBRACE RBRACE
    (174) expression -> . array_type LBRACE expression_list RBRACE
    (175) expression -> . array_type LBRACE RBRACE
    (176) expression -> . expression DOT IDENTIFIER
    (177) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (178) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (91) for_statement -> . FOR for_init for_condition for_incr LBRACE for_body_list RBRACE
    (92) for_statement -> . FOR for_init for_condition for_incr LBRACE RBRACE
    (126) if_statement -> . IF if_init if_condition block if_else_clause
    (160) switch_statement -> . SWITCH switch_init switch_expression LBRACE case_clauses RBRACE
    (121) return_statement -> . RETURN
    (122) return_statement -> . RETURN return_list
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (134) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (173) array_type -> . LBRACKET INT RBRACKET primitive_type

    RBRACE          shift and go to state 273
    BREAK           shift and go to state 276
    CONTINUE        shift and go to state 277
    VAR             shift and go to state 25
    CONST           shift and go to state 26
    IDENTIFIER      shift and go to state 207
    LPAREN          shift and go to state 23
    INT             shift and go to state 28
    FLOAT64         shift and go to state 29
    STRING          shift and go to state 12
    TRUE            shift and go to state 30
    FALSE           shift and go to state 31
    LNOT            shift and go to state 32
    FOR             shift and go to state 208
    IF              shift and go to state 209
    SWITCH          shift and go to state 210
    RETURN          shift and go to state 211
    LBRACKET        shift and go to state 35
    MAP             shift and go to state 36

    for_body_list                  shift and go to state 272
    for_body                       shift and go to state 274
    local_statement                shift and go to state 275
    var_dec                        shift and go to state 200
    assignment_compound            shift and go to state 201
    expression                     shift and go to state 202
    for_statement                  shift and go to state 203
    if_statement                   shift and go to state 204
    switch_statement               shift and go to state 205
    return_statement               shift and go to state 206
    slice_type                     shift and go to state 27
    map_type                       shift and go to state 33
    array_type                     shift and go to state 34

state 265

    (126) if_statement -> IF if_init if_condition block if_else_clause .

    RBRACE          reduce using rule 126 (if_statement -> IF if_init if_condition block if_else_clause .)
    SEMICOLON       reduce using rule 126 (if_statement -> IF if_init if_condition block if_else_clause .)
    CASE            reduce using rule 126 (if_statement -> IF if_init if_condition block if_else_clause .)
    DEFAULT         reduce using rule 126 (if_statement -> IF if_init if_condition block if_else_clause .)


state 266

    (131) if_else_clause -> ELSE . block
    (132) if_else_clause -> ELSE . if_statement
    (87) block -> . LBRACE local_statement_list RBRACE
    (88) block -> . LBRACE RBRACE
    (126) if_statement -> . IF if_init if_condition block if_else_clause

    LBRACE          shift and go to state 192
    IF              shift and go to state 209

    block                          shift and go to state 278
    if_statement                   shift and go to state 279

state 267

    (133) if_else_clause -> empty .

    RBRACE          reduce using rule 133 (if_else_clause -> empty .)
    SEMICOLON       reduce using rule 133 (if_else_clause -> empty .)
    CASE            reduce using rule 133 (if_else_clause -> empty .)
    DEFAULT         reduce using rule 133 (if_else_clause -> empty .)


state 268

    (160) switch_statement -> SWITCH switch_init switch_expression LBRACE case_clauses . RBRACE
    (167) case_clauses -> case_clauses . case_clause
    (168) case_clause -> . CASE expression_list COLON case_body
    (169) case_clause -> . DEFAULT COLON case_body

    RBRACE          shift and go to state 280
    CASE            shift and go to state 270
    DEFAULT         shift and go to state 271

    case_clause                    shift and go to state 281

state 269

    (166) case_clauses -> case_clause .

    RBRACE          reduce using rule 166 (case_clauses -> case_clause .)
    CASE            reduce using rule 166 (case_clauses -> case_clause .)
    DEFAULT         reduce using rule 166 (case_clauses -> case_clause .)


state 270

    (168) case_clause -> CASE . expression_list COLON case_body
    (68) expression_list -> . expression
    (69) expression_list -> . expression_list COMMA expression
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (123) expression -> . LNOT expression
    (124) expression -> . IDENTIFIER PLUSPLUS
    (125) expression -> . IDENTIFIER MINUSMINUS
    (135) expression -> . map_type LBRACE expression_map_list RBRACE
    (136) expression -> . map_type LBRACE RBRACE
    (158) expression -> . IDENTIFIER LBRACE keyed_element_list RBRACE
    (159) expression -> . IDENTIFIER LBRACE RBRACE
    (174) expression -> . array_type LBRACE expression_list RBRACE
    (175) expression -> . array_type LBRACE RBRACE
    (176) expression -> . expression DOT IDENTIFIER
    (177) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (178) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (134) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (173) array_type -> . LBRACKET INT RBRACKET primitive_type

    LPAREN          shift and go to state 23
    INT             shift and go to state 28
    FLOAT64         shift and go to state 29
    IDENTIFIER      shift and go to state 82
    STRING          shift and go to state 12
    TRUE            shift and go to state 30
    FALSE           shift and go to state 31
    LNOT            shift and go to state 32
    LBRACKET        shift and go to state 35
    MAP             shift and go to state 36

    expression_list                shift and go to state 282
    expression                     shift and go to state 109
    slice_type                     shift and go to state 27
    map_type                       shift and go to state 33
    array_type                     shift and go to state 34

state 271

    (169) case_clause -> DEFAULT . COLON case_body

    COLON           shift and go to state 283


state 272

    (91) for_statement -> FOR for_init for_condition for_incr LBRACE for_body_list . RBRACE
    (104) for_body_list -> for_body_list . SEMICOLON for_body

    RBRACE          shift and go to state 284
    SEMICOLON       shift and go to state 285


state 273

    (92) for_statement -> FOR for_init for_condition for_incr LBRACE RBRACE .

    RBRACE          reduce using rule 92 (for_statement -> FOR for_init for_condition for_incr LBRACE RBRACE .)
    SEMICOLON       reduce using rule 92 (for_statement -> FOR for_init for_condition for_incr LBRACE RBRACE .)
    CASE            reduce using rule 92 (for_statement -> FOR for_init for_condition for_incr LBRACE RBRACE .)
    DEFAULT         reduce using rule 92 (for_statement -> FOR for_init for_condition for_incr LBRACE RBRACE .)


state 274

    (103) for_body_list -> for_body .

    RBRACE          reduce using rule 103 (for_body_list -> for_body .)
    SEMICOLON       reduce using rule 103 (for_body_list -> for_body .)


state 275

    (105) for_body -> local_statement .

    RBRACE          reduce using rule 105 (for_body -> local_statement .)
    SEMICOLON       reduce using rule 105 (for_body -> local_statement .)


state 276

    (106) for_body -> BREAK .

    RBRACE          reduce using rule 106 (for_body -> BREAK .)
    SEMICOLON       reduce using rule 106 (for_body -> BREAK .)


state 277

    (107) for_body -> CONTINUE .

    RBRACE          reduce using rule 107 (for_body -> CONTINUE .)
    SEMICOLON       reduce using rule 107 (for_body -> CONTINUE .)


state 278

    (131) if_else_clause -> ELSE block .

    RBRACE          reduce using rule 131 (if_else_clause -> ELSE block .)
    SEMICOLON       reduce using rule 131 (if_else_clause -> ELSE block .)
    CASE            reduce using rule 131 (if_else_clause -> ELSE block .)
    DEFAULT         reduce using rule 131 (if_else_clause -> ELSE block .)


state 279

    (132) if_else_clause -> ELSE if_statement .

    RBRACE          reduce using rule 132 (if_else_clause -> ELSE if_statement .)
    SEMICOLON       reduce using rule 132 (if_else_clause -> ELSE if_statement .)
    CASE            reduce using rule 132 (if_else_clause -> ELSE if_statement .)
    DEFAULT         reduce using rule 132 (if_else_clause -> ELSE if_statement .)


state 280

    (160) switch_statement -> SWITCH switch_init switch_expression LBRACE case_clauses RBRACE .

    RBRACE          reduce using rule 160 (switch_statement -> SWITCH switch_init switch_expression LBRACE case_clauses RBRACE .)
    SEMICOLON       reduce using rule 160 (switch_statement -> SWITCH switch_init switch_expression LBRACE case_clauses RBRACE .)
    CASE            reduce using rule 160 (switch_statement -> SWITCH switch_init switch_expression LBRACE case_clauses RBRACE .)
    DEFAULT         reduce using rule 160 (switch_statement -> SWITCH switch_init switch_expression LBRACE case_clauses RBRACE .)


state 281

    (167) case_clauses -> case_clauses case_clause .

    RBRACE          reduce using rule 167 (case_clauses -> case_clauses case_clause .)
    CASE            reduce using rule 167 (case_clauses -> case_clauses case_clause .)
    DEFAULT         reduce using rule 167 (case_clauses -> case_clauses case_clause .)


state 282

    (168) case_clause -> CASE expression_list . COLON case_body
    (69) expression_list -> expression_list . COMMA expression

    COLON           shift and go to state 286
    COMMA           shift and go to state 150


state 283

    (169) case_clause -> DEFAULT COLON . case_body
    (170) case_body -> . local_statement_list
    (171) case_body -> . BREAK
    (172) case_body -> . empty
    (89) local_statement_list -> . local_statement
    (90) local_statement_list -> . local_statement_list SEMICOLON local_statement
    (7) empty -> .
    (79) local_statement -> . var_dec
    (80) local_statement -> . var_dec simple_assign
    (81) local_statement -> . assignment_compound
    (82) local_statement -> . expression
    (83) local_statement -> . for_statement
    (84) local_statement -> . if_statement
    (85) local_statement -> . switch_statement
    (86) local_statement -> . return_statement
    (20) var_dec -> . VAR IDENTIFIER type
    (21) var_dec -> . CONST IDENTIFIER type
    (22) var_dec -> . VAR IDENTIFIER
    (23) var_dec -> . CONST IDENTIFIER
    (25) assignment_compound -> . IDENTIFIER operator_assign expression
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (123) expression -> . LNOT expression
    (124) expression -> . IDENTIFIER PLUSPLUS
    (125) expression -> . IDENTIFIER MINUSMINUS
    (135) expression -> . map_type LBRACE expression_map_list RBRACE
    (136) expression -> . map_type LBRACE RBRACE
    (158) expression -> . IDENTIFIER LBRACE keyed_element_list RBRACE
    (159) expression -> . IDENTIFIER LBRACE RBRACE
    (174) expression -> . array_type LBRACE expression_list RBRACE
    (175) expression -> . array_type LBRACE RBRACE
    (176) expression -> . expression DOT IDENTIFIER
    (177) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (178) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (91) for_statement -> . FOR for_init for_condition for_incr LBRACE for_body_list RBRACE
    (92) for_statement -> . FOR for_init for_condition for_incr LBRACE RBRACE
    (126) if_statement -> . IF if_init if_condition block if_else_clause
    (160) switch_statement -> . SWITCH switch_init switch_expression LBRACE case_clauses RBRACE
    (121) return_statement -> . RETURN
    (122) return_statement -> . RETURN return_list
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (134) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (173) array_type -> . LBRACKET INT RBRACKET primitive_type

    BREAK           shift and go to state 289
    RBRACE          reduce using rule 7 (empty -> .)
    CASE            reduce using rule 7 (empty -> .)
    DEFAULT         reduce using rule 7 (empty -> .)
    VAR             shift and go to state 25
    CONST           shift and go to state 26
    IDENTIFIER      shift and go to state 207
    LPAREN          shift and go to state 23
    INT             shift and go to state 28
    FLOAT64         shift and go to state 29
    STRING          shift and go to state 12
    TRUE            shift and go to state 30
    FALSE           shift and go to state 31
    LNOT            shift and go to state 32
    FOR             shift and go to state 208
    IF              shift and go to state 209
    SWITCH          shift and go to state 210
    RETURN          shift and go to state 211
    LBRACKET        shift and go to state 35
    MAP             shift and go to state 36

    case_body                      shift and go to state 287
    local_statement_list           shift and go to state 288
    empty                          shift and go to state 290
    local_statement                shift and go to state 199
    var_dec                        shift and go to state 200
    assignment_compound            shift and go to state 201
    expression                     shift and go to state 202
    for_statement                  shift and go to state 203
    if_statement                   shift and go to state 204
    switch_statement               shift and go to state 205
    return_statement               shift and go to state 206
    slice_type                     shift and go to state 27
    map_type                       shift and go to state 33
    array_type                     shift and go to state 34

state 284

    (91) for_statement -> FOR for_init for_condition for_incr LBRACE for_body_list RBRACE .

    RBRACE          reduce using rule 91 (for_statement -> FOR for_init for_condition for_incr LBRACE for_body_list RBRACE .)
    SEMICOLON       reduce using rule 91 (for_statement -> FOR for_init for_condition for_incr LBRACE for_body_list RBRACE .)
    CASE            reduce using rule 91 (for_statement -> FOR for_init for_condition for_incr LBRACE for_body_list RBRACE .)
    DEFAULT         reduce using rule 91 (for_statement -> FOR for_init for_condition for_incr LBRACE for_body_list RBRACE .)


state 285

    (104) for_body_list -> for_body_list SEMICOLON . for_body
    (105) for_body -> . local_statement
    (106) for_body -> . BREAK
    (107) for_body -> . CONTINUE
    (79) local_statement -> . var_dec
    (80) local_statement -> . var_dec simple_assign
    (81) local_statement -> . assignment_compound
    (82) local_statement -> . expression
    (83) local_statement -> . for_statement
    (84) local_statement -> . if_statement
    (85) local_statement -> . switch_statement
    (86) local_statement -> . return_statement
    (20) var_dec -> . VAR IDENTIFIER type
    (21) var_dec -> . CONST IDENTIFIER type
    (22) var_dec -> . VAR IDENTIFIER
    (23) var_dec -> . CONST IDENTIFIER
    (25) assignment_compound -> . IDENTIFIER operator_assign expression
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (123) expression -> . LNOT expression
    (124) expression -> . IDENTIFIER PLUSPLUS
    (125) expression -> . IDENTIFIER MINUSMINUS
    (135) expression -> . map_type LBRACE expression_map_list RBRACE
    (136) expression -> . map_type LBRACE RBRACE
    (158) expression -> . IDENTIFIER LBRACE keyed_element_list RBRACE
    (159) expression -> . IDENTIFIER LBRACE RBRACE
    (174) expression -> . array_type LBRACE expression_list RBRACE
    (175) expression -> . array_type LBRACE RBRACE
    (176) expression -> . expression DOT IDENTIFIER
    (177) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (178) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (91) for_statement -> . FOR for_init for_condition for_incr LBRACE for_body_list RBRACE
    (92) for_statement -> . FOR for_init for_condition for_incr LBRACE RBRACE
    (126) if_statement -> . IF if_init if_condition block if_else_clause
    (160) switch_statement -> . SWITCH switch_init switch_expression LBRACE case_clauses RBRACE
    (121) return_statement -> . RETURN
    (122) return_statement -> . RETURN return_list
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (134) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (173) array_type -> . LBRACKET INT RBRACKET primitive_type

    BREAK           shift and go to state 276
    CONTINUE        shift and go to state 277
    VAR             shift and go to state 25
    CONST           shift and go to state 26
    IDENTIFIER      shift and go to state 207
    LPAREN          shift and go to state 23
    INT             shift and go to state 28
    FLOAT64         shift and go to state 29
    STRING          shift and go to state 12
    TRUE            shift and go to state 30
    FALSE           shift and go to state 31
    LNOT            shift and go to state 32
    FOR             shift and go to state 208
    IF              shift and go to state 209
    SWITCH          shift and go to state 210
    RETURN          shift and go to state 211
    LBRACKET        shift and go to state 35
    MAP             shift and go to state 36

    for_body                       shift and go to state 291
    local_statement                shift and go to state 275
    var_dec                        shift and go to state 200
    assignment_compound            shift and go to state 201
    expression                     shift and go to state 202
    for_statement                  shift and go to state 203
    if_statement                   shift and go to state 204
    switch_statement               shift and go to state 205
    return_statement               shift and go to state 206
    slice_type                     shift and go to state 27
    map_type                       shift and go to state 33
    array_type                     shift and go to state 34

state 286

    (168) case_clause -> CASE expression_list COLON . case_body
    (170) case_body -> . local_statement_list
    (171) case_body -> . BREAK
    (172) case_body -> . empty
    (89) local_statement_list -> . local_statement
    (90) local_statement_list -> . local_statement_list SEMICOLON local_statement
    (7) empty -> .
    (79) local_statement -> . var_dec
    (80) local_statement -> . var_dec simple_assign
    (81) local_statement -> . assignment_compound
    (82) local_statement -> . expression
    (83) local_statement -> . for_statement
    (84) local_statement -> . if_statement
    (85) local_statement -> . switch_statement
    (86) local_statement -> . return_statement
    (20) var_dec -> . VAR IDENTIFIER type
    (21) var_dec -> . CONST IDENTIFIER type
    (22) var_dec -> . VAR IDENTIFIER
    (23) var_dec -> . CONST IDENTIFIER
    (25) assignment_compound -> . IDENTIFIER operator_assign expression
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (123) expression -> . LNOT expression
    (124) expression -> . IDENTIFIER PLUSPLUS
    (125) expression -> . IDENTIFIER MINUSMINUS
    (135) expression -> . map_type LBRACE expression_map_list RBRACE
    (136) expression -> . map_type LBRACE RBRACE
    (158) expression -> . IDENTIFIER LBRACE keyed_element_list RBRACE
    (159) expression -> . IDENTIFIER LBRACE RBRACE
    (174) expression -> . array_type LBRACE expression_list RBRACE
    (175) expression -> . array_type LBRACE RBRACE
    (176) expression -> . expression DOT IDENTIFIER
    (177) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (178) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (91) for_statement -> . FOR for_init for_condition for_incr LBRACE for_body_list RBRACE
    (92) for_statement -> . FOR for_init for_condition for_incr LBRACE RBRACE
    (126) if_statement -> . IF if_init if_condition block if_else_clause
    (160) switch_statement -> . SWITCH switch_init switch_expression LBRACE case_clauses RBRACE
    (121) return_statement -> . RETURN
    (122) return_statement -> . RETURN return_list
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (134) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (173) array_type -> . LBRACKET INT RBRACKET primitive_type

    BREAK           shift and go to state 289
    RBRACE          reduce using rule 7 (empty -> .)
    CASE            reduce using rule 7 (empty -> .)
    DEFAULT         reduce using rule 7 (empty -> .)
    VAR             shift and go to state 25
    CONST           shift and go to state 26
    IDENTIFIER      shift and go to state 207
    LPAREN          shift and go to state 23
    INT             shift and go to state 28
    FLOAT64         shift and go to state 29
    STRING          shift and go to state 12
    TRUE            shift and go to state 30
    FALSE           shift and go to state 31
    LNOT            shift and go to state 32
    FOR             shift and go to state 208
    IF              shift and go to state 209
    SWITCH          shift and go to state 210
    RETURN          shift and go to state 211
    LBRACKET        shift and go to state 35
    MAP             shift and go to state 36

    case_body                      shift and go to state 292
    local_statement_list           shift and go to state 288
    empty                          shift and go to state 290
    local_statement                shift and go to state 199
    var_dec                        shift and go to state 200
    assignment_compound            shift and go to state 201
    expression                     shift and go to state 202
    for_statement                  shift and go to state 203
    if_statement                   shift and go to state 204
    switch_statement               shift and go to state 205
    return_statement               shift and go to state 206
    slice_type                     shift and go to state 27
    map_type                       shift and go to state 33
    array_type                     shift and go to state 34

state 287

    (169) case_clause -> DEFAULT COLON case_body .

    RBRACE          reduce using rule 169 (case_clause -> DEFAULT COLON case_body .)
    CASE            reduce using rule 169 (case_clause -> DEFAULT COLON case_body .)
    DEFAULT         reduce using rule 169 (case_clause -> DEFAULT COLON case_body .)


state 288

    (170) case_body -> local_statement_list .
    (90) local_statement_list -> local_statement_list . SEMICOLON local_statement

    RBRACE          reduce using rule 170 (case_body -> local_statement_list .)
    CASE            reduce using rule 170 (case_body -> local_statement_list .)
    DEFAULT         reduce using rule 170 (case_body -> local_statement_list .)
    SEMICOLON       shift and go to state 215


state 289

    (171) case_body -> BREAK .

    RBRACE          reduce using rule 171 (case_body -> BREAK .)
    CASE            reduce using rule 171 (case_body -> BREAK .)
    DEFAULT         reduce using rule 171 (case_body -> BREAK .)


state 290

    (172) case_body -> empty .

    RBRACE          reduce using rule 172 (case_body -> empty .)
    CASE            reduce using rule 172 (case_body -> empty .)
    DEFAULT         reduce using rule 172 (case_body -> empty .)


state 291

    (104) for_body_list -> for_body_list SEMICOLON for_body .

    RBRACE          reduce using rule 104 (for_body_list -> for_body_list SEMICOLON for_body .)
    SEMICOLON       reduce using rule 104 (for_body_list -> for_body_list SEMICOLON for_body .)


state 292

    (168) case_clause -> CASE expression_list COLON case_body .

    RBRACE          reduce using rule 168 (case_clause -> CASE expression_list COLON case_body .)
    CASE            reduce using rule 168 (case_clause -> CASE expression_list COLON case_body .)
    DEFAULT         reduce using rule 168 (case_clause -> CASE expression_list COLON case_body .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for IMPORT in state 2 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 22 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 82 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 82 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 84 resolved as shift
WARNING: shift/reduce conflict for MAP in state 84 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 85 resolved as shift
WARNING: shift/reduce conflict for MAP in state 85 resolved as shift
WARNING: shift/reduce conflict for DOT in state 87 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 87 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 87 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 87 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 87 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 87 resolved as shift
WARNING: shift/reduce conflict for EQ in state 87 resolved as shift
WARNING: shift/reduce conflict for NEQ in state 87 resolved as shift
WARNING: shift/reduce conflict for LT in state 87 resolved as shift
WARNING: shift/reduce conflict for LE in state 87 resolved as shift
WARNING: shift/reduce conflict for GT in state 87 resolved as shift
WARNING: shift/reduce conflict for GE in state 87 resolved as shift
WARNING: shift/reduce conflict for LAND in state 87 resolved as shift
WARNING: shift/reduce conflict for LOR in state 87 resolved as shift
WARNING: shift/reduce conflict for AND in state 87 resolved as shift
WARNING: shift/reduce conflict for OR in state 87 resolved as shift
WARNING: shift/reduce conflict for XOR in state 87 resolved as shift
WARNING: shift/reduce conflict for AND_NOT in state 87 resolved as shift
WARNING: shift/reduce conflict for LSHIFT in state 87 resolved as shift
WARNING: shift/reduce conflict for RSHIFT in state 87 resolved as shift
WARNING: shift/reduce conflict for DOT in state 94 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 94 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 94 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 94 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 94 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 94 resolved as shift
WARNING: shift/reduce conflict for EQ in state 94 resolved as shift
WARNING: shift/reduce conflict for NEQ in state 94 resolved as shift
WARNING: shift/reduce conflict for LT in state 94 resolved as shift
WARNING: shift/reduce conflict for LE in state 94 resolved as shift
WARNING: shift/reduce conflict for GT in state 94 resolved as shift
WARNING: shift/reduce conflict for GE in state 94 resolved as shift
WARNING: shift/reduce conflict for LAND in state 94 resolved as shift
WARNING: shift/reduce conflict for LOR in state 94 resolved as shift
WARNING: shift/reduce conflict for AND in state 94 resolved as shift
WARNING: shift/reduce conflict for OR in state 94 resolved as shift
WARNING: shift/reduce conflict for XOR in state 94 resolved as shift
WARNING: shift/reduce conflict for AND_NOT in state 94 resolved as shift
WARNING: shift/reduce conflict for LSHIFT in state 94 resolved as shift
WARNING: shift/reduce conflict for RSHIFT in state 94 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 95 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 208 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 208 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 209 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 210 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 217 resolved as shift
