Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> package_declaration import global_statement_list
Rule 2     package_declaration -> PACKAGE IDENTIFIER
Rule 3     import -> simple_import
Rule 4     import -> import simple_import
Rule 5     import -> empty
Rule 6     simple_import -> IMPORT STRING
Rule 7     empty -> <empty>
<<<<<<< Updated upstream
Rule 8     global_statement_list -> global_statement
Rule 9     global_statement_list -> global_statement_list global_statement
Rule 10    global_statement -> global_var_dec
Rule 11    global_statement -> global_const_dec
Rule 12    global_statement -> function_declaration
Rule 13    global_statement -> method_declaration
Rule 14    global_statement -> type_declaration
Rule 15    global_var_dec -> VAR IDENTIFIER type
Rule 16    global_var_dec -> VAR IDENTIFIER type ASSIGN expression
Rule 17    global_var_dec -> VAR IDENTIFIER ASSIGN expression
Rule 18    global_const_dec -> CONST IDENTIFIER type ASSIGN expression
Rule 19    global_const_dec -> CONST IDENTIFIER ASSIGN expression
Rule 20    local_var_dec -> VAR IDENTIFIER type
Rule 21    local_var_dec -> VAR IDENTIFIER type ASSIGN expression
Rule 22    local_var_dec -> VAR IDENTIFIER ASSIGN expression
Rule 23    local_const_dec -> CONST IDENTIFIER type ASSIGN expression
Rule 24    local_const_dec -> CONST IDENTIFIER ASSIGN expression
Rule 25    assignment_compound -> IDENTIFIER operator_assign expression
Rule 26    operator_assign -> PLUS_ASSIGN
Rule 27    operator_assign -> MINUS_ASSIGN
Rule 28    operator_assign -> MULT_ASSIGN
Rule 29    operator_assign -> DIV_ASSIGN
Rule 30    operator_assign -> MOD_ASSIGN
Rule 31    operator_assign -> AND_ASSIGN
Rule 32    operator_assign -> OR_ASSIGN
Rule 33    operator_assign -> XOR_ASSIGN
Rule 34    operator_assign -> LSHIFT_ASSIGN
Rule 35    operator_assign -> RSHIFT_ASSIGN
Rule 36    expression -> expression binary_operator expression
Rule 37    binary_operator -> PLUS
Rule 38    binary_operator -> MINUS
Rule 39    binary_operator -> TIMES
Rule 40    binary_operator -> DIVIDE
Rule 41    binary_operator -> MODULE
Rule 42    binary_operator -> EQ
Rule 43    binary_operator -> NEQ
Rule 44    binary_operator -> LT
Rule 45    binary_operator -> LE
Rule 46    binary_operator -> GT
Rule 47    binary_operator -> GE
Rule 48    binary_operator -> LAND
Rule 49    binary_operator -> LOR
Rule 50    binary_operator -> AND
Rule 51    binary_operator -> OR
Rule 52    binary_operator -> XOR
Rule 53    binary_operator -> AND_NOT
Rule 54    binary_operator -> LSHIFT
Rule 55    binary_operator -> RSHIFT
Rule 56    simple_assignment -> IDENTIFIER ASSIGN expression
Rule 57    type -> primitive_type
Rule 58    type -> slice_type
Rule 59    type -> array_type
Rule 60    type -> map_type
Rule 61    primitive_type -> INT_TYPE
Rule 62    primitive_type -> FLOAT64_TYPE
Rule 63    primitive_type -> STRING_TYPE
Rule 64    primitive_type -> BOOL_TYPE
Rule 65    slice_type -> LBRACKET RBRACKET primitive_type
Rule 66    expression -> slice_type LBRACE expression_list RBRACE
Rule 67    expression -> slice_type LBRACE RBRACE
Rule 68    expression_list -> expression
Rule 69    expression_list -> expression_list COMMA expression
Rule 70    expression -> LPAREN expression RPAREN
Rule 71    expression -> INT
Rule 72    expression -> FLOAT64
Rule 73    expression -> IDENTIFIER
Rule 74    expression -> STRING
Rule 75    expression -> TRUE
Rule 76    expression -> FALSE
Rule 77    short_assignment -> IDENTIFIER SHORT_ASSIGN expression
Rule 78    local_statement -> local_var_dec
Rule 79    local_statement -> local_const_dec
Rule 80    local_statement -> short_assignment
Rule 81    local_statement -> simple_assignment
Rule 82    local_statement -> assignment_compound
Rule 83    local_statement -> expression
Rule 84    local_statement -> for_statement
Rule 85    local_statement -> if_statement
Rule 86    local_statement -> switch_statement
Rule 87    local_statement -> return_statement
Rule 88    local_statement -> BREAK
Rule 89    local_statement -> CONTINUE
Rule 90    block -> LBRACE local_statement_list RBRACE
Rule 91    block -> LBRACE RBRACE
Rule 92    local_statement_list -> local_statement
Rule 93    local_statement_list -> local_statement_list local_statement
Rule 94    for_statement -> for_classic
Rule 95    for_statement -> for_condition
Rule 96    for_statement -> for_infinite
Rule 97    for_classic -> FOR for_init SEMICOLON for_cond SEMICOLON for_post block
Rule 98    for_condition -> FOR expression block
Rule 99    for_infinite -> FOR block
Rule 100   for_init -> simple_assignment
Rule 101   for_init -> short_assignment
Rule 102   for_init -> local_var_dec
Rule 103   for_init -> empty
Rule 104   for_cond -> expression
Rule 105   for_cond -> empty
Rule 106   for_post -> simple_assignment
Rule 107   for_post -> assignment_compound
Rule 108   for_post -> expression
Rule 109   for_post -> empty
Rule 110   return_list -> expression
Rule 111   return_list -> return_list COMMA expression
Rule 112   function_declaration -> FUNC IDENTIFIER LPAREN parameter_list RPAREN return_type block
Rule 113   parameter_list -> parameter_list COMMA parameter
Rule 114   parameter_list -> parameter
Rule 115   parameter_list -> empty
Rule 116   parameter -> IDENTIFIER type
Rule 117   parameter -> IDENTIFIER ELLIPSIS primitive_type
Rule 118   return_type -> type
Rule 119   return_type -> LPAREN type_list RPAREN
Rule 120   return_type -> empty
Rule 121   type_list -> type
Rule 122   type_list -> type_list COMMA type
Rule 123   return_statement -> RETURN
Rule 124   return_statement -> RETURN return_list
Rule 125   expression -> LNOT expression
Rule 126   expression -> IDENTIFIER PLUSPLUS
Rule 127   expression -> IDENTIFIER MINUSMINUS
Rule 128   if_statement -> IF expression block
Rule 129   if_statement -> IF expression block ELSE block
Rule 130   if_statement -> IF expression block ELSE if_statement
Rule 131   if_statement -> IF if_assignment SEMICOLON expression block
Rule 132   if_statement -> IF if_assignment SEMICOLON expression block ELSE block
Rule 133   if_statement -> IF if_assignment SEMICOLON expression block ELSE if_statement
Rule 134   if_assignment -> simple_assignment
Rule 135   if_assignment -> short_assignment
Rule 136   if_assignment -> local_var_dec
Rule 137   map_type -> MAP LBRACKET primitive_type RBRACKET primitive_type
Rule 138   expression -> map_type LBRACE expression_map_list RBRACE
Rule 139   expression -> map_type LBRACE RBRACE
Rule 140   expression_map_list -> key_value
Rule 141   expression_map_list -> expression_map_list COMMA key_value
Rule 142   key_value -> expression COLON expression
Rule 143   field_list -> field_declaration
Rule 144   field_list -> field_list field_declaration
Rule 145   field_declaration -> IDENTIFIER type
Rule 146   method_declaration -> FUNC LPAREN receiver RPAREN IDENTIFIER LPAREN parameter_list RPAREN return_type block
Rule 147   receiver -> IDENTIFIER IDENTIFIER
Rule 148   receiver -> IDENTIFIER TIMES IDENTIFIER
Rule 149   receiver -> IDENTIFIER TIMES type
Rule 150   type_declaration -> TYPE IDENTIFIER type_alias
Rule 151   type_alias -> struct_type
Rule 152   type_alias -> type
Rule 153   type_alias -> IDENTIFIER
Rule 154   struct_type -> STRUCT LBRACE RBRACE
Rule 155   struct_type -> STRUCT LBRACE field_list RBRACE
Rule 156   keyed_element_list -> keyed_element
Rule 157   keyed_element_list -> keyed_element_list COMMA keyed_element
Rule 158   keyed_element -> IDENTIFIER COLON expression
Rule 159   keyed_element -> INT COLON expression
Rule 160   keyed_element -> expression
Rule 161   expression -> type_name LBRACE keyed_element_list RBRACE
Rule 162   expression -> type_name LBRACE RBRACE
Rule 163   type_name -> IDENTIFIER
Rule 164   type_name -> slice_type
Rule 165   type_name -> array_type
Rule 166   type_name -> map_type
Rule 167   switch_statement -> SWITCH switch_expr LBRACE case_clause_list RBRACE
Rule 168   switch_statement -> SWITCH switch_expr LBRACE RBRACE
Rule 169   switch_statement -> SWITCH LBRACE case_clause_list RBRACE
Rule 170   switch_statement -> SWITCH LBRACE RBRACE
Rule 171   switch_statement -> SWITCH switch_assignment SEMICOLON switch_expr LBRACE case_clause_list RBRACE
Rule 172   switch_statement -> SWITCH switch_assignment SEMICOLON switch_expr LBRACE RBRACE
Rule 173   switch_statement -> SWITCH switch_assignment SEMICOLON LBRACE case_clause_list RBRACE
Rule 174   switch_statement -> SWITCH switch_assignment SEMICOLON LBRACE RBRACE
Rule 175   switch_expr -> primary_expression
Rule 176   primary_expression -> IDENTIFIER
Rule 177   primary_expression -> INT
Rule 178   primary_expression -> FLOAT64
Rule 179   primary_expression -> STRING
Rule 180   primary_expression -> TRUE
Rule 181   primary_expression -> FALSE
Rule 182   primary_expression -> LPAREN expression RPAREN
Rule 183   primary_expression -> IDENTIFIER LPAREN argument_list RPAREN
Rule 184   primary_expression -> primary_expression DOT IDENTIFIER
Rule 185   primary_expression -> primary_expression LBRACKET expression RBRACKET
Rule 186   case_clause_list -> case_clause
Rule 187   case_clause_list -> case_clause_list case_clause
Rule 188   switch_assignment -> simple_assignment
Rule 189   switch_assignment -> short_assignment
Rule 190   switch_assignment -> local_var_dec
Rule 191   case_clause -> CASE case_expression_list COLON case_body
Rule 192   case_clause -> DEFAULT COLON case_body
Rule 193   case_expression_list -> expression
Rule 194   case_expression_list -> case_expression_list COMMA expression
Rule 195   case_body -> local_statement_list
Rule 196   case_body -> empty
Rule 197   array_type -> LBRACKET INT RBRACKET primitive_type
Rule 198   expression -> array_type LBRACE expression_list RBRACE
Rule 199   expression -> array_type LBRACE RBRACE
Rule 200   expression -> expression DOT IDENTIFIER
Rule 201   expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN
Rule 202   expression -> expression LBRACKET expression RBRACKET
Rule 203   expression -> IDENTIFIER LPAREN argument_list RPAREN
Rule 204   argument_list -> expression_list
Rule 205   argument_list -> empty

Terminals, with rules where they appear

AND                  : 50
AND_ASSIGN           : 31
AND_NOT              : 53
ASSIGN               : 16 17 18 19 21 22 23 24 56
BOOL_TYPE            : 64
BREAK                : 88
CASE                 : 191
COLON                : 142 158 159 191 192
COMMA                : 69 111 113 122 141 157 194
CONST                : 18 19 23 24
CONTINUE             : 89
DEFAULT              : 192
DIVIDE               : 40
DIV_ASSIGN           : 29
DOT                  : 184 200 201
ELLIPSIS             : 117
ELSE                 : 129 130 132 133
EQ                   : 42
FALSE                : 76 181
FLOAT64              : 72 178
FLOAT64_TYPE         : 62
FOR                  : 97 98 99
FUNC                 : 112 146
GE                   : 47
GT                   : 46
IDENTIFIER           : 2 15 16 17 18 19 20 21 22 23 24 25 56 73 77 112 116 117 126 127 145 146 147 147 148 148 149 150 153 158 163 176 183 184 200 201 203
IF                   : 128 129 130 131 132 133
IMPORT               : 6
INT                  : 71 159 177 197
INT_TYPE             : 61
LAND                 : 48
LBRACE               : 66 67 90 91 138 139 154 155 161 162 167 168 169 170 171 172 173 174 198 199
LBRACKET             : 65 137 185 197 202
LE                   : 45
LNOT                 : 125
LOR                  : 49
LPAREN               : 70 112 119 146 146 182 183 201 203
LSHIFT               : 54
LSHIFT_ASSIGN        : 34
LT                   : 44
MAP                  : 137
MINUS                : 38
MINUSMINUS           : 127
MINUS_ASSIGN         : 27
MODULE               : 41
MOD_ASSIGN           : 30
MULT_ASSIGN          : 28
NEQ                  : 43
OR                   : 51
OR_ASSIGN            : 32
PACKAGE              : 2
PLUS                 : 37
PLUSPLUS             : 126
PLUS_ASSIGN          : 26
RBRACE               : 66 67 90 91 138 139 154 155 161 162 167 168 169 170 171 172 173 174 198 199
RBRACKET             : 65 137 185 197 202
RETURN               : 123 124
RPAREN               : 70 112 119 146 146 182 183 201 203
RSHIFT               : 55
RSHIFT_ASSIGN        : 35
SEMICOLON            : 97 97 131 132 133 171 172 173 174
SHORT_ASSIGN         : 77
STRING               : 6 74 179
STRING_TYPE          : 63
STRUCT               : 154 155
SWITCH               : 167 168 169 170 171 172 173 174
TIMES                : 39 148 149
TRUE                 : 75 180
TYPE                 : 150
VAR                  : 15 16 17 20 21 22
XOR                  : 52
XOR_ASSIGN           : 33
=======
Rule 8     optional_semicolon -> SEMICOLON
Rule 9     optional_semicolon -> empty
Rule 10    global_sequence -> global_statement
Rule 11    global_sequence -> global_sequence global_statement
Rule 12    global_statement -> statement optional_semicolon
Rule 13    global_statement -> function_declaration
Rule 14    global_statement -> method_declaration
Rule 15    global_statement -> type_declaration
Rule 16    block -> LBRACE enter_block exit_block RBRACE
Rule 17    block -> LBRACE enter_block statement_list exit_block RBRACE
Rule 18    statement_list -> statement
Rule 19    statement_list -> statement_list optional_semicolon statement
Rule 20    statement -> assignment
Rule 21    statement -> assignment_compound
Rule 22    statement -> variable_declaration
Rule 23    statement -> expression
Rule 24    statement -> return_statement
Rule 25    statement -> for_statement
Rule 26    statement -> if_statement
Rule 27    statement -> switch_statement
Rule 28    statement -> break_statement
Rule 29    statement -> continue_statement
Rule 30    statement -> fallthrough_statement
Rule 31    break_statement -> BREAK
Rule 32    continue_statement -> CONTINUE
Rule 33    for_statement -> FOR expression block
Rule 34    for_statement -> FOR block
Rule 35    for_statement -> FOR for_clause block
Rule 36    for_clause -> assignment SEMICOLON expression SEMICOLON assignment
Rule 37    for_clause -> SEMICOLON expression SEMICOLON assignment
Rule 38    for_clause -> SEMICOLON expression SEMICOLON
Rule 39    return_statement -> RETURN
Rule 40    return_statement -> RETURN return_list
Rule 41    return_list -> expression
Rule 42    return_list -> return_list COMMA expression
Rule 43    function_declaration -> FUNC IDENTIFIER LPAREN parameter_list RPAREN return_type block
Rule 44    parameter_list -> parameter_list COMMA parameter
Rule 45    parameter_list -> parameter
Rule 46    parameter_list -> empty
Rule 47    parameter -> IDENTIFIER type
Rule 48    parameter -> IDENTIFIER ELLIPSIS primitive_type
Rule 49    return_type -> type
Rule 50    return_type -> LPAREN type_list RPAREN
Rule 51    return_type -> empty
Rule 52    type_list -> type_list COMMA type
Rule 53    type_list -> type
Rule 54    assignment -> IDENTIFIER ASSIGN expression
Rule 55    assignment -> IDENTIFIER SHORT_ASSIGN expression
Rule 56    assignment_compound -> IDENTIFIER PLUS_ASSIGN expression
Rule 57    assignment_compound -> IDENTIFIER MINUS_ASSIGN expression
Rule 58    assignment_compound -> IDENTIFIER MULT_ASSIGN expression
Rule 59    assignment_compound -> IDENTIFIER DIV_ASSIGN expression
Rule 60    assignment_compound -> IDENTIFIER MOD_ASSIGN expression
Rule 61    assignment_compound -> IDENTIFIER AND_ASSIGN expression
Rule 62    assignment_compound -> IDENTIFIER OR_ASSIGN expression
Rule 63    assignment_compound -> IDENTIFIER XOR_ASSIGN expression
Rule 64    assignment_compound -> IDENTIFIER LSHIFT_ASSIGN expression
Rule 65    assignment_compound -> IDENTIFIER RSHIFT_ASSIGN expression
Rule 66    variable_declaration -> VAR IDENTIFIER type ASSIGN expression
Rule 67    variable_declaration -> CONST IDENTIFIER type ASSIGN expression
Rule 68    variable_declaration -> VAR IDENTIFIER ASSIGN expression
Rule 69    variable_declaration -> CONST IDENTIFIER ASSIGN expression
Rule 70    type -> primitive_type
Rule 71    type -> slice_type
Rule 72    type -> array_type
Rule 73    type -> map_type
Rule 74    type -> struct_type
Rule 75    type -> IDENTIFIER
Rule 76    primitive_type -> INT_TYPE
Rule 77    primitive_type -> FLOAT64_TYPE
Rule 78    primitive_type -> STRING_TYPE
Rule 79    primitive_type -> BOOL_TYPE
Rule 80    slice_type -> LBRACKET RBRACKET primitive_type
Rule 81    array_type -> LBRACKET INT RBRACKET type
Rule 82    expression -> binary_expression
Rule 83    expression -> relational_expression
Rule 84    expression -> logical_expression
Rule 85    expression -> bitwise_expression
Rule 86    expression -> PLUS expression
Rule 87    expression -> MINUS expression
Rule 88    expression -> LNOT expression
Rule 89    expression -> LBRACKET RBRACKET primitive_type LBRACE expression_list RBRACE
Rule 90    expression -> LBRACKET RBRACKET primitive_type LBRACE RBRACE
Rule 91    expression -> LPAREN expression RPAREN
Rule 92    expression -> INT
Rule 93    expression -> FLOAT64
Rule 94    expression -> TRUE
Rule 95    expression -> FALSE
Rule 96    expression -> IDENTIFIER
Rule 97    expression -> STRING
Rule 98    expression -> IDENTIFIER PLUSPLUS
Rule 99    expression -> IDENTIFIER MINUSMINUS
Rule 100   expression -> expression DOT IDENTIFIER
Rule 101   expression_list -> expression_list COMMA expression
Rule 102   expression_list -> expression
Rule 103   expression -> IDENTIFIER LPAREN argument_list RPAREN
Rule 104   argument_list -> expression_list
Rule 105   argument_list -> empty
Rule 106   if_statement -> IF expression block
Rule 107   if_statement -> IF expression block ELSE block
Rule 108   if_statement -> IF expression block ELSE if_statement
Rule 109   if_statement -> IF assignment SEMICOLON expression block
Rule 110   if_statement -> IF assignment SEMICOLON expression block ELSE block
Rule 111   if_statement -> IF assignment SEMICOLON expression block ELSE if_statement
Rule 112   type_declaration -> TYPE IDENTIFIER struct_type optional_semicolon
Rule 113   type_declaration -> TYPE IDENTIFIER primitive_type optional_semicolon
Rule 114   type_declaration -> TYPE IDENTIFIER slice_type optional_semicolon
Rule 115   type_declaration -> TYPE IDENTIFIER array_type optional_semicolon
Rule 116   type_declaration -> TYPE IDENTIFIER map_type optional_semicolon
Rule 117   type_declaration -> TYPE IDENTIFIER IDENTIFIER optional_semicolon
Rule 118   struct_type -> STRUCT LBRACE RBRACE
Rule 119   struct_type -> STRUCT LBRACE field_list RBRACE
Rule 120   field_list -> field_declaration
Rule 121   field_list -> field_list field_declaration
Rule 122   field_declaration -> IDENTIFIER type
Rule 123   field_declaration -> IDENTIFIER
Rule 124   method_declaration -> FUNC LPAREN receiver RPAREN IDENTIFIER LPAREN parameter_list RPAREN return_type block
Rule 125   receiver -> IDENTIFIER type
Rule 126   receiver -> IDENTIFIER TIMES IDENTIFIER
Rule 127   map_type -> MAP LBRACKET primitive_type RBRACKET type
Rule 128   keyed_element_list -> keyed_element_list COMMA keyed_element
Rule 129   keyed_element_list -> keyed_element
Rule 130   keyed_element -> IDENTIFIER COLON expression
Rule 131   keyed_element -> INT COLON expression
Rule 132   keyed_element -> expression
Rule 133   expression -> IDENTIFIER LBRACE keyed_element_list RBRACE
Rule 134   expression -> IDENTIFIER LBRACE RBRACE
Rule 135   binary_expression -> expression PLUS expression
Rule 136   binary_expression -> expression MINUS expression
Rule 137   binary_expression -> expression TIMES expression
Rule 138   binary_expression -> expression DIVIDE expression
Rule 139   binary_expression -> expression MODULE expression
Rule 140   grouped_expression -> LPAREN expression RPAREN
Rule 141   unary_expression -> PLUS expression
Rule 142   unary_expression -> MINUS expression
Rule 143   unary_expression -> LNOT expression
Rule 144   relational_expression -> expression EQ expression
Rule 145   relational_expression -> expression NEQ expression
Rule 146   relational_expression -> expression LT expression
Rule 147   relational_expression -> expression LE expression
Rule 148   relational_expression -> expression GT expression
Rule 149   relational_expression -> expression GE expression
Rule 150   logical_expression -> expression LAND expression
Rule 151   logical_expression -> expression LOR expression
Rule 152   bitwise_expression -> expression AND expression
Rule 153   bitwise_expression -> expression OR expression
Rule 154   bitwise_expression -> expression XOR expression
Rule 155   bitwise_expression -> expression AND_NOT expression
Rule 156   bitwise_expression -> expression LSHIFT expression
Rule 157   bitwise_expression -> expression RSHIFT expression
Rule 158   postfix_expression -> IDENTIFIER PLUSPLUS
Rule 159   postfix_expression -> IDENTIFIER MINUSMINUS
Rule 160   selector_expression -> expression DOT IDENTIFIER
Rule 161   func_call_expression -> IDENTIFIER LPAREN argument_list RPAREN
Rule 162   call_expression -> print_expression
Rule 163   call_expression -> input_expression
Rule 164   call_expression -> func_call_expression
Rule 165   slice_expression -> LBRACKET RBRACKET primitive_type LBRACE expression_list RBRACE
Rule 166   slice_expression -> LBRACKET RBRACKET primitive_type LBRACE RBRACE
Rule 167   enter_block -> <empty>
Rule 168   exit_block -> <empty>
Rule 169   case_expression_list -> expression
Rule 170   case_expression_list -> case_expression_list COMMA expression
Rule 171   case_clauses -> case_clause
Rule 172   case_clauses -> case_clauses case_clause
Rule 173   case_clause -> CASE case_expression_list COLON enter_block case_body exit_block
Rule 174   case_clause -> DEFAULT COLON enter_block case_body exit_block
Rule 175   case_body -> statement_list
Rule 176   case_body -> empty
Rule 177   fallthrough_statement -> FALLTHROUGH
Rule 178   switch_primary -> IDENTIFIER
Rule 179   switch_primary -> INT
Rule 180   switch_primary -> FLOAT64
Rule 181   switch_primary -> STRING
Rule 182   switch_primary -> TRUE
Rule 183   switch_primary -> FALSE
Rule 184   switch_init -> assignment SEMICOLON switch_expression
Rule 185   switch_expression -> switch_primary
Rule 186   switch_expression -> empty
Rule 187   switch_header -> switch_expression
Rule 188   switch_header -> switch_init
Rule 189   switch_statement -> SWITCH enter_block switch_header LBRACE case_clauses RBRACE exit_block
Rule 190   print_expression -> IDENTIFIER DOT IDENTIFIER LPAREN argument_list RPAREN
Rule 191   input_expression -> IDENTIFIER DOT IDENTIFIER LPAREN AND IDENTIFIER COMMA argument_list RPAREN

Terminals, with rules where they appear

AND                  : 152 191
AND_ASSIGN           : 61
AND_NOT              : 155
ASSIGN               : 54 66 67 68 69
BOOL_TYPE            : 79
BREAK                : 31
CASE                 : 173
COLON                : 130 131 173 174
COMMA                : 42 44 52 101 128 170 191
CONST                : 67 69
CONTINUE             : 32
DEFAULT              : 174
DIVIDE               : 138
DIV_ASSIGN           : 59
DOT                  : 100 160 190 191
ELLIPSIS             : 48
ELSE                 : 107 108 110 111
EQ                   : 144
FALLTHROUGH          : 177
FALSE                : 95 183
FLOAT64              : 93 180
FLOAT64_TYPE         : 77
FOR                  : 33 34 35
FUNC                 : 43 124
GE                   : 149
GT                   : 148
IDENTIFIER           : 3 43 47 48 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 75 96 98 99 100 103 112 113 114 115 116 117 117 122 123 124 125 126 126 130 133 134 158 159 160 161 178 190 190 191 191 191
IF                   : 106 107 108 109 110 111
IMPORT               : 6
INT                  : 81 92 131 179
INTERFACE            : 
INT_TYPE             : 76
LAND                 : 150
LBRACE               : 16 17 89 90 118 119 133 134 165 166 189
LBRACKET             : 80 81 89 90 127 165 166
LE                   : 147
LNOT                 : 88 143
LOR                  : 151
LPAREN               : 43 50 91 103 124 124 140 161 190 191
LSHIFT               : 156
LSHIFT_ASSIGN        : 64
LT                   : 146
MAP                  : 127
MINUS                : 87 136 142
MINUSMINUS           : 99 159
MINUS_ASSIGN         : 57
MODULE               : 139
MOD_ASSIGN           : 60
MULT_ASSIGN          : 58
NEQ                  : 145
OR                   : 153
OR_ASSIGN            : 62
PACKAGE              : 3
PLUS                 : 86 135 141
PLUSPLUS             : 98 158
PLUS_ASSIGN          : 56
RANGE                : 
RBRACE               : 16 17 89 90 118 119 133 134 165 166 189
RBRACKET             : 80 81 89 90 127 165 166
RETURN               : 39 40
RPAREN               : 43 50 91 103 124 124 140 161 190 191
RSHIFT               : 157
RSHIFT_ASSIGN        : 65
SEMICOLON            : 8 36 36 37 37 38 38 109 110 111 184
SHORT_ASSIGN         : 55
STRING               : 6 97 181
STRING_TYPE          : 78
STRUCT               : 118 119
SWITCH               : 189
TIMES                : 126 137
TRUE                 : 94 182
TYPE                 : 112 113 114 115 116 117
VAR                  : 66 68
XOR                  : 154
XOR_ASSIGN           : 63
>>>>>>> Stashed changes
error                : 

Nonterminals, with rules where they appear

<<<<<<< Updated upstream
argument_list        : 183 201 203
array_type           : 59 165 198 199
assignment_compound  : 82 107
binary_operator      : 36
block                : 97 98 99 112 128 129 129 130 131 132 132 133 146
case_body            : 191 192
case_clause          : 186 187
case_clause_list     : 167 169 171 173 187
case_expression_list : 191 194
empty                : 5 103 105 109 115 120 196 205
expression           : 16 17 18 19 21 22 23 24 25 36 36 56 68 69 70 77 83 98 104 108 110 111 125 128 129 130 131 132 133 142 142 158 159 160 182 185 193 194 200 201 202 202
expression_list      : 66 69 198 204
expression_map_list  : 138 141
field_declaration    : 143 144
field_list           : 144 155
for_classic          : 94
for_cond             : 97
for_condition        : 95
for_infinite         : 96
for_init             : 97
for_post             : 97
for_statement        : 84
function_declaration : 12
global_const_dec     : 11
global_statement     : 8 9
global_statement_list : 1 9
global_var_dec       : 10
if_assignment        : 131 132 133
if_statement         : 85 130 133
import               : 1 4
key_value            : 140 141
keyed_element        : 156 157
keyed_element_list   : 157 161
local_const_dec      : 79
local_statement      : 92 93
local_statement_list : 90 93 195
local_var_dec        : 78 102 136 190
map_type             : 60 138 139 166
method_declaration   : 13
operator_assign      : 25
package_declaration  : 1
parameter            : 113 114
parameter_list       : 112 113 146
primary_expression   : 175 184 185
primitive_type       : 57 65 117 137 137 197
program              : 0
receiver             : 146
return_list          : 111 124
return_statement     : 87
return_type          : 112 146
short_assignment     : 80 101 135 189
simple_assignment    : 81 100 106 134 188
simple_import        : 3 4
slice_type           : 58 66 67 164
struct_type          : 151
switch_assignment    : 171 172 173 174
switch_expr          : 167 168 171 172
switch_statement     : 86
type                 : 15 16 18 20 21 23 116 118 121 122 145 149 152
type_alias           : 150
type_declaration     : 14
type_list            : 119 122
type_name            : 161 162
=======
argument_list        : 103 161 190 191
array_type           : 72 115
assignment           : 20 36 36 37 109 110 111 184
assignment_compound  : 21
binary_expression    : 82
bitwise_expression   : 85
block                : 33 34 35 43 106 107 107 108 109 110 110 111 124
break_statement      : 28
call_expression      : 
case_body            : 173 174
case_clause          : 171 172
case_clauses         : 172 189
case_expression_list : 170 173
continue_statement   : 29
empty                : 5 9 46 51 105 176 186
enter_block          : 16 17 173 174 189
exit_block           : 16 17 173 174 189
expression           : 23 33 36 37 38 41 42 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 86 87 88 91 100 101 102 106 107 108 109 110 111 130 131 132 135 135 136 136 137 137 138 138 139 139 140 141 142 143 144 144 145 145 146 146 147 147 148 148 149 149 150 150 151 151 152 152 153 153 154 154 155 155 156 156 157 157 160 169 170
expression_list      : 89 101 104 165
fallthrough_statement : 30
field_declaration    : 120 121
field_list           : 119 121
for_clause           : 35
for_statement        : 25
func_call_expression : 164
function_declaration : 13
global_sequence      : 2 11
global_statement     : 10 11
grouped_expression   : 
if_statement         : 26 108 111
input_expression     : 163
keyed_element        : 128 129
keyed_element_list   : 128 133
logical_expression   : 84
map_type             : 73 116
method_declaration   : 14
multiple_import      : 1 2 4
optional_semicolon   : 3 6 12 19 112 113 114 115 116 117
package_declaration  : 1 2
parameter            : 44 45
parameter_list       : 43 44 124
postfix_expression   : 
primitive_type       : 48 70 80 89 90 113 127 165 166
print_expression     : 162
program              : 0
receiver             : 124
relational_expression : 83
return_list          : 40 42
return_statement     : 24
return_type          : 43 124
selector_expression  : 
simple_import        : 4
slice_expression     : 
slice_type           : 71 114
statement            : 12 18 19
statement_list       : 17 19 175
struct_type          : 74 112
switch_expression    : 184 187
switch_header        : 189
switch_init          : 188
switch_primary       : 185
switch_statement     : 27
type                 : 47 49 52 53 66 67 81 122 125 127
type_declaration     : 15
type_list            : 50 52
unary_expression     : 
variable_declaration : 22
>>>>>>> Stashed changes

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . package_declaration import global_statement_list
    (2) package_declaration -> . PACKAGE IDENTIFIER

    PACKAGE         shift and go to state 3

    program                        shift and go to state 1
    package_declaration            shift and go to state 2

state 1

    (0) S' -> program .



state 2

    (1) program -> package_declaration . import global_statement_list
    (3) import -> . simple_import
    (4) import -> . import simple_import
    (5) import -> . empty
    (6) simple_import -> . IMPORT STRING
    (7) empty -> .

  ! shift/reduce conflict for IMPORT resolved as shift
    IMPORT          shift and go to state 7
    VAR             reduce using rule 7 (empty -> .)
    CONST           reduce using rule 7 (empty -> .)
<<<<<<< Updated upstream
    FUNC            reduce using rule 7 (empty -> .)
    TYPE            reduce using rule 7 (empty -> .)
=======
    PLUS            reduce using rule 7 (empty -> .)
    MINUS           reduce using rule 7 (empty -> .)
    LNOT            reduce using rule 7 (empty -> .)
    LBRACKET        reduce using rule 7 (empty -> .)
    LPAREN          reduce using rule 7 (empty -> .)
    INT             reduce using rule 7 (empty -> .)
    FLOAT64         reduce using rule 7 (empty -> .)
    TRUE            reduce using rule 7 (empty -> .)
    FALSE           reduce using rule 7 (empty -> .)
    STRING          reduce using rule 7 (empty -> .)
    RETURN          reduce using rule 7 (empty -> .)
    FOR             reduce using rule 7 (empty -> .)
    IF              reduce using rule 7 (empty -> .)
    SWITCH          reduce using rule 7 (empty -> .)
    BREAK           reduce using rule 7 (empty -> .)
    CONTINUE        reduce using rule 7 (empty -> .)
    FALLTHROUGH     reduce using rule 7 (empty -> .)
    $end            reduce using rule 7 (empty -> .)
>>>>>>> Stashed changes

  ! IMPORT          [ reduce using rule 7 (empty -> .) ]

    import                         shift and go to state 4
    simple_import                  shift and go to state 5
    empty                          shift and go to state 6

state 3

    (2) package_declaration -> PACKAGE . IDENTIFIER

    IDENTIFIER      shift and go to state 8


state 4

<<<<<<< Updated upstream
    (1) program -> package_declaration import . global_statement_list
    (4) import -> import . simple_import
    (8) global_statement_list -> . global_statement
    (9) global_statement_list -> . global_statement_list global_statement
    (6) simple_import -> . IMPORT STRING
    (10) global_statement -> . global_var_dec
    (11) global_statement -> . global_const_dec
    (12) global_statement -> . function_declaration
    (13) global_statement -> . method_declaration
    (14) global_statement -> . type_declaration
    (15) global_var_dec -> . VAR IDENTIFIER type
    (16) global_var_dec -> . VAR IDENTIFIER type ASSIGN expression
    (17) global_var_dec -> . VAR IDENTIFIER ASSIGN expression
    (18) global_const_dec -> . CONST IDENTIFIER type ASSIGN expression
    (19) global_const_dec -> . CONST IDENTIFIER ASSIGN expression
    (112) function_declaration -> . FUNC IDENTIFIER LPAREN parameter_list RPAREN return_type block
    (146) method_declaration -> . FUNC LPAREN receiver RPAREN IDENTIFIER LPAREN parameter_list RPAREN return_type block
    (150) type_declaration -> . TYPE IDENTIFIER type_alias

    IMPORT          shift and go to state 7
    VAR             shift and go to state 17
    CONST           shift and go to state 18
    FUNC            shift and go to state 19
    TYPE            shift and go to state 20

    global_statement_list          shift and go to state 9
    simple_import                  shift and go to state 10
    global_statement               shift and go to state 11
    global_var_dec                 shift and go to state 12
    global_const_dec               shift and go to state 13
    function_declaration           shift and go to state 14
    method_declaration             shift and go to state 15
    type_declaration               shift and go to state 16
=======
    (1) program -> package_declaration multiple_import .
    (2) program -> package_declaration multiple_import . global_sequence
    (4) multiple_import -> multiple_import . simple_import
    (10) global_sequence -> . global_statement
    (11) global_sequence -> . global_sequence global_statement
    (6) simple_import -> . IMPORT STRING optional_semicolon
    (12) global_statement -> . statement optional_semicolon
    (13) global_statement -> . function_declaration
    (14) global_statement -> . method_declaration
    (15) global_statement -> . type_declaration
    (20) statement -> . assignment
    (21) statement -> . assignment_compound
    (22) statement -> . variable_declaration
    (23) statement -> . expression
    (24) statement -> . return_statement
    (25) statement -> . for_statement
    (26) statement -> . if_statement
    (27) statement -> . switch_statement
    (28) statement -> . break_statement
    (29) statement -> . continue_statement
    (30) statement -> . fallthrough_statement
    (43) function_declaration -> . FUNC IDENTIFIER LPAREN parameter_list RPAREN return_type block
    (124) method_declaration -> . FUNC LPAREN receiver RPAREN IDENTIFIER LPAREN parameter_list RPAREN return_type block
    (112) type_declaration -> . TYPE IDENTIFIER struct_type optional_semicolon
    (113) type_declaration -> . TYPE IDENTIFIER primitive_type optional_semicolon
    (114) type_declaration -> . TYPE IDENTIFIER slice_type optional_semicolon
    (115) type_declaration -> . TYPE IDENTIFIER array_type optional_semicolon
    (116) type_declaration -> . TYPE IDENTIFIER map_type optional_semicolon
    (117) type_declaration -> . TYPE IDENTIFIER IDENTIFIER optional_semicolon
    (54) assignment -> . IDENTIFIER ASSIGN expression
    (55) assignment -> . IDENTIFIER SHORT_ASSIGN expression
    (56) assignment_compound -> . IDENTIFIER PLUS_ASSIGN expression
    (57) assignment_compound -> . IDENTIFIER MINUS_ASSIGN expression
    (58) assignment_compound -> . IDENTIFIER MULT_ASSIGN expression
    (59) assignment_compound -> . IDENTIFIER DIV_ASSIGN expression
    (60) assignment_compound -> . IDENTIFIER MOD_ASSIGN expression
    (61) assignment_compound -> . IDENTIFIER AND_ASSIGN expression
    (62) assignment_compound -> . IDENTIFIER OR_ASSIGN expression
    (63) assignment_compound -> . IDENTIFIER XOR_ASSIGN expression
    (64) assignment_compound -> . IDENTIFIER LSHIFT_ASSIGN expression
    (65) assignment_compound -> . IDENTIFIER RSHIFT_ASSIGN expression
    (66) variable_declaration -> . VAR IDENTIFIER type ASSIGN expression
    (67) variable_declaration -> . CONST IDENTIFIER type ASSIGN expression
    (68) variable_declaration -> . VAR IDENTIFIER ASSIGN expression
    (69) variable_declaration -> . CONST IDENTIFIER ASSIGN expression
    (82) expression -> . binary_expression
    (83) expression -> . relational_expression
    (84) expression -> . logical_expression
    (85) expression -> . bitwise_expression
    (86) expression -> . PLUS expression
    (87) expression -> . MINUS expression
    (88) expression -> . LNOT expression
    (89) expression -> . LBRACKET RBRACKET primitive_type LBRACE expression_list RBRACE
    (90) expression -> . LBRACKET RBRACKET primitive_type LBRACE RBRACE
    (91) expression -> . LPAREN expression RPAREN
    (92) expression -> . INT
    (93) expression -> . FLOAT64
    (94) expression -> . TRUE
    (95) expression -> . FALSE
    (96) expression -> . IDENTIFIER
    (97) expression -> . STRING
    (98) expression -> . IDENTIFIER PLUSPLUS
    (99) expression -> . IDENTIFIER MINUSMINUS
    (100) expression -> . expression DOT IDENTIFIER
    (103) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (133) expression -> . IDENTIFIER LBRACE keyed_element_list RBRACE
    (134) expression -> . IDENTIFIER LBRACE RBRACE
    (39) return_statement -> . RETURN
    (40) return_statement -> . RETURN return_list
    (33) for_statement -> . FOR expression block
    (34) for_statement -> . FOR block
    (35) for_statement -> . FOR for_clause block
    (106) if_statement -> . IF expression block
    (107) if_statement -> . IF expression block ELSE block
    (108) if_statement -> . IF expression block ELSE if_statement
    (109) if_statement -> . IF assignment SEMICOLON expression block
    (110) if_statement -> . IF assignment SEMICOLON expression block ELSE block
    (111) if_statement -> . IF assignment SEMICOLON expression block ELSE if_statement
    (189) switch_statement -> . SWITCH enter_block switch_header LBRACE case_clauses RBRACE exit_block
    (31) break_statement -> . BREAK
    (32) continue_statement -> . CONTINUE
    (177) fallthrough_statement -> . FALLTHROUGH
    (135) binary_expression -> . expression PLUS expression
    (136) binary_expression -> . expression MINUS expression
    (137) binary_expression -> . expression TIMES expression
    (138) binary_expression -> . expression DIVIDE expression
    (139) binary_expression -> . expression MODULE expression
    (144) relational_expression -> . expression EQ expression
    (145) relational_expression -> . expression NEQ expression
    (146) relational_expression -> . expression LT expression
    (147) relational_expression -> . expression LE expression
    (148) relational_expression -> . expression GT expression
    (149) relational_expression -> . expression GE expression
    (150) logical_expression -> . expression LAND expression
    (151) logical_expression -> . expression LOR expression
    (152) bitwise_expression -> . expression AND expression
    (153) bitwise_expression -> . expression OR expression
    (154) bitwise_expression -> . expression XOR expression
    (155) bitwise_expression -> . expression AND_NOT expression
    (156) bitwise_expression -> . expression LSHIFT expression
    (157) bitwise_expression -> . expression RSHIFT expression

    $end            reduce using rule 1 (program -> package_declaration multiple_import .)
    IMPORT          shift and go to state 10
    FUNC            shift and go to state 27
    TYPE            shift and go to state 30
    IDENTIFIER      shift and go to state 28
    VAR             shift and go to state 31
    CONST           shift and go to state 32
    PLUS            shift and go to state 37
    MINUS           shift and go to state 38
    LNOT            shift and go to state 39
    LBRACKET        shift and go to state 40
    LPAREN          shift and go to state 29
    INT             shift and go to state 41
    FLOAT64         shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44
    STRING          shift and go to state 11
    RETURN          shift and go to state 45
    FOR             shift and go to state 46
    IF              shift and go to state 47
    SWITCH          shift and go to state 48
    BREAK           shift and go to state 49
    CONTINUE        shift and go to state 50
    FALLTHROUGH     shift and go to state 51

    global_sequence                shift and go to state 7
    simple_import                  shift and go to state 8
    global_statement               shift and go to state 9
    statement                      shift and go to state 12
    function_declaration           shift and go to state 13
    method_declaration             shift and go to state 14
    type_declaration               shift and go to state 15
    assignment                     shift and go to state 16
    assignment_compound            shift and go to state 17
    variable_declaration           shift and go to state 18
    expression                     shift and go to state 19
    return_statement               shift and go to state 20
    for_statement                  shift and go to state 21
    if_statement                   shift and go to state 22
    switch_statement               shift and go to state 23
    break_statement                shift and go to state 24
    continue_statement             shift and go to state 25
    fallthrough_statement          shift and go to state 26
    binary_expression              shift and go to state 33
    relational_expression          shift and go to state 34
    logical_expression             shift and go to state 35
    bitwise_expression             shift and go to state 36
>>>>>>> Stashed changes

state 5

    (3) import -> simple_import .

<<<<<<< Updated upstream
    IMPORT          reduce using rule 3 (import -> simple_import .)
    VAR             reduce using rule 3 (import -> simple_import .)
    CONST           reduce using rule 3 (import -> simple_import .)
    FUNC            reduce using rule 3 (import -> simple_import .)
    TYPE            reduce using rule 3 (import -> simple_import .)
=======
    IMPORT          reduce using rule 5 (multiple_import -> empty .)
    FUNC            reduce using rule 5 (multiple_import -> empty .)
    TYPE            reduce using rule 5 (multiple_import -> empty .)
    IDENTIFIER      reduce using rule 5 (multiple_import -> empty .)
    VAR             reduce using rule 5 (multiple_import -> empty .)
    CONST           reduce using rule 5 (multiple_import -> empty .)
    PLUS            reduce using rule 5 (multiple_import -> empty .)
    MINUS           reduce using rule 5 (multiple_import -> empty .)
    LNOT            reduce using rule 5 (multiple_import -> empty .)
    LBRACKET        reduce using rule 5 (multiple_import -> empty .)
    LPAREN          reduce using rule 5 (multiple_import -> empty .)
    INT             reduce using rule 5 (multiple_import -> empty .)
    FLOAT64         reduce using rule 5 (multiple_import -> empty .)
    TRUE            reduce using rule 5 (multiple_import -> empty .)
    FALSE           reduce using rule 5 (multiple_import -> empty .)
    STRING          reduce using rule 5 (multiple_import -> empty .)
    RETURN          reduce using rule 5 (multiple_import -> empty .)
    FOR             reduce using rule 5 (multiple_import -> empty .)
    IF              reduce using rule 5 (multiple_import -> empty .)
    SWITCH          reduce using rule 5 (multiple_import -> empty .)
    BREAK           reduce using rule 5 (multiple_import -> empty .)
    CONTINUE        reduce using rule 5 (multiple_import -> empty .)
    FALLTHROUGH     reduce using rule 5 (multiple_import -> empty .)
    $end            reduce using rule 5 (multiple_import -> empty .)
>>>>>>> Stashed changes


state 6

    (5) import -> empty .

<<<<<<< Updated upstream
    IMPORT          reduce using rule 5 (import -> empty .)
    VAR             reduce using rule 5 (import -> empty .)
    CONST           reduce using rule 5 (import -> empty .)
    FUNC            reduce using rule 5 (import -> empty .)
    TYPE            reduce using rule 5 (import -> empty .)


state 7

    (6) simple_import -> IMPORT . STRING

    STRING          shift and go to state 21

=======
    SEMICOLON       shift and go to state 53
    IMPORT          reduce using rule 7 (empty -> .)
    FUNC            reduce using rule 7 (empty -> .)
    TYPE            reduce using rule 7 (empty -> .)
    IDENTIFIER      reduce using rule 7 (empty -> .)
    VAR             reduce using rule 7 (empty -> .)
    CONST           reduce using rule 7 (empty -> .)
    PLUS            reduce using rule 7 (empty -> .)
    MINUS           reduce using rule 7 (empty -> .)
    LNOT            reduce using rule 7 (empty -> .)
    LBRACKET        reduce using rule 7 (empty -> .)
    LPAREN          reduce using rule 7 (empty -> .)
    INT             reduce using rule 7 (empty -> .)
    FLOAT64         reduce using rule 7 (empty -> .)
    TRUE            reduce using rule 7 (empty -> .)
    FALSE           reduce using rule 7 (empty -> .)
    STRING          reduce using rule 7 (empty -> .)
    RETURN          reduce using rule 7 (empty -> .)
    FOR             reduce using rule 7 (empty -> .)
    IF              reduce using rule 7 (empty -> .)
    SWITCH          reduce using rule 7 (empty -> .)
    BREAK           reduce using rule 7 (empty -> .)
    CONTINUE        reduce using rule 7 (empty -> .)
    FALLTHROUGH     reduce using rule 7 (empty -> .)
    $end            reduce using rule 7 (empty -> .)

    optional_semicolon             shift and go to state 52
    empty                          shift and go to state 54

state 7

    (2) program -> package_declaration multiple_import global_sequence .
    (11) global_sequence -> global_sequence . global_statement
    (12) global_statement -> . statement optional_semicolon
    (13) global_statement -> . function_declaration
    (14) global_statement -> . method_declaration
    (15) global_statement -> . type_declaration
    (20) statement -> . assignment
    (21) statement -> . assignment_compound
    (22) statement -> . variable_declaration
    (23) statement -> . expression
    (24) statement -> . return_statement
    (25) statement -> . for_statement
    (26) statement -> . if_statement
    (27) statement -> . switch_statement
    (28) statement -> . break_statement
    (29) statement -> . continue_statement
    (30) statement -> . fallthrough_statement
    (43) function_declaration -> . FUNC IDENTIFIER LPAREN parameter_list RPAREN return_type block
    (124) method_declaration -> . FUNC LPAREN receiver RPAREN IDENTIFIER LPAREN parameter_list RPAREN return_type block
    (112) type_declaration -> . TYPE IDENTIFIER struct_type optional_semicolon
    (113) type_declaration -> . TYPE IDENTIFIER primitive_type optional_semicolon
    (114) type_declaration -> . TYPE IDENTIFIER slice_type optional_semicolon
    (115) type_declaration -> . TYPE IDENTIFIER array_type optional_semicolon
    (116) type_declaration -> . TYPE IDENTIFIER map_type optional_semicolon
    (117) type_declaration -> . TYPE IDENTIFIER IDENTIFIER optional_semicolon
    (54) assignment -> . IDENTIFIER ASSIGN expression
    (55) assignment -> . IDENTIFIER SHORT_ASSIGN expression
    (56) assignment_compound -> . IDENTIFIER PLUS_ASSIGN expression
    (57) assignment_compound -> . IDENTIFIER MINUS_ASSIGN expression
    (58) assignment_compound -> . IDENTIFIER MULT_ASSIGN expression
    (59) assignment_compound -> . IDENTIFIER DIV_ASSIGN expression
    (60) assignment_compound -> . IDENTIFIER MOD_ASSIGN expression
    (61) assignment_compound -> . IDENTIFIER AND_ASSIGN expression
    (62) assignment_compound -> . IDENTIFIER OR_ASSIGN expression
    (63) assignment_compound -> . IDENTIFIER XOR_ASSIGN expression
    (64) assignment_compound -> . IDENTIFIER LSHIFT_ASSIGN expression
    (65) assignment_compound -> . IDENTIFIER RSHIFT_ASSIGN expression
    (66) variable_declaration -> . VAR IDENTIFIER type ASSIGN expression
    (67) variable_declaration -> . CONST IDENTIFIER type ASSIGN expression
    (68) variable_declaration -> . VAR IDENTIFIER ASSIGN expression
    (69) variable_declaration -> . CONST IDENTIFIER ASSIGN expression
    (82) expression -> . binary_expression
    (83) expression -> . relational_expression
    (84) expression -> . logical_expression
    (85) expression -> . bitwise_expression
    (86) expression -> . PLUS expression
    (87) expression -> . MINUS expression
    (88) expression -> . LNOT expression
    (89) expression -> . LBRACKET RBRACKET primitive_type LBRACE expression_list RBRACE
    (90) expression -> . LBRACKET RBRACKET primitive_type LBRACE RBRACE
    (91) expression -> . LPAREN expression RPAREN
    (92) expression -> . INT
    (93) expression -> . FLOAT64
    (94) expression -> . TRUE
    (95) expression -> . FALSE
    (96) expression -> . IDENTIFIER
    (97) expression -> . STRING
    (98) expression -> . IDENTIFIER PLUSPLUS
    (99) expression -> . IDENTIFIER MINUSMINUS
    (100) expression -> . expression DOT IDENTIFIER
    (103) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (133) expression -> . IDENTIFIER LBRACE keyed_element_list RBRACE
    (134) expression -> . IDENTIFIER LBRACE RBRACE
    (39) return_statement -> . RETURN
    (40) return_statement -> . RETURN return_list
    (33) for_statement -> . FOR expression block
    (34) for_statement -> . FOR block
    (35) for_statement -> . FOR for_clause block
    (106) if_statement -> . IF expression block
    (107) if_statement -> . IF expression block ELSE block
    (108) if_statement -> . IF expression block ELSE if_statement
    (109) if_statement -> . IF assignment SEMICOLON expression block
    (110) if_statement -> . IF assignment SEMICOLON expression block ELSE block
    (111) if_statement -> . IF assignment SEMICOLON expression block ELSE if_statement
    (189) switch_statement -> . SWITCH enter_block switch_header LBRACE case_clauses RBRACE exit_block
    (31) break_statement -> . BREAK
    (32) continue_statement -> . CONTINUE
    (177) fallthrough_statement -> . FALLTHROUGH
    (135) binary_expression -> . expression PLUS expression
    (136) binary_expression -> . expression MINUS expression
    (137) binary_expression -> . expression TIMES expression
    (138) binary_expression -> . expression DIVIDE expression
    (139) binary_expression -> . expression MODULE expression
    (144) relational_expression -> . expression EQ expression
    (145) relational_expression -> . expression NEQ expression
    (146) relational_expression -> . expression LT expression
    (147) relational_expression -> . expression LE expression
    (148) relational_expression -> . expression GT expression
    (149) relational_expression -> . expression GE expression
    (150) logical_expression -> . expression LAND expression
    (151) logical_expression -> . expression LOR expression
    (152) bitwise_expression -> . expression AND expression
    (153) bitwise_expression -> . expression OR expression
    (154) bitwise_expression -> . expression XOR expression
    (155) bitwise_expression -> . expression AND_NOT expression
    (156) bitwise_expression -> . expression LSHIFT expression
    (157) bitwise_expression -> . expression RSHIFT expression

    $end            reduce using rule 2 (program -> package_declaration multiple_import global_sequence .)
    FUNC            shift and go to state 27
    TYPE            shift and go to state 30
    IDENTIFIER      shift and go to state 28
    VAR             shift and go to state 31
    CONST           shift and go to state 32
    PLUS            shift and go to state 37
    MINUS           shift and go to state 38
    LNOT            shift and go to state 39
    LBRACKET        shift and go to state 40
    LPAREN          shift and go to state 29
    INT             shift and go to state 41
    FLOAT64         shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44
    STRING          shift and go to state 11
    RETURN          shift and go to state 45
    FOR             shift and go to state 46
    IF              shift and go to state 47
    SWITCH          shift and go to state 48
    BREAK           shift and go to state 49
    CONTINUE        shift and go to state 50
    FALLTHROUGH     shift and go to state 51

    global_statement               shift and go to state 55
    statement                      shift and go to state 12
    function_declaration           shift and go to state 13
    method_declaration             shift and go to state 14
    type_declaration               shift and go to state 15
    assignment                     shift and go to state 16
    assignment_compound            shift and go to state 17
    variable_declaration           shift and go to state 18
    expression                     shift and go to state 19
    return_statement               shift and go to state 20
    for_statement                  shift and go to state 21
    if_statement                   shift and go to state 22
    switch_statement               shift and go to state 23
    break_statement                shift and go to state 24
    continue_statement             shift and go to state 25
    fallthrough_statement          shift and go to state 26
    binary_expression              shift and go to state 33
    relational_expression          shift and go to state 34
    logical_expression             shift and go to state 35
    bitwise_expression             shift and go to state 36
>>>>>>> Stashed changes

state 8

    (2) package_declaration -> PACKAGE IDENTIFIER .

<<<<<<< Updated upstream
    IMPORT          reduce using rule 2 (package_declaration -> PACKAGE IDENTIFIER .)
    VAR             reduce using rule 2 (package_declaration -> PACKAGE IDENTIFIER .)
    CONST           reduce using rule 2 (package_declaration -> PACKAGE IDENTIFIER .)
    FUNC            reduce using rule 2 (package_declaration -> PACKAGE IDENTIFIER .)
    TYPE            reduce using rule 2 (package_declaration -> PACKAGE IDENTIFIER .)
=======
    IMPORT          reduce using rule 4 (multiple_import -> multiple_import simple_import .)
    FUNC            reduce using rule 4 (multiple_import -> multiple_import simple_import .)
    TYPE            reduce using rule 4 (multiple_import -> multiple_import simple_import .)
    IDENTIFIER      reduce using rule 4 (multiple_import -> multiple_import simple_import .)
    VAR             reduce using rule 4 (multiple_import -> multiple_import simple_import .)
    CONST           reduce using rule 4 (multiple_import -> multiple_import simple_import .)
    PLUS            reduce using rule 4 (multiple_import -> multiple_import simple_import .)
    MINUS           reduce using rule 4 (multiple_import -> multiple_import simple_import .)
    LNOT            reduce using rule 4 (multiple_import -> multiple_import simple_import .)
    LBRACKET        reduce using rule 4 (multiple_import -> multiple_import simple_import .)
    LPAREN          reduce using rule 4 (multiple_import -> multiple_import simple_import .)
    INT             reduce using rule 4 (multiple_import -> multiple_import simple_import .)
    FLOAT64         reduce using rule 4 (multiple_import -> multiple_import simple_import .)
    TRUE            reduce using rule 4 (multiple_import -> multiple_import simple_import .)
    FALSE           reduce using rule 4 (multiple_import -> multiple_import simple_import .)
    STRING          reduce using rule 4 (multiple_import -> multiple_import simple_import .)
    RETURN          reduce using rule 4 (multiple_import -> multiple_import simple_import .)
    FOR             reduce using rule 4 (multiple_import -> multiple_import simple_import .)
    IF              reduce using rule 4 (multiple_import -> multiple_import simple_import .)
    SWITCH          reduce using rule 4 (multiple_import -> multiple_import simple_import .)
    BREAK           reduce using rule 4 (multiple_import -> multiple_import simple_import .)
    CONTINUE        reduce using rule 4 (multiple_import -> multiple_import simple_import .)
    FALLTHROUGH     reduce using rule 4 (multiple_import -> multiple_import simple_import .)
    $end            reduce using rule 4 (multiple_import -> multiple_import simple_import .)
>>>>>>> Stashed changes


state 9

    (1) program -> package_declaration import global_statement_list .
    (9) global_statement_list -> global_statement_list . global_statement
    (10) global_statement -> . global_var_dec
    (11) global_statement -> . global_const_dec
    (12) global_statement -> . function_declaration
    (13) global_statement -> . method_declaration
    (14) global_statement -> . type_declaration
    (15) global_var_dec -> . VAR IDENTIFIER type
    (16) global_var_dec -> . VAR IDENTIFIER type ASSIGN expression
    (17) global_var_dec -> . VAR IDENTIFIER ASSIGN expression
    (18) global_const_dec -> . CONST IDENTIFIER type ASSIGN expression
    (19) global_const_dec -> . CONST IDENTIFIER ASSIGN expression
    (112) function_declaration -> . FUNC IDENTIFIER LPAREN parameter_list RPAREN return_type block
    (146) method_declaration -> . FUNC LPAREN receiver RPAREN IDENTIFIER LPAREN parameter_list RPAREN return_type block
    (150) type_declaration -> . TYPE IDENTIFIER type_alias

<<<<<<< Updated upstream
    $end            reduce using rule 1 (program -> package_declaration import global_statement_list .)
    VAR             shift and go to state 17
    CONST           shift and go to state 18
    FUNC            shift and go to state 19
    TYPE            shift and go to state 20
=======
    FUNC            reduce using rule 10 (global_sequence -> global_statement .)
    TYPE            reduce using rule 10 (global_sequence -> global_statement .)
    IDENTIFIER      reduce using rule 10 (global_sequence -> global_statement .)
    VAR             reduce using rule 10 (global_sequence -> global_statement .)
    CONST           reduce using rule 10 (global_sequence -> global_statement .)
    PLUS            reduce using rule 10 (global_sequence -> global_statement .)
    MINUS           reduce using rule 10 (global_sequence -> global_statement .)
    LNOT            reduce using rule 10 (global_sequence -> global_statement .)
    LBRACKET        reduce using rule 10 (global_sequence -> global_statement .)
    LPAREN          reduce using rule 10 (global_sequence -> global_statement .)
    INT             reduce using rule 10 (global_sequence -> global_statement .)
    FLOAT64         reduce using rule 10 (global_sequence -> global_statement .)
    TRUE            reduce using rule 10 (global_sequence -> global_statement .)
    FALSE           reduce using rule 10 (global_sequence -> global_statement .)
    STRING          reduce using rule 10 (global_sequence -> global_statement .)
    RETURN          reduce using rule 10 (global_sequence -> global_statement .)
    FOR             reduce using rule 10 (global_sequence -> global_statement .)
    IF              reduce using rule 10 (global_sequence -> global_statement .)
    SWITCH          reduce using rule 10 (global_sequence -> global_statement .)
    BREAK           reduce using rule 10 (global_sequence -> global_statement .)
    CONTINUE        reduce using rule 10 (global_sequence -> global_statement .)
    FALLTHROUGH     reduce using rule 10 (global_sequence -> global_statement .)
    $end            reduce using rule 10 (global_sequence -> global_statement .)
>>>>>>> Stashed changes

    global_statement               shift and go to state 22
    global_var_dec                 shift and go to state 12
    global_const_dec               shift and go to state 13
    function_declaration           shift and go to state 14
    method_declaration             shift and go to state 15
    type_declaration               shift and go to state 16

state 10

    (4) import -> import simple_import .

<<<<<<< Updated upstream
    IMPORT          reduce using rule 4 (import -> import simple_import .)
    VAR             reduce using rule 4 (import -> import simple_import .)
    CONST           reduce using rule 4 (import -> import simple_import .)
    FUNC            reduce using rule 4 (import -> import simple_import .)
    TYPE            reduce using rule 4 (import -> import simple_import .)
=======
    STRING          shift and go to state 56
>>>>>>> Stashed changes


state 11

<<<<<<< Updated upstream
    (8) global_statement_list -> global_statement .

    VAR             reduce using rule 8 (global_statement_list -> global_statement .)
    CONST           reduce using rule 8 (global_statement_list -> global_statement .)
    FUNC            reduce using rule 8 (global_statement_list -> global_statement .)
    TYPE            reduce using rule 8 (global_statement_list -> global_statement .)
    $end            reduce using rule 8 (global_statement_list -> global_statement .)
=======
    (97) expression -> STRING .

    DOT             reduce using rule 97 (expression -> STRING .)
    PLUS            reduce using rule 97 (expression -> STRING .)
    MINUS           reduce using rule 97 (expression -> STRING .)
    TIMES           reduce using rule 97 (expression -> STRING .)
    DIVIDE          reduce using rule 97 (expression -> STRING .)
    MODULE          reduce using rule 97 (expression -> STRING .)
    EQ              reduce using rule 97 (expression -> STRING .)
    NEQ             reduce using rule 97 (expression -> STRING .)
    LT              reduce using rule 97 (expression -> STRING .)
    LE              reduce using rule 97 (expression -> STRING .)
    GT              reduce using rule 97 (expression -> STRING .)
    GE              reduce using rule 97 (expression -> STRING .)
    LAND            reduce using rule 97 (expression -> STRING .)
    LOR             reduce using rule 97 (expression -> STRING .)
    AND             reduce using rule 97 (expression -> STRING .)
    OR              reduce using rule 97 (expression -> STRING .)
    XOR             reduce using rule 97 (expression -> STRING .)
    AND_NOT         reduce using rule 97 (expression -> STRING .)
    LSHIFT          reduce using rule 97 (expression -> STRING .)
    RSHIFT          reduce using rule 97 (expression -> STRING .)
    SEMICOLON       reduce using rule 97 (expression -> STRING .)
    FUNC            reduce using rule 97 (expression -> STRING .)
    TYPE            reduce using rule 97 (expression -> STRING .)
    IDENTIFIER      reduce using rule 97 (expression -> STRING .)
    VAR             reduce using rule 97 (expression -> STRING .)
    CONST           reduce using rule 97 (expression -> STRING .)
    LNOT            reduce using rule 97 (expression -> STRING .)
    LBRACKET        reduce using rule 97 (expression -> STRING .)
    LPAREN          reduce using rule 97 (expression -> STRING .)
    INT             reduce using rule 97 (expression -> STRING .)
    FLOAT64         reduce using rule 97 (expression -> STRING .)
    TRUE            reduce using rule 97 (expression -> STRING .)
    FALSE           reduce using rule 97 (expression -> STRING .)
    STRING          reduce using rule 97 (expression -> STRING .)
    RETURN          reduce using rule 97 (expression -> STRING .)
    FOR             reduce using rule 97 (expression -> STRING .)
    IF              reduce using rule 97 (expression -> STRING .)
    SWITCH          reduce using rule 97 (expression -> STRING .)
    BREAK           reduce using rule 97 (expression -> STRING .)
    CONTINUE        reduce using rule 97 (expression -> STRING .)
    FALLTHROUGH     reduce using rule 97 (expression -> STRING .)
    $end            reduce using rule 97 (expression -> STRING .)
    RPAREN          reduce using rule 97 (expression -> STRING .)
    COMMA           reduce using rule 97 (expression -> STRING .)
    RBRACE          reduce using rule 97 (expression -> STRING .)
    CASE            reduce using rule 97 (expression -> STRING .)
    DEFAULT         reduce using rule 97 (expression -> STRING .)
    LBRACE          reduce using rule 97 (expression -> STRING .)
    COLON           reduce using rule 97 (expression -> STRING .)
>>>>>>> Stashed changes


state 12

    (10) global_statement -> global_var_dec .

<<<<<<< Updated upstream
    VAR             reduce using rule 10 (global_statement -> global_var_dec .)
    CONST           reduce using rule 10 (global_statement -> global_var_dec .)
    FUNC            reduce using rule 10 (global_statement -> global_var_dec .)
    TYPE            reduce using rule 10 (global_statement -> global_var_dec .)
    $end            reduce using rule 10 (global_statement -> global_var_dec .)

=======
    SEMICOLON       shift and go to state 53
    FUNC            reduce using rule 7 (empty -> .)
    TYPE            reduce using rule 7 (empty -> .)
    IDENTIFIER      reduce using rule 7 (empty -> .)
    VAR             reduce using rule 7 (empty -> .)
    CONST           reduce using rule 7 (empty -> .)
    PLUS            reduce using rule 7 (empty -> .)
    MINUS           reduce using rule 7 (empty -> .)
    LNOT            reduce using rule 7 (empty -> .)
    LBRACKET        reduce using rule 7 (empty -> .)
    LPAREN          reduce using rule 7 (empty -> .)
    INT             reduce using rule 7 (empty -> .)
    FLOAT64         reduce using rule 7 (empty -> .)
    TRUE            reduce using rule 7 (empty -> .)
    FALSE           reduce using rule 7 (empty -> .)
    STRING          reduce using rule 7 (empty -> .)
    RETURN          reduce using rule 7 (empty -> .)
    FOR             reduce using rule 7 (empty -> .)
    IF              reduce using rule 7 (empty -> .)
    SWITCH          reduce using rule 7 (empty -> .)
    BREAK           reduce using rule 7 (empty -> .)
    CONTINUE        reduce using rule 7 (empty -> .)
    FALLTHROUGH     reduce using rule 7 (empty -> .)
    $end            reduce using rule 7 (empty -> .)

    optional_semicolon             shift and go to state 57
    empty                          shift and go to state 54
>>>>>>> Stashed changes

state 13

    (11) global_statement -> global_const_dec .

<<<<<<< Updated upstream
    VAR             reduce using rule 11 (global_statement -> global_const_dec .)
    CONST           reduce using rule 11 (global_statement -> global_const_dec .)
    FUNC            reduce using rule 11 (global_statement -> global_const_dec .)
    TYPE            reduce using rule 11 (global_statement -> global_const_dec .)
    $end            reduce using rule 11 (global_statement -> global_const_dec .)
=======
    FUNC            reduce using rule 13 (global_statement -> function_declaration .)
    TYPE            reduce using rule 13 (global_statement -> function_declaration .)
    IDENTIFIER      reduce using rule 13 (global_statement -> function_declaration .)
    VAR             reduce using rule 13 (global_statement -> function_declaration .)
    CONST           reduce using rule 13 (global_statement -> function_declaration .)
    PLUS            reduce using rule 13 (global_statement -> function_declaration .)
    MINUS           reduce using rule 13 (global_statement -> function_declaration .)
    LNOT            reduce using rule 13 (global_statement -> function_declaration .)
    LBRACKET        reduce using rule 13 (global_statement -> function_declaration .)
    LPAREN          reduce using rule 13 (global_statement -> function_declaration .)
    INT             reduce using rule 13 (global_statement -> function_declaration .)
    FLOAT64         reduce using rule 13 (global_statement -> function_declaration .)
    TRUE            reduce using rule 13 (global_statement -> function_declaration .)
    FALSE           reduce using rule 13 (global_statement -> function_declaration .)
    STRING          reduce using rule 13 (global_statement -> function_declaration .)
    RETURN          reduce using rule 13 (global_statement -> function_declaration .)
    FOR             reduce using rule 13 (global_statement -> function_declaration .)
    IF              reduce using rule 13 (global_statement -> function_declaration .)
    SWITCH          reduce using rule 13 (global_statement -> function_declaration .)
    BREAK           reduce using rule 13 (global_statement -> function_declaration .)
    CONTINUE        reduce using rule 13 (global_statement -> function_declaration .)
    FALLTHROUGH     reduce using rule 13 (global_statement -> function_declaration .)
    $end            reduce using rule 13 (global_statement -> function_declaration .)
>>>>>>> Stashed changes


state 14

    (12) global_statement -> function_declaration .

<<<<<<< Updated upstream
    VAR             reduce using rule 12 (global_statement -> function_declaration .)
    CONST           reduce using rule 12 (global_statement -> function_declaration .)
    FUNC            reduce using rule 12 (global_statement -> function_declaration .)
    TYPE            reduce using rule 12 (global_statement -> function_declaration .)
    $end            reduce using rule 12 (global_statement -> function_declaration .)
=======
    FUNC            reduce using rule 14 (global_statement -> method_declaration .)
    TYPE            reduce using rule 14 (global_statement -> method_declaration .)
    IDENTIFIER      reduce using rule 14 (global_statement -> method_declaration .)
    VAR             reduce using rule 14 (global_statement -> method_declaration .)
    CONST           reduce using rule 14 (global_statement -> method_declaration .)
    PLUS            reduce using rule 14 (global_statement -> method_declaration .)
    MINUS           reduce using rule 14 (global_statement -> method_declaration .)
    LNOT            reduce using rule 14 (global_statement -> method_declaration .)
    LBRACKET        reduce using rule 14 (global_statement -> method_declaration .)
    LPAREN          reduce using rule 14 (global_statement -> method_declaration .)
    INT             reduce using rule 14 (global_statement -> method_declaration .)
    FLOAT64         reduce using rule 14 (global_statement -> method_declaration .)
    TRUE            reduce using rule 14 (global_statement -> method_declaration .)
    FALSE           reduce using rule 14 (global_statement -> method_declaration .)
    STRING          reduce using rule 14 (global_statement -> method_declaration .)
    RETURN          reduce using rule 14 (global_statement -> method_declaration .)
    FOR             reduce using rule 14 (global_statement -> method_declaration .)
    IF              reduce using rule 14 (global_statement -> method_declaration .)
    SWITCH          reduce using rule 14 (global_statement -> method_declaration .)
    BREAK           reduce using rule 14 (global_statement -> method_declaration .)
    CONTINUE        reduce using rule 14 (global_statement -> method_declaration .)
    FALLTHROUGH     reduce using rule 14 (global_statement -> method_declaration .)
    $end            reduce using rule 14 (global_statement -> method_declaration .)
>>>>>>> Stashed changes


state 15

    (13) global_statement -> method_declaration .

<<<<<<< Updated upstream
    VAR             reduce using rule 13 (global_statement -> method_declaration .)
    CONST           reduce using rule 13 (global_statement -> method_declaration .)
    FUNC            reduce using rule 13 (global_statement -> method_declaration .)
    TYPE            reduce using rule 13 (global_statement -> method_declaration .)
    $end            reduce using rule 13 (global_statement -> method_declaration .)
=======
    FUNC            reduce using rule 15 (global_statement -> type_declaration .)
    TYPE            reduce using rule 15 (global_statement -> type_declaration .)
    IDENTIFIER      reduce using rule 15 (global_statement -> type_declaration .)
    VAR             reduce using rule 15 (global_statement -> type_declaration .)
    CONST           reduce using rule 15 (global_statement -> type_declaration .)
    PLUS            reduce using rule 15 (global_statement -> type_declaration .)
    MINUS           reduce using rule 15 (global_statement -> type_declaration .)
    LNOT            reduce using rule 15 (global_statement -> type_declaration .)
    LBRACKET        reduce using rule 15 (global_statement -> type_declaration .)
    LPAREN          reduce using rule 15 (global_statement -> type_declaration .)
    INT             reduce using rule 15 (global_statement -> type_declaration .)
    FLOAT64         reduce using rule 15 (global_statement -> type_declaration .)
    TRUE            reduce using rule 15 (global_statement -> type_declaration .)
    FALSE           reduce using rule 15 (global_statement -> type_declaration .)
    STRING          reduce using rule 15 (global_statement -> type_declaration .)
    RETURN          reduce using rule 15 (global_statement -> type_declaration .)
    FOR             reduce using rule 15 (global_statement -> type_declaration .)
    IF              reduce using rule 15 (global_statement -> type_declaration .)
    SWITCH          reduce using rule 15 (global_statement -> type_declaration .)
    BREAK           reduce using rule 15 (global_statement -> type_declaration .)
    CONTINUE        reduce using rule 15 (global_statement -> type_declaration .)
    FALLTHROUGH     reduce using rule 15 (global_statement -> type_declaration .)
    $end            reduce using rule 15 (global_statement -> type_declaration .)
>>>>>>> Stashed changes


state 16

    (14) global_statement -> type_declaration .

<<<<<<< Updated upstream
    VAR             reduce using rule 14 (global_statement -> type_declaration .)
    CONST           reduce using rule 14 (global_statement -> type_declaration .)
    FUNC            reduce using rule 14 (global_statement -> type_declaration .)
    TYPE            reduce using rule 14 (global_statement -> type_declaration .)
    $end            reduce using rule 14 (global_statement -> type_declaration .)
=======
    SEMICOLON       reduce using rule 20 (statement -> assignment .)
    FUNC            reduce using rule 20 (statement -> assignment .)
    TYPE            reduce using rule 20 (statement -> assignment .)
    IDENTIFIER      reduce using rule 20 (statement -> assignment .)
    VAR             reduce using rule 20 (statement -> assignment .)
    CONST           reduce using rule 20 (statement -> assignment .)
    PLUS            reduce using rule 20 (statement -> assignment .)
    MINUS           reduce using rule 20 (statement -> assignment .)
    LNOT            reduce using rule 20 (statement -> assignment .)
    LBRACKET        reduce using rule 20 (statement -> assignment .)
    LPAREN          reduce using rule 20 (statement -> assignment .)
    INT             reduce using rule 20 (statement -> assignment .)
    FLOAT64         reduce using rule 20 (statement -> assignment .)
    TRUE            reduce using rule 20 (statement -> assignment .)
    FALSE           reduce using rule 20 (statement -> assignment .)
    STRING          reduce using rule 20 (statement -> assignment .)
    RETURN          reduce using rule 20 (statement -> assignment .)
    FOR             reduce using rule 20 (statement -> assignment .)
    IF              reduce using rule 20 (statement -> assignment .)
    SWITCH          reduce using rule 20 (statement -> assignment .)
    BREAK           reduce using rule 20 (statement -> assignment .)
    CONTINUE        reduce using rule 20 (statement -> assignment .)
    FALLTHROUGH     reduce using rule 20 (statement -> assignment .)
    $end            reduce using rule 20 (statement -> assignment .)
    RBRACE          reduce using rule 20 (statement -> assignment .)
    CASE            reduce using rule 20 (statement -> assignment .)
    DEFAULT         reduce using rule 20 (statement -> assignment .)
>>>>>>> Stashed changes


state 17

    (15) global_var_dec -> VAR . IDENTIFIER type
    (16) global_var_dec -> VAR . IDENTIFIER type ASSIGN expression
    (17) global_var_dec -> VAR . IDENTIFIER ASSIGN expression

<<<<<<< Updated upstream
    IDENTIFIER      shift and go to state 23
=======
    SEMICOLON       reduce using rule 21 (statement -> assignment_compound .)
    FUNC            reduce using rule 21 (statement -> assignment_compound .)
    TYPE            reduce using rule 21 (statement -> assignment_compound .)
    IDENTIFIER      reduce using rule 21 (statement -> assignment_compound .)
    VAR             reduce using rule 21 (statement -> assignment_compound .)
    CONST           reduce using rule 21 (statement -> assignment_compound .)
    PLUS            reduce using rule 21 (statement -> assignment_compound .)
    MINUS           reduce using rule 21 (statement -> assignment_compound .)
    LNOT            reduce using rule 21 (statement -> assignment_compound .)
    LBRACKET        reduce using rule 21 (statement -> assignment_compound .)
    LPAREN          reduce using rule 21 (statement -> assignment_compound .)
    INT             reduce using rule 21 (statement -> assignment_compound .)
    FLOAT64         reduce using rule 21 (statement -> assignment_compound .)
    TRUE            reduce using rule 21 (statement -> assignment_compound .)
    FALSE           reduce using rule 21 (statement -> assignment_compound .)
    STRING          reduce using rule 21 (statement -> assignment_compound .)
    RETURN          reduce using rule 21 (statement -> assignment_compound .)
    FOR             reduce using rule 21 (statement -> assignment_compound .)
    IF              reduce using rule 21 (statement -> assignment_compound .)
    SWITCH          reduce using rule 21 (statement -> assignment_compound .)
    BREAK           reduce using rule 21 (statement -> assignment_compound .)
    CONTINUE        reduce using rule 21 (statement -> assignment_compound .)
    FALLTHROUGH     reduce using rule 21 (statement -> assignment_compound .)
    $end            reduce using rule 21 (statement -> assignment_compound .)
    RBRACE          reduce using rule 21 (statement -> assignment_compound .)
    CASE            reduce using rule 21 (statement -> assignment_compound .)
    DEFAULT         reduce using rule 21 (statement -> assignment_compound .)
>>>>>>> Stashed changes


state 18

    (18) global_const_dec -> CONST . IDENTIFIER type ASSIGN expression
    (19) global_const_dec -> CONST . IDENTIFIER ASSIGN expression

<<<<<<< Updated upstream
    IDENTIFIER      shift and go to state 24
=======
    SEMICOLON       reduce using rule 22 (statement -> variable_declaration .)
    FUNC            reduce using rule 22 (statement -> variable_declaration .)
    TYPE            reduce using rule 22 (statement -> variable_declaration .)
    IDENTIFIER      reduce using rule 22 (statement -> variable_declaration .)
    VAR             reduce using rule 22 (statement -> variable_declaration .)
    CONST           reduce using rule 22 (statement -> variable_declaration .)
    PLUS            reduce using rule 22 (statement -> variable_declaration .)
    MINUS           reduce using rule 22 (statement -> variable_declaration .)
    LNOT            reduce using rule 22 (statement -> variable_declaration .)
    LBRACKET        reduce using rule 22 (statement -> variable_declaration .)
    LPAREN          reduce using rule 22 (statement -> variable_declaration .)
    INT             reduce using rule 22 (statement -> variable_declaration .)
    FLOAT64         reduce using rule 22 (statement -> variable_declaration .)
    TRUE            reduce using rule 22 (statement -> variable_declaration .)
    FALSE           reduce using rule 22 (statement -> variable_declaration .)
    STRING          reduce using rule 22 (statement -> variable_declaration .)
    RETURN          reduce using rule 22 (statement -> variable_declaration .)
    FOR             reduce using rule 22 (statement -> variable_declaration .)
    IF              reduce using rule 22 (statement -> variable_declaration .)
    SWITCH          reduce using rule 22 (statement -> variable_declaration .)
    BREAK           reduce using rule 22 (statement -> variable_declaration .)
    CONTINUE        reduce using rule 22 (statement -> variable_declaration .)
    FALLTHROUGH     reduce using rule 22 (statement -> variable_declaration .)
    $end            reduce using rule 22 (statement -> variable_declaration .)
    RBRACE          reduce using rule 22 (statement -> variable_declaration .)
    CASE            reduce using rule 22 (statement -> variable_declaration .)
    DEFAULT         reduce using rule 22 (statement -> variable_declaration .)
>>>>>>> Stashed changes


state 19

<<<<<<< Updated upstream
    (112) function_declaration -> FUNC . IDENTIFIER LPAREN parameter_list RPAREN return_type block
    (146) method_declaration -> FUNC . LPAREN receiver RPAREN IDENTIFIER LPAREN parameter_list RPAREN return_type block

    IDENTIFIER      shift and go to state 25
    LPAREN          shift and go to state 26
=======
    (23) statement -> expression .
    (100) expression -> expression . DOT IDENTIFIER
    (135) binary_expression -> expression . PLUS expression
    (136) binary_expression -> expression . MINUS expression
    (137) binary_expression -> expression . TIMES expression
    (138) binary_expression -> expression . DIVIDE expression
    (139) binary_expression -> expression . MODULE expression
    (144) relational_expression -> expression . EQ expression
    (145) relational_expression -> expression . NEQ expression
    (146) relational_expression -> expression . LT expression
    (147) relational_expression -> expression . LE expression
    (148) relational_expression -> expression . GT expression
    (149) relational_expression -> expression . GE expression
    (150) logical_expression -> expression . LAND expression
    (151) logical_expression -> expression . LOR expression
    (152) bitwise_expression -> expression . AND expression
    (153) bitwise_expression -> expression . OR expression
    (154) bitwise_expression -> expression . XOR expression
    (155) bitwise_expression -> expression . AND_NOT expression
    (156) bitwise_expression -> expression . LSHIFT expression
    (157) bitwise_expression -> expression . RSHIFT expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    SEMICOLON       reduce using rule 23 (statement -> expression .)
    FUNC            reduce using rule 23 (statement -> expression .)
    TYPE            reduce using rule 23 (statement -> expression .)
    IDENTIFIER      reduce using rule 23 (statement -> expression .)
    VAR             reduce using rule 23 (statement -> expression .)
    CONST           reduce using rule 23 (statement -> expression .)
    LNOT            reduce using rule 23 (statement -> expression .)
    LBRACKET        reduce using rule 23 (statement -> expression .)
    LPAREN          reduce using rule 23 (statement -> expression .)
    INT             reduce using rule 23 (statement -> expression .)
    FLOAT64         reduce using rule 23 (statement -> expression .)
    TRUE            reduce using rule 23 (statement -> expression .)
    FALSE           reduce using rule 23 (statement -> expression .)
    STRING          reduce using rule 23 (statement -> expression .)
    RETURN          reduce using rule 23 (statement -> expression .)
    FOR             reduce using rule 23 (statement -> expression .)
    IF              reduce using rule 23 (statement -> expression .)
    SWITCH          reduce using rule 23 (statement -> expression .)
    BREAK           reduce using rule 23 (statement -> expression .)
    CONTINUE        reduce using rule 23 (statement -> expression .)
    FALLTHROUGH     reduce using rule 23 (statement -> expression .)
    $end            reduce using rule 23 (statement -> expression .)
    RBRACE          reduce using rule 23 (statement -> expression .)
    CASE            reduce using rule 23 (statement -> expression .)
    DEFAULT         reduce using rule 23 (statement -> expression .)
    DOT             shift and go to state 58
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    TIMES           shift and go to state 61
    DIVIDE          shift and go to state 62
    MODULE          shift and go to state 63
    EQ              shift and go to state 64
    NEQ             shift and go to state 65
    LT              shift and go to state 66
    LE              shift and go to state 67
    GT              shift and go to state 68
    GE              shift and go to state 69
    LAND            shift and go to state 70
    LOR             shift and go to state 71
    AND             shift and go to state 72
    OR              shift and go to state 73
    XOR             shift and go to state 74
    AND_NOT         shift and go to state 75
    LSHIFT          shift and go to state 76
    RSHIFT          shift and go to state 77

  ! PLUS            [ reduce using rule 23 (statement -> expression .) ]
  ! MINUS           [ reduce using rule 23 (statement -> expression .) ]
>>>>>>> Stashed changes


state 20

    (150) type_declaration -> TYPE . IDENTIFIER type_alias

<<<<<<< Updated upstream
    IDENTIFIER      shift and go to state 27
=======
    SEMICOLON       reduce using rule 24 (statement -> return_statement .)
    FUNC            reduce using rule 24 (statement -> return_statement .)
    TYPE            reduce using rule 24 (statement -> return_statement .)
    IDENTIFIER      reduce using rule 24 (statement -> return_statement .)
    VAR             reduce using rule 24 (statement -> return_statement .)
    CONST           reduce using rule 24 (statement -> return_statement .)
    PLUS            reduce using rule 24 (statement -> return_statement .)
    MINUS           reduce using rule 24 (statement -> return_statement .)
    LNOT            reduce using rule 24 (statement -> return_statement .)
    LBRACKET        reduce using rule 24 (statement -> return_statement .)
    LPAREN          reduce using rule 24 (statement -> return_statement .)
    INT             reduce using rule 24 (statement -> return_statement .)
    FLOAT64         reduce using rule 24 (statement -> return_statement .)
    TRUE            reduce using rule 24 (statement -> return_statement .)
    FALSE           reduce using rule 24 (statement -> return_statement .)
    STRING          reduce using rule 24 (statement -> return_statement .)
    RETURN          reduce using rule 24 (statement -> return_statement .)
    FOR             reduce using rule 24 (statement -> return_statement .)
    IF              reduce using rule 24 (statement -> return_statement .)
    SWITCH          reduce using rule 24 (statement -> return_statement .)
    BREAK           reduce using rule 24 (statement -> return_statement .)
    CONTINUE        reduce using rule 24 (statement -> return_statement .)
    FALLTHROUGH     reduce using rule 24 (statement -> return_statement .)
    $end            reduce using rule 24 (statement -> return_statement .)
    RBRACE          reduce using rule 24 (statement -> return_statement .)
    CASE            reduce using rule 24 (statement -> return_statement .)
    DEFAULT         reduce using rule 24 (statement -> return_statement .)
>>>>>>> Stashed changes


state 21

    (6) simple_import -> IMPORT STRING .

<<<<<<< Updated upstream
    IMPORT          reduce using rule 6 (simple_import -> IMPORT STRING .)
    VAR             reduce using rule 6 (simple_import -> IMPORT STRING .)
    CONST           reduce using rule 6 (simple_import -> IMPORT STRING .)
    FUNC            reduce using rule 6 (simple_import -> IMPORT STRING .)
    TYPE            reduce using rule 6 (simple_import -> IMPORT STRING .)
=======
    SEMICOLON       reduce using rule 25 (statement -> for_statement .)
    FUNC            reduce using rule 25 (statement -> for_statement .)
    TYPE            reduce using rule 25 (statement -> for_statement .)
    IDENTIFIER      reduce using rule 25 (statement -> for_statement .)
    VAR             reduce using rule 25 (statement -> for_statement .)
    CONST           reduce using rule 25 (statement -> for_statement .)
    PLUS            reduce using rule 25 (statement -> for_statement .)
    MINUS           reduce using rule 25 (statement -> for_statement .)
    LNOT            reduce using rule 25 (statement -> for_statement .)
    LBRACKET        reduce using rule 25 (statement -> for_statement .)
    LPAREN          reduce using rule 25 (statement -> for_statement .)
    INT             reduce using rule 25 (statement -> for_statement .)
    FLOAT64         reduce using rule 25 (statement -> for_statement .)
    TRUE            reduce using rule 25 (statement -> for_statement .)
    FALSE           reduce using rule 25 (statement -> for_statement .)
    STRING          reduce using rule 25 (statement -> for_statement .)
    RETURN          reduce using rule 25 (statement -> for_statement .)
    FOR             reduce using rule 25 (statement -> for_statement .)
    IF              reduce using rule 25 (statement -> for_statement .)
    SWITCH          reduce using rule 25 (statement -> for_statement .)
    BREAK           reduce using rule 25 (statement -> for_statement .)
    CONTINUE        reduce using rule 25 (statement -> for_statement .)
    FALLTHROUGH     reduce using rule 25 (statement -> for_statement .)
    $end            reduce using rule 25 (statement -> for_statement .)
    RBRACE          reduce using rule 25 (statement -> for_statement .)
    CASE            reduce using rule 25 (statement -> for_statement .)
    DEFAULT         reduce using rule 25 (statement -> for_statement .)
>>>>>>> Stashed changes


state 22

    (9) global_statement_list -> global_statement_list global_statement .

<<<<<<< Updated upstream
    VAR             reduce using rule 9 (global_statement_list -> global_statement_list global_statement .)
    CONST           reduce using rule 9 (global_statement_list -> global_statement_list global_statement .)
    FUNC            reduce using rule 9 (global_statement_list -> global_statement_list global_statement .)
    TYPE            reduce using rule 9 (global_statement_list -> global_statement_list global_statement .)
    $end            reduce using rule 9 (global_statement_list -> global_statement_list global_statement .)
=======
    SEMICOLON       reduce using rule 26 (statement -> if_statement .)
    FUNC            reduce using rule 26 (statement -> if_statement .)
    TYPE            reduce using rule 26 (statement -> if_statement .)
    IDENTIFIER      reduce using rule 26 (statement -> if_statement .)
    VAR             reduce using rule 26 (statement -> if_statement .)
    CONST           reduce using rule 26 (statement -> if_statement .)
    PLUS            reduce using rule 26 (statement -> if_statement .)
    MINUS           reduce using rule 26 (statement -> if_statement .)
    LNOT            reduce using rule 26 (statement -> if_statement .)
    LBRACKET        reduce using rule 26 (statement -> if_statement .)
    LPAREN          reduce using rule 26 (statement -> if_statement .)
    INT             reduce using rule 26 (statement -> if_statement .)
    FLOAT64         reduce using rule 26 (statement -> if_statement .)
    TRUE            reduce using rule 26 (statement -> if_statement .)
    FALSE           reduce using rule 26 (statement -> if_statement .)
    STRING          reduce using rule 26 (statement -> if_statement .)
    RETURN          reduce using rule 26 (statement -> if_statement .)
    FOR             reduce using rule 26 (statement -> if_statement .)
    IF              reduce using rule 26 (statement -> if_statement .)
    SWITCH          reduce using rule 26 (statement -> if_statement .)
    BREAK           reduce using rule 26 (statement -> if_statement .)
    CONTINUE        reduce using rule 26 (statement -> if_statement .)
    FALLTHROUGH     reduce using rule 26 (statement -> if_statement .)
    $end            reduce using rule 26 (statement -> if_statement .)
    RBRACE          reduce using rule 26 (statement -> if_statement .)
    CASE            reduce using rule 26 (statement -> if_statement .)
    DEFAULT         reduce using rule 26 (statement -> if_statement .)
>>>>>>> Stashed changes


state 23

    (15) global_var_dec -> VAR IDENTIFIER . type
    (16) global_var_dec -> VAR IDENTIFIER . type ASSIGN expression
    (17) global_var_dec -> VAR IDENTIFIER . ASSIGN expression
    (57) type -> . primitive_type
    (58) type -> . slice_type
    (59) type -> . array_type
    (60) type -> . map_type
    (61) primitive_type -> . INT_TYPE
    (62) primitive_type -> . FLOAT64_TYPE
    (63) primitive_type -> . STRING_TYPE
    (64) primitive_type -> . BOOL_TYPE
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (197) array_type -> . LBRACKET INT RBRACKET primitive_type
    (137) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type

<<<<<<< Updated upstream
    ASSIGN          shift and go to state 29
    INT_TYPE        shift and go to state 34
    FLOAT64_TYPE    shift and go to state 35
    STRING_TYPE     shift and go to state 36
    BOOL_TYPE       shift and go to state 37
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39
=======
    SEMICOLON       reduce using rule 27 (statement -> switch_statement .)
    FUNC            reduce using rule 27 (statement -> switch_statement .)
    TYPE            reduce using rule 27 (statement -> switch_statement .)
    IDENTIFIER      reduce using rule 27 (statement -> switch_statement .)
    VAR             reduce using rule 27 (statement -> switch_statement .)
    CONST           reduce using rule 27 (statement -> switch_statement .)
    PLUS            reduce using rule 27 (statement -> switch_statement .)
    MINUS           reduce using rule 27 (statement -> switch_statement .)
    LNOT            reduce using rule 27 (statement -> switch_statement .)
    LBRACKET        reduce using rule 27 (statement -> switch_statement .)
    LPAREN          reduce using rule 27 (statement -> switch_statement .)
    INT             reduce using rule 27 (statement -> switch_statement .)
    FLOAT64         reduce using rule 27 (statement -> switch_statement .)
    TRUE            reduce using rule 27 (statement -> switch_statement .)
    FALSE           reduce using rule 27 (statement -> switch_statement .)
    STRING          reduce using rule 27 (statement -> switch_statement .)
    RETURN          reduce using rule 27 (statement -> switch_statement .)
    FOR             reduce using rule 27 (statement -> switch_statement .)
    IF              reduce using rule 27 (statement -> switch_statement .)
    SWITCH          reduce using rule 27 (statement -> switch_statement .)
    BREAK           reduce using rule 27 (statement -> switch_statement .)
    CONTINUE        reduce using rule 27 (statement -> switch_statement .)
    FALLTHROUGH     reduce using rule 27 (statement -> switch_statement .)
    $end            reduce using rule 27 (statement -> switch_statement .)
    RBRACE          reduce using rule 27 (statement -> switch_statement .)
    CASE            reduce using rule 27 (statement -> switch_statement .)
    DEFAULT         reduce using rule 27 (statement -> switch_statement .)
>>>>>>> Stashed changes

    type                           shift and go to state 28
    primitive_type                 shift and go to state 30
    slice_type                     shift and go to state 31
    array_type                     shift and go to state 32
    map_type                       shift and go to state 33

state 24

    (18) global_const_dec -> CONST IDENTIFIER . type ASSIGN expression
    (19) global_const_dec -> CONST IDENTIFIER . ASSIGN expression
    (57) type -> . primitive_type
    (58) type -> . slice_type
    (59) type -> . array_type
    (60) type -> . map_type
    (61) primitive_type -> . INT_TYPE
    (62) primitive_type -> . FLOAT64_TYPE
    (63) primitive_type -> . STRING_TYPE
    (64) primitive_type -> . BOOL_TYPE
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (197) array_type -> . LBRACKET INT RBRACKET primitive_type
    (137) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type

<<<<<<< Updated upstream
    ASSIGN          shift and go to state 41
    INT_TYPE        shift and go to state 34
    FLOAT64_TYPE    shift and go to state 35
    STRING_TYPE     shift and go to state 36
    BOOL_TYPE       shift and go to state 37
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39
=======
    SEMICOLON       reduce using rule 28 (statement -> break_statement .)
    FUNC            reduce using rule 28 (statement -> break_statement .)
    TYPE            reduce using rule 28 (statement -> break_statement .)
    IDENTIFIER      reduce using rule 28 (statement -> break_statement .)
    VAR             reduce using rule 28 (statement -> break_statement .)
    CONST           reduce using rule 28 (statement -> break_statement .)
    PLUS            reduce using rule 28 (statement -> break_statement .)
    MINUS           reduce using rule 28 (statement -> break_statement .)
    LNOT            reduce using rule 28 (statement -> break_statement .)
    LBRACKET        reduce using rule 28 (statement -> break_statement .)
    LPAREN          reduce using rule 28 (statement -> break_statement .)
    INT             reduce using rule 28 (statement -> break_statement .)
    FLOAT64         reduce using rule 28 (statement -> break_statement .)
    TRUE            reduce using rule 28 (statement -> break_statement .)
    FALSE           reduce using rule 28 (statement -> break_statement .)
    STRING          reduce using rule 28 (statement -> break_statement .)
    RETURN          reduce using rule 28 (statement -> break_statement .)
    FOR             reduce using rule 28 (statement -> break_statement .)
    IF              reduce using rule 28 (statement -> break_statement .)
    SWITCH          reduce using rule 28 (statement -> break_statement .)
    BREAK           reduce using rule 28 (statement -> break_statement .)
    CONTINUE        reduce using rule 28 (statement -> break_statement .)
    FALLTHROUGH     reduce using rule 28 (statement -> break_statement .)
    $end            reduce using rule 28 (statement -> break_statement .)
    RBRACE          reduce using rule 28 (statement -> break_statement .)
    CASE            reduce using rule 28 (statement -> break_statement .)
    DEFAULT         reduce using rule 28 (statement -> break_statement .)
>>>>>>> Stashed changes

    type                           shift and go to state 40
    primitive_type                 shift and go to state 30
    slice_type                     shift and go to state 31
    array_type                     shift and go to state 32
    map_type                       shift and go to state 33

state 25

    (112) function_declaration -> FUNC IDENTIFIER . LPAREN parameter_list RPAREN return_type block

<<<<<<< Updated upstream
    LPAREN          shift and go to state 42
=======
    SEMICOLON       reduce using rule 29 (statement -> continue_statement .)
    FUNC            reduce using rule 29 (statement -> continue_statement .)
    TYPE            reduce using rule 29 (statement -> continue_statement .)
    IDENTIFIER      reduce using rule 29 (statement -> continue_statement .)
    VAR             reduce using rule 29 (statement -> continue_statement .)
    CONST           reduce using rule 29 (statement -> continue_statement .)
    PLUS            reduce using rule 29 (statement -> continue_statement .)
    MINUS           reduce using rule 29 (statement -> continue_statement .)
    LNOT            reduce using rule 29 (statement -> continue_statement .)
    LBRACKET        reduce using rule 29 (statement -> continue_statement .)
    LPAREN          reduce using rule 29 (statement -> continue_statement .)
    INT             reduce using rule 29 (statement -> continue_statement .)
    FLOAT64         reduce using rule 29 (statement -> continue_statement .)
    TRUE            reduce using rule 29 (statement -> continue_statement .)
    FALSE           reduce using rule 29 (statement -> continue_statement .)
    STRING          reduce using rule 29 (statement -> continue_statement .)
    RETURN          reduce using rule 29 (statement -> continue_statement .)
    FOR             reduce using rule 29 (statement -> continue_statement .)
    IF              reduce using rule 29 (statement -> continue_statement .)
    SWITCH          reduce using rule 29 (statement -> continue_statement .)
    BREAK           reduce using rule 29 (statement -> continue_statement .)
    CONTINUE        reduce using rule 29 (statement -> continue_statement .)
    FALLTHROUGH     reduce using rule 29 (statement -> continue_statement .)
    $end            reduce using rule 29 (statement -> continue_statement .)
    RBRACE          reduce using rule 29 (statement -> continue_statement .)
    CASE            reduce using rule 29 (statement -> continue_statement .)
    DEFAULT         reduce using rule 29 (statement -> continue_statement .)
>>>>>>> Stashed changes


state 26

<<<<<<< Updated upstream
    (146) method_declaration -> FUNC LPAREN . receiver RPAREN IDENTIFIER LPAREN parameter_list RPAREN return_type block
    (147) receiver -> . IDENTIFIER IDENTIFIER
    (148) receiver -> . IDENTIFIER TIMES IDENTIFIER
    (149) receiver -> . IDENTIFIER TIMES type

    IDENTIFIER      shift and go to state 44
=======
    (30) statement -> fallthrough_statement .

    SEMICOLON       reduce using rule 30 (statement -> fallthrough_statement .)
    FUNC            reduce using rule 30 (statement -> fallthrough_statement .)
    TYPE            reduce using rule 30 (statement -> fallthrough_statement .)
    IDENTIFIER      reduce using rule 30 (statement -> fallthrough_statement .)
    VAR             reduce using rule 30 (statement -> fallthrough_statement .)
    CONST           reduce using rule 30 (statement -> fallthrough_statement .)
    PLUS            reduce using rule 30 (statement -> fallthrough_statement .)
    MINUS           reduce using rule 30 (statement -> fallthrough_statement .)
    LNOT            reduce using rule 30 (statement -> fallthrough_statement .)
    LBRACKET        reduce using rule 30 (statement -> fallthrough_statement .)
    LPAREN          reduce using rule 30 (statement -> fallthrough_statement .)
    INT             reduce using rule 30 (statement -> fallthrough_statement .)
    FLOAT64         reduce using rule 30 (statement -> fallthrough_statement .)
    TRUE            reduce using rule 30 (statement -> fallthrough_statement .)
    FALSE           reduce using rule 30 (statement -> fallthrough_statement .)
    STRING          reduce using rule 30 (statement -> fallthrough_statement .)
    RETURN          reduce using rule 30 (statement -> fallthrough_statement .)
    FOR             reduce using rule 30 (statement -> fallthrough_statement .)
    IF              reduce using rule 30 (statement -> fallthrough_statement .)
    SWITCH          reduce using rule 30 (statement -> fallthrough_statement .)
    BREAK           reduce using rule 30 (statement -> fallthrough_statement .)
    CONTINUE        reduce using rule 30 (statement -> fallthrough_statement .)
    FALLTHROUGH     reduce using rule 30 (statement -> fallthrough_statement .)
    $end            reduce using rule 30 (statement -> fallthrough_statement .)
    RBRACE          reduce using rule 30 (statement -> fallthrough_statement .)
    CASE            reduce using rule 30 (statement -> fallthrough_statement .)
    DEFAULT         reduce using rule 30 (statement -> fallthrough_statement .)
>>>>>>> Stashed changes

    receiver                       shift and go to state 43

state 27

<<<<<<< Updated upstream
    (150) type_declaration -> TYPE IDENTIFIER . type_alias
    (151) type_alias -> . struct_type
    (152) type_alias -> . type
    (153) type_alias -> . IDENTIFIER
    (154) struct_type -> . STRUCT LBRACE RBRACE
    (155) struct_type -> . STRUCT LBRACE field_list RBRACE
    (57) type -> . primitive_type
    (58) type -> . slice_type
    (59) type -> . array_type
    (60) type -> . map_type
    (61) primitive_type -> . INT_TYPE
    (62) primitive_type -> . FLOAT64_TYPE
    (63) primitive_type -> . STRING_TYPE
    (64) primitive_type -> . BOOL_TYPE
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (197) array_type -> . LBRACKET INT RBRACKET primitive_type
    (137) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type

    IDENTIFIER      shift and go to state 45
    STRUCT          shift and go to state 49
    INT_TYPE        shift and go to state 34
    FLOAT64_TYPE    shift and go to state 35
    STRING_TYPE     shift and go to state 36
    BOOL_TYPE       shift and go to state 37
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39
=======
    (43) function_declaration -> FUNC . IDENTIFIER LPAREN parameter_list RPAREN return_type block
    (124) method_declaration -> FUNC . LPAREN receiver RPAREN IDENTIFIER LPAREN parameter_list RPAREN return_type block

    IDENTIFIER      shift and go to state 78
    LPAREN          shift and go to state 79
>>>>>>> Stashed changes

    type_alias                     shift and go to state 46
    struct_type                    shift and go to state 47
    type                           shift and go to state 48
    primitive_type                 shift and go to state 30
    slice_type                     shift and go to state 31
    array_type                     shift and go to state 32
    map_type                       shift and go to state 33

state 28

<<<<<<< Updated upstream
    (15) global_var_dec -> VAR IDENTIFIER type .
    (16) global_var_dec -> VAR IDENTIFIER type . ASSIGN expression

    VAR             reduce using rule 15 (global_var_dec -> VAR IDENTIFIER type .)
    CONST           reduce using rule 15 (global_var_dec -> VAR IDENTIFIER type .)
    FUNC            reduce using rule 15 (global_var_dec -> VAR IDENTIFIER type .)
    TYPE            reduce using rule 15 (global_var_dec -> VAR IDENTIFIER type .)
    $end            reduce using rule 15 (global_var_dec -> VAR IDENTIFIER type .)
    ASSIGN          shift and go to state 50
=======
    (54) assignment -> IDENTIFIER . ASSIGN expression
    (55) assignment -> IDENTIFIER . SHORT_ASSIGN expression
    (56) assignment_compound -> IDENTIFIER . PLUS_ASSIGN expression
    (57) assignment_compound -> IDENTIFIER . MINUS_ASSIGN expression
    (58) assignment_compound -> IDENTIFIER . MULT_ASSIGN expression
    (59) assignment_compound -> IDENTIFIER . DIV_ASSIGN expression
    (60) assignment_compound -> IDENTIFIER . MOD_ASSIGN expression
    (61) assignment_compound -> IDENTIFIER . AND_ASSIGN expression
    (62) assignment_compound -> IDENTIFIER . OR_ASSIGN expression
    (63) assignment_compound -> IDENTIFIER . XOR_ASSIGN expression
    (64) assignment_compound -> IDENTIFIER . LSHIFT_ASSIGN expression
    (65) assignment_compound -> IDENTIFIER . RSHIFT_ASSIGN expression
    (96) expression -> IDENTIFIER .
    (98) expression -> IDENTIFIER . PLUSPLUS
    (99) expression -> IDENTIFIER . MINUSMINUS
    (103) expression -> IDENTIFIER . LPAREN argument_list RPAREN
    (133) expression -> IDENTIFIER . LBRACE keyed_element_list RBRACE
    (134) expression -> IDENTIFIER . LBRACE RBRACE

  ! shift/reduce conflict for LPAREN resolved as shift
    ASSIGN          shift and go to state 80
    SHORT_ASSIGN    shift and go to state 81
    PLUS_ASSIGN     shift and go to state 82
    MINUS_ASSIGN    shift and go to state 83
    MULT_ASSIGN     shift and go to state 84
    DIV_ASSIGN      shift and go to state 85
    MOD_ASSIGN      shift and go to state 86
    AND_ASSIGN      shift and go to state 87
    OR_ASSIGN       shift and go to state 88
    XOR_ASSIGN      shift and go to state 89
    LSHIFT_ASSIGN   shift and go to state 90
    RSHIFT_ASSIGN   shift and go to state 91
    DOT             reduce using rule 96 (expression -> IDENTIFIER .)
    PLUS            reduce using rule 96 (expression -> IDENTIFIER .)
    MINUS           reduce using rule 96 (expression -> IDENTIFIER .)
    TIMES           reduce using rule 96 (expression -> IDENTIFIER .)
    DIVIDE          reduce using rule 96 (expression -> IDENTIFIER .)
    MODULE          reduce using rule 96 (expression -> IDENTIFIER .)
    EQ              reduce using rule 96 (expression -> IDENTIFIER .)
    NEQ             reduce using rule 96 (expression -> IDENTIFIER .)
    LT              reduce using rule 96 (expression -> IDENTIFIER .)
    LE              reduce using rule 96 (expression -> IDENTIFIER .)
    GT              reduce using rule 96 (expression -> IDENTIFIER .)
    GE              reduce using rule 96 (expression -> IDENTIFIER .)
    LAND            reduce using rule 96 (expression -> IDENTIFIER .)
    LOR             reduce using rule 96 (expression -> IDENTIFIER .)
    AND             reduce using rule 96 (expression -> IDENTIFIER .)
    OR              reduce using rule 96 (expression -> IDENTIFIER .)
    XOR             reduce using rule 96 (expression -> IDENTIFIER .)
    AND_NOT         reduce using rule 96 (expression -> IDENTIFIER .)
    LSHIFT          reduce using rule 96 (expression -> IDENTIFIER .)
    RSHIFT          reduce using rule 96 (expression -> IDENTIFIER .)
    SEMICOLON       reduce using rule 96 (expression -> IDENTIFIER .)
    FUNC            reduce using rule 96 (expression -> IDENTIFIER .)
    TYPE            reduce using rule 96 (expression -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 96 (expression -> IDENTIFIER .)
    VAR             reduce using rule 96 (expression -> IDENTIFIER .)
    CONST           reduce using rule 96 (expression -> IDENTIFIER .)
    LNOT            reduce using rule 96 (expression -> IDENTIFIER .)
    LBRACKET        reduce using rule 96 (expression -> IDENTIFIER .)
    INT             reduce using rule 96 (expression -> IDENTIFIER .)
    FLOAT64         reduce using rule 96 (expression -> IDENTIFIER .)
    TRUE            reduce using rule 96 (expression -> IDENTIFIER .)
    FALSE           reduce using rule 96 (expression -> IDENTIFIER .)
    STRING          reduce using rule 96 (expression -> IDENTIFIER .)
    RETURN          reduce using rule 96 (expression -> IDENTIFIER .)
    FOR             reduce using rule 96 (expression -> IDENTIFIER .)
    IF              reduce using rule 96 (expression -> IDENTIFIER .)
    SWITCH          reduce using rule 96 (expression -> IDENTIFIER .)
    BREAK           reduce using rule 96 (expression -> IDENTIFIER .)
    CONTINUE        reduce using rule 96 (expression -> IDENTIFIER .)
    FALLTHROUGH     reduce using rule 96 (expression -> IDENTIFIER .)
    $end            reduce using rule 96 (expression -> IDENTIFIER .)
    RBRACE          reduce using rule 96 (expression -> IDENTIFIER .)
    CASE            reduce using rule 96 (expression -> IDENTIFIER .)
    DEFAULT         reduce using rule 96 (expression -> IDENTIFIER .)
    PLUSPLUS        shift and go to state 92
    MINUSMINUS      shift and go to state 93
    LPAREN          shift and go to state 94
    LBRACE          shift and go to state 95

  ! LPAREN          [ reduce using rule 96 (expression -> IDENTIFIER .) ]
>>>>>>> Stashed changes


state 29

<<<<<<< Updated upstream
    (17) global_var_dec -> VAR IDENTIFIER ASSIGN . expression
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (125) expression -> . LNOT expression
    (126) expression -> . IDENTIFIER PLUSPLUS
    (127) expression -> . IDENTIFIER MINUSMINUS
    (138) expression -> . map_type LBRACE expression_map_list RBRACE
    (139) expression -> . map_type LBRACE RBRACE
    (161) expression -> . type_name LBRACE keyed_element_list RBRACE
    (162) expression -> . type_name LBRACE RBRACE
    (198) expression -> . array_type LBRACE expression_list RBRACE
    (199) expression -> . array_type LBRACE RBRACE
    (200) expression -> . expression DOT IDENTIFIER
    (201) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> . expression LBRACKET expression RBRACKET
    (203) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (137) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (163) type_name -> . IDENTIFIER
    (164) type_name -> . slice_type
    (165) type_name -> . array_type
    (166) type_name -> . map_type
    (197) array_type -> . LBRACKET INT RBRACKET primitive_type

    LPAREN          shift and go to state 54
    INT             shift and go to state 55
    FLOAT64         shift and go to state 56
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 57
    TRUE            shift and go to state 58
    FALSE           shift and go to state 59
    LNOT            shift and go to state 60
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    expression                     shift and go to state 52
    slice_type                     shift and go to state 53
    map_type                       shift and go to state 61
    type_name                      shift and go to state 62
    array_type                     shift and go to state 63

state 30

    (57) type -> primitive_type .

    ASSIGN          reduce using rule 57 (type -> primitive_type .)
    VAR             reduce using rule 57 (type -> primitive_type .)
    CONST           reduce using rule 57 (type -> primitive_type .)
    FUNC            reduce using rule 57 (type -> primitive_type .)
    TYPE            reduce using rule 57 (type -> primitive_type .)
    $end            reduce using rule 57 (type -> primitive_type .)
    RPAREN          reduce using rule 57 (type -> primitive_type .)
    COMMA           reduce using rule 57 (type -> primitive_type .)
    LBRACE          reduce using rule 57 (type -> primitive_type .)
    RBRACE          reduce using rule 57 (type -> primitive_type .)
    IDENTIFIER      reduce using rule 57 (type -> primitive_type .)
    BREAK           reduce using rule 57 (type -> primitive_type .)
    CONTINUE        reduce using rule 57 (type -> primitive_type .)
    LPAREN          reduce using rule 57 (type -> primitive_type .)
    INT             reduce using rule 57 (type -> primitive_type .)
    FLOAT64         reduce using rule 57 (type -> primitive_type .)
    STRING          reduce using rule 57 (type -> primitive_type .)
    TRUE            reduce using rule 57 (type -> primitive_type .)
    FALSE           reduce using rule 57 (type -> primitive_type .)
    LNOT            reduce using rule 57 (type -> primitive_type .)
    IF              reduce using rule 57 (type -> primitive_type .)
    SWITCH          reduce using rule 57 (type -> primitive_type .)
    RETURN          reduce using rule 57 (type -> primitive_type .)
    LBRACKET        reduce using rule 57 (type -> primitive_type .)
    MAP             reduce using rule 57 (type -> primitive_type .)
    FOR             reduce using rule 57 (type -> primitive_type .)
    SEMICOLON       reduce using rule 57 (type -> primitive_type .)
    CASE            reduce using rule 57 (type -> primitive_type .)
    DEFAULT         reduce using rule 57 (type -> primitive_type .)
=======
    (91) expression -> LPAREN . expression RPAREN
    (82) expression -> . binary_expression
    (83) expression -> . relational_expression
    (84) expression -> . logical_expression
    (85) expression -> . bitwise_expression
    (86) expression -> . PLUS expression
    (87) expression -> . MINUS expression
    (88) expression -> . LNOT expression
    (89) expression -> . LBRACKET RBRACKET primitive_type LBRACE expression_list RBRACE
    (90) expression -> . LBRACKET RBRACKET primitive_type LBRACE RBRACE
    (91) expression -> . LPAREN expression RPAREN
    (92) expression -> . INT
    (93) expression -> . FLOAT64
    (94) expression -> . TRUE
    (95) expression -> . FALSE
    (96) expression -> . IDENTIFIER
    (97) expression -> . STRING
    (98) expression -> . IDENTIFIER PLUSPLUS
    (99) expression -> . IDENTIFIER MINUSMINUS
    (100) expression -> . expression DOT IDENTIFIER
    (103) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (133) expression -> . IDENTIFIER LBRACE keyed_element_list RBRACE
    (134) expression -> . IDENTIFIER LBRACE RBRACE
    (135) binary_expression -> . expression PLUS expression
    (136) binary_expression -> . expression MINUS expression
    (137) binary_expression -> . expression TIMES expression
    (138) binary_expression -> . expression DIVIDE expression
    (139) binary_expression -> . expression MODULE expression
    (144) relational_expression -> . expression EQ expression
    (145) relational_expression -> . expression NEQ expression
    (146) relational_expression -> . expression LT expression
    (147) relational_expression -> . expression LE expression
    (148) relational_expression -> . expression GT expression
    (149) relational_expression -> . expression GE expression
    (150) logical_expression -> . expression LAND expression
    (151) logical_expression -> . expression LOR expression
    (152) bitwise_expression -> . expression AND expression
    (153) bitwise_expression -> . expression OR expression
    (154) bitwise_expression -> . expression XOR expression
    (155) bitwise_expression -> . expression AND_NOT expression
    (156) bitwise_expression -> . expression LSHIFT expression
    (157) bitwise_expression -> . expression RSHIFT expression

    PLUS            shift and go to state 37
    MINUS           shift and go to state 38
    LNOT            shift and go to state 39
    LBRACKET        shift and go to state 40
    LPAREN          shift and go to state 29
    INT             shift and go to state 41
    FLOAT64         shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44
    IDENTIFIER      shift and go to state 97
    STRING          shift and go to state 11

    expression                     shift and go to state 96
    binary_expression              shift and go to state 33
    relational_expression          shift and go to state 34
    logical_expression             shift and go to state 35
    bitwise_expression             shift and go to state 36

state 30

    (112) type_declaration -> TYPE . IDENTIFIER struct_type optional_semicolon
    (113) type_declaration -> TYPE . IDENTIFIER primitive_type optional_semicolon
    (114) type_declaration -> TYPE . IDENTIFIER slice_type optional_semicolon
    (115) type_declaration -> TYPE . IDENTIFIER array_type optional_semicolon
    (116) type_declaration -> TYPE . IDENTIFIER map_type optional_semicolon
    (117) type_declaration -> TYPE . IDENTIFIER IDENTIFIER optional_semicolon

    IDENTIFIER      shift and go to state 98
>>>>>>> Stashed changes


state 31

<<<<<<< Updated upstream
    (58) type -> slice_type .

    ASSIGN          reduce using rule 58 (type -> slice_type .)
    VAR             reduce using rule 58 (type -> slice_type .)
    CONST           reduce using rule 58 (type -> slice_type .)
    FUNC            reduce using rule 58 (type -> slice_type .)
    TYPE            reduce using rule 58 (type -> slice_type .)
    $end            reduce using rule 58 (type -> slice_type .)
    RPAREN          reduce using rule 58 (type -> slice_type .)
    COMMA           reduce using rule 58 (type -> slice_type .)
    LBRACE          reduce using rule 58 (type -> slice_type .)
    RBRACE          reduce using rule 58 (type -> slice_type .)
    IDENTIFIER      reduce using rule 58 (type -> slice_type .)
    BREAK           reduce using rule 58 (type -> slice_type .)
    CONTINUE        reduce using rule 58 (type -> slice_type .)
    LPAREN          reduce using rule 58 (type -> slice_type .)
    INT             reduce using rule 58 (type -> slice_type .)
    FLOAT64         reduce using rule 58 (type -> slice_type .)
    STRING          reduce using rule 58 (type -> slice_type .)
    TRUE            reduce using rule 58 (type -> slice_type .)
    FALSE           reduce using rule 58 (type -> slice_type .)
    LNOT            reduce using rule 58 (type -> slice_type .)
    IF              reduce using rule 58 (type -> slice_type .)
    SWITCH          reduce using rule 58 (type -> slice_type .)
    RETURN          reduce using rule 58 (type -> slice_type .)
    LBRACKET        reduce using rule 58 (type -> slice_type .)
    MAP             reduce using rule 58 (type -> slice_type .)
    FOR             reduce using rule 58 (type -> slice_type .)
    SEMICOLON       reduce using rule 58 (type -> slice_type .)
    CASE            reduce using rule 58 (type -> slice_type .)
    DEFAULT         reduce using rule 58 (type -> slice_type .)
=======
    (66) variable_declaration -> VAR . IDENTIFIER type ASSIGN expression
    (68) variable_declaration -> VAR . IDENTIFIER ASSIGN expression

    IDENTIFIER      shift and go to state 99
>>>>>>> Stashed changes


state 32

<<<<<<< Updated upstream
    (59) type -> array_type .

    ASSIGN          reduce using rule 59 (type -> array_type .)
    VAR             reduce using rule 59 (type -> array_type .)
    CONST           reduce using rule 59 (type -> array_type .)
    FUNC            reduce using rule 59 (type -> array_type .)
    TYPE            reduce using rule 59 (type -> array_type .)
    $end            reduce using rule 59 (type -> array_type .)
    RPAREN          reduce using rule 59 (type -> array_type .)
    COMMA           reduce using rule 59 (type -> array_type .)
    LBRACE          reduce using rule 59 (type -> array_type .)
    RBRACE          reduce using rule 59 (type -> array_type .)
    IDENTIFIER      reduce using rule 59 (type -> array_type .)
    BREAK           reduce using rule 59 (type -> array_type .)
    CONTINUE        reduce using rule 59 (type -> array_type .)
    LPAREN          reduce using rule 59 (type -> array_type .)
    INT             reduce using rule 59 (type -> array_type .)
    FLOAT64         reduce using rule 59 (type -> array_type .)
    STRING          reduce using rule 59 (type -> array_type .)
    TRUE            reduce using rule 59 (type -> array_type .)
    FALSE           reduce using rule 59 (type -> array_type .)
    LNOT            reduce using rule 59 (type -> array_type .)
    IF              reduce using rule 59 (type -> array_type .)
    SWITCH          reduce using rule 59 (type -> array_type .)
    RETURN          reduce using rule 59 (type -> array_type .)
    LBRACKET        reduce using rule 59 (type -> array_type .)
    MAP             reduce using rule 59 (type -> array_type .)
    FOR             reduce using rule 59 (type -> array_type .)
    SEMICOLON       reduce using rule 59 (type -> array_type .)
    CASE            reduce using rule 59 (type -> array_type .)
    DEFAULT         reduce using rule 59 (type -> array_type .)
=======
    (67) variable_declaration -> CONST . IDENTIFIER type ASSIGN expression
    (69) variable_declaration -> CONST . IDENTIFIER ASSIGN expression

    IDENTIFIER      shift and go to state 100
>>>>>>> Stashed changes


state 33

<<<<<<< Updated upstream
    (60) type -> map_type .

    ASSIGN          reduce using rule 60 (type -> map_type .)
    VAR             reduce using rule 60 (type -> map_type .)
    CONST           reduce using rule 60 (type -> map_type .)
    FUNC            reduce using rule 60 (type -> map_type .)
    TYPE            reduce using rule 60 (type -> map_type .)
    $end            reduce using rule 60 (type -> map_type .)
    RPAREN          reduce using rule 60 (type -> map_type .)
    COMMA           reduce using rule 60 (type -> map_type .)
    LBRACE          reduce using rule 60 (type -> map_type .)
    RBRACE          reduce using rule 60 (type -> map_type .)
    IDENTIFIER      reduce using rule 60 (type -> map_type .)
    BREAK           reduce using rule 60 (type -> map_type .)
    CONTINUE        reduce using rule 60 (type -> map_type .)
    LPAREN          reduce using rule 60 (type -> map_type .)
    INT             reduce using rule 60 (type -> map_type .)
    FLOAT64         reduce using rule 60 (type -> map_type .)
    STRING          reduce using rule 60 (type -> map_type .)
    TRUE            reduce using rule 60 (type -> map_type .)
    FALSE           reduce using rule 60 (type -> map_type .)
    LNOT            reduce using rule 60 (type -> map_type .)
    IF              reduce using rule 60 (type -> map_type .)
    SWITCH          reduce using rule 60 (type -> map_type .)
    RETURN          reduce using rule 60 (type -> map_type .)
    LBRACKET        reduce using rule 60 (type -> map_type .)
    MAP             reduce using rule 60 (type -> map_type .)
    FOR             reduce using rule 60 (type -> map_type .)
    SEMICOLON       reduce using rule 60 (type -> map_type .)
    CASE            reduce using rule 60 (type -> map_type .)
    DEFAULT         reduce using rule 60 (type -> map_type .)
=======
    (82) expression -> binary_expression .

    DOT             reduce using rule 82 (expression -> binary_expression .)
    PLUS            reduce using rule 82 (expression -> binary_expression .)
    MINUS           reduce using rule 82 (expression -> binary_expression .)
    TIMES           reduce using rule 82 (expression -> binary_expression .)
    DIVIDE          reduce using rule 82 (expression -> binary_expression .)
    MODULE          reduce using rule 82 (expression -> binary_expression .)
    EQ              reduce using rule 82 (expression -> binary_expression .)
    NEQ             reduce using rule 82 (expression -> binary_expression .)
    LT              reduce using rule 82 (expression -> binary_expression .)
    LE              reduce using rule 82 (expression -> binary_expression .)
    GT              reduce using rule 82 (expression -> binary_expression .)
    GE              reduce using rule 82 (expression -> binary_expression .)
    LAND            reduce using rule 82 (expression -> binary_expression .)
    LOR             reduce using rule 82 (expression -> binary_expression .)
    AND             reduce using rule 82 (expression -> binary_expression .)
    OR              reduce using rule 82 (expression -> binary_expression .)
    XOR             reduce using rule 82 (expression -> binary_expression .)
    AND_NOT         reduce using rule 82 (expression -> binary_expression .)
    LSHIFT          reduce using rule 82 (expression -> binary_expression .)
    RSHIFT          reduce using rule 82 (expression -> binary_expression .)
    SEMICOLON       reduce using rule 82 (expression -> binary_expression .)
    FUNC            reduce using rule 82 (expression -> binary_expression .)
    TYPE            reduce using rule 82 (expression -> binary_expression .)
    IDENTIFIER      reduce using rule 82 (expression -> binary_expression .)
    VAR             reduce using rule 82 (expression -> binary_expression .)
    CONST           reduce using rule 82 (expression -> binary_expression .)
    LNOT            reduce using rule 82 (expression -> binary_expression .)
    LBRACKET        reduce using rule 82 (expression -> binary_expression .)
    LPAREN          reduce using rule 82 (expression -> binary_expression .)
    INT             reduce using rule 82 (expression -> binary_expression .)
    FLOAT64         reduce using rule 82 (expression -> binary_expression .)
    TRUE            reduce using rule 82 (expression -> binary_expression .)
    FALSE           reduce using rule 82 (expression -> binary_expression .)
    STRING          reduce using rule 82 (expression -> binary_expression .)
    RETURN          reduce using rule 82 (expression -> binary_expression .)
    FOR             reduce using rule 82 (expression -> binary_expression .)
    IF              reduce using rule 82 (expression -> binary_expression .)
    SWITCH          reduce using rule 82 (expression -> binary_expression .)
    BREAK           reduce using rule 82 (expression -> binary_expression .)
    CONTINUE        reduce using rule 82 (expression -> binary_expression .)
    FALLTHROUGH     reduce using rule 82 (expression -> binary_expression .)
    $end            reduce using rule 82 (expression -> binary_expression .)
    RPAREN          reduce using rule 82 (expression -> binary_expression .)
    COMMA           reduce using rule 82 (expression -> binary_expression .)
    RBRACE          reduce using rule 82 (expression -> binary_expression .)
    CASE            reduce using rule 82 (expression -> binary_expression .)
    DEFAULT         reduce using rule 82 (expression -> binary_expression .)
    LBRACE          reduce using rule 82 (expression -> binary_expression .)
    COLON           reduce using rule 82 (expression -> binary_expression .)
>>>>>>> Stashed changes


state 34

<<<<<<< Updated upstream
    (61) primitive_type -> INT_TYPE .

    ASSIGN          reduce using rule 61 (primitive_type -> INT_TYPE .)
    VAR             reduce using rule 61 (primitive_type -> INT_TYPE .)
    CONST           reduce using rule 61 (primitive_type -> INT_TYPE .)
    FUNC            reduce using rule 61 (primitive_type -> INT_TYPE .)
    TYPE            reduce using rule 61 (primitive_type -> INT_TYPE .)
    $end            reduce using rule 61 (primitive_type -> INT_TYPE .)
    LBRACE          reduce using rule 61 (primitive_type -> INT_TYPE .)
    RPAREN          reduce using rule 61 (primitive_type -> INT_TYPE .)
    COMMA           reduce using rule 61 (primitive_type -> INT_TYPE .)
    RBRACE          reduce using rule 61 (primitive_type -> INT_TYPE .)
    IDENTIFIER      reduce using rule 61 (primitive_type -> INT_TYPE .)
    BREAK           reduce using rule 61 (primitive_type -> INT_TYPE .)
    CONTINUE        reduce using rule 61 (primitive_type -> INT_TYPE .)
    LPAREN          reduce using rule 61 (primitive_type -> INT_TYPE .)
    INT             reduce using rule 61 (primitive_type -> INT_TYPE .)
    FLOAT64         reduce using rule 61 (primitive_type -> INT_TYPE .)
    STRING          reduce using rule 61 (primitive_type -> INT_TYPE .)
    TRUE            reduce using rule 61 (primitive_type -> INT_TYPE .)
    FALSE           reduce using rule 61 (primitive_type -> INT_TYPE .)
    LNOT            reduce using rule 61 (primitive_type -> INT_TYPE .)
    IF              reduce using rule 61 (primitive_type -> INT_TYPE .)
    SWITCH          reduce using rule 61 (primitive_type -> INT_TYPE .)
    RETURN          reduce using rule 61 (primitive_type -> INT_TYPE .)
    LBRACKET        reduce using rule 61 (primitive_type -> INT_TYPE .)
    MAP             reduce using rule 61 (primitive_type -> INT_TYPE .)
    FOR             reduce using rule 61 (primitive_type -> INT_TYPE .)
    SEMICOLON       reduce using rule 61 (primitive_type -> INT_TYPE .)
    CASE            reduce using rule 61 (primitive_type -> INT_TYPE .)
    DEFAULT         reduce using rule 61 (primitive_type -> INT_TYPE .)
    RBRACKET        reduce using rule 61 (primitive_type -> INT_TYPE .)
=======
    (83) expression -> relational_expression .

    DOT             reduce using rule 83 (expression -> relational_expression .)
    PLUS            reduce using rule 83 (expression -> relational_expression .)
    MINUS           reduce using rule 83 (expression -> relational_expression .)
    TIMES           reduce using rule 83 (expression -> relational_expression .)
    DIVIDE          reduce using rule 83 (expression -> relational_expression .)
    MODULE          reduce using rule 83 (expression -> relational_expression .)
    EQ              reduce using rule 83 (expression -> relational_expression .)
    NEQ             reduce using rule 83 (expression -> relational_expression .)
    LT              reduce using rule 83 (expression -> relational_expression .)
    LE              reduce using rule 83 (expression -> relational_expression .)
    GT              reduce using rule 83 (expression -> relational_expression .)
    GE              reduce using rule 83 (expression -> relational_expression .)
    LAND            reduce using rule 83 (expression -> relational_expression .)
    LOR             reduce using rule 83 (expression -> relational_expression .)
    AND             reduce using rule 83 (expression -> relational_expression .)
    OR              reduce using rule 83 (expression -> relational_expression .)
    XOR             reduce using rule 83 (expression -> relational_expression .)
    AND_NOT         reduce using rule 83 (expression -> relational_expression .)
    LSHIFT          reduce using rule 83 (expression -> relational_expression .)
    RSHIFT          reduce using rule 83 (expression -> relational_expression .)
    SEMICOLON       reduce using rule 83 (expression -> relational_expression .)
    FUNC            reduce using rule 83 (expression -> relational_expression .)
    TYPE            reduce using rule 83 (expression -> relational_expression .)
    IDENTIFIER      reduce using rule 83 (expression -> relational_expression .)
    VAR             reduce using rule 83 (expression -> relational_expression .)
    CONST           reduce using rule 83 (expression -> relational_expression .)
    LNOT            reduce using rule 83 (expression -> relational_expression .)
    LBRACKET        reduce using rule 83 (expression -> relational_expression .)
    LPAREN          reduce using rule 83 (expression -> relational_expression .)
    INT             reduce using rule 83 (expression -> relational_expression .)
    FLOAT64         reduce using rule 83 (expression -> relational_expression .)
    TRUE            reduce using rule 83 (expression -> relational_expression .)
    FALSE           reduce using rule 83 (expression -> relational_expression .)
    STRING          reduce using rule 83 (expression -> relational_expression .)
    RETURN          reduce using rule 83 (expression -> relational_expression .)
    FOR             reduce using rule 83 (expression -> relational_expression .)
    IF              reduce using rule 83 (expression -> relational_expression .)
    SWITCH          reduce using rule 83 (expression -> relational_expression .)
    BREAK           reduce using rule 83 (expression -> relational_expression .)
    CONTINUE        reduce using rule 83 (expression -> relational_expression .)
    FALLTHROUGH     reduce using rule 83 (expression -> relational_expression .)
    $end            reduce using rule 83 (expression -> relational_expression .)
    RPAREN          reduce using rule 83 (expression -> relational_expression .)
    COMMA           reduce using rule 83 (expression -> relational_expression .)
    RBRACE          reduce using rule 83 (expression -> relational_expression .)
    CASE            reduce using rule 83 (expression -> relational_expression .)
    DEFAULT         reduce using rule 83 (expression -> relational_expression .)
    LBRACE          reduce using rule 83 (expression -> relational_expression .)
    COLON           reduce using rule 83 (expression -> relational_expression .)
>>>>>>> Stashed changes


state 35

<<<<<<< Updated upstream
    (62) primitive_type -> FLOAT64_TYPE .

    ASSIGN          reduce using rule 62 (primitive_type -> FLOAT64_TYPE .)
    VAR             reduce using rule 62 (primitive_type -> FLOAT64_TYPE .)
    CONST           reduce using rule 62 (primitive_type -> FLOAT64_TYPE .)
    FUNC            reduce using rule 62 (primitive_type -> FLOAT64_TYPE .)
    TYPE            reduce using rule 62 (primitive_type -> FLOAT64_TYPE .)
    $end            reduce using rule 62 (primitive_type -> FLOAT64_TYPE .)
    LBRACE          reduce using rule 62 (primitive_type -> FLOAT64_TYPE .)
    RPAREN          reduce using rule 62 (primitive_type -> FLOAT64_TYPE .)
    COMMA           reduce using rule 62 (primitive_type -> FLOAT64_TYPE .)
    RBRACE          reduce using rule 62 (primitive_type -> FLOAT64_TYPE .)
    IDENTIFIER      reduce using rule 62 (primitive_type -> FLOAT64_TYPE .)
    BREAK           reduce using rule 62 (primitive_type -> FLOAT64_TYPE .)
    CONTINUE        reduce using rule 62 (primitive_type -> FLOAT64_TYPE .)
    LPAREN          reduce using rule 62 (primitive_type -> FLOAT64_TYPE .)
    INT             reduce using rule 62 (primitive_type -> FLOAT64_TYPE .)
    FLOAT64         reduce using rule 62 (primitive_type -> FLOAT64_TYPE .)
    STRING          reduce using rule 62 (primitive_type -> FLOAT64_TYPE .)
    TRUE            reduce using rule 62 (primitive_type -> FLOAT64_TYPE .)
    FALSE           reduce using rule 62 (primitive_type -> FLOAT64_TYPE .)
    LNOT            reduce using rule 62 (primitive_type -> FLOAT64_TYPE .)
    IF              reduce using rule 62 (primitive_type -> FLOAT64_TYPE .)
    SWITCH          reduce using rule 62 (primitive_type -> FLOAT64_TYPE .)
    RETURN          reduce using rule 62 (primitive_type -> FLOAT64_TYPE .)
    LBRACKET        reduce using rule 62 (primitive_type -> FLOAT64_TYPE .)
    MAP             reduce using rule 62 (primitive_type -> FLOAT64_TYPE .)
    FOR             reduce using rule 62 (primitive_type -> FLOAT64_TYPE .)
    SEMICOLON       reduce using rule 62 (primitive_type -> FLOAT64_TYPE .)
    CASE            reduce using rule 62 (primitive_type -> FLOAT64_TYPE .)
    DEFAULT         reduce using rule 62 (primitive_type -> FLOAT64_TYPE .)
    RBRACKET        reduce using rule 62 (primitive_type -> FLOAT64_TYPE .)
=======
    (84) expression -> logical_expression .

    DOT             reduce using rule 84 (expression -> logical_expression .)
    PLUS            reduce using rule 84 (expression -> logical_expression .)
    MINUS           reduce using rule 84 (expression -> logical_expression .)
    TIMES           reduce using rule 84 (expression -> logical_expression .)
    DIVIDE          reduce using rule 84 (expression -> logical_expression .)
    MODULE          reduce using rule 84 (expression -> logical_expression .)
    EQ              reduce using rule 84 (expression -> logical_expression .)
    NEQ             reduce using rule 84 (expression -> logical_expression .)
    LT              reduce using rule 84 (expression -> logical_expression .)
    LE              reduce using rule 84 (expression -> logical_expression .)
    GT              reduce using rule 84 (expression -> logical_expression .)
    GE              reduce using rule 84 (expression -> logical_expression .)
    LAND            reduce using rule 84 (expression -> logical_expression .)
    LOR             reduce using rule 84 (expression -> logical_expression .)
    AND             reduce using rule 84 (expression -> logical_expression .)
    OR              reduce using rule 84 (expression -> logical_expression .)
    XOR             reduce using rule 84 (expression -> logical_expression .)
    AND_NOT         reduce using rule 84 (expression -> logical_expression .)
    LSHIFT          reduce using rule 84 (expression -> logical_expression .)
    RSHIFT          reduce using rule 84 (expression -> logical_expression .)
    SEMICOLON       reduce using rule 84 (expression -> logical_expression .)
    FUNC            reduce using rule 84 (expression -> logical_expression .)
    TYPE            reduce using rule 84 (expression -> logical_expression .)
    IDENTIFIER      reduce using rule 84 (expression -> logical_expression .)
    VAR             reduce using rule 84 (expression -> logical_expression .)
    CONST           reduce using rule 84 (expression -> logical_expression .)
    LNOT            reduce using rule 84 (expression -> logical_expression .)
    LBRACKET        reduce using rule 84 (expression -> logical_expression .)
    LPAREN          reduce using rule 84 (expression -> logical_expression .)
    INT             reduce using rule 84 (expression -> logical_expression .)
    FLOAT64         reduce using rule 84 (expression -> logical_expression .)
    TRUE            reduce using rule 84 (expression -> logical_expression .)
    FALSE           reduce using rule 84 (expression -> logical_expression .)
    STRING          reduce using rule 84 (expression -> logical_expression .)
    RETURN          reduce using rule 84 (expression -> logical_expression .)
    FOR             reduce using rule 84 (expression -> logical_expression .)
    IF              reduce using rule 84 (expression -> logical_expression .)
    SWITCH          reduce using rule 84 (expression -> logical_expression .)
    BREAK           reduce using rule 84 (expression -> logical_expression .)
    CONTINUE        reduce using rule 84 (expression -> logical_expression .)
    FALLTHROUGH     reduce using rule 84 (expression -> logical_expression .)
    $end            reduce using rule 84 (expression -> logical_expression .)
    RPAREN          reduce using rule 84 (expression -> logical_expression .)
    COMMA           reduce using rule 84 (expression -> logical_expression .)
    RBRACE          reduce using rule 84 (expression -> logical_expression .)
    CASE            reduce using rule 84 (expression -> logical_expression .)
    DEFAULT         reduce using rule 84 (expression -> logical_expression .)
    LBRACE          reduce using rule 84 (expression -> logical_expression .)
    COLON           reduce using rule 84 (expression -> logical_expression .)
>>>>>>> Stashed changes


state 36

<<<<<<< Updated upstream
    (63) primitive_type -> STRING_TYPE .

    ASSIGN          reduce using rule 63 (primitive_type -> STRING_TYPE .)
    VAR             reduce using rule 63 (primitive_type -> STRING_TYPE .)
    CONST           reduce using rule 63 (primitive_type -> STRING_TYPE .)
    FUNC            reduce using rule 63 (primitive_type -> STRING_TYPE .)
    TYPE            reduce using rule 63 (primitive_type -> STRING_TYPE .)
    $end            reduce using rule 63 (primitive_type -> STRING_TYPE .)
    LBRACE          reduce using rule 63 (primitive_type -> STRING_TYPE .)
    RPAREN          reduce using rule 63 (primitive_type -> STRING_TYPE .)
    COMMA           reduce using rule 63 (primitive_type -> STRING_TYPE .)
    RBRACE          reduce using rule 63 (primitive_type -> STRING_TYPE .)
    IDENTIFIER      reduce using rule 63 (primitive_type -> STRING_TYPE .)
    BREAK           reduce using rule 63 (primitive_type -> STRING_TYPE .)
    CONTINUE        reduce using rule 63 (primitive_type -> STRING_TYPE .)
    LPAREN          reduce using rule 63 (primitive_type -> STRING_TYPE .)
    INT             reduce using rule 63 (primitive_type -> STRING_TYPE .)
    FLOAT64         reduce using rule 63 (primitive_type -> STRING_TYPE .)
    STRING          reduce using rule 63 (primitive_type -> STRING_TYPE .)
    TRUE            reduce using rule 63 (primitive_type -> STRING_TYPE .)
    FALSE           reduce using rule 63 (primitive_type -> STRING_TYPE .)
    LNOT            reduce using rule 63 (primitive_type -> STRING_TYPE .)
    IF              reduce using rule 63 (primitive_type -> STRING_TYPE .)
    SWITCH          reduce using rule 63 (primitive_type -> STRING_TYPE .)
    RETURN          reduce using rule 63 (primitive_type -> STRING_TYPE .)
    LBRACKET        reduce using rule 63 (primitive_type -> STRING_TYPE .)
    MAP             reduce using rule 63 (primitive_type -> STRING_TYPE .)
    FOR             reduce using rule 63 (primitive_type -> STRING_TYPE .)
    SEMICOLON       reduce using rule 63 (primitive_type -> STRING_TYPE .)
    CASE            reduce using rule 63 (primitive_type -> STRING_TYPE .)
    DEFAULT         reduce using rule 63 (primitive_type -> STRING_TYPE .)
    RBRACKET        reduce using rule 63 (primitive_type -> STRING_TYPE .)
=======
    (85) expression -> bitwise_expression .

    DOT             reduce using rule 85 (expression -> bitwise_expression .)
    PLUS            reduce using rule 85 (expression -> bitwise_expression .)
    MINUS           reduce using rule 85 (expression -> bitwise_expression .)
    TIMES           reduce using rule 85 (expression -> bitwise_expression .)
    DIVIDE          reduce using rule 85 (expression -> bitwise_expression .)
    MODULE          reduce using rule 85 (expression -> bitwise_expression .)
    EQ              reduce using rule 85 (expression -> bitwise_expression .)
    NEQ             reduce using rule 85 (expression -> bitwise_expression .)
    LT              reduce using rule 85 (expression -> bitwise_expression .)
    LE              reduce using rule 85 (expression -> bitwise_expression .)
    GT              reduce using rule 85 (expression -> bitwise_expression .)
    GE              reduce using rule 85 (expression -> bitwise_expression .)
    LAND            reduce using rule 85 (expression -> bitwise_expression .)
    LOR             reduce using rule 85 (expression -> bitwise_expression .)
    AND             reduce using rule 85 (expression -> bitwise_expression .)
    OR              reduce using rule 85 (expression -> bitwise_expression .)
    XOR             reduce using rule 85 (expression -> bitwise_expression .)
    AND_NOT         reduce using rule 85 (expression -> bitwise_expression .)
    LSHIFT          reduce using rule 85 (expression -> bitwise_expression .)
    RSHIFT          reduce using rule 85 (expression -> bitwise_expression .)
    SEMICOLON       reduce using rule 85 (expression -> bitwise_expression .)
    FUNC            reduce using rule 85 (expression -> bitwise_expression .)
    TYPE            reduce using rule 85 (expression -> bitwise_expression .)
    IDENTIFIER      reduce using rule 85 (expression -> bitwise_expression .)
    VAR             reduce using rule 85 (expression -> bitwise_expression .)
    CONST           reduce using rule 85 (expression -> bitwise_expression .)
    LNOT            reduce using rule 85 (expression -> bitwise_expression .)
    LBRACKET        reduce using rule 85 (expression -> bitwise_expression .)
    LPAREN          reduce using rule 85 (expression -> bitwise_expression .)
    INT             reduce using rule 85 (expression -> bitwise_expression .)
    FLOAT64         reduce using rule 85 (expression -> bitwise_expression .)
    TRUE            reduce using rule 85 (expression -> bitwise_expression .)
    FALSE           reduce using rule 85 (expression -> bitwise_expression .)
    STRING          reduce using rule 85 (expression -> bitwise_expression .)
    RETURN          reduce using rule 85 (expression -> bitwise_expression .)
    FOR             reduce using rule 85 (expression -> bitwise_expression .)
    IF              reduce using rule 85 (expression -> bitwise_expression .)
    SWITCH          reduce using rule 85 (expression -> bitwise_expression .)
    BREAK           reduce using rule 85 (expression -> bitwise_expression .)
    CONTINUE        reduce using rule 85 (expression -> bitwise_expression .)
    FALLTHROUGH     reduce using rule 85 (expression -> bitwise_expression .)
    $end            reduce using rule 85 (expression -> bitwise_expression .)
    RPAREN          reduce using rule 85 (expression -> bitwise_expression .)
    COMMA           reduce using rule 85 (expression -> bitwise_expression .)
    RBRACE          reduce using rule 85 (expression -> bitwise_expression .)
    CASE            reduce using rule 85 (expression -> bitwise_expression .)
    DEFAULT         reduce using rule 85 (expression -> bitwise_expression .)
    LBRACE          reduce using rule 85 (expression -> bitwise_expression .)
    COLON           reduce using rule 85 (expression -> bitwise_expression .)
>>>>>>> Stashed changes


state 37

<<<<<<< Updated upstream
    (64) primitive_type -> BOOL_TYPE .

    ASSIGN          reduce using rule 64 (primitive_type -> BOOL_TYPE .)
    VAR             reduce using rule 64 (primitive_type -> BOOL_TYPE .)
    CONST           reduce using rule 64 (primitive_type -> BOOL_TYPE .)
    FUNC            reduce using rule 64 (primitive_type -> BOOL_TYPE .)
    TYPE            reduce using rule 64 (primitive_type -> BOOL_TYPE .)
    $end            reduce using rule 64 (primitive_type -> BOOL_TYPE .)
    LBRACE          reduce using rule 64 (primitive_type -> BOOL_TYPE .)
    RPAREN          reduce using rule 64 (primitive_type -> BOOL_TYPE .)
    COMMA           reduce using rule 64 (primitive_type -> BOOL_TYPE .)
    RBRACE          reduce using rule 64 (primitive_type -> BOOL_TYPE .)
    IDENTIFIER      reduce using rule 64 (primitive_type -> BOOL_TYPE .)
    BREAK           reduce using rule 64 (primitive_type -> BOOL_TYPE .)
    CONTINUE        reduce using rule 64 (primitive_type -> BOOL_TYPE .)
    LPAREN          reduce using rule 64 (primitive_type -> BOOL_TYPE .)
    INT             reduce using rule 64 (primitive_type -> BOOL_TYPE .)
    FLOAT64         reduce using rule 64 (primitive_type -> BOOL_TYPE .)
    STRING          reduce using rule 64 (primitive_type -> BOOL_TYPE .)
    TRUE            reduce using rule 64 (primitive_type -> BOOL_TYPE .)
    FALSE           reduce using rule 64 (primitive_type -> BOOL_TYPE .)
    LNOT            reduce using rule 64 (primitive_type -> BOOL_TYPE .)
    IF              reduce using rule 64 (primitive_type -> BOOL_TYPE .)
    SWITCH          reduce using rule 64 (primitive_type -> BOOL_TYPE .)
    RETURN          reduce using rule 64 (primitive_type -> BOOL_TYPE .)
    LBRACKET        reduce using rule 64 (primitive_type -> BOOL_TYPE .)
    MAP             reduce using rule 64 (primitive_type -> BOOL_TYPE .)
    FOR             reduce using rule 64 (primitive_type -> BOOL_TYPE .)
    SEMICOLON       reduce using rule 64 (primitive_type -> BOOL_TYPE .)
    CASE            reduce using rule 64 (primitive_type -> BOOL_TYPE .)
    DEFAULT         reduce using rule 64 (primitive_type -> BOOL_TYPE .)
    RBRACKET        reduce using rule 64 (primitive_type -> BOOL_TYPE .)
=======
    (86) expression -> PLUS . expression
    (82) expression -> . binary_expression
    (83) expression -> . relational_expression
    (84) expression -> . logical_expression
    (85) expression -> . bitwise_expression
    (86) expression -> . PLUS expression
    (87) expression -> . MINUS expression
    (88) expression -> . LNOT expression
    (89) expression -> . LBRACKET RBRACKET primitive_type LBRACE expression_list RBRACE
    (90) expression -> . LBRACKET RBRACKET primitive_type LBRACE RBRACE
    (91) expression -> . LPAREN expression RPAREN
    (92) expression -> . INT
    (93) expression -> . FLOAT64
    (94) expression -> . TRUE
    (95) expression -> . FALSE
    (96) expression -> . IDENTIFIER
    (97) expression -> . STRING
    (98) expression -> . IDENTIFIER PLUSPLUS
    (99) expression -> . IDENTIFIER MINUSMINUS
    (100) expression -> . expression DOT IDENTIFIER
    (103) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (133) expression -> . IDENTIFIER LBRACE keyed_element_list RBRACE
    (134) expression -> . IDENTIFIER LBRACE RBRACE
    (135) binary_expression -> . expression PLUS expression
    (136) binary_expression -> . expression MINUS expression
    (137) binary_expression -> . expression TIMES expression
    (138) binary_expression -> . expression DIVIDE expression
    (139) binary_expression -> . expression MODULE expression
    (144) relational_expression -> . expression EQ expression
    (145) relational_expression -> . expression NEQ expression
    (146) relational_expression -> . expression LT expression
    (147) relational_expression -> . expression LE expression
    (148) relational_expression -> . expression GT expression
    (149) relational_expression -> . expression GE expression
    (150) logical_expression -> . expression LAND expression
    (151) logical_expression -> . expression LOR expression
    (152) bitwise_expression -> . expression AND expression
    (153) bitwise_expression -> . expression OR expression
    (154) bitwise_expression -> . expression XOR expression
    (155) bitwise_expression -> . expression AND_NOT expression
    (156) bitwise_expression -> . expression LSHIFT expression
    (157) bitwise_expression -> . expression RSHIFT expression

    PLUS            shift and go to state 37
    MINUS           shift and go to state 38
    LNOT            shift and go to state 39
    LBRACKET        shift and go to state 40
    LPAREN          shift and go to state 29
    INT             shift and go to state 41
    FLOAT64         shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44
    IDENTIFIER      shift and go to state 97
    STRING          shift and go to state 11
>>>>>>> Stashed changes

    expression                     shift and go to state 101
    binary_expression              shift and go to state 33
    relational_expression          shift and go to state 34
    logical_expression             shift and go to state 35
    bitwise_expression             shift and go to state 36

state 38

<<<<<<< Updated upstream
    (65) slice_type -> LBRACKET . RBRACKET primitive_type
    (197) array_type -> LBRACKET . INT RBRACKET primitive_type

    RBRACKET        shift and go to state 64
    INT             shift and go to state 65
=======
    (87) expression -> MINUS . expression
    (82) expression -> . binary_expression
    (83) expression -> . relational_expression
    (84) expression -> . logical_expression
    (85) expression -> . bitwise_expression
    (86) expression -> . PLUS expression
    (87) expression -> . MINUS expression
    (88) expression -> . LNOT expression
    (89) expression -> . LBRACKET RBRACKET primitive_type LBRACE expression_list RBRACE
    (90) expression -> . LBRACKET RBRACKET primitive_type LBRACE RBRACE
    (91) expression -> . LPAREN expression RPAREN
    (92) expression -> . INT
    (93) expression -> . FLOAT64
    (94) expression -> . TRUE
    (95) expression -> . FALSE
    (96) expression -> . IDENTIFIER
    (97) expression -> . STRING
    (98) expression -> . IDENTIFIER PLUSPLUS
    (99) expression -> . IDENTIFIER MINUSMINUS
    (100) expression -> . expression DOT IDENTIFIER
    (103) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (133) expression -> . IDENTIFIER LBRACE keyed_element_list RBRACE
    (134) expression -> . IDENTIFIER LBRACE RBRACE
    (135) binary_expression -> . expression PLUS expression
    (136) binary_expression -> . expression MINUS expression
    (137) binary_expression -> . expression TIMES expression
    (138) binary_expression -> . expression DIVIDE expression
    (139) binary_expression -> . expression MODULE expression
    (144) relational_expression -> . expression EQ expression
    (145) relational_expression -> . expression NEQ expression
    (146) relational_expression -> . expression LT expression
    (147) relational_expression -> . expression LE expression
    (148) relational_expression -> . expression GT expression
    (149) relational_expression -> . expression GE expression
    (150) logical_expression -> . expression LAND expression
    (151) logical_expression -> . expression LOR expression
    (152) bitwise_expression -> . expression AND expression
    (153) bitwise_expression -> . expression OR expression
    (154) bitwise_expression -> . expression XOR expression
    (155) bitwise_expression -> . expression AND_NOT expression
    (156) bitwise_expression -> . expression LSHIFT expression
    (157) bitwise_expression -> . expression RSHIFT expression

    PLUS            shift and go to state 37
    MINUS           shift and go to state 38
    LNOT            shift and go to state 39
    LBRACKET        shift and go to state 40
    LPAREN          shift and go to state 29
    INT             shift and go to state 41
    FLOAT64         shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44
    IDENTIFIER      shift and go to state 97
    STRING          shift and go to state 11
>>>>>>> Stashed changes

    expression                     shift and go to state 102
    binary_expression              shift and go to state 33
    relational_expression          shift and go to state 34
    logical_expression             shift and go to state 35
    bitwise_expression             shift and go to state 36

state 39

<<<<<<< Updated upstream
    (137) map_type -> MAP . LBRACKET primitive_type RBRACKET primitive_type

    LBRACKET        shift and go to state 66
=======
    (88) expression -> LNOT . expression
    (82) expression -> . binary_expression
    (83) expression -> . relational_expression
    (84) expression -> . logical_expression
    (85) expression -> . bitwise_expression
    (86) expression -> . PLUS expression
    (87) expression -> . MINUS expression
    (88) expression -> . LNOT expression
    (89) expression -> . LBRACKET RBRACKET primitive_type LBRACE expression_list RBRACE
    (90) expression -> . LBRACKET RBRACKET primitive_type LBRACE RBRACE
    (91) expression -> . LPAREN expression RPAREN
    (92) expression -> . INT
    (93) expression -> . FLOAT64
    (94) expression -> . TRUE
    (95) expression -> . FALSE
    (96) expression -> . IDENTIFIER
    (97) expression -> . STRING
    (98) expression -> . IDENTIFIER PLUSPLUS
    (99) expression -> . IDENTIFIER MINUSMINUS
    (100) expression -> . expression DOT IDENTIFIER
    (103) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (133) expression -> . IDENTIFIER LBRACE keyed_element_list RBRACE
    (134) expression -> . IDENTIFIER LBRACE RBRACE
    (135) binary_expression -> . expression PLUS expression
    (136) binary_expression -> . expression MINUS expression
    (137) binary_expression -> . expression TIMES expression
    (138) binary_expression -> . expression DIVIDE expression
    (139) binary_expression -> . expression MODULE expression
    (144) relational_expression -> . expression EQ expression
    (145) relational_expression -> . expression NEQ expression
    (146) relational_expression -> . expression LT expression
    (147) relational_expression -> . expression LE expression
    (148) relational_expression -> . expression GT expression
    (149) relational_expression -> . expression GE expression
    (150) logical_expression -> . expression LAND expression
    (151) logical_expression -> . expression LOR expression
    (152) bitwise_expression -> . expression AND expression
    (153) bitwise_expression -> . expression OR expression
    (154) bitwise_expression -> . expression XOR expression
    (155) bitwise_expression -> . expression AND_NOT expression
    (156) bitwise_expression -> . expression LSHIFT expression
    (157) bitwise_expression -> . expression RSHIFT expression

    PLUS            shift and go to state 37
    MINUS           shift and go to state 38
    LNOT            shift and go to state 39
    LBRACKET        shift and go to state 40
    LPAREN          shift and go to state 29
    INT             shift and go to state 41
    FLOAT64         shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44
    IDENTIFIER      shift and go to state 97
    STRING          shift and go to state 11
>>>>>>> Stashed changes

    expression                     shift and go to state 103
    binary_expression              shift and go to state 33
    relational_expression          shift and go to state 34
    logical_expression             shift and go to state 35
    bitwise_expression             shift and go to state 36

state 40

<<<<<<< Updated upstream
    (18) global_const_dec -> CONST IDENTIFIER type . ASSIGN expression

    ASSIGN          shift and go to state 67


state 41

    (19) global_const_dec -> CONST IDENTIFIER ASSIGN . expression
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (125) expression -> . LNOT expression
    (126) expression -> . IDENTIFIER PLUSPLUS
    (127) expression -> . IDENTIFIER MINUSMINUS
    (138) expression -> . map_type LBRACE expression_map_list RBRACE
    (139) expression -> . map_type LBRACE RBRACE
    (161) expression -> . type_name LBRACE keyed_element_list RBRACE
    (162) expression -> . type_name LBRACE RBRACE
    (198) expression -> . array_type LBRACE expression_list RBRACE
    (199) expression -> . array_type LBRACE RBRACE
    (200) expression -> . expression DOT IDENTIFIER
    (201) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> . expression LBRACKET expression RBRACKET
    (203) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (137) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (163) type_name -> . IDENTIFIER
    (164) type_name -> . slice_type
    (165) type_name -> . array_type
    (166) type_name -> . map_type
    (197) array_type -> . LBRACKET INT RBRACKET primitive_type

    LPAREN          shift and go to state 54
    INT             shift and go to state 55
    FLOAT64         shift and go to state 56
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 57
    TRUE            shift and go to state 58
    FALSE           shift and go to state 59
    LNOT            shift and go to state 60
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    expression                     shift and go to state 68
    slice_type                     shift and go to state 53
    map_type                       shift and go to state 61
    type_name                      shift and go to state 62
    array_type                     shift and go to state 63

state 42

    (112) function_declaration -> FUNC IDENTIFIER LPAREN . parameter_list RPAREN return_type block
    (113) parameter_list -> . parameter_list COMMA parameter
    (114) parameter_list -> . parameter
    (115) parameter_list -> . empty
    (116) parameter -> . IDENTIFIER type
    (117) parameter -> . IDENTIFIER ELLIPSIS primitive_type
    (7) empty -> .

    IDENTIFIER      shift and go to state 69
    RPAREN          reduce using rule 7 (empty -> .)
    COMMA           reduce using rule 7 (empty -> .)

    parameter_list                 shift and go to state 70
    parameter                      shift and go to state 71
    empty                          shift and go to state 72

state 43

    (146) method_declaration -> FUNC LPAREN receiver . RPAREN IDENTIFIER LPAREN parameter_list RPAREN return_type block

    RPAREN          shift and go to state 73


state 44

    (147) receiver -> IDENTIFIER . IDENTIFIER
    (148) receiver -> IDENTIFIER . TIMES IDENTIFIER
    (149) receiver -> IDENTIFIER . TIMES type

    IDENTIFIER      shift and go to state 74
    TIMES           shift and go to state 75


state 45

    (153) type_alias -> IDENTIFIER .

    VAR             reduce using rule 153 (type_alias -> IDENTIFIER .)
    CONST           reduce using rule 153 (type_alias -> IDENTIFIER .)
    FUNC            reduce using rule 153 (type_alias -> IDENTIFIER .)
    TYPE            reduce using rule 153 (type_alias -> IDENTIFIER .)
    $end            reduce using rule 153 (type_alias -> IDENTIFIER .)
=======
    (89) expression -> LBRACKET . RBRACKET primitive_type LBRACE expression_list RBRACE
    (90) expression -> LBRACKET . RBRACKET primitive_type LBRACE RBRACE

    RBRACKET        shift and go to state 104


state 41

    (92) expression -> INT .

    DOT             reduce using rule 92 (expression -> INT .)
    PLUS            reduce using rule 92 (expression -> INT .)
    MINUS           reduce using rule 92 (expression -> INT .)
    TIMES           reduce using rule 92 (expression -> INT .)
    DIVIDE          reduce using rule 92 (expression -> INT .)
    MODULE          reduce using rule 92 (expression -> INT .)
    EQ              reduce using rule 92 (expression -> INT .)
    NEQ             reduce using rule 92 (expression -> INT .)
    LT              reduce using rule 92 (expression -> INT .)
    LE              reduce using rule 92 (expression -> INT .)
    GT              reduce using rule 92 (expression -> INT .)
    GE              reduce using rule 92 (expression -> INT .)
    LAND            reduce using rule 92 (expression -> INT .)
    LOR             reduce using rule 92 (expression -> INT .)
    AND             reduce using rule 92 (expression -> INT .)
    OR              reduce using rule 92 (expression -> INT .)
    XOR             reduce using rule 92 (expression -> INT .)
    AND_NOT         reduce using rule 92 (expression -> INT .)
    LSHIFT          reduce using rule 92 (expression -> INT .)
    RSHIFT          reduce using rule 92 (expression -> INT .)
    SEMICOLON       reduce using rule 92 (expression -> INT .)
    FUNC            reduce using rule 92 (expression -> INT .)
    TYPE            reduce using rule 92 (expression -> INT .)
    IDENTIFIER      reduce using rule 92 (expression -> INT .)
    VAR             reduce using rule 92 (expression -> INT .)
    CONST           reduce using rule 92 (expression -> INT .)
    LNOT            reduce using rule 92 (expression -> INT .)
    LBRACKET        reduce using rule 92 (expression -> INT .)
    LPAREN          reduce using rule 92 (expression -> INT .)
    INT             reduce using rule 92 (expression -> INT .)
    FLOAT64         reduce using rule 92 (expression -> INT .)
    TRUE            reduce using rule 92 (expression -> INT .)
    FALSE           reduce using rule 92 (expression -> INT .)
    STRING          reduce using rule 92 (expression -> INT .)
    RETURN          reduce using rule 92 (expression -> INT .)
    FOR             reduce using rule 92 (expression -> INT .)
    IF              reduce using rule 92 (expression -> INT .)
    SWITCH          reduce using rule 92 (expression -> INT .)
    BREAK           reduce using rule 92 (expression -> INT .)
    CONTINUE        reduce using rule 92 (expression -> INT .)
    FALLTHROUGH     reduce using rule 92 (expression -> INT .)
    $end            reduce using rule 92 (expression -> INT .)
    RPAREN          reduce using rule 92 (expression -> INT .)
    COMMA           reduce using rule 92 (expression -> INT .)
    RBRACE          reduce using rule 92 (expression -> INT .)
    CASE            reduce using rule 92 (expression -> INT .)
    DEFAULT         reduce using rule 92 (expression -> INT .)
    LBRACE          reduce using rule 92 (expression -> INT .)
    COLON           reduce using rule 92 (expression -> INT .)


state 42

    (93) expression -> FLOAT64 .

    DOT             reduce using rule 93 (expression -> FLOAT64 .)
    PLUS            reduce using rule 93 (expression -> FLOAT64 .)
    MINUS           reduce using rule 93 (expression -> FLOAT64 .)
    TIMES           reduce using rule 93 (expression -> FLOAT64 .)
    DIVIDE          reduce using rule 93 (expression -> FLOAT64 .)
    MODULE          reduce using rule 93 (expression -> FLOAT64 .)
    EQ              reduce using rule 93 (expression -> FLOAT64 .)
    NEQ             reduce using rule 93 (expression -> FLOAT64 .)
    LT              reduce using rule 93 (expression -> FLOAT64 .)
    LE              reduce using rule 93 (expression -> FLOAT64 .)
    GT              reduce using rule 93 (expression -> FLOAT64 .)
    GE              reduce using rule 93 (expression -> FLOAT64 .)
    LAND            reduce using rule 93 (expression -> FLOAT64 .)
    LOR             reduce using rule 93 (expression -> FLOAT64 .)
    AND             reduce using rule 93 (expression -> FLOAT64 .)
    OR              reduce using rule 93 (expression -> FLOAT64 .)
    XOR             reduce using rule 93 (expression -> FLOAT64 .)
    AND_NOT         reduce using rule 93 (expression -> FLOAT64 .)
    LSHIFT          reduce using rule 93 (expression -> FLOAT64 .)
    RSHIFT          reduce using rule 93 (expression -> FLOAT64 .)
    SEMICOLON       reduce using rule 93 (expression -> FLOAT64 .)
    FUNC            reduce using rule 93 (expression -> FLOAT64 .)
    TYPE            reduce using rule 93 (expression -> FLOAT64 .)
    IDENTIFIER      reduce using rule 93 (expression -> FLOAT64 .)
    VAR             reduce using rule 93 (expression -> FLOAT64 .)
    CONST           reduce using rule 93 (expression -> FLOAT64 .)
    LNOT            reduce using rule 93 (expression -> FLOAT64 .)
    LBRACKET        reduce using rule 93 (expression -> FLOAT64 .)
    LPAREN          reduce using rule 93 (expression -> FLOAT64 .)
    INT             reduce using rule 93 (expression -> FLOAT64 .)
    FLOAT64         reduce using rule 93 (expression -> FLOAT64 .)
    TRUE            reduce using rule 93 (expression -> FLOAT64 .)
    FALSE           reduce using rule 93 (expression -> FLOAT64 .)
    STRING          reduce using rule 93 (expression -> FLOAT64 .)
    RETURN          reduce using rule 93 (expression -> FLOAT64 .)
    FOR             reduce using rule 93 (expression -> FLOAT64 .)
    IF              reduce using rule 93 (expression -> FLOAT64 .)
    SWITCH          reduce using rule 93 (expression -> FLOAT64 .)
    BREAK           reduce using rule 93 (expression -> FLOAT64 .)
    CONTINUE        reduce using rule 93 (expression -> FLOAT64 .)
    FALLTHROUGH     reduce using rule 93 (expression -> FLOAT64 .)
    $end            reduce using rule 93 (expression -> FLOAT64 .)
    RPAREN          reduce using rule 93 (expression -> FLOAT64 .)
    COMMA           reduce using rule 93 (expression -> FLOAT64 .)
    RBRACE          reduce using rule 93 (expression -> FLOAT64 .)
    CASE            reduce using rule 93 (expression -> FLOAT64 .)
    DEFAULT         reduce using rule 93 (expression -> FLOAT64 .)
    LBRACE          reduce using rule 93 (expression -> FLOAT64 .)
    COLON           reduce using rule 93 (expression -> FLOAT64 .)


state 43

    (94) expression -> TRUE .

    DOT             reduce using rule 94 (expression -> TRUE .)
    PLUS            reduce using rule 94 (expression -> TRUE .)
    MINUS           reduce using rule 94 (expression -> TRUE .)
    TIMES           reduce using rule 94 (expression -> TRUE .)
    DIVIDE          reduce using rule 94 (expression -> TRUE .)
    MODULE          reduce using rule 94 (expression -> TRUE .)
    EQ              reduce using rule 94 (expression -> TRUE .)
    NEQ             reduce using rule 94 (expression -> TRUE .)
    LT              reduce using rule 94 (expression -> TRUE .)
    LE              reduce using rule 94 (expression -> TRUE .)
    GT              reduce using rule 94 (expression -> TRUE .)
    GE              reduce using rule 94 (expression -> TRUE .)
    LAND            reduce using rule 94 (expression -> TRUE .)
    LOR             reduce using rule 94 (expression -> TRUE .)
    AND             reduce using rule 94 (expression -> TRUE .)
    OR              reduce using rule 94 (expression -> TRUE .)
    XOR             reduce using rule 94 (expression -> TRUE .)
    AND_NOT         reduce using rule 94 (expression -> TRUE .)
    LSHIFT          reduce using rule 94 (expression -> TRUE .)
    RSHIFT          reduce using rule 94 (expression -> TRUE .)
    SEMICOLON       reduce using rule 94 (expression -> TRUE .)
    FUNC            reduce using rule 94 (expression -> TRUE .)
    TYPE            reduce using rule 94 (expression -> TRUE .)
    IDENTIFIER      reduce using rule 94 (expression -> TRUE .)
    VAR             reduce using rule 94 (expression -> TRUE .)
    CONST           reduce using rule 94 (expression -> TRUE .)
    LNOT            reduce using rule 94 (expression -> TRUE .)
    LBRACKET        reduce using rule 94 (expression -> TRUE .)
    LPAREN          reduce using rule 94 (expression -> TRUE .)
    INT             reduce using rule 94 (expression -> TRUE .)
    FLOAT64         reduce using rule 94 (expression -> TRUE .)
    TRUE            reduce using rule 94 (expression -> TRUE .)
    FALSE           reduce using rule 94 (expression -> TRUE .)
    STRING          reduce using rule 94 (expression -> TRUE .)
    RETURN          reduce using rule 94 (expression -> TRUE .)
    FOR             reduce using rule 94 (expression -> TRUE .)
    IF              reduce using rule 94 (expression -> TRUE .)
    SWITCH          reduce using rule 94 (expression -> TRUE .)
    BREAK           reduce using rule 94 (expression -> TRUE .)
    CONTINUE        reduce using rule 94 (expression -> TRUE .)
    FALLTHROUGH     reduce using rule 94 (expression -> TRUE .)
    $end            reduce using rule 94 (expression -> TRUE .)
    RPAREN          reduce using rule 94 (expression -> TRUE .)
    COMMA           reduce using rule 94 (expression -> TRUE .)
    RBRACE          reduce using rule 94 (expression -> TRUE .)
    CASE            reduce using rule 94 (expression -> TRUE .)
    DEFAULT         reduce using rule 94 (expression -> TRUE .)
    LBRACE          reduce using rule 94 (expression -> TRUE .)
    COLON           reduce using rule 94 (expression -> TRUE .)


state 44

    (95) expression -> FALSE .

    DOT             reduce using rule 95 (expression -> FALSE .)
    PLUS            reduce using rule 95 (expression -> FALSE .)
    MINUS           reduce using rule 95 (expression -> FALSE .)
    TIMES           reduce using rule 95 (expression -> FALSE .)
    DIVIDE          reduce using rule 95 (expression -> FALSE .)
    MODULE          reduce using rule 95 (expression -> FALSE .)
    EQ              reduce using rule 95 (expression -> FALSE .)
    NEQ             reduce using rule 95 (expression -> FALSE .)
    LT              reduce using rule 95 (expression -> FALSE .)
    LE              reduce using rule 95 (expression -> FALSE .)
    GT              reduce using rule 95 (expression -> FALSE .)
    GE              reduce using rule 95 (expression -> FALSE .)
    LAND            reduce using rule 95 (expression -> FALSE .)
    LOR             reduce using rule 95 (expression -> FALSE .)
    AND             reduce using rule 95 (expression -> FALSE .)
    OR              reduce using rule 95 (expression -> FALSE .)
    XOR             reduce using rule 95 (expression -> FALSE .)
    AND_NOT         reduce using rule 95 (expression -> FALSE .)
    LSHIFT          reduce using rule 95 (expression -> FALSE .)
    RSHIFT          reduce using rule 95 (expression -> FALSE .)
    SEMICOLON       reduce using rule 95 (expression -> FALSE .)
    FUNC            reduce using rule 95 (expression -> FALSE .)
    TYPE            reduce using rule 95 (expression -> FALSE .)
    IDENTIFIER      reduce using rule 95 (expression -> FALSE .)
    VAR             reduce using rule 95 (expression -> FALSE .)
    CONST           reduce using rule 95 (expression -> FALSE .)
    LNOT            reduce using rule 95 (expression -> FALSE .)
    LBRACKET        reduce using rule 95 (expression -> FALSE .)
    LPAREN          reduce using rule 95 (expression -> FALSE .)
    INT             reduce using rule 95 (expression -> FALSE .)
    FLOAT64         reduce using rule 95 (expression -> FALSE .)
    TRUE            reduce using rule 95 (expression -> FALSE .)
    FALSE           reduce using rule 95 (expression -> FALSE .)
    STRING          reduce using rule 95 (expression -> FALSE .)
    RETURN          reduce using rule 95 (expression -> FALSE .)
    FOR             reduce using rule 95 (expression -> FALSE .)
    IF              reduce using rule 95 (expression -> FALSE .)
    SWITCH          reduce using rule 95 (expression -> FALSE .)
    BREAK           reduce using rule 95 (expression -> FALSE .)
    CONTINUE        reduce using rule 95 (expression -> FALSE .)
    FALLTHROUGH     reduce using rule 95 (expression -> FALSE .)
    $end            reduce using rule 95 (expression -> FALSE .)
    RPAREN          reduce using rule 95 (expression -> FALSE .)
    COMMA           reduce using rule 95 (expression -> FALSE .)
    RBRACE          reduce using rule 95 (expression -> FALSE .)
    CASE            reduce using rule 95 (expression -> FALSE .)
    DEFAULT         reduce using rule 95 (expression -> FALSE .)
    LBRACE          reduce using rule 95 (expression -> FALSE .)
    COLON           reduce using rule 95 (expression -> FALSE .)


state 45

    (39) return_statement -> RETURN .
    (40) return_statement -> RETURN . return_list
    (41) return_list -> . expression
    (42) return_list -> . return_list COMMA expression
    (82) expression -> . binary_expression
    (83) expression -> . relational_expression
    (84) expression -> . logical_expression
    (85) expression -> . bitwise_expression
    (86) expression -> . PLUS expression
    (87) expression -> . MINUS expression
    (88) expression -> . LNOT expression
    (89) expression -> . LBRACKET RBRACKET primitive_type LBRACE expression_list RBRACE
    (90) expression -> . LBRACKET RBRACKET primitive_type LBRACE RBRACE
    (91) expression -> . LPAREN expression RPAREN
    (92) expression -> . INT
    (93) expression -> . FLOAT64
    (94) expression -> . TRUE
    (95) expression -> . FALSE
    (96) expression -> . IDENTIFIER
    (97) expression -> . STRING
    (98) expression -> . IDENTIFIER PLUSPLUS
    (99) expression -> . IDENTIFIER MINUSMINUS
    (100) expression -> . expression DOT IDENTIFIER
    (103) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (133) expression -> . IDENTIFIER LBRACE keyed_element_list RBRACE
    (134) expression -> . IDENTIFIER LBRACE RBRACE
    (135) binary_expression -> . expression PLUS expression
    (136) binary_expression -> . expression MINUS expression
    (137) binary_expression -> . expression TIMES expression
    (138) binary_expression -> . expression DIVIDE expression
    (139) binary_expression -> . expression MODULE expression
    (144) relational_expression -> . expression EQ expression
    (145) relational_expression -> . expression NEQ expression
    (146) relational_expression -> . expression LT expression
    (147) relational_expression -> . expression LE expression
    (148) relational_expression -> . expression GT expression
    (149) relational_expression -> . expression GE expression
    (150) logical_expression -> . expression LAND expression
    (151) logical_expression -> . expression LOR expression
    (152) bitwise_expression -> . expression AND expression
    (153) bitwise_expression -> . expression OR expression
    (154) bitwise_expression -> . expression XOR expression
    (155) bitwise_expression -> . expression AND_NOT expression
    (156) bitwise_expression -> . expression LSHIFT expression
    (157) bitwise_expression -> . expression RSHIFT expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for LNOT resolved as shift
  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT64 resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
    SEMICOLON       reduce using rule 39 (return_statement -> RETURN .)
    FUNC            reduce using rule 39 (return_statement -> RETURN .)
    TYPE            reduce using rule 39 (return_statement -> RETURN .)
    VAR             reduce using rule 39 (return_statement -> RETURN .)
    CONST           reduce using rule 39 (return_statement -> RETURN .)
    RETURN          reduce using rule 39 (return_statement -> RETURN .)
    FOR             reduce using rule 39 (return_statement -> RETURN .)
    IF              reduce using rule 39 (return_statement -> RETURN .)
    SWITCH          reduce using rule 39 (return_statement -> RETURN .)
    BREAK           reduce using rule 39 (return_statement -> RETURN .)
    CONTINUE        reduce using rule 39 (return_statement -> RETURN .)
    FALLTHROUGH     reduce using rule 39 (return_statement -> RETURN .)
    $end            reduce using rule 39 (return_statement -> RETURN .)
    RBRACE          reduce using rule 39 (return_statement -> RETURN .)
    CASE            reduce using rule 39 (return_statement -> RETURN .)
    DEFAULT         reduce using rule 39 (return_statement -> RETURN .)
    PLUS            shift and go to state 37
    MINUS           shift and go to state 38
    LNOT            shift and go to state 39
    LBRACKET        shift and go to state 40
    LPAREN          shift and go to state 29
    INT             shift and go to state 41
    FLOAT64         shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44
    IDENTIFIER      shift and go to state 97
    STRING          shift and go to state 11

  ! IDENTIFIER      [ reduce using rule 39 (return_statement -> RETURN .) ]
  ! PLUS            [ reduce using rule 39 (return_statement -> RETURN .) ]
  ! MINUS           [ reduce using rule 39 (return_statement -> RETURN .) ]
  ! LNOT            [ reduce using rule 39 (return_statement -> RETURN .) ]
  ! LBRACKET        [ reduce using rule 39 (return_statement -> RETURN .) ]
  ! LPAREN          [ reduce using rule 39 (return_statement -> RETURN .) ]
  ! INT             [ reduce using rule 39 (return_statement -> RETURN .) ]
  ! FLOAT64         [ reduce using rule 39 (return_statement -> RETURN .) ]
  ! TRUE            [ reduce using rule 39 (return_statement -> RETURN .) ]
  ! FALSE           [ reduce using rule 39 (return_statement -> RETURN .) ]
  ! STRING          [ reduce using rule 39 (return_statement -> RETURN .) ]
>>>>>>> Stashed changes

    return_list                    shift and go to state 105
    expression                     shift and go to state 106
    binary_expression              shift and go to state 33
    relational_expression          shift and go to state 34
    logical_expression             shift and go to state 35
    bitwise_expression             shift and go to state 36

state 46

<<<<<<< Updated upstream
    (150) type_declaration -> TYPE IDENTIFIER type_alias .

    VAR             reduce using rule 150 (type_declaration -> TYPE IDENTIFIER type_alias .)
    CONST           reduce using rule 150 (type_declaration -> TYPE IDENTIFIER type_alias .)
    FUNC            reduce using rule 150 (type_declaration -> TYPE IDENTIFIER type_alias .)
    TYPE            reduce using rule 150 (type_declaration -> TYPE IDENTIFIER type_alias .)
    $end            reduce using rule 150 (type_declaration -> TYPE IDENTIFIER type_alias .)
=======
    (33) for_statement -> FOR . expression block
    (34) for_statement -> FOR . block
    (35) for_statement -> FOR . for_clause block
    (82) expression -> . binary_expression
    (83) expression -> . relational_expression
    (84) expression -> . logical_expression
    (85) expression -> . bitwise_expression
    (86) expression -> . PLUS expression
    (87) expression -> . MINUS expression
    (88) expression -> . LNOT expression
    (89) expression -> . LBRACKET RBRACKET primitive_type LBRACE expression_list RBRACE
    (90) expression -> . LBRACKET RBRACKET primitive_type LBRACE RBRACE
    (91) expression -> . LPAREN expression RPAREN
    (92) expression -> . INT
    (93) expression -> . FLOAT64
    (94) expression -> . TRUE
    (95) expression -> . FALSE
    (96) expression -> . IDENTIFIER
    (97) expression -> . STRING
    (98) expression -> . IDENTIFIER PLUSPLUS
    (99) expression -> . IDENTIFIER MINUSMINUS
    (100) expression -> . expression DOT IDENTIFIER
    (103) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (133) expression -> . IDENTIFIER LBRACE keyed_element_list RBRACE
    (134) expression -> . IDENTIFIER LBRACE RBRACE
    (16) block -> . LBRACE enter_block exit_block RBRACE
    (17) block -> . LBRACE enter_block statement_list exit_block RBRACE
    (36) for_clause -> . assignment SEMICOLON expression SEMICOLON assignment
    (37) for_clause -> . SEMICOLON expression SEMICOLON assignment
    (38) for_clause -> . SEMICOLON expression SEMICOLON
    (135) binary_expression -> . expression PLUS expression
    (136) binary_expression -> . expression MINUS expression
    (137) binary_expression -> . expression TIMES expression
    (138) binary_expression -> . expression DIVIDE expression
    (139) binary_expression -> . expression MODULE expression
    (144) relational_expression -> . expression EQ expression
    (145) relational_expression -> . expression NEQ expression
    (146) relational_expression -> . expression LT expression
    (147) relational_expression -> . expression LE expression
    (148) relational_expression -> . expression GT expression
    (149) relational_expression -> . expression GE expression
    (150) logical_expression -> . expression LAND expression
    (151) logical_expression -> . expression LOR expression
    (152) bitwise_expression -> . expression AND expression
    (153) bitwise_expression -> . expression OR expression
    (154) bitwise_expression -> . expression XOR expression
    (155) bitwise_expression -> . expression AND_NOT expression
    (156) bitwise_expression -> . expression LSHIFT expression
    (157) bitwise_expression -> . expression RSHIFT expression
    (54) assignment -> . IDENTIFIER ASSIGN expression
    (55) assignment -> . IDENTIFIER SHORT_ASSIGN expression

    PLUS            shift and go to state 37
    MINUS           shift and go to state 38
    LNOT            shift and go to state 39
    LBRACKET        shift and go to state 40
    LPAREN          shift and go to state 29
    INT             shift and go to state 41
    FLOAT64         shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44
    IDENTIFIER      shift and go to state 111
    STRING          shift and go to state 11
    LBRACE          shift and go to state 110
    SEMICOLON       shift and go to state 113

    expression                     shift and go to state 107
    block                          shift and go to state 108
    for_clause                     shift and go to state 109
    binary_expression              shift and go to state 33
    relational_expression          shift and go to state 34
    logical_expression             shift and go to state 35
    bitwise_expression             shift and go to state 36
    assignment                     shift and go to state 112

state 47

    (106) if_statement -> IF . expression block
    (107) if_statement -> IF . expression block ELSE block
    (108) if_statement -> IF . expression block ELSE if_statement
    (109) if_statement -> IF . assignment SEMICOLON expression block
    (110) if_statement -> IF . assignment SEMICOLON expression block ELSE block
    (111) if_statement -> IF . assignment SEMICOLON expression block ELSE if_statement
    (82) expression -> . binary_expression
    (83) expression -> . relational_expression
    (84) expression -> . logical_expression
    (85) expression -> . bitwise_expression
    (86) expression -> . PLUS expression
    (87) expression -> . MINUS expression
    (88) expression -> . LNOT expression
    (89) expression -> . LBRACKET RBRACKET primitive_type LBRACE expression_list RBRACE
    (90) expression -> . LBRACKET RBRACKET primitive_type LBRACE RBRACE
    (91) expression -> . LPAREN expression RPAREN
    (92) expression -> . INT
    (93) expression -> . FLOAT64
    (94) expression -> . TRUE
    (95) expression -> . FALSE
    (96) expression -> . IDENTIFIER
    (97) expression -> . STRING
    (98) expression -> . IDENTIFIER PLUSPLUS
    (99) expression -> . IDENTIFIER MINUSMINUS
    (100) expression -> . expression DOT IDENTIFIER
    (103) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (133) expression -> . IDENTIFIER LBRACE keyed_element_list RBRACE
    (134) expression -> . IDENTIFIER LBRACE RBRACE
    (54) assignment -> . IDENTIFIER ASSIGN expression
    (55) assignment -> . IDENTIFIER SHORT_ASSIGN expression
    (135) binary_expression -> . expression PLUS expression
    (136) binary_expression -> . expression MINUS expression
    (137) binary_expression -> . expression TIMES expression
    (138) binary_expression -> . expression DIVIDE expression
    (139) binary_expression -> . expression MODULE expression
    (144) relational_expression -> . expression EQ expression
    (145) relational_expression -> . expression NEQ expression
    (146) relational_expression -> . expression LT expression
    (147) relational_expression -> . expression LE expression
    (148) relational_expression -> . expression GT expression
    (149) relational_expression -> . expression GE expression
    (150) logical_expression -> . expression LAND expression
    (151) logical_expression -> . expression LOR expression
    (152) bitwise_expression -> . expression AND expression
    (153) bitwise_expression -> . expression OR expression
    (154) bitwise_expression -> . expression XOR expression
    (155) bitwise_expression -> . expression AND_NOT expression
    (156) bitwise_expression -> . expression LSHIFT expression
    (157) bitwise_expression -> . expression RSHIFT expression

    PLUS            shift and go to state 37
    MINUS           shift and go to state 38
    LNOT            shift and go to state 39
    LBRACKET        shift and go to state 40
    LPAREN          shift and go to state 29
    INT             shift and go to state 41
    FLOAT64         shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44
    IDENTIFIER      shift and go to state 111
    STRING          shift and go to state 11

    expression                     shift and go to state 114
    assignment                     shift and go to state 115
    binary_expression              shift and go to state 33
    relational_expression          shift and go to state 34
    logical_expression             shift and go to state 35
    bitwise_expression             shift and go to state 36

state 48

    (189) switch_statement -> SWITCH . enter_block switch_header LBRACE case_clauses RBRACE exit_block
    (167) enter_block -> .

    IDENTIFIER      reduce using rule 167 (enter_block -> .)
    INT             reduce using rule 167 (enter_block -> .)
    FLOAT64         reduce using rule 167 (enter_block -> .)
    STRING          reduce using rule 167 (enter_block -> .)
    TRUE            reduce using rule 167 (enter_block -> .)
    FALSE           reduce using rule 167 (enter_block -> .)
    LBRACE          reduce using rule 167 (enter_block -> .)

    enter_block                    shift and go to state 116

state 49

    (31) break_statement -> BREAK .

    SEMICOLON       reduce using rule 31 (break_statement -> BREAK .)
    FUNC            reduce using rule 31 (break_statement -> BREAK .)
    TYPE            reduce using rule 31 (break_statement -> BREAK .)
    IDENTIFIER      reduce using rule 31 (break_statement -> BREAK .)
    VAR             reduce using rule 31 (break_statement -> BREAK .)
    CONST           reduce using rule 31 (break_statement -> BREAK .)
    PLUS            reduce using rule 31 (break_statement -> BREAK .)
    MINUS           reduce using rule 31 (break_statement -> BREAK .)
    LNOT            reduce using rule 31 (break_statement -> BREAK .)
    LBRACKET        reduce using rule 31 (break_statement -> BREAK .)
    LPAREN          reduce using rule 31 (break_statement -> BREAK .)
    INT             reduce using rule 31 (break_statement -> BREAK .)
    FLOAT64         reduce using rule 31 (break_statement -> BREAK .)
    TRUE            reduce using rule 31 (break_statement -> BREAK .)
    FALSE           reduce using rule 31 (break_statement -> BREAK .)
    STRING          reduce using rule 31 (break_statement -> BREAK .)
    RETURN          reduce using rule 31 (break_statement -> BREAK .)
    FOR             reduce using rule 31 (break_statement -> BREAK .)
    IF              reduce using rule 31 (break_statement -> BREAK .)
    SWITCH          reduce using rule 31 (break_statement -> BREAK .)
    BREAK           reduce using rule 31 (break_statement -> BREAK .)
    CONTINUE        reduce using rule 31 (break_statement -> BREAK .)
    FALLTHROUGH     reduce using rule 31 (break_statement -> BREAK .)
    $end            reduce using rule 31 (break_statement -> BREAK .)
    RBRACE          reduce using rule 31 (break_statement -> BREAK .)
    CASE            reduce using rule 31 (break_statement -> BREAK .)
    DEFAULT         reduce using rule 31 (break_statement -> BREAK .)


state 50

    (32) continue_statement -> CONTINUE .

    SEMICOLON       reduce using rule 32 (continue_statement -> CONTINUE .)
    FUNC            reduce using rule 32 (continue_statement -> CONTINUE .)
    TYPE            reduce using rule 32 (continue_statement -> CONTINUE .)
    IDENTIFIER      reduce using rule 32 (continue_statement -> CONTINUE .)
    VAR             reduce using rule 32 (continue_statement -> CONTINUE .)
    CONST           reduce using rule 32 (continue_statement -> CONTINUE .)
    PLUS            reduce using rule 32 (continue_statement -> CONTINUE .)
    MINUS           reduce using rule 32 (continue_statement -> CONTINUE .)
    LNOT            reduce using rule 32 (continue_statement -> CONTINUE .)
    LBRACKET        reduce using rule 32 (continue_statement -> CONTINUE .)
    LPAREN          reduce using rule 32 (continue_statement -> CONTINUE .)
    INT             reduce using rule 32 (continue_statement -> CONTINUE .)
    FLOAT64         reduce using rule 32 (continue_statement -> CONTINUE .)
    TRUE            reduce using rule 32 (continue_statement -> CONTINUE .)
    FALSE           reduce using rule 32 (continue_statement -> CONTINUE .)
    STRING          reduce using rule 32 (continue_statement -> CONTINUE .)
    RETURN          reduce using rule 32 (continue_statement -> CONTINUE .)
    FOR             reduce using rule 32 (continue_statement -> CONTINUE .)
    IF              reduce using rule 32 (continue_statement -> CONTINUE .)
    SWITCH          reduce using rule 32 (continue_statement -> CONTINUE .)
    BREAK           reduce using rule 32 (continue_statement -> CONTINUE .)
    CONTINUE        reduce using rule 32 (continue_statement -> CONTINUE .)
    FALLTHROUGH     reduce using rule 32 (continue_statement -> CONTINUE .)
    $end            reduce using rule 32 (continue_statement -> CONTINUE .)
    RBRACE          reduce using rule 32 (continue_statement -> CONTINUE .)
    CASE            reduce using rule 32 (continue_statement -> CONTINUE .)
    DEFAULT         reduce using rule 32 (continue_statement -> CONTINUE .)


state 51

    (177) fallthrough_statement -> FALLTHROUGH .

    SEMICOLON       reduce using rule 177 (fallthrough_statement -> FALLTHROUGH .)
    FUNC            reduce using rule 177 (fallthrough_statement -> FALLTHROUGH .)
    TYPE            reduce using rule 177 (fallthrough_statement -> FALLTHROUGH .)
    IDENTIFIER      reduce using rule 177 (fallthrough_statement -> FALLTHROUGH .)
    VAR             reduce using rule 177 (fallthrough_statement -> FALLTHROUGH .)
    CONST           reduce using rule 177 (fallthrough_statement -> FALLTHROUGH .)
    PLUS            reduce using rule 177 (fallthrough_statement -> FALLTHROUGH .)
    MINUS           reduce using rule 177 (fallthrough_statement -> FALLTHROUGH .)
    LNOT            reduce using rule 177 (fallthrough_statement -> FALLTHROUGH .)
    LBRACKET        reduce using rule 177 (fallthrough_statement -> FALLTHROUGH .)
    LPAREN          reduce using rule 177 (fallthrough_statement -> FALLTHROUGH .)
    INT             reduce using rule 177 (fallthrough_statement -> FALLTHROUGH .)
    FLOAT64         reduce using rule 177 (fallthrough_statement -> FALLTHROUGH .)
    TRUE            reduce using rule 177 (fallthrough_statement -> FALLTHROUGH .)
    FALSE           reduce using rule 177 (fallthrough_statement -> FALLTHROUGH .)
    STRING          reduce using rule 177 (fallthrough_statement -> FALLTHROUGH .)
    RETURN          reduce using rule 177 (fallthrough_statement -> FALLTHROUGH .)
    FOR             reduce using rule 177 (fallthrough_statement -> FALLTHROUGH .)
    IF              reduce using rule 177 (fallthrough_statement -> FALLTHROUGH .)
    SWITCH          reduce using rule 177 (fallthrough_statement -> FALLTHROUGH .)
    BREAK           reduce using rule 177 (fallthrough_statement -> FALLTHROUGH .)
    CONTINUE        reduce using rule 177 (fallthrough_statement -> FALLTHROUGH .)
    FALLTHROUGH     reduce using rule 177 (fallthrough_statement -> FALLTHROUGH .)
    $end            reduce using rule 177 (fallthrough_statement -> FALLTHROUGH .)
    RBRACE          reduce using rule 177 (fallthrough_statement -> FALLTHROUGH .)
    CASE            reduce using rule 177 (fallthrough_statement -> FALLTHROUGH .)
    DEFAULT         reduce using rule 177 (fallthrough_statement -> FALLTHROUGH .)


state 52

    (3) package_declaration -> PACKAGE IDENTIFIER optional_semicolon .

    IMPORT          reduce using rule 3 (package_declaration -> PACKAGE IDENTIFIER optional_semicolon .)
    FUNC            reduce using rule 3 (package_declaration -> PACKAGE IDENTIFIER optional_semicolon .)
    TYPE            reduce using rule 3 (package_declaration -> PACKAGE IDENTIFIER optional_semicolon .)
    IDENTIFIER      reduce using rule 3 (package_declaration -> PACKAGE IDENTIFIER optional_semicolon .)
    VAR             reduce using rule 3 (package_declaration -> PACKAGE IDENTIFIER optional_semicolon .)
    CONST           reduce using rule 3 (package_declaration -> PACKAGE IDENTIFIER optional_semicolon .)
    PLUS            reduce using rule 3 (package_declaration -> PACKAGE IDENTIFIER optional_semicolon .)
    MINUS           reduce using rule 3 (package_declaration -> PACKAGE IDENTIFIER optional_semicolon .)
    LNOT            reduce using rule 3 (package_declaration -> PACKAGE IDENTIFIER optional_semicolon .)
    LBRACKET        reduce using rule 3 (package_declaration -> PACKAGE IDENTIFIER optional_semicolon .)
    LPAREN          reduce using rule 3 (package_declaration -> PACKAGE IDENTIFIER optional_semicolon .)
    INT             reduce using rule 3 (package_declaration -> PACKAGE IDENTIFIER optional_semicolon .)
    FLOAT64         reduce using rule 3 (package_declaration -> PACKAGE IDENTIFIER optional_semicolon .)
    TRUE            reduce using rule 3 (package_declaration -> PACKAGE IDENTIFIER optional_semicolon .)
    FALSE           reduce using rule 3 (package_declaration -> PACKAGE IDENTIFIER optional_semicolon .)
    STRING          reduce using rule 3 (package_declaration -> PACKAGE IDENTIFIER optional_semicolon .)
    RETURN          reduce using rule 3 (package_declaration -> PACKAGE IDENTIFIER optional_semicolon .)
    FOR             reduce using rule 3 (package_declaration -> PACKAGE IDENTIFIER optional_semicolon .)
    IF              reduce using rule 3 (package_declaration -> PACKAGE IDENTIFIER optional_semicolon .)
    SWITCH          reduce using rule 3 (package_declaration -> PACKAGE IDENTIFIER optional_semicolon .)
    BREAK           reduce using rule 3 (package_declaration -> PACKAGE IDENTIFIER optional_semicolon .)
    CONTINUE        reduce using rule 3 (package_declaration -> PACKAGE IDENTIFIER optional_semicolon .)
    FALLTHROUGH     reduce using rule 3 (package_declaration -> PACKAGE IDENTIFIER optional_semicolon .)
    $end            reduce using rule 3 (package_declaration -> PACKAGE IDENTIFIER optional_semicolon .)
>>>>>>> Stashed changes


state 53

    (151) type_alias -> struct_type .

<<<<<<< Updated upstream
    VAR             reduce using rule 151 (type_alias -> struct_type .)
    CONST           reduce using rule 151 (type_alias -> struct_type .)
    FUNC            reduce using rule 151 (type_alias -> struct_type .)
    TYPE            reduce using rule 151 (type_alias -> struct_type .)
    $end            reduce using rule 151 (type_alias -> struct_type .)
=======
    IMPORT          reduce using rule 8 (optional_semicolon -> SEMICOLON .)
    FUNC            reduce using rule 8 (optional_semicolon -> SEMICOLON .)
    TYPE            reduce using rule 8 (optional_semicolon -> SEMICOLON .)
    IDENTIFIER      reduce using rule 8 (optional_semicolon -> SEMICOLON .)
    VAR             reduce using rule 8 (optional_semicolon -> SEMICOLON .)
    CONST           reduce using rule 8 (optional_semicolon -> SEMICOLON .)
    PLUS            reduce using rule 8 (optional_semicolon -> SEMICOLON .)
    MINUS           reduce using rule 8 (optional_semicolon -> SEMICOLON .)
    LNOT            reduce using rule 8 (optional_semicolon -> SEMICOLON .)
    LBRACKET        reduce using rule 8 (optional_semicolon -> SEMICOLON .)
    LPAREN          reduce using rule 8 (optional_semicolon -> SEMICOLON .)
    INT             reduce using rule 8 (optional_semicolon -> SEMICOLON .)
    FLOAT64         reduce using rule 8 (optional_semicolon -> SEMICOLON .)
    TRUE            reduce using rule 8 (optional_semicolon -> SEMICOLON .)
    FALSE           reduce using rule 8 (optional_semicolon -> SEMICOLON .)
    STRING          reduce using rule 8 (optional_semicolon -> SEMICOLON .)
    RETURN          reduce using rule 8 (optional_semicolon -> SEMICOLON .)
    FOR             reduce using rule 8 (optional_semicolon -> SEMICOLON .)
    IF              reduce using rule 8 (optional_semicolon -> SEMICOLON .)
    SWITCH          reduce using rule 8 (optional_semicolon -> SEMICOLON .)
    BREAK           reduce using rule 8 (optional_semicolon -> SEMICOLON .)
    CONTINUE        reduce using rule 8 (optional_semicolon -> SEMICOLON .)
    FALLTHROUGH     reduce using rule 8 (optional_semicolon -> SEMICOLON .)
    $end            reduce using rule 8 (optional_semicolon -> SEMICOLON .)
>>>>>>> Stashed changes


state 54

    (152) type_alias -> type .

<<<<<<< Updated upstream
    VAR             reduce using rule 152 (type_alias -> type .)
    CONST           reduce using rule 152 (type_alias -> type .)
    FUNC            reduce using rule 152 (type_alias -> type .)
    TYPE            reduce using rule 152 (type_alias -> type .)
    $end            reduce using rule 152 (type_alias -> type .)
=======
    IMPORT          reduce using rule 9 (optional_semicolon -> empty .)
    FUNC            reduce using rule 9 (optional_semicolon -> empty .)
    TYPE            reduce using rule 9 (optional_semicolon -> empty .)
    IDENTIFIER      reduce using rule 9 (optional_semicolon -> empty .)
    VAR             reduce using rule 9 (optional_semicolon -> empty .)
    CONST           reduce using rule 9 (optional_semicolon -> empty .)
    PLUS            reduce using rule 9 (optional_semicolon -> empty .)
    MINUS           reduce using rule 9 (optional_semicolon -> empty .)
    LNOT            reduce using rule 9 (optional_semicolon -> empty .)
    LBRACKET        reduce using rule 9 (optional_semicolon -> empty .)
    LPAREN          reduce using rule 9 (optional_semicolon -> empty .)
    INT             reduce using rule 9 (optional_semicolon -> empty .)
    FLOAT64         reduce using rule 9 (optional_semicolon -> empty .)
    TRUE            reduce using rule 9 (optional_semicolon -> empty .)
    FALSE           reduce using rule 9 (optional_semicolon -> empty .)
    STRING          reduce using rule 9 (optional_semicolon -> empty .)
    RETURN          reduce using rule 9 (optional_semicolon -> empty .)
    FOR             reduce using rule 9 (optional_semicolon -> empty .)
    IF              reduce using rule 9 (optional_semicolon -> empty .)
    SWITCH          reduce using rule 9 (optional_semicolon -> empty .)
    BREAK           reduce using rule 9 (optional_semicolon -> empty .)
    CONTINUE        reduce using rule 9 (optional_semicolon -> empty .)
    FALLTHROUGH     reduce using rule 9 (optional_semicolon -> empty .)
    $end            reduce using rule 9 (optional_semicolon -> empty .)
>>>>>>> Stashed changes


state 55

    (154) struct_type -> STRUCT . LBRACE RBRACE
    (155) struct_type -> STRUCT . LBRACE field_list RBRACE

<<<<<<< Updated upstream
    LBRACE          shift and go to state 76
=======
    FUNC            reduce using rule 11 (global_sequence -> global_sequence global_statement .)
    TYPE            reduce using rule 11 (global_sequence -> global_sequence global_statement .)
    IDENTIFIER      reduce using rule 11 (global_sequence -> global_sequence global_statement .)
    VAR             reduce using rule 11 (global_sequence -> global_sequence global_statement .)
    CONST           reduce using rule 11 (global_sequence -> global_sequence global_statement .)
    PLUS            reduce using rule 11 (global_sequence -> global_sequence global_statement .)
    MINUS           reduce using rule 11 (global_sequence -> global_sequence global_statement .)
    LNOT            reduce using rule 11 (global_sequence -> global_sequence global_statement .)
    LBRACKET        reduce using rule 11 (global_sequence -> global_sequence global_statement .)
    LPAREN          reduce using rule 11 (global_sequence -> global_sequence global_statement .)
    INT             reduce using rule 11 (global_sequence -> global_sequence global_statement .)
    FLOAT64         reduce using rule 11 (global_sequence -> global_sequence global_statement .)
    TRUE            reduce using rule 11 (global_sequence -> global_sequence global_statement .)
    FALSE           reduce using rule 11 (global_sequence -> global_sequence global_statement .)
    STRING          reduce using rule 11 (global_sequence -> global_sequence global_statement .)
    RETURN          reduce using rule 11 (global_sequence -> global_sequence global_statement .)
    FOR             reduce using rule 11 (global_sequence -> global_sequence global_statement .)
    IF              reduce using rule 11 (global_sequence -> global_sequence global_statement .)
    SWITCH          reduce using rule 11 (global_sequence -> global_sequence global_statement .)
    BREAK           reduce using rule 11 (global_sequence -> global_sequence global_statement .)
    CONTINUE        reduce using rule 11 (global_sequence -> global_sequence global_statement .)
    FALLTHROUGH     reduce using rule 11 (global_sequence -> global_sequence global_statement .)
    $end            reduce using rule 11 (global_sequence -> global_sequence global_statement .)
>>>>>>> Stashed changes


state 56

    (16) global_var_dec -> VAR IDENTIFIER type ASSIGN . expression
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (125) expression -> . LNOT expression
    (126) expression -> . IDENTIFIER PLUSPLUS
    (127) expression -> . IDENTIFIER MINUSMINUS
    (138) expression -> . map_type LBRACE expression_map_list RBRACE
    (139) expression -> . map_type LBRACE RBRACE
    (161) expression -> . type_name LBRACE keyed_element_list RBRACE
    (162) expression -> . type_name LBRACE RBRACE
    (198) expression -> . array_type LBRACE expression_list RBRACE
    (199) expression -> . array_type LBRACE RBRACE
    (200) expression -> . expression DOT IDENTIFIER
    (201) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> . expression LBRACKET expression RBRACKET
    (203) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (137) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (163) type_name -> . IDENTIFIER
    (164) type_name -> . slice_type
    (165) type_name -> . array_type
    (166) type_name -> . map_type
    (197) array_type -> . LBRACKET INT RBRACKET primitive_type

<<<<<<< Updated upstream
    LPAREN          shift and go to state 54
    INT             shift and go to state 55
    FLOAT64         shift and go to state 56
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 57
    TRUE            shift and go to state 58
    FALSE           shift and go to state 59
    LNOT            shift and go to state 60
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    expression                     shift and go to state 77
    slice_type                     shift and go to state 53
    map_type                       shift and go to state 61
    type_name                      shift and go to state 62
    array_type                     shift and go to state 63
=======
    SEMICOLON       shift and go to state 53
    IMPORT          reduce using rule 7 (empty -> .)
    FUNC            reduce using rule 7 (empty -> .)
    TYPE            reduce using rule 7 (empty -> .)
    IDENTIFIER      reduce using rule 7 (empty -> .)
    VAR             reduce using rule 7 (empty -> .)
    CONST           reduce using rule 7 (empty -> .)
    PLUS            reduce using rule 7 (empty -> .)
    MINUS           reduce using rule 7 (empty -> .)
    LNOT            reduce using rule 7 (empty -> .)
    LBRACKET        reduce using rule 7 (empty -> .)
    LPAREN          reduce using rule 7 (empty -> .)
    INT             reduce using rule 7 (empty -> .)
    FLOAT64         reduce using rule 7 (empty -> .)
    TRUE            reduce using rule 7 (empty -> .)
    FALSE           reduce using rule 7 (empty -> .)
    STRING          reduce using rule 7 (empty -> .)
    RETURN          reduce using rule 7 (empty -> .)
    FOR             reduce using rule 7 (empty -> .)
    IF              reduce using rule 7 (empty -> .)
    SWITCH          reduce using rule 7 (empty -> .)
    BREAK           reduce using rule 7 (empty -> .)
    CONTINUE        reduce using rule 7 (empty -> .)
    FALLTHROUGH     reduce using rule 7 (empty -> .)
    $end            reduce using rule 7 (empty -> .)

    optional_semicolon             shift and go to state 117
    empty                          shift and go to state 54
>>>>>>> Stashed changes

state 57

    (73) expression -> IDENTIFIER .
    (126) expression -> IDENTIFIER . PLUSPLUS
    (127) expression -> IDENTIFIER . MINUSMINUS
    (203) expression -> IDENTIFIER . LPAREN argument_list RPAREN
    (163) type_name -> IDENTIFIER .

<<<<<<< Updated upstream
  ! shift/reduce conflict for LPAREN resolved as shift
  ! reduce/reduce conflict for LBRACE resolved using rule 73 (expression -> IDENTIFIER .)
    DOT             reduce using rule 73 (expression -> IDENTIFIER .)
    LBRACKET        reduce using rule 73 (expression -> IDENTIFIER .)
    PLUS            reduce using rule 73 (expression -> IDENTIFIER .)
    MINUS           reduce using rule 73 (expression -> IDENTIFIER .)
    TIMES           reduce using rule 73 (expression -> IDENTIFIER .)
    DIVIDE          reduce using rule 73 (expression -> IDENTIFIER .)
    MODULE          reduce using rule 73 (expression -> IDENTIFIER .)
    EQ              reduce using rule 73 (expression -> IDENTIFIER .)
    NEQ             reduce using rule 73 (expression -> IDENTIFIER .)
    LT              reduce using rule 73 (expression -> IDENTIFIER .)
    LE              reduce using rule 73 (expression -> IDENTIFIER .)
    GT              reduce using rule 73 (expression -> IDENTIFIER .)
    GE              reduce using rule 73 (expression -> IDENTIFIER .)
    LAND            reduce using rule 73 (expression -> IDENTIFIER .)
    LOR             reduce using rule 73 (expression -> IDENTIFIER .)
    AND             reduce using rule 73 (expression -> IDENTIFIER .)
    OR              reduce using rule 73 (expression -> IDENTIFIER .)
    XOR             reduce using rule 73 (expression -> IDENTIFIER .)
    AND_NOT         reduce using rule 73 (expression -> IDENTIFIER .)
    LSHIFT          reduce using rule 73 (expression -> IDENTIFIER .)
    RSHIFT          reduce using rule 73 (expression -> IDENTIFIER .)
    VAR             reduce using rule 73 (expression -> IDENTIFIER .)
    CONST           reduce using rule 73 (expression -> IDENTIFIER .)
    FUNC            reduce using rule 73 (expression -> IDENTIFIER .)
    TYPE            reduce using rule 73 (expression -> IDENTIFIER .)
    $end            reduce using rule 73 (expression -> IDENTIFIER .)
    RPAREN          reduce using rule 73 (expression -> IDENTIFIER .)
    COMMA           reduce using rule 73 (expression -> IDENTIFIER .)
    RBRACKET        reduce using rule 73 (expression -> IDENTIFIER .)
    RBRACE          reduce using rule 73 (expression -> IDENTIFIER .)
    COLON           reduce using rule 73 (expression -> IDENTIFIER .)
    BREAK           reduce using rule 73 (expression -> IDENTIFIER .)
    CONTINUE        reduce using rule 73 (expression -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 73 (expression -> IDENTIFIER .)
    INT             reduce using rule 73 (expression -> IDENTIFIER .)
    FLOAT64         reduce using rule 73 (expression -> IDENTIFIER .)
    STRING          reduce using rule 73 (expression -> IDENTIFIER .)
    TRUE            reduce using rule 73 (expression -> IDENTIFIER .)
    FALSE           reduce using rule 73 (expression -> IDENTIFIER .)
    LNOT            reduce using rule 73 (expression -> IDENTIFIER .)
    IF              reduce using rule 73 (expression -> IDENTIFIER .)
    SWITCH          reduce using rule 73 (expression -> IDENTIFIER .)
    RETURN          reduce using rule 73 (expression -> IDENTIFIER .)
    MAP             reduce using rule 73 (expression -> IDENTIFIER .)
    FOR             reduce using rule 73 (expression -> IDENTIFIER .)
    LBRACE          reduce using rule 73 (expression -> IDENTIFIER .)
    CASE            reduce using rule 73 (expression -> IDENTIFIER .)
    DEFAULT         reduce using rule 73 (expression -> IDENTIFIER .)
    SEMICOLON       reduce using rule 73 (expression -> IDENTIFIER .)
    PLUSPLUS        shift and go to state 78
    MINUSMINUS      shift and go to state 79
    LPAREN          shift and go to state 80

  ! LPAREN          [ reduce using rule 73 (expression -> IDENTIFIER .) ]
  ! LBRACE          [ reduce using rule 163 (type_name -> IDENTIFIER .) ]


state 52

    (17) global_var_dec -> VAR IDENTIFIER ASSIGN expression .
    (36) expression -> expression . binary_operator expression
    (200) expression -> expression . DOT IDENTIFIER
    (201) expression -> expression . DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> expression . LBRACKET expression RBRACKET
    (37) binary_operator -> . PLUS
    (38) binary_operator -> . MINUS
    (39) binary_operator -> . TIMES
    (40) binary_operator -> . DIVIDE
    (41) binary_operator -> . MODULE
    (42) binary_operator -> . EQ
    (43) binary_operator -> . NEQ
    (44) binary_operator -> . LT
    (45) binary_operator -> . LE
    (46) binary_operator -> . GT
    (47) binary_operator -> . GE
    (48) binary_operator -> . LAND
    (49) binary_operator -> . LOR
    (50) binary_operator -> . AND
    (51) binary_operator -> . OR
    (52) binary_operator -> . XOR
    (53) binary_operator -> . AND_NOT
    (54) binary_operator -> . LSHIFT
    (55) binary_operator -> . RSHIFT

    VAR             reduce using rule 17 (global_var_dec -> VAR IDENTIFIER ASSIGN expression .)
    CONST           reduce using rule 17 (global_var_dec -> VAR IDENTIFIER ASSIGN expression .)
    FUNC            reduce using rule 17 (global_var_dec -> VAR IDENTIFIER ASSIGN expression .)
    TYPE            reduce using rule 17 (global_var_dec -> VAR IDENTIFIER ASSIGN expression .)
    $end            reduce using rule 17 (global_var_dec -> VAR IDENTIFIER ASSIGN expression .)
    DOT             shift and go to state 82
    LBRACKET        shift and go to state 83
    PLUS            shift and go to state 84
    MINUS           shift and go to state 85
    TIMES           shift and go to state 86
    DIVIDE          shift and go to state 87
    MODULE          shift and go to state 88
    EQ              shift and go to state 89
    NEQ             shift and go to state 90
    LT              shift and go to state 91
    LE              shift and go to state 92
    GT              shift and go to state 93
    GE              shift and go to state 94
    LAND            shift and go to state 95
    LOR             shift and go to state 96
    AND             shift and go to state 97
    OR              shift and go to state 98
    XOR             shift and go to state 99
    AND_NOT         shift and go to state 100
    LSHIFT          shift and go to state 101
    RSHIFT          shift and go to state 102

    binary_operator                shift and go to state 81

state 53

    (66) expression -> slice_type . LBRACE expression_list RBRACE
    (67) expression -> slice_type . LBRACE RBRACE
    (164) type_name -> slice_type .

  ! shift/reduce conflict for LBRACE resolved as shift
    LBRACE          shift and go to state 103

  ! LBRACE          [ reduce using rule 164 (type_name -> slice_type .) ]


state 54

    (70) expression -> LPAREN . expression RPAREN
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (125) expression -> . LNOT expression
    (126) expression -> . IDENTIFIER PLUSPLUS
    (127) expression -> . IDENTIFIER MINUSMINUS
    (138) expression -> . map_type LBRACE expression_map_list RBRACE
    (139) expression -> . map_type LBRACE RBRACE
    (161) expression -> . type_name LBRACE keyed_element_list RBRACE
    (162) expression -> . type_name LBRACE RBRACE
    (198) expression -> . array_type LBRACE expression_list RBRACE
    (199) expression -> . array_type LBRACE RBRACE
    (200) expression -> . expression DOT IDENTIFIER
    (201) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> . expression LBRACKET expression RBRACKET
    (203) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (137) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (163) type_name -> . IDENTIFIER
    (164) type_name -> . slice_type
    (165) type_name -> . array_type
    (166) type_name -> . map_type
    (197) array_type -> . LBRACKET INT RBRACKET primitive_type

    LPAREN          shift and go to state 54
    INT             shift and go to state 55
    FLOAT64         shift and go to state 56
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 57
    TRUE            shift and go to state 58
    FALSE           shift and go to state 59
    LNOT            shift and go to state 60
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    expression                     shift and go to state 104
    slice_type                     shift and go to state 53
    map_type                       shift and go to state 61
    type_name                      shift and go to state 62
    array_type                     shift and go to state 63

state 55

    (71) expression -> INT .

    DOT             reduce using rule 71 (expression -> INT .)
    LBRACKET        reduce using rule 71 (expression -> INT .)
    PLUS            reduce using rule 71 (expression -> INT .)
    MINUS           reduce using rule 71 (expression -> INT .)
    TIMES           reduce using rule 71 (expression -> INT .)
    DIVIDE          reduce using rule 71 (expression -> INT .)
    MODULE          reduce using rule 71 (expression -> INT .)
    EQ              reduce using rule 71 (expression -> INT .)
    NEQ             reduce using rule 71 (expression -> INT .)
    LT              reduce using rule 71 (expression -> INT .)
    LE              reduce using rule 71 (expression -> INT .)
    GT              reduce using rule 71 (expression -> INT .)
    GE              reduce using rule 71 (expression -> INT .)
    LAND            reduce using rule 71 (expression -> INT .)
    LOR             reduce using rule 71 (expression -> INT .)
    AND             reduce using rule 71 (expression -> INT .)
    OR              reduce using rule 71 (expression -> INT .)
    XOR             reduce using rule 71 (expression -> INT .)
    AND_NOT         reduce using rule 71 (expression -> INT .)
    LSHIFT          reduce using rule 71 (expression -> INT .)
    RSHIFT          reduce using rule 71 (expression -> INT .)
    VAR             reduce using rule 71 (expression -> INT .)
    CONST           reduce using rule 71 (expression -> INT .)
    FUNC            reduce using rule 71 (expression -> INT .)
    TYPE            reduce using rule 71 (expression -> INT .)
    $end            reduce using rule 71 (expression -> INT .)
    RPAREN          reduce using rule 71 (expression -> INT .)
    COMMA           reduce using rule 71 (expression -> INT .)
    RBRACKET        reduce using rule 71 (expression -> INT .)
    RBRACE          reduce using rule 71 (expression -> INT .)
    COLON           reduce using rule 71 (expression -> INT .)
    BREAK           reduce using rule 71 (expression -> INT .)
    CONTINUE        reduce using rule 71 (expression -> INT .)
    IDENTIFIER      reduce using rule 71 (expression -> INT .)
    LPAREN          reduce using rule 71 (expression -> INT .)
    INT             reduce using rule 71 (expression -> INT .)
    FLOAT64         reduce using rule 71 (expression -> INT .)
    STRING          reduce using rule 71 (expression -> INT .)
    TRUE            reduce using rule 71 (expression -> INT .)
    FALSE           reduce using rule 71 (expression -> INT .)
    LNOT            reduce using rule 71 (expression -> INT .)
    IF              reduce using rule 71 (expression -> INT .)
    SWITCH          reduce using rule 71 (expression -> INT .)
    RETURN          reduce using rule 71 (expression -> INT .)
    MAP             reduce using rule 71 (expression -> INT .)
    FOR             reduce using rule 71 (expression -> INT .)
    LBRACE          reduce using rule 71 (expression -> INT .)
    CASE            reduce using rule 71 (expression -> INT .)
    DEFAULT         reduce using rule 71 (expression -> INT .)
    SEMICOLON       reduce using rule 71 (expression -> INT .)


state 56

    (72) expression -> FLOAT64 .

    DOT             reduce using rule 72 (expression -> FLOAT64 .)
    LBRACKET        reduce using rule 72 (expression -> FLOAT64 .)
    PLUS            reduce using rule 72 (expression -> FLOAT64 .)
    MINUS           reduce using rule 72 (expression -> FLOAT64 .)
    TIMES           reduce using rule 72 (expression -> FLOAT64 .)
    DIVIDE          reduce using rule 72 (expression -> FLOAT64 .)
    MODULE          reduce using rule 72 (expression -> FLOAT64 .)
    EQ              reduce using rule 72 (expression -> FLOAT64 .)
    NEQ             reduce using rule 72 (expression -> FLOAT64 .)
    LT              reduce using rule 72 (expression -> FLOAT64 .)
    LE              reduce using rule 72 (expression -> FLOAT64 .)
    GT              reduce using rule 72 (expression -> FLOAT64 .)
    GE              reduce using rule 72 (expression -> FLOAT64 .)
    LAND            reduce using rule 72 (expression -> FLOAT64 .)
    LOR             reduce using rule 72 (expression -> FLOAT64 .)
    AND             reduce using rule 72 (expression -> FLOAT64 .)
    OR              reduce using rule 72 (expression -> FLOAT64 .)
    XOR             reduce using rule 72 (expression -> FLOAT64 .)
    AND_NOT         reduce using rule 72 (expression -> FLOAT64 .)
    LSHIFT          reduce using rule 72 (expression -> FLOAT64 .)
    RSHIFT          reduce using rule 72 (expression -> FLOAT64 .)
    VAR             reduce using rule 72 (expression -> FLOAT64 .)
    CONST           reduce using rule 72 (expression -> FLOAT64 .)
    FUNC            reduce using rule 72 (expression -> FLOAT64 .)
    TYPE            reduce using rule 72 (expression -> FLOAT64 .)
    $end            reduce using rule 72 (expression -> FLOAT64 .)
    RPAREN          reduce using rule 72 (expression -> FLOAT64 .)
    COMMA           reduce using rule 72 (expression -> FLOAT64 .)
    RBRACKET        reduce using rule 72 (expression -> FLOAT64 .)
    RBRACE          reduce using rule 72 (expression -> FLOAT64 .)
    COLON           reduce using rule 72 (expression -> FLOAT64 .)
    BREAK           reduce using rule 72 (expression -> FLOAT64 .)
    CONTINUE        reduce using rule 72 (expression -> FLOAT64 .)
    IDENTIFIER      reduce using rule 72 (expression -> FLOAT64 .)
    LPAREN          reduce using rule 72 (expression -> FLOAT64 .)
    INT             reduce using rule 72 (expression -> FLOAT64 .)
    FLOAT64         reduce using rule 72 (expression -> FLOAT64 .)
    STRING          reduce using rule 72 (expression -> FLOAT64 .)
    TRUE            reduce using rule 72 (expression -> FLOAT64 .)
    FALSE           reduce using rule 72 (expression -> FLOAT64 .)
    LNOT            reduce using rule 72 (expression -> FLOAT64 .)
    IF              reduce using rule 72 (expression -> FLOAT64 .)
    SWITCH          reduce using rule 72 (expression -> FLOAT64 .)
    RETURN          reduce using rule 72 (expression -> FLOAT64 .)
    MAP             reduce using rule 72 (expression -> FLOAT64 .)
    FOR             reduce using rule 72 (expression -> FLOAT64 .)
    LBRACE          reduce using rule 72 (expression -> FLOAT64 .)
    CASE            reduce using rule 72 (expression -> FLOAT64 .)
    DEFAULT         reduce using rule 72 (expression -> FLOAT64 .)
    SEMICOLON       reduce using rule 72 (expression -> FLOAT64 .)


state 57

    (74) expression -> STRING .

    DOT             reduce using rule 74 (expression -> STRING .)
    LBRACKET        reduce using rule 74 (expression -> STRING .)
    PLUS            reduce using rule 74 (expression -> STRING .)
    MINUS           reduce using rule 74 (expression -> STRING .)
    TIMES           reduce using rule 74 (expression -> STRING .)
    DIVIDE          reduce using rule 74 (expression -> STRING .)
    MODULE          reduce using rule 74 (expression -> STRING .)
    EQ              reduce using rule 74 (expression -> STRING .)
    NEQ             reduce using rule 74 (expression -> STRING .)
    LT              reduce using rule 74 (expression -> STRING .)
    LE              reduce using rule 74 (expression -> STRING .)
    GT              reduce using rule 74 (expression -> STRING .)
    GE              reduce using rule 74 (expression -> STRING .)
    LAND            reduce using rule 74 (expression -> STRING .)
    LOR             reduce using rule 74 (expression -> STRING .)
    AND             reduce using rule 74 (expression -> STRING .)
    OR              reduce using rule 74 (expression -> STRING .)
    XOR             reduce using rule 74 (expression -> STRING .)
    AND_NOT         reduce using rule 74 (expression -> STRING .)
    LSHIFT          reduce using rule 74 (expression -> STRING .)
    RSHIFT          reduce using rule 74 (expression -> STRING .)
    VAR             reduce using rule 74 (expression -> STRING .)
    CONST           reduce using rule 74 (expression -> STRING .)
    FUNC            reduce using rule 74 (expression -> STRING .)
    TYPE            reduce using rule 74 (expression -> STRING .)
    $end            reduce using rule 74 (expression -> STRING .)
    RPAREN          reduce using rule 74 (expression -> STRING .)
    COMMA           reduce using rule 74 (expression -> STRING .)
    RBRACKET        reduce using rule 74 (expression -> STRING .)
    RBRACE          reduce using rule 74 (expression -> STRING .)
    COLON           reduce using rule 74 (expression -> STRING .)
    BREAK           reduce using rule 74 (expression -> STRING .)
    CONTINUE        reduce using rule 74 (expression -> STRING .)
    IDENTIFIER      reduce using rule 74 (expression -> STRING .)
    LPAREN          reduce using rule 74 (expression -> STRING .)
    INT             reduce using rule 74 (expression -> STRING .)
    FLOAT64         reduce using rule 74 (expression -> STRING .)
    STRING          reduce using rule 74 (expression -> STRING .)
    TRUE            reduce using rule 74 (expression -> STRING .)
    FALSE           reduce using rule 74 (expression -> STRING .)
    LNOT            reduce using rule 74 (expression -> STRING .)
    IF              reduce using rule 74 (expression -> STRING .)
    SWITCH          reduce using rule 74 (expression -> STRING .)
    RETURN          reduce using rule 74 (expression -> STRING .)
    MAP             reduce using rule 74 (expression -> STRING .)
    FOR             reduce using rule 74 (expression -> STRING .)
    LBRACE          reduce using rule 74 (expression -> STRING .)
    CASE            reduce using rule 74 (expression -> STRING .)
    DEFAULT         reduce using rule 74 (expression -> STRING .)
    SEMICOLON       reduce using rule 74 (expression -> STRING .)


state 58

    (75) expression -> TRUE .

    DOT             reduce using rule 75 (expression -> TRUE .)
    LBRACKET        reduce using rule 75 (expression -> TRUE .)
    PLUS            reduce using rule 75 (expression -> TRUE .)
    MINUS           reduce using rule 75 (expression -> TRUE .)
    TIMES           reduce using rule 75 (expression -> TRUE .)
    DIVIDE          reduce using rule 75 (expression -> TRUE .)
    MODULE          reduce using rule 75 (expression -> TRUE .)
    EQ              reduce using rule 75 (expression -> TRUE .)
    NEQ             reduce using rule 75 (expression -> TRUE .)
    LT              reduce using rule 75 (expression -> TRUE .)
    LE              reduce using rule 75 (expression -> TRUE .)
    GT              reduce using rule 75 (expression -> TRUE .)
    GE              reduce using rule 75 (expression -> TRUE .)
    LAND            reduce using rule 75 (expression -> TRUE .)
    LOR             reduce using rule 75 (expression -> TRUE .)
    AND             reduce using rule 75 (expression -> TRUE .)
    OR              reduce using rule 75 (expression -> TRUE .)
    XOR             reduce using rule 75 (expression -> TRUE .)
    AND_NOT         reduce using rule 75 (expression -> TRUE .)
    LSHIFT          reduce using rule 75 (expression -> TRUE .)
    RSHIFT          reduce using rule 75 (expression -> TRUE .)
    VAR             reduce using rule 75 (expression -> TRUE .)
    CONST           reduce using rule 75 (expression -> TRUE .)
    FUNC            reduce using rule 75 (expression -> TRUE .)
    TYPE            reduce using rule 75 (expression -> TRUE .)
    $end            reduce using rule 75 (expression -> TRUE .)
    RPAREN          reduce using rule 75 (expression -> TRUE .)
    COMMA           reduce using rule 75 (expression -> TRUE .)
    RBRACKET        reduce using rule 75 (expression -> TRUE .)
    RBRACE          reduce using rule 75 (expression -> TRUE .)
    COLON           reduce using rule 75 (expression -> TRUE .)
    BREAK           reduce using rule 75 (expression -> TRUE .)
    CONTINUE        reduce using rule 75 (expression -> TRUE .)
    IDENTIFIER      reduce using rule 75 (expression -> TRUE .)
    LPAREN          reduce using rule 75 (expression -> TRUE .)
    INT             reduce using rule 75 (expression -> TRUE .)
    FLOAT64         reduce using rule 75 (expression -> TRUE .)
    STRING          reduce using rule 75 (expression -> TRUE .)
    TRUE            reduce using rule 75 (expression -> TRUE .)
    FALSE           reduce using rule 75 (expression -> TRUE .)
    LNOT            reduce using rule 75 (expression -> TRUE .)
    IF              reduce using rule 75 (expression -> TRUE .)
    SWITCH          reduce using rule 75 (expression -> TRUE .)
    RETURN          reduce using rule 75 (expression -> TRUE .)
    MAP             reduce using rule 75 (expression -> TRUE .)
    FOR             reduce using rule 75 (expression -> TRUE .)
    LBRACE          reduce using rule 75 (expression -> TRUE .)
    CASE            reduce using rule 75 (expression -> TRUE .)
    DEFAULT         reduce using rule 75 (expression -> TRUE .)
    SEMICOLON       reduce using rule 75 (expression -> TRUE .)
=======
    FUNC            reduce using rule 12 (global_statement -> statement optional_semicolon .)
    TYPE            reduce using rule 12 (global_statement -> statement optional_semicolon .)
    IDENTIFIER      reduce using rule 12 (global_statement -> statement optional_semicolon .)
    VAR             reduce using rule 12 (global_statement -> statement optional_semicolon .)
    CONST           reduce using rule 12 (global_statement -> statement optional_semicolon .)
    PLUS            reduce using rule 12 (global_statement -> statement optional_semicolon .)
    MINUS           reduce using rule 12 (global_statement -> statement optional_semicolon .)
    LNOT            reduce using rule 12 (global_statement -> statement optional_semicolon .)
    LBRACKET        reduce using rule 12 (global_statement -> statement optional_semicolon .)
    LPAREN          reduce using rule 12 (global_statement -> statement optional_semicolon .)
    INT             reduce using rule 12 (global_statement -> statement optional_semicolon .)
    FLOAT64         reduce using rule 12 (global_statement -> statement optional_semicolon .)
    TRUE            reduce using rule 12 (global_statement -> statement optional_semicolon .)
    FALSE           reduce using rule 12 (global_statement -> statement optional_semicolon .)
    STRING          reduce using rule 12 (global_statement -> statement optional_semicolon .)
    RETURN          reduce using rule 12 (global_statement -> statement optional_semicolon .)
    FOR             reduce using rule 12 (global_statement -> statement optional_semicolon .)
    IF              reduce using rule 12 (global_statement -> statement optional_semicolon .)
    SWITCH          reduce using rule 12 (global_statement -> statement optional_semicolon .)
    BREAK           reduce using rule 12 (global_statement -> statement optional_semicolon .)
    CONTINUE        reduce using rule 12 (global_statement -> statement optional_semicolon .)
    FALLTHROUGH     reduce using rule 12 (global_statement -> statement optional_semicolon .)
    $end            reduce using rule 12 (global_statement -> statement optional_semicolon .)


state 58

    (100) expression -> expression DOT . IDENTIFIER

    IDENTIFIER      shift and go to state 118
>>>>>>> Stashed changes


state 59

<<<<<<< Updated upstream
    (76) expression -> FALSE .

    DOT             reduce using rule 76 (expression -> FALSE .)
    LBRACKET        reduce using rule 76 (expression -> FALSE .)
    PLUS            reduce using rule 76 (expression -> FALSE .)
    MINUS           reduce using rule 76 (expression -> FALSE .)
    TIMES           reduce using rule 76 (expression -> FALSE .)
    DIVIDE          reduce using rule 76 (expression -> FALSE .)
    MODULE          reduce using rule 76 (expression -> FALSE .)
    EQ              reduce using rule 76 (expression -> FALSE .)
    NEQ             reduce using rule 76 (expression -> FALSE .)
    LT              reduce using rule 76 (expression -> FALSE .)
    LE              reduce using rule 76 (expression -> FALSE .)
    GT              reduce using rule 76 (expression -> FALSE .)
    GE              reduce using rule 76 (expression -> FALSE .)
    LAND            reduce using rule 76 (expression -> FALSE .)
    LOR             reduce using rule 76 (expression -> FALSE .)
    AND             reduce using rule 76 (expression -> FALSE .)
    OR              reduce using rule 76 (expression -> FALSE .)
    XOR             reduce using rule 76 (expression -> FALSE .)
    AND_NOT         reduce using rule 76 (expression -> FALSE .)
    LSHIFT          reduce using rule 76 (expression -> FALSE .)
    RSHIFT          reduce using rule 76 (expression -> FALSE .)
    VAR             reduce using rule 76 (expression -> FALSE .)
    CONST           reduce using rule 76 (expression -> FALSE .)
    FUNC            reduce using rule 76 (expression -> FALSE .)
    TYPE            reduce using rule 76 (expression -> FALSE .)
    $end            reduce using rule 76 (expression -> FALSE .)
    RPAREN          reduce using rule 76 (expression -> FALSE .)
    COMMA           reduce using rule 76 (expression -> FALSE .)
    RBRACKET        reduce using rule 76 (expression -> FALSE .)
    RBRACE          reduce using rule 76 (expression -> FALSE .)
    COLON           reduce using rule 76 (expression -> FALSE .)
    BREAK           reduce using rule 76 (expression -> FALSE .)
    CONTINUE        reduce using rule 76 (expression -> FALSE .)
    IDENTIFIER      reduce using rule 76 (expression -> FALSE .)
    LPAREN          reduce using rule 76 (expression -> FALSE .)
    INT             reduce using rule 76 (expression -> FALSE .)
    FLOAT64         reduce using rule 76 (expression -> FALSE .)
    STRING          reduce using rule 76 (expression -> FALSE .)
    TRUE            reduce using rule 76 (expression -> FALSE .)
    FALSE           reduce using rule 76 (expression -> FALSE .)
    LNOT            reduce using rule 76 (expression -> FALSE .)
    IF              reduce using rule 76 (expression -> FALSE .)
    SWITCH          reduce using rule 76 (expression -> FALSE .)
    RETURN          reduce using rule 76 (expression -> FALSE .)
    MAP             reduce using rule 76 (expression -> FALSE .)
    FOR             reduce using rule 76 (expression -> FALSE .)
    LBRACE          reduce using rule 76 (expression -> FALSE .)
    CASE            reduce using rule 76 (expression -> FALSE .)
    DEFAULT         reduce using rule 76 (expression -> FALSE .)
    SEMICOLON       reduce using rule 76 (expression -> FALSE .)


state 60

    (125) expression -> LNOT . expression
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (125) expression -> . LNOT expression
    (126) expression -> . IDENTIFIER PLUSPLUS
    (127) expression -> . IDENTIFIER MINUSMINUS
    (138) expression -> . map_type LBRACE expression_map_list RBRACE
    (139) expression -> . map_type LBRACE RBRACE
    (161) expression -> . type_name LBRACE keyed_element_list RBRACE
    (162) expression -> . type_name LBRACE RBRACE
    (198) expression -> . array_type LBRACE expression_list RBRACE
    (199) expression -> . array_type LBRACE RBRACE
    (200) expression -> . expression DOT IDENTIFIER
    (201) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> . expression LBRACKET expression RBRACKET
    (203) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (137) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (163) type_name -> . IDENTIFIER
    (164) type_name -> . slice_type
    (165) type_name -> . array_type
    (166) type_name -> . map_type
    (197) array_type -> . LBRACKET INT RBRACKET primitive_type

    LPAREN          shift and go to state 54
    INT             shift and go to state 55
    FLOAT64         shift and go to state 56
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 57
    TRUE            shift and go to state 58
    FALSE           shift and go to state 59
    LNOT            shift and go to state 60
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    expression                     shift and go to state 105
    slice_type                     shift and go to state 53
    map_type                       shift and go to state 61
    type_name                      shift and go to state 62
    array_type                     shift and go to state 63

state 61

    (138) expression -> map_type . LBRACE expression_map_list RBRACE
    (139) expression -> map_type . LBRACE RBRACE
    (166) type_name -> map_type .

  ! shift/reduce conflict for LBRACE resolved as shift
    LBRACE          shift and go to state 106

  ! LBRACE          [ reduce using rule 166 (type_name -> map_type .) ]


state 62

    (161) expression -> type_name . LBRACE keyed_element_list RBRACE
    (162) expression -> type_name . LBRACE RBRACE

    LBRACE          shift and go to state 107


state 63

    (198) expression -> array_type . LBRACE expression_list RBRACE
    (199) expression -> array_type . LBRACE RBRACE
    (165) type_name -> array_type .

  ! shift/reduce conflict for LBRACE resolved as shift
    LBRACE          shift and go to state 108

  ! LBRACE          [ reduce using rule 165 (type_name -> array_type .) ]


state 64

    (65) slice_type -> LBRACKET RBRACKET . primitive_type
    (61) primitive_type -> . INT_TYPE
    (62) primitive_type -> . FLOAT64_TYPE
    (63) primitive_type -> . STRING_TYPE
    (64) primitive_type -> . BOOL_TYPE

    INT_TYPE        shift and go to state 34
    FLOAT64_TYPE    shift and go to state 35
    STRING_TYPE     shift and go to state 36
    BOOL_TYPE       shift and go to state 37

    primitive_type                 shift and go to state 109

state 65

    (197) array_type -> LBRACKET INT . RBRACKET primitive_type

    RBRACKET        shift and go to state 110


state 66

    (137) map_type -> MAP LBRACKET . primitive_type RBRACKET primitive_type
    (61) primitive_type -> . INT_TYPE
    (62) primitive_type -> . FLOAT64_TYPE
    (63) primitive_type -> . STRING_TYPE
    (64) primitive_type -> . BOOL_TYPE

    INT_TYPE        shift and go to state 34
    FLOAT64_TYPE    shift and go to state 35
    STRING_TYPE     shift and go to state 36
    BOOL_TYPE       shift and go to state 37

    primitive_type                 shift and go to state 111

state 67

    (18) global_const_dec -> CONST IDENTIFIER type ASSIGN . expression
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (125) expression -> . LNOT expression
    (126) expression -> . IDENTIFIER PLUSPLUS
    (127) expression -> . IDENTIFIER MINUSMINUS
    (138) expression -> . map_type LBRACE expression_map_list RBRACE
    (139) expression -> . map_type LBRACE RBRACE
    (161) expression -> . type_name LBRACE keyed_element_list RBRACE
    (162) expression -> . type_name LBRACE RBRACE
    (198) expression -> . array_type LBRACE expression_list RBRACE
    (199) expression -> . array_type LBRACE RBRACE
    (200) expression -> . expression DOT IDENTIFIER
    (201) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> . expression LBRACKET expression RBRACKET
    (203) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (137) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (163) type_name -> . IDENTIFIER
    (164) type_name -> . slice_type
    (165) type_name -> . array_type
    (166) type_name -> . map_type
    (197) array_type -> . LBRACKET INT RBRACKET primitive_type

    LPAREN          shift and go to state 54
    INT             shift and go to state 55
    FLOAT64         shift and go to state 56
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 57
    TRUE            shift and go to state 58
    FALSE           shift and go to state 59
    LNOT            shift and go to state 60
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    expression                     shift and go to state 112
    slice_type                     shift and go to state 53
    map_type                       shift and go to state 61
    type_name                      shift and go to state 62
    array_type                     shift and go to state 63

state 68

    (19) global_const_dec -> CONST IDENTIFIER ASSIGN expression .
    (36) expression -> expression . binary_operator expression
    (200) expression -> expression . DOT IDENTIFIER
    (201) expression -> expression . DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> expression . LBRACKET expression RBRACKET
    (37) binary_operator -> . PLUS
    (38) binary_operator -> . MINUS
    (39) binary_operator -> . TIMES
    (40) binary_operator -> . DIVIDE
    (41) binary_operator -> . MODULE
    (42) binary_operator -> . EQ
    (43) binary_operator -> . NEQ
    (44) binary_operator -> . LT
    (45) binary_operator -> . LE
    (46) binary_operator -> . GT
    (47) binary_operator -> . GE
    (48) binary_operator -> . LAND
    (49) binary_operator -> . LOR
    (50) binary_operator -> . AND
    (51) binary_operator -> . OR
    (52) binary_operator -> . XOR
    (53) binary_operator -> . AND_NOT
    (54) binary_operator -> . LSHIFT
    (55) binary_operator -> . RSHIFT

    VAR             reduce using rule 19 (global_const_dec -> CONST IDENTIFIER ASSIGN expression .)
    CONST           reduce using rule 19 (global_const_dec -> CONST IDENTIFIER ASSIGN expression .)
    FUNC            reduce using rule 19 (global_const_dec -> CONST IDENTIFIER ASSIGN expression .)
    TYPE            reduce using rule 19 (global_const_dec -> CONST IDENTIFIER ASSIGN expression .)
    $end            reduce using rule 19 (global_const_dec -> CONST IDENTIFIER ASSIGN expression .)
    DOT             shift and go to state 82
    LBRACKET        shift and go to state 83
    PLUS            shift and go to state 84
    MINUS           shift and go to state 85
    TIMES           shift and go to state 86
    DIVIDE          shift and go to state 87
    MODULE          shift and go to state 88
    EQ              shift and go to state 89
    NEQ             shift and go to state 90
    LT              shift and go to state 91
    LE              shift and go to state 92
    GT              shift and go to state 93
    GE              shift and go to state 94
    LAND            shift and go to state 95
    LOR             shift and go to state 96
    AND             shift and go to state 97
    OR              shift and go to state 98
    XOR             shift and go to state 99
    AND_NOT         shift and go to state 100
    LSHIFT          shift and go to state 101
    RSHIFT          shift and go to state 102

    binary_operator                shift and go to state 81

state 69

    (116) parameter -> IDENTIFIER . type
    (117) parameter -> IDENTIFIER . ELLIPSIS primitive_type
    (57) type -> . primitive_type
    (58) type -> . slice_type
    (59) type -> . array_type
    (60) type -> . map_type
    (61) primitive_type -> . INT_TYPE
    (62) primitive_type -> . FLOAT64_TYPE
    (63) primitive_type -> . STRING_TYPE
    (64) primitive_type -> . BOOL_TYPE
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (197) array_type -> . LBRACKET INT RBRACKET primitive_type
    (137) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type

    ELLIPSIS        shift and go to state 114
    INT_TYPE        shift and go to state 34
    FLOAT64_TYPE    shift and go to state 35
    STRING_TYPE     shift and go to state 36
    BOOL_TYPE       shift and go to state 37
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    type                           shift and go to state 113
    primitive_type                 shift and go to state 30
    slice_type                     shift and go to state 31
    array_type                     shift and go to state 32
    map_type                       shift and go to state 33

state 70

    (112) function_declaration -> FUNC IDENTIFIER LPAREN parameter_list . RPAREN return_type block
    (113) parameter_list -> parameter_list . COMMA parameter

    RPAREN          shift and go to state 115
    COMMA           shift and go to state 116


state 71

    (114) parameter_list -> parameter .

    RPAREN          reduce using rule 114 (parameter_list -> parameter .)
    COMMA           reduce using rule 114 (parameter_list -> parameter .)
=======
    (135) binary_expression -> expression PLUS . expression
    (82) expression -> . binary_expression
    (83) expression -> . relational_expression
    (84) expression -> . logical_expression
    (85) expression -> . bitwise_expression
    (86) expression -> . PLUS expression
    (87) expression -> . MINUS expression
    (88) expression -> . LNOT expression
    (89) expression -> . LBRACKET RBRACKET primitive_type LBRACE expression_list RBRACE
    (90) expression -> . LBRACKET RBRACKET primitive_type LBRACE RBRACE
    (91) expression -> . LPAREN expression RPAREN
    (92) expression -> . INT
    (93) expression -> . FLOAT64
    (94) expression -> . TRUE
    (95) expression -> . FALSE
    (96) expression -> . IDENTIFIER
    (97) expression -> . STRING
    (98) expression -> . IDENTIFIER PLUSPLUS
    (99) expression -> . IDENTIFIER MINUSMINUS
    (100) expression -> . expression DOT IDENTIFIER
    (103) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (133) expression -> . IDENTIFIER LBRACE keyed_element_list RBRACE
    (134) expression -> . IDENTIFIER LBRACE RBRACE
    (135) binary_expression -> . expression PLUS expression
    (136) binary_expression -> . expression MINUS expression
    (137) binary_expression -> . expression TIMES expression
    (138) binary_expression -> . expression DIVIDE expression
    (139) binary_expression -> . expression MODULE expression
    (144) relational_expression -> . expression EQ expression
    (145) relational_expression -> . expression NEQ expression
    (146) relational_expression -> . expression LT expression
    (147) relational_expression -> . expression LE expression
    (148) relational_expression -> . expression GT expression
    (149) relational_expression -> . expression GE expression
    (150) logical_expression -> . expression LAND expression
    (151) logical_expression -> . expression LOR expression
    (152) bitwise_expression -> . expression AND expression
    (153) bitwise_expression -> . expression OR expression
    (154) bitwise_expression -> . expression XOR expression
    (155) bitwise_expression -> . expression AND_NOT expression
    (156) bitwise_expression -> . expression LSHIFT expression
    (157) bitwise_expression -> . expression RSHIFT expression

    PLUS            shift and go to state 37
    MINUS           shift and go to state 38
    LNOT            shift and go to state 39
    LBRACKET        shift and go to state 40
    LPAREN          shift and go to state 29
    INT             shift and go to state 41
    FLOAT64         shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44
    IDENTIFIER      shift and go to state 97
    STRING          shift and go to state 11

    expression                     shift and go to state 119
    binary_expression              shift and go to state 33
    relational_expression          shift and go to state 34
    logical_expression             shift and go to state 35
    bitwise_expression             shift and go to state 36

state 60

    (136) binary_expression -> expression MINUS . expression
    (82) expression -> . binary_expression
    (83) expression -> . relational_expression
    (84) expression -> . logical_expression
    (85) expression -> . bitwise_expression
    (86) expression -> . PLUS expression
    (87) expression -> . MINUS expression
    (88) expression -> . LNOT expression
    (89) expression -> . LBRACKET RBRACKET primitive_type LBRACE expression_list RBRACE
    (90) expression -> . LBRACKET RBRACKET primitive_type LBRACE RBRACE
    (91) expression -> . LPAREN expression RPAREN
    (92) expression -> . INT
    (93) expression -> . FLOAT64
    (94) expression -> . TRUE
    (95) expression -> . FALSE
    (96) expression -> . IDENTIFIER
    (97) expression -> . STRING
    (98) expression -> . IDENTIFIER PLUSPLUS
    (99) expression -> . IDENTIFIER MINUSMINUS
    (100) expression -> . expression DOT IDENTIFIER
    (103) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (133) expression -> . IDENTIFIER LBRACE keyed_element_list RBRACE
    (134) expression -> . IDENTIFIER LBRACE RBRACE
    (135) binary_expression -> . expression PLUS expression
    (136) binary_expression -> . expression MINUS expression
    (137) binary_expression -> . expression TIMES expression
    (138) binary_expression -> . expression DIVIDE expression
    (139) binary_expression -> . expression MODULE expression
    (144) relational_expression -> . expression EQ expression
    (145) relational_expression -> . expression NEQ expression
    (146) relational_expression -> . expression LT expression
    (147) relational_expression -> . expression LE expression
    (148) relational_expression -> . expression GT expression
    (149) relational_expression -> . expression GE expression
    (150) logical_expression -> . expression LAND expression
    (151) logical_expression -> . expression LOR expression
    (152) bitwise_expression -> . expression AND expression
    (153) bitwise_expression -> . expression OR expression
    (154) bitwise_expression -> . expression XOR expression
    (155) bitwise_expression -> . expression AND_NOT expression
    (156) bitwise_expression -> . expression LSHIFT expression
    (157) bitwise_expression -> . expression RSHIFT expression

    PLUS            shift and go to state 37
    MINUS           shift and go to state 38
    LNOT            shift and go to state 39
    LBRACKET        shift and go to state 40
    LPAREN          shift and go to state 29
    INT             shift and go to state 41
    FLOAT64         shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44
    IDENTIFIER      shift and go to state 97
    STRING          shift and go to state 11

    expression                     shift and go to state 120
    binary_expression              shift and go to state 33
    relational_expression          shift and go to state 34
    logical_expression             shift and go to state 35
    bitwise_expression             shift and go to state 36

state 61

    (137) binary_expression -> expression TIMES . expression
    (82) expression -> . binary_expression
    (83) expression -> . relational_expression
    (84) expression -> . logical_expression
    (85) expression -> . bitwise_expression
    (86) expression -> . PLUS expression
    (87) expression -> . MINUS expression
    (88) expression -> . LNOT expression
    (89) expression -> . LBRACKET RBRACKET primitive_type LBRACE expression_list RBRACE
    (90) expression -> . LBRACKET RBRACKET primitive_type LBRACE RBRACE
    (91) expression -> . LPAREN expression RPAREN
    (92) expression -> . INT
    (93) expression -> . FLOAT64
    (94) expression -> . TRUE
    (95) expression -> . FALSE
    (96) expression -> . IDENTIFIER
    (97) expression -> . STRING
    (98) expression -> . IDENTIFIER PLUSPLUS
    (99) expression -> . IDENTIFIER MINUSMINUS
    (100) expression -> . expression DOT IDENTIFIER
    (103) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (133) expression -> . IDENTIFIER LBRACE keyed_element_list RBRACE
    (134) expression -> . IDENTIFIER LBRACE RBRACE
    (135) binary_expression -> . expression PLUS expression
    (136) binary_expression -> . expression MINUS expression
    (137) binary_expression -> . expression TIMES expression
    (138) binary_expression -> . expression DIVIDE expression
    (139) binary_expression -> . expression MODULE expression
    (144) relational_expression -> . expression EQ expression
    (145) relational_expression -> . expression NEQ expression
    (146) relational_expression -> . expression LT expression
    (147) relational_expression -> . expression LE expression
    (148) relational_expression -> . expression GT expression
    (149) relational_expression -> . expression GE expression
    (150) logical_expression -> . expression LAND expression
    (151) logical_expression -> . expression LOR expression
    (152) bitwise_expression -> . expression AND expression
    (153) bitwise_expression -> . expression OR expression
    (154) bitwise_expression -> . expression XOR expression
    (155) bitwise_expression -> . expression AND_NOT expression
    (156) bitwise_expression -> . expression LSHIFT expression
    (157) bitwise_expression -> . expression RSHIFT expression

    PLUS            shift and go to state 37
    MINUS           shift and go to state 38
    LNOT            shift and go to state 39
    LBRACKET        shift and go to state 40
    LPAREN          shift and go to state 29
    INT             shift and go to state 41
    FLOAT64         shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44
    IDENTIFIER      shift and go to state 97
    STRING          shift and go to state 11

    expression                     shift and go to state 121
    binary_expression              shift and go to state 33
    relational_expression          shift and go to state 34
    logical_expression             shift and go to state 35
    bitwise_expression             shift and go to state 36

state 62

    (138) binary_expression -> expression DIVIDE . expression
    (82) expression -> . binary_expression
    (83) expression -> . relational_expression
    (84) expression -> . logical_expression
    (85) expression -> . bitwise_expression
    (86) expression -> . PLUS expression
    (87) expression -> . MINUS expression
    (88) expression -> . LNOT expression
    (89) expression -> . LBRACKET RBRACKET primitive_type LBRACE expression_list RBRACE
    (90) expression -> . LBRACKET RBRACKET primitive_type LBRACE RBRACE
    (91) expression -> . LPAREN expression RPAREN
    (92) expression -> . INT
    (93) expression -> . FLOAT64
    (94) expression -> . TRUE
    (95) expression -> . FALSE
    (96) expression -> . IDENTIFIER
    (97) expression -> . STRING
    (98) expression -> . IDENTIFIER PLUSPLUS
    (99) expression -> . IDENTIFIER MINUSMINUS
    (100) expression -> . expression DOT IDENTIFIER
    (103) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (133) expression -> . IDENTIFIER LBRACE keyed_element_list RBRACE
    (134) expression -> . IDENTIFIER LBRACE RBRACE
    (135) binary_expression -> . expression PLUS expression
    (136) binary_expression -> . expression MINUS expression
    (137) binary_expression -> . expression TIMES expression
    (138) binary_expression -> . expression DIVIDE expression
    (139) binary_expression -> . expression MODULE expression
    (144) relational_expression -> . expression EQ expression
    (145) relational_expression -> . expression NEQ expression
    (146) relational_expression -> . expression LT expression
    (147) relational_expression -> . expression LE expression
    (148) relational_expression -> . expression GT expression
    (149) relational_expression -> . expression GE expression
    (150) logical_expression -> . expression LAND expression
    (151) logical_expression -> . expression LOR expression
    (152) bitwise_expression -> . expression AND expression
    (153) bitwise_expression -> . expression OR expression
    (154) bitwise_expression -> . expression XOR expression
    (155) bitwise_expression -> . expression AND_NOT expression
    (156) bitwise_expression -> . expression LSHIFT expression
    (157) bitwise_expression -> . expression RSHIFT expression

    PLUS            shift and go to state 37
    MINUS           shift and go to state 38
    LNOT            shift and go to state 39
    LBRACKET        shift and go to state 40
    LPAREN          shift and go to state 29
    INT             shift and go to state 41
    FLOAT64         shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44
    IDENTIFIER      shift and go to state 97
    STRING          shift and go to state 11

    expression                     shift and go to state 122
    binary_expression              shift and go to state 33
    relational_expression          shift and go to state 34
    logical_expression             shift and go to state 35
    bitwise_expression             shift and go to state 36

state 63

    (139) binary_expression -> expression MODULE . expression
    (82) expression -> . binary_expression
    (83) expression -> . relational_expression
    (84) expression -> . logical_expression
    (85) expression -> . bitwise_expression
    (86) expression -> . PLUS expression
    (87) expression -> . MINUS expression
    (88) expression -> . LNOT expression
    (89) expression -> . LBRACKET RBRACKET primitive_type LBRACE expression_list RBRACE
    (90) expression -> . LBRACKET RBRACKET primitive_type LBRACE RBRACE
    (91) expression -> . LPAREN expression RPAREN
    (92) expression -> . INT
    (93) expression -> . FLOAT64
    (94) expression -> . TRUE
    (95) expression -> . FALSE
    (96) expression -> . IDENTIFIER
    (97) expression -> . STRING
    (98) expression -> . IDENTIFIER PLUSPLUS
    (99) expression -> . IDENTIFIER MINUSMINUS
    (100) expression -> . expression DOT IDENTIFIER
    (103) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (133) expression -> . IDENTIFIER LBRACE keyed_element_list RBRACE
    (134) expression -> . IDENTIFIER LBRACE RBRACE
    (135) binary_expression -> . expression PLUS expression
    (136) binary_expression -> . expression MINUS expression
    (137) binary_expression -> . expression TIMES expression
    (138) binary_expression -> . expression DIVIDE expression
    (139) binary_expression -> . expression MODULE expression
    (144) relational_expression -> . expression EQ expression
    (145) relational_expression -> . expression NEQ expression
    (146) relational_expression -> . expression LT expression
    (147) relational_expression -> . expression LE expression
    (148) relational_expression -> . expression GT expression
    (149) relational_expression -> . expression GE expression
    (150) logical_expression -> . expression LAND expression
    (151) logical_expression -> . expression LOR expression
    (152) bitwise_expression -> . expression AND expression
    (153) bitwise_expression -> . expression OR expression
    (154) bitwise_expression -> . expression XOR expression
    (155) bitwise_expression -> . expression AND_NOT expression
    (156) bitwise_expression -> . expression LSHIFT expression
    (157) bitwise_expression -> . expression RSHIFT expression

    PLUS            shift and go to state 37
    MINUS           shift and go to state 38
    LNOT            shift and go to state 39
    LBRACKET        shift and go to state 40
    LPAREN          shift and go to state 29
    INT             shift and go to state 41
    FLOAT64         shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44
    IDENTIFIER      shift and go to state 97
    STRING          shift and go to state 11

    expression                     shift and go to state 123
    binary_expression              shift and go to state 33
    relational_expression          shift and go to state 34
    logical_expression             shift and go to state 35
    bitwise_expression             shift and go to state 36

state 64

    (144) relational_expression -> expression EQ . expression
    (82) expression -> . binary_expression
    (83) expression -> . relational_expression
    (84) expression -> . logical_expression
    (85) expression -> . bitwise_expression
    (86) expression -> . PLUS expression
    (87) expression -> . MINUS expression
    (88) expression -> . LNOT expression
    (89) expression -> . LBRACKET RBRACKET primitive_type LBRACE expression_list RBRACE
    (90) expression -> . LBRACKET RBRACKET primitive_type LBRACE RBRACE
    (91) expression -> . LPAREN expression RPAREN
    (92) expression -> . INT
    (93) expression -> . FLOAT64
    (94) expression -> . TRUE
    (95) expression -> . FALSE
    (96) expression -> . IDENTIFIER
    (97) expression -> . STRING
    (98) expression -> . IDENTIFIER PLUSPLUS
    (99) expression -> . IDENTIFIER MINUSMINUS
    (100) expression -> . expression DOT IDENTIFIER
    (103) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (133) expression -> . IDENTIFIER LBRACE keyed_element_list RBRACE
    (134) expression -> . IDENTIFIER LBRACE RBRACE
    (135) binary_expression -> . expression PLUS expression
    (136) binary_expression -> . expression MINUS expression
    (137) binary_expression -> . expression TIMES expression
    (138) binary_expression -> . expression DIVIDE expression
    (139) binary_expression -> . expression MODULE expression
    (144) relational_expression -> . expression EQ expression
    (145) relational_expression -> . expression NEQ expression
    (146) relational_expression -> . expression LT expression
    (147) relational_expression -> . expression LE expression
    (148) relational_expression -> . expression GT expression
    (149) relational_expression -> . expression GE expression
    (150) logical_expression -> . expression LAND expression
    (151) logical_expression -> . expression LOR expression
    (152) bitwise_expression -> . expression AND expression
    (153) bitwise_expression -> . expression OR expression
    (154) bitwise_expression -> . expression XOR expression
    (155) bitwise_expression -> . expression AND_NOT expression
    (156) bitwise_expression -> . expression LSHIFT expression
    (157) bitwise_expression -> . expression RSHIFT expression

    PLUS            shift and go to state 37
    MINUS           shift and go to state 38
    LNOT            shift and go to state 39
    LBRACKET        shift and go to state 40
    LPAREN          shift and go to state 29
    INT             shift and go to state 41
    FLOAT64         shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44
    IDENTIFIER      shift and go to state 97
    STRING          shift and go to state 11

    expression                     shift and go to state 124
    binary_expression              shift and go to state 33
    relational_expression          shift and go to state 34
    logical_expression             shift and go to state 35
    bitwise_expression             shift and go to state 36

state 65

    (145) relational_expression -> expression NEQ . expression
    (82) expression -> . binary_expression
    (83) expression -> . relational_expression
    (84) expression -> . logical_expression
    (85) expression -> . bitwise_expression
    (86) expression -> . PLUS expression
    (87) expression -> . MINUS expression
    (88) expression -> . LNOT expression
    (89) expression -> . LBRACKET RBRACKET primitive_type LBRACE expression_list RBRACE
    (90) expression -> . LBRACKET RBRACKET primitive_type LBRACE RBRACE
    (91) expression -> . LPAREN expression RPAREN
    (92) expression -> . INT
    (93) expression -> . FLOAT64
    (94) expression -> . TRUE
    (95) expression -> . FALSE
    (96) expression -> . IDENTIFIER
    (97) expression -> . STRING
    (98) expression -> . IDENTIFIER PLUSPLUS
    (99) expression -> . IDENTIFIER MINUSMINUS
    (100) expression -> . expression DOT IDENTIFIER
    (103) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (133) expression -> . IDENTIFIER LBRACE keyed_element_list RBRACE
    (134) expression -> . IDENTIFIER LBRACE RBRACE
    (135) binary_expression -> . expression PLUS expression
    (136) binary_expression -> . expression MINUS expression
    (137) binary_expression -> . expression TIMES expression
    (138) binary_expression -> . expression DIVIDE expression
    (139) binary_expression -> . expression MODULE expression
    (144) relational_expression -> . expression EQ expression
    (145) relational_expression -> . expression NEQ expression
    (146) relational_expression -> . expression LT expression
    (147) relational_expression -> . expression LE expression
    (148) relational_expression -> . expression GT expression
    (149) relational_expression -> . expression GE expression
    (150) logical_expression -> . expression LAND expression
    (151) logical_expression -> . expression LOR expression
    (152) bitwise_expression -> . expression AND expression
    (153) bitwise_expression -> . expression OR expression
    (154) bitwise_expression -> . expression XOR expression
    (155) bitwise_expression -> . expression AND_NOT expression
    (156) bitwise_expression -> . expression LSHIFT expression
    (157) bitwise_expression -> . expression RSHIFT expression

    PLUS            shift and go to state 37
    MINUS           shift and go to state 38
    LNOT            shift and go to state 39
    LBRACKET        shift and go to state 40
    LPAREN          shift and go to state 29
    INT             shift and go to state 41
    FLOAT64         shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44
    IDENTIFIER      shift and go to state 97
    STRING          shift and go to state 11

    expression                     shift and go to state 125
    binary_expression              shift and go to state 33
    relational_expression          shift and go to state 34
    logical_expression             shift and go to state 35
    bitwise_expression             shift and go to state 36

state 66

    (146) relational_expression -> expression LT . expression
    (82) expression -> . binary_expression
    (83) expression -> . relational_expression
    (84) expression -> . logical_expression
    (85) expression -> . bitwise_expression
    (86) expression -> . PLUS expression
    (87) expression -> . MINUS expression
    (88) expression -> . LNOT expression
    (89) expression -> . LBRACKET RBRACKET primitive_type LBRACE expression_list RBRACE
    (90) expression -> . LBRACKET RBRACKET primitive_type LBRACE RBRACE
    (91) expression -> . LPAREN expression RPAREN
    (92) expression -> . INT
    (93) expression -> . FLOAT64
    (94) expression -> . TRUE
    (95) expression -> . FALSE
    (96) expression -> . IDENTIFIER
    (97) expression -> . STRING
    (98) expression -> . IDENTIFIER PLUSPLUS
    (99) expression -> . IDENTIFIER MINUSMINUS
    (100) expression -> . expression DOT IDENTIFIER
    (103) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (133) expression -> . IDENTIFIER LBRACE keyed_element_list RBRACE
    (134) expression -> . IDENTIFIER LBRACE RBRACE
    (135) binary_expression -> . expression PLUS expression
    (136) binary_expression -> . expression MINUS expression
    (137) binary_expression -> . expression TIMES expression
    (138) binary_expression -> . expression DIVIDE expression
    (139) binary_expression -> . expression MODULE expression
    (144) relational_expression -> . expression EQ expression
    (145) relational_expression -> . expression NEQ expression
    (146) relational_expression -> . expression LT expression
    (147) relational_expression -> . expression LE expression
    (148) relational_expression -> . expression GT expression
    (149) relational_expression -> . expression GE expression
    (150) logical_expression -> . expression LAND expression
    (151) logical_expression -> . expression LOR expression
    (152) bitwise_expression -> . expression AND expression
    (153) bitwise_expression -> . expression OR expression
    (154) bitwise_expression -> . expression XOR expression
    (155) bitwise_expression -> . expression AND_NOT expression
    (156) bitwise_expression -> . expression LSHIFT expression
    (157) bitwise_expression -> . expression RSHIFT expression

    PLUS            shift and go to state 37
    MINUS           shift and go to state 38
    LNOT            shift and go to state 39
    LBRACKET        shift and go to state 40
    LPAREN          shift and go to state 29
    INT             shift and go to state 41
    FLOAT64         shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44
    IDENTIFIER      shift and go to state 97
    STRING          shift and go to state 11

    expression                     shift and go to state 126
    binary_expression              shift and go to state 33
    relational_expression          shift and go to state 34
    logical_expression             shift and go to state 35
    bitwise_expression             shift and go to state 36

state 67

    (147) relational_expression -> expression LE . expression
    (82) expression -> . binary_expression
    (83) expression -> . relational_expression
    (84) expression -> . logical_expression
    (85) expression -> . bitwise_expression
    (86) expression -> . PLUS expression
    (87) expression -> . MINUS expression
    (88) expression -> . LNOT expression
    (89) expression -> . LBRACKET RBRACKET primitive_type LBRACE expression_list RBRACE
    (90) expression -> . LBRACKET RBRACKET primitive_type LBRACE RBRACE
    (91) expression -> . LPAREN expression RPAREN
    (92) expression -> . INT
    (93) expression -> . FLOAT64
    (94) expression -> . TRUE
    (95) expression -> . FALSE
    (96) expression -> . IDENTIFIER
    (97) expression -> . STRING
    (98) expression -> . IDENTIFIER PLUSPLUS
    (99) expression -> . IDENTIFIER MINUSMINUS
    (100) expression -> . expression DOT IDENTIFIER
    (103) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (133) expression -> . IDENTIFIER LBRACE keyed_element_list RBRACE
    (134) expression -> . IDENTIFIER LBRACE RBRACE
    (135) binary_expression -> . expression PLUS expression
    (136) binary_expression -> . expression MINUS expression
    (137) binary_expression -> . expression TIMES expression
    (138) binary_expression -> . expression DIVIDE expression
    (139) binary_expression -> . expression MODULE expression
    (144) relational_expression -> . expression EQ expression
    (145) relational_expression -> . expression NEQ expression
    (146) relational_expression -> . expression LT expression
    (147) relational_expression -> . expression LE expression
    (148) relational_expression -> . expression GT expression
    (149) relational_expression -> . expression GE expression
    (150) logical_expression -> . expression LAND expression
    (151) logical_expression -> . expression LOR expression
    (152) bitwise_expression -> . expression AND expression
    (153) bitwise_expression -> . expression OR expression
    (154) bitwise_expression -> . expression XOR expression
    (155) bitwise_expression -> . expression AND_NOT expression
    (156) bitwise_expression -> . expression LSHIFT expression
    (157) bitwise_expression -> . expression RSHIFT expression

    PLUS            shift and go to state 37
    MINUS           shift and go to state 38
    LNOT            shift and go to state 39
    LBRACKET        shift and go to state 40
    LPAREN          shift and go to state 29
    INT             shift and go to state 41
    FLOAT64         shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44
    IDENTIFIER      shift and go to state 97
    STRING          shift and go to state 11

    expression                     shift and go to state 127
    binary_expression              shift and go to state 33
    relational_expression          shift and go to state 34
    logical_expression             shift and go to state 35
    bitwise_expression             shift and go to state 36

state 68

    (148) relational_expression -> expression GT . expression
    (82) expression -> . binary_expression
    (83) expression -> . relational_expression
    (84) expression -> . logical_expression
    (85) expression -> . bitwise_expression
    (86) expression -> . PLUS expression
    (87) expression -> . MINUS expression
    (88) expression -> . LNOT expression
    (89) expression -> . LBRACKET RBRACKET primitive_type LBRACE expression_list RBRACE
    (90) expression -> . LBRACKET RBRACKET primitive_type LBRACE RBRACE
    (91) expression -> . LPAREN expression RPAREN
    (92) expression -> . INT
    (93) expression -> . FLOAT64
    (94) expression -> . TRUE
    (95) expression -> . FALSE
    (96) expression -> . IDENTIFIER
    (97) expression -> . STRING
    (98) expression -> . IDENTIFIER PLUSPLUS
    (99) expression -> . IDENTIFIER MINUSMINUS
    (100) expression -> . expression DOT IDENTIFIER
    (103) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (133) expression -> . IDENTIFIER LBRACE keyed_element_list RBRACE
    (134) expression -> . IDENTIFIER LBRACE RBRACE
    (135) binary_expression -> . expression PLUS expression
    (136) binary_expression -> . expression MINUS expression
    (137) binary_expression -> . expression TIMES expression
    (138) binary_expression -> . expression DIVIDE expression
    (139) binary_expression -> . expression MODULE expression
    (144) relational_expression -> . expression EQ expression
    (145) relational_expression -> . expression NEQ expression
    (146) relational_expression -> . expression LT expression
    (147) relational_expression -> . expression LE expression
    (148) relational_expression -> . expression GT expression
    (149) relational_expression -> . expression GE expression
    (150) logical_expression -> . expression LAND expression
    (151) logical_expression -> . expression LOR expression
    (152) bitwise_expression -> . expression AND expression
    (153) bitwise_expression -> . expression OR expression
    (154) bitwise_expression -> . expression XOR expression
    (155) bitwise_expression -> . expression AND_NOT expression
    (156) bitwise_expression -> . expression LSHIFT expression
    (157) bitwise_expression -> . expression RSHIFT expression

    PLUS            shift and go to state 37
    MINUS           shift and go to state 38
    LNOT            shift and go to state 39
    LBRACKET        shift and go to state 40
    LPAREN          shift and go to state 29
    INT             shift and go to state 41
    FLOAT64         shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44
    IDENTIFIER      shift and go to state 97
    STRING          shift and go to state 11

    expression                     shift and go to state 128
    binary_expression              shift and go to state 33
    relational_expression          shift and go to state 34
    logical_expression             shift and go to state 35
    bitwise_expression             shift and go to state 36

state 69

    (149) relational_expression -> expression GE . expression
    (82) expression -> . binary_expression
    (83) expression -> . relational_expression
    (84) expression -> . logical_expression
    (85) expression -> . bitwise_expression
    (86) expression -> . PLUS expression
    (87) expression -> . MINUS expression
    (88) expression -> . LNOT expression
    (89) expression -> . LBRACKET RBRACKET primitive_type LBRACE expression_list RBRACE
    (90) expression -> . LBRACKET RBRACKET primitive_type LBRACE RBRACE
    (91) expression -> . LPAREN expression RPAREN
    (92) expression -> . INT
    (93) expression -> . FLOAT64
    (94) expression -> . TRUE
    (95) expression -> . FALSE
    (96) expression -> . IDENTIFIER
    (97) expression -> . STRING
    (98) expression -> . IDENTIFIER PLUSPLUS
    (99) expression -> . IDENTIFIER MINUSMINUS
    (100) expression -> . expression DOT IDENTIFIER
    (103) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (133) expression -> . IDENTIFIER LBRACE keyed_element_list RBRACE
    (134) expression -> . IDENTIFIER LBRACE RBRACE
    (135) binary_expression -> . expression PLUS expression
    (136) binary_expression -> . expression MINUS expression
    (137) binary_expression -> . expression TIMES expression
    (138) binary_expression -> . expression DIVIDE expression
    (139) binary_expression -> . expression MODULE expression
    (144) relational_expression -> . expression EQ expression
    (145) relational_expression -> . expression NEQ expression
    (146) relational_expression -> . expression LT expression
    (147) relational_expression -> . expression LE expression
    (148) relational_expression -> . expression GT expression
    (149) relational_expression -> . expression GE expression
    (150) logical_expression -> . expression LAND expression
    (151) logical_expression -> . expression LOR expression
    (152) bitwise_expression -> . expression AND expression
    (153) bitwise_expression -> . expression OR expression
    (154) bitwise_expression -> . expression XOR expression
    (155) bitwise_expression -> . expression AND_NOT expression
    (156) bitwise_expression -> . expression LSHIFT expression
    (157) bitwise_expression -> . expression RSHIFT expression

    PLUS            shift and go to state 37
    MINUS           shift and go to state 38
    LNOT            shift and go to state 39
    LBRACKET        shift and go to state 40
    LPAREN          shift and go to state 29
    INT             shift and go to state 41
    FLOAT64         shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44
    IDENTIFIER      shift and go to state 97
    STRING          shift and go to state 11

    expression                     shift and go to state 129
    binary_expression              shift and go to state 33
    relational_expression          shift and go to state 34
    logical_expression             shift and go to state 35
    bitwise_expression             shift and go to state 36

state 70

    (150) logical_expression -> expression LAND . expression
    (82) expression -> . binary_expression
    (83) expression -> . relational_expression
    (84) expression -> . logical_expression
    (85) expression -> . bitwise_expression
    (86) expression -> . PLUS expression
    (87) expression -> . MINUS expression
    (88) expression -> . LNOT expression
    (89) expression -> . LBRACKET RBRACKET primitive_type LBRACE expression_list RBRACE
    (90) expression -> . LBRACKET RBRACKET primitive_type LBRACE RBRACE
    (91) expression -> . LPAREN expression RPAREN
    (92) expression -> . INT
    (93) expression -> . FLOAT64
    (94) expression -> . TRUE
    (95) expression -> . FALSE
    (96) expression -> . IDENTIFIER
    (97) expression -> . STRING
    (98) expression -> . IDENTIFIER PLUSPLUS
    (99) expression -> . IDENTIFIER MINUSMINUS
    (100) expression -> . expression DOT IDENTIFIER
    (103) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (133) expression -> . IDENTIFIER LBRACE keyed_element_list RBRACE
    (134) expression -> . IDENTIFIER LBRACE RBRACE
    (135) binary_expression -> . expression PLUS expression
    (136) binary_expression -> . expression MINUS expression
    (137) binary_expression -> . expression TIMES expression
    (138) binary_expression -> . expression DIVIDE expression
    (139) binary_expression -> . expression MODULE expression
    (144) relational_expression -> . expression EQ expression
    (145) relational_expression -> . expression NEQ expression
    (146) relational_expression -> . expression LT expression
    (147) relational_expression -> . expression LE expression
    (148) relational_expression -> . expression GT expression
    (149) relational_expression -> . expression GE expression
    (150) logical_expression -> . expression LAND expression
    (151) logical_expression -> . expression LOR expression
    (152) bitwise_expression -> . expression AND expression
    (153) bitwise_expression -> . expression OR expression
    (154) bitwise_expression -> . expression XOR expression
    (155) bitwise_expression -> . expression AND_NOT expression
    (156) bitwise_expression -> . expression LSHIFT expression
    (157) bitwise_expression -> . expression RSHIFT expression

    PLUS            shift and go to state 37
    MINUS           shift and go to state 38
    LNOT            shift and go to state 39
    LBRACKET        shift and go to state 40
    LPAREN          shift and go to state 29
    INT             shift and go to state 41
    FLOAT64         shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44
    IDENTIFIER      shift and go to state 97
    STRING          shift and go to state 11

    expression                     shift and go to state 130
    binary_expression              shift and go to state 33
    relational_expression          shift and go to state 34
    logical_expression             shift and go to state 35
    bitwise_expression             shift and go to state 36

state 71

    (151) logical_expression -> expression LOR . expression
    (82) expression -> . binary_expression
    (83) expression -> . relational_expression
    (84) expression -> . logical_expression
    (85) expression -> . bitwise_expression
    (86) expression -> . PLUS expression
    (87) expression -> . MINUS expression
    (88) expression -> . LNOT expression
    (89) expression -> . LBRACKET RBRACKET primitive_type LBRACE expression_list RBRACE
    (90) expression -> . LBRACKET RBRACKET primitive_type LBRACE RBRACE
    (91) expression -> . LPAREN expression RPAREN
    (92) expression -> . INT
    (93) expression -> . FLOAT64
    (94) expression -> . TRUE
    (95) expression -> . FALSE
    (96) expression -> . IDENTIFIER
    (97) expression -> . STRING
    (98) expression -> . IDENTIFIER PLUSPLUS
    (99) expression -> . IDENTIFIER MINUSMINUS
    (100) expression -> . expression DOT IDENTIFIER
    (103) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (133) expression -> . IDENTIFIER LBRACE keyed_element_list RBRACE
    (134) expression -> . IDENTIFIER LBRACE RBRACE
    (135) binary_expression -> . expression PLUS expression
    (136) binary_expression -> . expression MINUS expression
    (137) binary_expression -> . expression TIMES expression
    (138) binary_expression -> . expression DIVIDE expression
    (139) binary_expression -> . expression MODULE expression
    (144) relational_expression -> . expression EQ expression
    (145) relational_expression -> . expression NEQ expression
    (146) relational_expression -> . expression LT expression
    (147) relational_expression -> . expression LE expression
    (148) relational_expression -> . expression GT expression
    (149) relational_expression -> . expression GE expression
    (150) logical_expression -> . expression LAND expression
    (151) logical_expression -> . expression LOR expression
    (152) bitwise_expression -> . expression AND expression
    (153) bitwise_expression -> . expression OR expression
    (154) bitwise_expression -> . expression XOR expression
    (155) bitwise_expression -> . expression AND_NOT expression
    (156) bitwise_expression -> . expression LSHIFT expression
    (157) bitwise_expression -> . expression RSHIFT expression

    PLUS            shift and go to state 37
    MINUS           shift and go to state 38
    LNOT            shift and go to state 39
    LBRACKET        shift and go to state 40
    LPAREN          shift and go to state 29
    INT             shift and go to state 41
    FLOAT64         shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44
    IDENTIFIER      shift and go to state 97
    STRING          shift and go to state 11
>>>>>>> Stashed changes

    expression                     shift and go to state 131
    binary_expression              shift and go to state 33
    relational_expression          shift and go to state 34
    logical_expression             shift and go to state 35
    bitwise_expression             shift and go to state 36

state 72

<<<<<<< Updated upstream
    (115) parameter_list -> empty .

    RPAREN          reduce using rule 115 (parameter_list -> empty .)
    COMMA           reduce using rule 115 (parameter_list -> empty .)
=======
    (152) bitwise_expression -> expression AND . expression
    (82) expression -> . binary_expression
    (83) expression -> . relational_expression
    (84) expression -> . logical_expression
    (85) expression -> . bitwise_expression
    (86) expression -> . PLUS expression
    (87) expression -> . MINUS expression
    (88) expression -> . LNOT expression
    (89) expression -> . LBRACKET RBRACKET primitive_type LBRACE expression_list RBRACE
    (90) expression -> . LBRACKET RBRACKET primitive_type LBRACE RBRACE
    (91) expression -> . LPAREN expression RPAREN
    (92) expression -> . INT
    (93) expression -> . FLOAT64
    (94) expression -> . TRUE
    (95) expression -> . FALSE
    (96) expression -> . IDENTIFIER
    (97) expression -> . STRING
    (98) expression -> . IDENTIFIER PLUSPLUS
    (99) expression -> . IDENTIFIER MINUSMINUS
    (100) expression -> . expression DOT IDENTIFIER
    (103) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (133) expression -> . IDENTIFIER LBRACE keyed_element_list RBRACE
    (134) expression -> . IDENTIFIER LBRACE RBRACE
    (135) binary_expression -> . expression PLUS expression
    (136) binary_expression -> . expression MINUS expression
    (137) binary_expression -> . expression TIMES expression
    (138) binary_expression -> . expression DIVIDE expression
    (139) binary_expression -> . expression MODULE expression
    (144) relational_expression -> . expression EQ expression
    (145) relational_expression -> . expression NEQ expression
    (146) relational_expression -> . expression LT expression
    (147) relational_expression -> . expression LE expression
    (148) relational_expression -> . expression GT expression
    (149) relational_expression -> . expression GE expression
    (150) logical_expression -> . expression LAND expression
    (151) logical_expression -> . expression LOR expression
    (152) bitwise_expression -> . expression AND expression
    (153) bitwise_expression -> . expression OR expression
    (154) bitwise_expression -> . expression XOR expression
    (155) bitwise_expression -> . expression AND_NOT expression
    (156) bitwise_expression -> . expression LSHIFT expression
    (157) bitwise_expression -> . expression RSHIFT expression

    PLUS            shift and go to state 37
    MINUS           shift and go to state 38
    LNOT            shift and go to state 39
    LBRACKET        shift and go to state 40
    LPAREN          shift and go to state 29
    INT             shift and go to state 41
    FLOAT64         shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44
    IDENTIFIER      shift and go to state 97
    STRING          shift and go to state 11
>>>>>>> Stashed changes

    expression                     shift and go to state 132
    binary_expression              shift and go to state 33
    relational_expression          shift and go to state 34
    logical_expression             shift and go to state 35
    bitwise_expression             shift and go to state 36

state 73

<<<<<<< Updated upstream
    (146) method_declaration -> FUNC LPAREN receiver RPAREN . IDENTIFIER LPAREN parameter_list RPAREN return_type block

    IDENTIFIER      shift and go to state 117


state 74

    (147) receiver -> IDENTIFIER IDENTIFIER .

    RPAREN          reduce using rule 147 (receiver -> IDENTIFIER IDENTIFIER .)


state 75

    (148) receiver -> IDENTIFIER TIMES . IDENTIFIER
    (149) receiver -> IDENTIFIER TIMES . type
    (57) type -> . primitive_type
    (58) type -> . slice_type
    (59) type -> . array_type
    (60) type -> . map_type
    (61) primitive_type -> . INT_TYPE
    (62) primitive_type -> . FLOAT64_TYPE
    (63) primitive_type -> . STRING_TYPE
    (64) primitive_type -> . BOOL_TYPE
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (197) array_type -> . LBRACKET INT RBRACKET primitive_type
    (137) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type

    IDENTIFIER      shift and go to state 118
    INT_TYPE        shift and go to state 34
    FLOAT64_TYPE    shift and go to state 35
    STRING_TYPE     shift and go to state 36
    BOOL_TYPE       shift and go to state 37
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    type                           shift and go to state 119
    primitive_type                 shift and go to state 30
    slice_type                     shift and go to state 31
    array_type                     shift and go to state 32
    map_type                       shift and go to state 33

state 76

    (154) struct_type -> STRUCT LBRACE . RBRACE
    (155) struct_type -> STRUCT LBRACE . field_list RBRACE
    (143) field_list -> . field_declaration
    (144) field_list -> . field_list field_declaration
    (145) field_declaration -> . IDENTIFIER type

    RBRACE          shift and go to state 120
    IDENTIFIER      shift and go to state 123

    field_list                     shift and go to state 121
    field_declaration              shift and go to state 122

state 77

    (16) global_var_dec -> VAR IDENTIFIER type ASSIGN expression .
    (36) expression -> expression . binary_operator expression
    (200) expression -> expression . DOT IDENTIFIER
    (201) expression -> expression . DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> expression . LBRACKET expression RBRACKET
    (37) binary_operator -> . PLUS
    (38) binary_operator -> . MINUS
    (39) binary_operator -> . TIMES
    (40) binary_operator -> . DIVIDE
    (41) binary_operator -> . MODULE
    (42) binary_operator -> . EQ
    (43) binary_operator -> . NEQ
    (44) binary_operator -> . LT
    (45) binary_operator -> . LE
    (46) binary_operator -> . GT
    (47) binary_operator -> . GE
    (48) binary_operator -> . LAND
    (49) binary_operator -> . LOR
    (50) binary_operator -> . AND
    (51) binary_operator -> . OR
    (52) binary_operator -> . XOR
    (53) binary_operator -> . AND_NOT
    (54) binary_operator -> . LSHIFT
    (55) binary_operator -> . RSHIFT

    VAR             reduce using rule 16 (global_var_dec -> VAR IDENTIFIER type ASSIGN expression .)
    CONST           reduce using rule 16 (global_var_dec -> VAR IDENTIFIER type ASSIGN expression .)
    FUNC            reduce using rule 16 (global_var_dec -> VAR IDENTIFIER type ASSIGN expression .)
    TYPE            reduce using rule 16 (global_var_dec -> VAR IDENTIFIER type ASSIGN expression .)
    $end            reduce using rule 16 (global_var_dec -> VAR IDENTIFIER type ASSIGN expression .)
    DOT             shift and go to state 82
    LBRACKET        shift and go to state 83
    PLUS            shift and go to state 84
    MINUS           shift and go to state 85
    TIMES           shift and go to state 86
    DIVIDE          shift and go to state 87
    MODULE          shift and go to state 88
    EQ              shift and go to state 89
    NEQ             shift and go to state 90
    LT              shift and go to state 91
    LE              shift and go to state 92
    GT              shift and go to state 93
    GE              shift and go to state 94
    LAND            shift and go to state 95
    LOR             shift and go to state 96
    AND             shift and go to state 97
    OR              shift and go to state 98
    XOR             shift and go to state 99
    AND_NOT         shift and go to state 100
    LSHIFT          shift and go to state 101
    RSHIFT          shift and go to state 102

    binary_operator                shift and go to state 81

state 78

    (126) expression -> IDENTIFIER PLUSPLUS .

    DOT             reduce using rule 126 (expression -> IDENTIFIER PLUSPLUS .)
    LBRACKET        reduce using rule 126 (expression -> IDENTIFIER PLUSPLUS .)
    PLUS            reduce using rule 126 (expression -> IDENTIFIER PLUSPLUS .)
    MINUS           reduce using rule 126 (expression -> IDENTIFIER PLUSPLUS .)
    TIMES           reduce using rule 126 (expression -> IDENTIFIER PLUSPLUS .)
    DIVIDE          reduce using rule 126 (expression -> IDENTIFIER PLUSPLUS .)
    MODULE          reduce using rule 126 (expression -> IDENTIFIER PLUSPLUS .)
    EQ              reduce using rule 126 (expression -> IDENTIFIER PLUSPLUS .)
    NEQ             reduce using rule 126 (expression -> IDENTIFIER PLUSPLUS .)
    LT              reduce using rule 126 (expression -> IDENTIFIER PLUSPLUS .)
    LE              reduce using rule 126 (expression -> IDENTIFIER PLUSPLUS .)
    GT              reduce using rule 126 (expression -> IDENTIFIER PLUSPLUS .)
    GE              reduce using rule 126 (expression -> IDENTIFIER PLUSPLUS .)
    LAND            reduce using rule 126 (expression -> IDENTIFIER PLUSPLUS .)
    LOR             reduce using rule 126 (expression -> IDENTIFIER PLUSPLUS .)
    AND             reduce using rule 126 (expression -> IDENTIFIER PLUSPLUS .)
    OR              reduce using rule 126 (expression -> IDENTIFIER PLUSPLUS .)
    XOR             reduce using rule 126 (expression -> IDENTIFIER PLUSPLUS .)
    AND_NOT         reduce using rule 126 (expression -> IDENTIFIER PLUSPLUS .)
    LSHIFT          reduce using rule 126 (expression -> IDENTIFIER PLUSPLUS .)
    RSHIFT          reduce using rule 126 (expression -> IDENTIFIER PLUSPLUS .)
    VAR             reduce using rule 126 (expression -> IDENTIFIER PLUSPLUS .)
    CONST           reduce using rule 126 (expression -> IDENTIFIER PLUSPLUS .)
    FUNC            reduce using rule 126 (expression -> IDENTIFIER PLUSPLUS .)
    TYPE            reduce using rule 126 (expression -> IDENTIFIER PLUSPLUS .)
    $end            reduce using rule 126 (expression -> IDENTIFIER PLUSPLUS .)
    RPAREN          reduce using rule 126 (expression -> IDENTIFIER PLUSPLUS .)
    COMMA           reduce using rule 126 (expression -> IDENTIFIER PLUSPLUS .)
    RBRACKET        reduce using rule 126 (expression -> IDENTIFIER PLUSPLUS .)
    RBRACE          reduce using rule 126 (expression -> IDENTIFIER PLUSPLUS .)
    COLON           reduce using rule 126 (expression -> IDENTIFIER PLUSPLUS .)
    BREAK           reduce using rule 126 (expression -> IDENTIFIER PLUSPLUS .)
    CONTINUE        reduce using rule 126 (expression -> IDENTIFIER PLUSPLUS .)
    IDENTIFIER      reduce using rule 126 (expression -> IDENTIFIER PLUSPLUS .)
    LPAREN          reduce using rule 126 (expression -> IDENTIFIER PLUSPLUS .)
    INT             reduce using rule 126 (expression -> IDENTIFIER PLUSPLUS .)
    FLOAT64         reduce using rule 126 (expression -> IDENTIFIER PLUSPLUS .)
    STRING          reduce using rule 126 (expression -> IDENTIFIER PLUSPLUS .)
    TRUE            reduce using rule 126 (expression -> IDENTIFIER PLUSPLUS .)
    FALSE           reduce using rule 126 (expression -> IDENTIFIER PLUSPLUS .)
    LNOT            reduce using rule 126 (expression -> IDENTIFIER PLUSPLUS .)
    IF              reduce using rule 126 (expression -> IDENTIFIER PLUSPLUS .)
    SWITCH          reduce using rule 126 (expression -> IDENTIFIER PLUSPLUS .)
    RETURN          reduce using rule 126 (expression -> IDENTIFIER PLUSPLUS .)
    MAP             reduce using rule 126 (expression -> IDENTIFIER PLUSPLUS .)
    FOR             reduce using rule 126 (expression -> IDENTIFIER PLUSPLUS .)
    LBRACE          reduce using rule 126 (expression -> IDENTIFIER PLUSPLUS .)
    CASE            reduce using rule 126 (expression -> IDENTIFIER PLUSPLUS .)
    DEFAULT         reduce using rule 126 (expression -> IDENTIFIER PLUSPLUS .)
    SEMICOLON       reduce using rule 126 (expression -> IDENTIFIER PLUSPLUS .)
=======
    (153) bitwise_expression -> expression OR . expression
    (82) expression -> . binary_expression
    (83) expression -> . relational_expression
    (84) expression -> . logical_expression
    (85) expression -> . bitwise_expression
    (86) expression -> . PLUS expression
    (87) expression -> . MINUS expression
    (88) expression -> . LNOT expression
    (89) expression -> . LBRACKET RBRACKET primitive_type LBRACE expression_list RBRACE
    (90) expression -> . LBRACKET RBRACKET primitive_type LBRACE RBRACE
    (91) expression -> . LPAREN expression RPAREN
    (92) expression -> . INT
    (93) expression -> . FLOAT64
    (94) expression -> . TRUE
    (95) expression -> . FALSE
    (96) expression -> . IDENTIFIER
    (97) expression -> . STRING
    (98) expression -> . IDENTIFIER PLUSPLUS
    (99) expression -> . IDENTIFIER MINUSMINUS
    (100) expression -> . expression DOT IDENTIFIER
    (103) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (133) expression -> . IDENTIFIER LBRACE keyed_element_list RBRACE
    (134) expression -> . IDENTIFIER LBRACE RBRACE
    (135) binary_expression -> . expression PLUS expression
    (136) binary_expression -> . expression MINUS expression
    (137) binary_expression -> . expression TIMES expression
    (138) binary_expression -> . expression DIVIDE expression
    (139) binary_expression -> . expression MODULE expression
    (144) relational_expression -> . expression EQ expression
    (145) relational_expression -> . expression NEQ expression
    (146) relational_expression -> . expression LT expression
    (147) relational_expression -> . expression LE expression
    (148) relational_expression -> . expression GT expression
    (149) relational_expression -> . expression GE expression
    (150) logical_expression -> . expression LAND expression
    (151) logical_expression -> . expression LOR expression
    (152) bitwise_expression -> . expression AND expression
    (153) bitwise_expression -> . expression OR expression
    (154) bitwise_expression -> . expression XOR expression
    (155) bitwise_expression -> . expression AND_NOT expression
    (156) bitwise_expression -> . expression LSHIFT expression
    (157) bitwise_expression -> . expression RSHIFT expression

    PLUS            shift and go to state 37
    MINUS           shift and go to state 38
    LNOT            shift and go to state 39
    LBRACKET        shift and go to state 40
    LPAREN          shift and go to state 29
    INT             shift and go to state 41
    FLOAT64         shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44
    IDENTIFIER      shift and go to state 97
    STRING          shift and go to state 11

    expression                     shift and go to state 133
    binary_expression              shift and go to state 33
    relational_expression          shift and go to state 34
    logical_expression             shift and go to state 35
    bitwise_expression             shift and go to state 36

state 74

    (154) bitwise_expression -> expression XOR . expression
    (82) expression -> . binary_expression
    (83) expression -> . relational_expression
    (84) expression -> . logical_expression
    (85) expression -> . bitwise_expression
    (86) expression -> . PLUS expression
    (87) expression -> . MINUS expression
    (88) expression -> . LNOT expression
    (89) expression -> . LBRACKET RBRACKET primitive_type LBRACE expression_list RBRACE
    (90) expression -> . LBRACKET RBRACKET primitive_type LBRACE RBRACE
    (91) expression -> . LPAREN expression RPAREN
    (92) expression -> . INT
    (93) expression -> . FLOAT64
    (94) expression -> . TRUE
    (95) expression -> . FALSE
    (96) expression -> . IDENTIFIER
    (97) expression -> . STRING
    (98) expression -> . IDENTIFIER PLUSPLUS
    (99) expression -> . IDENTIFIER MINUSMINUS
    (100) expression -> . expression DOT IDENTIFIER
    (103) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (133) expression -> . IDENTIFIER LBRACE keyed_element_list RBRACE
    (134) expression -> . IDENTIFIER LBRACE RBRACE
    (135) binary_expression -> . expression PLUS expression
    (136) binary_expression -> . expression MINUS expression
    (137) binary_expression -> . expression TIMES expression
    (138) binary_expression -> . expression DIVIDE expression
    (139) binary_expression -> . expression MODULE expression
    (144) relational_expression -> . expression EQ expression
    (145) relational_expression -> . expression NEQ expression
    (146) relational_expression -> . expression LT expression
    (147) relational_expression -> . expression LE expression
    (148) relational_expression -> . expression GT expression
    (149) relational_expression -> . expression GE expression
    (150) logical_expression -> . expression LAND expression
    (151) logical_expression -> . expression LOR expression
    (152) bitwise_expression -> . expression AND expression
    (153) bitwise_expression -> . expression OR expression
    (154) bitwise_expression -> . expression XOR expression
    (155) bitwise_expression -> . expression AND_NOT expression
    (156) bitwise_expression -> . expression LSHIFT expression
    (157) bitwise_expression -> . expression RSHIFT expression

    PLUS            shift and go to state 37
    MINUS           shift and go to state 38
    LNOT            shift and go to state 39
    LBRACKET        shift and go to state 40
    LPAREN          shift and go to state 29
    INT             shift and go to state 41
    FLOAT64         shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44
    IDENTIFIER      shift and go to state 97
    STRING          shift and go to state 11

    expression                     shift and go to state 134
    binary_expression              shift and go to state 33
    relational_expression          shift and go to state 34
    logical_expression             shift and go to state 35
    bitwise_expression             shift and go to state 36

state 75

    (155) bitwise_expression -> expression AND_NOT . expression
    (82) expression -> . binary_expression
    (83) expression -> . relational_expression
    (84) expression -> . logical_expression
    (85) expression -> . bitwise_expression
    (86) expression -> . PLUS expression
    (87) expression -> . MINUS expression
    (88) expression -> . LNOT expression
    (89) expression -> . LBRACKET RBRACKET primitive_type LBRACE expression_list RBRACE
    (90) expression -> . LBRACKET RBRACKET primitive_type LBRACE RBRACE
    (91) expression -> . LPAREN expression RPAREN
    (92) expression -> . INT
    (93) expression -> . FLOAT64
    (94) expression -> . TRUE
    (95) expression -> . FALSE
    (96) expression -> . IDENTIFIER
    (97) expression -> . STRING
    (98) expression -> . IDENTIFIER PLUSPLUS
    (99) expression -> . IDENTIFIER MINUSMINUS
    (100) expression -> . expression DOT IDENTIFIER
    (103) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (133) expression -> . IDENTIFIER LBRACE keyed_element_list RBRACE
    (134) expression -> . IDENTIFIER LBRACE RBRACE
    (135) binary_expression -> . expression PLUS expression
    (136) binary_expression -> . expression MINUS expression
    (137) binary_expression -> . expression TIMES expression
    (138) binary_expression -> . expression DIVIDE expression
    (139) binary_expression -> . expression MODULE expression
    (144) relational_expression -> . expression EQ expression
    (145) relational_expression -> . expression NEQ expression
    (146) relational_expression -> . expression LT expression
    (147) relational_expression -> . expression LE expression
    (148) relational_expression -> . expression GT expression
    (149) relational_expression -> . expression GE expression
    (150) logical_expression -> . expression LAND expression
    (151) logical_expression -> . expression LOR expression
    (152) bitwise_expression -> . expression AND expression
    (153) bitwise_expression -> . expression OR expression
    (154) bitwise_expression -> . expression XOR expression
    (155) bitwise_expression -> . expression AND_NOT expression
    (156) bitwise_expression -> . expression LSHIFT expression
    (157) bitwise_expression -> . expression RSHIFT expression

    PLUS            shift and go to state 37
    MINUS           shift and go to state 38
    LNOT            shift and go to state 39
    LBRACKET        shift and go to state 40
    LPAREN          shift and go to state 29
    INT             shift and go to state 41
    FLOAT64         shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44
    IDENTIFIER      shift and go to state 97
    STRING          shift and go to state 11

    expression                     shift and go to state 135
    binary_expression              shift and go to state 33
    relational_expression          shift and go to state 34
    logical_expression             shift and go to state 35
    bitwise_expression             shift and go to state 36

state 76

    (156) bitwise_expression -> expression LSHIFT . expression
    (82) expression -> . binary_expression
    (83) expression -> . relational_expression
    (84) expression -> . logical_expression
    (85) expression -> . bitwise_expression
    (86) expression -> . PLUS expression
    (87) expression -> . MINUS expression
    (88) expression -> . LNOT expression
    (89) expression -> . LBRACKET RBRACKET primitive_type LBRACE expression_list RBRACE
    (90) expression -> . LBRACKET RBRACKET primitive_type LBRACE RBRACE
    (91) expression -> . LPAREN expression RPAREN
    (92) expression -> . INT
    (93) expression -> . FLOAT64
    (94) expression -> . TRUE
    (95) expression -> . FALSE
    (96) expression -> . IDENTIFIER
    (97) expression -> . STRING
    (98) expression -> . IDENTIFIER PLUSPLUS
    (99) expression -> . IDENTIFIER MINUSMINUS
    (100) expression -> . expression DOT IDENTIFIER
    (103) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (133) expression -> . IDENTIFIER LBRACE keyed_element_list RBRACE
    (134) expression -> . IDENTIFIER LBRACE RBRACE
    (135) binary_expression -> . expression PLUS expression
    (136) binary_expression -> . expression MINUS expression
    (137) binary_expression -> . expression TIMES expression
    (138) binary_expression -> . expression DIVIDE expression
    (139) binary_expression -> . expression MODULE expression
    (144) relational_expression -> . expression EQ expression
    (145) relational_expression -> . expression NEQ expression
    (146) relational_expression -> . expression LT expression
    (147) relational_expression -> . expression LE expression
    (148) relational_expression -> . expression GT expression
    (149) relational_expression -> . expression GE expression
    (150) logical_expression -> . expression LAND expression
    (151) logical_expression -> . expression LOR expression
    (152) bitwise_expression -> . expression AND expression
    (153) bitwise_expression -> . expression OR expression
    (154) bitwise_expression -> . expression XOR expression
    (155) bitwise_expression -> . expression AND_NOT expression
    (156) bitwise_expression -> . expression LSHIFT expression
    (157) bitwise_expression -> . expression RSHIFT expression

    PLUS            shift and go to state 37
    MINUS           shift and go to state 38
    LNOT            shift and go to state 39
    LBRACKET        shift and go to state 40
    LPAREN          shift and go to state 29
    INT             shift and go to state 41
    FLOAT64         shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44
    IDENTIFIER      shift and go to state 97
    STRING          shift and go to state 11

    expression                     shift and go to state 136
    binary_expression              shift and go to state 33
    relational_expression          shift and go to state 34
    logical_expression             shift and go to state 35
    bitwise_expression             shift and go to state 36

state 77

    (157) bitwise_expression -> expression RSHIFT . expression
    (82) expression -> . binary_expression
    (83) expression -> . relational_expression
    (84) expression -> . logical_expression
    (85) expression -> . bitwise_expression
    (86) expression -> . PLUS expression
    (87) expression -> . MINUS expression
    (88) expression -> . LNOT expression
    (89) expression -> . LBRACKET RBRACKET primitive_type LBRACE expression_list RBRACE
    (90) expression -> . LBRACKET RBRACKET primitive_type LBRACE RBRACE
    (91) expression -> . LPAREN expression RPAREN
    (92) expression -> . INT
    (93) expression -> . FLOAT64
    (94) expression -> . TRUE
    (95) expression -> . FALSE
    (96) expression -> . IDENTIFIER
    (97) expression -> . STRING
    (98) expression -> . IDENTIFIER PLUSPLUS
    (99) expression -> . IDENTIFIER MINUSMINUS
    (100) expression -> . expression DOT IDENTIFIER
    (103) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (133) expression -> . IDENTIFIER LBRACE keyed_element_list RBRACE
    (134) expression -> . IDENTIFIER LBRACE RBRACE
    (135) binary_expression -> . expression PLUS expression
    (136) binary_expression -> . expression MINUS expression
    (137) binary_expression -> . expression TIMES expression
    (138) binary_expression -> . expression DIVIDE expression
    (139) binary_expression -> . expression MODULE expression
    (144) relational_expression -> . expression EQ expression
    (145) relational_expression -> . expression NEQ expression
    (146) relational_expression -> . expression LT expression
    (147) relational_expression -> . expression LE expression
    (148) relational_expression -> . expression GT expression
    (149) relational_expression -> . expression GE expression
    (150) logical_expression -> . expression LAND expression
    (151) logical_expression -> . expression LOR expression
    (152) bitwise_expression -> . expression AND expression
    (153) bitwise_expression -> . expression OR expression
    (154) bitwise_expression -> . expression XOR expression
    (155) bitwise_expression -> . expression AND_NOT expression
    (156) bitwise_expression -> . expression LSHIFT expression
    (157) bitwise_expression -> . expression RSHIFT expression

    PLUS            shift and go to state 37
    MINUS           shift and go to state 38
    LNOT            shift and go to state 39
    LBRACKET        shift and go to state 40
    LPAREN          shift and go to state 29
    INT             shift and go to state 41
    FLOAT64         shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44
    IDENTIFIER      shift and go to state 97
    STRING          shift and go to state 11

    expression                     shift and go to state 137
    binary_expression              shift and go to state 33
    relational_expression          shift and go to state 34
    logical_expression             shift and go to state 35
    bitwise_expression             shift and go to state 36

state 78

    (43) function_declaration -> FUNC IDENTIFIER . LPAREN parameter_list RPAREN return_type block

    LPAREN          shift and go to state 138
>>>>>>> Stashed changes


state 79

<<<<<<< Updated upstream
    (127) expression -> IDENTIFIER MINUSMINUS .

    DOT             reduce using rule 127 (expression -> IDENTIFIER MINUSMINUS .)
    LBRACKET        reduce using rule 127 (expression -> IDENTIFIER MINUSMINUS .)
    PLUS            reduce using rule 127 (expression -> IDENTIFIER MINUSMINUS .)
    MINUS           reduce using rule 127 (expression -> IDENTIFIER MINUSMINUS .)
    TIMES           reduce using rule 127 (expression -> IDENTIFIER MINUSMINUS .)
    DIVIDE          reduce using rule 127 (expression -> IDENTIFIER MINUSMINUS .)
    MODULE          reduce using rule 127 (expression -> IDENTIFIER MINUSMINUS .)
    EQ              reduce using rule 127 (expression -> IDENTIFIER MINUSMINUS .)
    NEQ             reduce using rule 127 (expression -> IDENTIFIER MINUSMINUS .)
    LT              reduce using rule 127 (expression -> IDENTIFIER MINUSMINUS .)
    LE              reduce using rule 127 (expression -> IDENTIFIER MINUSMINUS .)
    GT              reduce using rule 127 (expression -> IDENTIFIER MINUSMINUS .)
    GE              reduce using rule 127 (expression -> IDENTIFIER MINUSMINUS .)
    LAND            reduce using rule 127 (expression -> IDENTIFIER MINUSMINUS .)
    LOR             reduce using rule 127 (expression -> IDENTIFIER MINUSMINUS .)
    AND             reduce using rule 127 (expression -> IDENTIFIER MINUSMINUS .)
    OR              reduce using rule 127 (expression -> IDENTIFIER MINUSMINUS .)
    XOR             reduce using rule 127 (expression -> IDENTIFIER MINUSMINUS .)
    AND_NOT         reduce using rule 127 (expression -> IDENTIFIER MINUSMINUS .)
    LSHIFT          reduce using rule 127 (expression -> IDENTIFIER MINUSMINUS .)
    RSHIFT          reduce using rule 127 (expression -> IDENTIFIER MINUSMINUS .)
    VAR             reduce using rule 127 (expression -> IDENTIFIER MINUSMINUS .)
    CONST           reduce using rule 127 (expression -> IDENTIFIER MINUSMINUS .)
    FUNC            reduce using rule 127 (expression -> IDENTIFIER MINUSMINUS .)
    TYPE            reduce using rule 127 (expression -> IDENTIFIER MINUSMINUS .)
    $end            reduce using rule 127 (expression -> IDENTIFIER MINUSMINUS .)
    RPAREN          reduce using rule 127 (expression -> IDENTIFIER MINUSMINUS .)
    COMMA           reduce using rule 127 (expression -> IDENTIFIER MINUSMINUS .)
    RBRACKET        reduce using rule 127 (expression -> IDENTIFIER MINUSMINUS .)
    RBRACE          reduce using rule 127 (expression -> IDENTIFIER MINUSMINUS .)
    COLON           reduce using rule 127 (expression -> IDENTIFIER MINUSMINUS .)
    BREAK           reduce using rule 127 (expression -> IDENTIFIER MINUSMINUS .)
    CONTINUE        reduce using rule 127 (expression -> IDENTIFIER MINUSMINUS .)
    IDENTIFIER      reduce using rule 127 (expression -> IDENTIFIER MINUSMINUS .)
    LPAREN          reduce using rule 127 (expression -> IDENTIFIER MINUSMINUS .)
    INT             reduce using rule 127 (expression -> IDENTIFIER MINUSMINUS .)
    FLOAT64         reduce using rule 127 (expression -> IDENTIFIER MINUSMINUS .)
    STRING          reduce using rule 127 (expression -> IDENTIFIER MINUSMINUS .)
    TRUE            reduce using rule 127 (expression -> IDENTIFIER MINUSMINUS .)
    FALSE           reduce using rule 127 (expression -> IDENTIFIER MINUSMINUS .)
    LNOT            reduce using rule 127 (expression -> IDENTIFIER MINUSMINUS .)
    IF              reduce using rule 127 (expression -> IDENTIFIER MINUSMINUS .)
    SWITCH          reduce using rule 127 (expression -> IDENTIFIER MINUSMINUS .)
    RETURN          reduce using rule 127 (expression -> IDENTIFIER MINUSMINUS .)
    MAP             reduce using rule 127 (expression -> IDENTIFIER MINUSMINUS .)
    FOR             reduce using rule 127 (expression -> IDENTIFIER MINUSMINUS .)
    LBRACE          reduce using rule 127 (expression -> IDENTIFIER MINUSMINUS .)
    CASE            reduce using rule 127 (expression -> IDENTIFIER MINUSMINUS .)
    DEFAULT         reduce using rule 127 (expression -> IDENTIFIER MINUSMINUS .)
    SEMICOLON       reduce using rule 127 (expression -> IDENTIFIER MINUSMINUS .)


state 80

    (203) expression -> IDENTIFIER LPAREN . argument_list RPAREN
    (204) argument_list -> . expression_list
    (205) argument_list -> . empty
    (68) expression_list -> . expression
    (69) expression_list -> . expression_list COMMA expression
    (7) empty -> .
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (125) expression -> . LNOT expression
    (126) expression -> . IDENTIFIER PLUSPLUS
    (127) expression -> . IDENTIFIER MINUSMINUS
    (138) expression -> . map_type LBRACE expression_map_list RBRACE
    (139) expression -> . map_type LBRACE RBRACE
    (161) expression -> . type_name LBRACE keyed_element_list RBRACE
    (162) expression -> . type_name LBRACE RBRACE
    (198) expression -> . array_type LBRACE expression_list RBRACE
    (199) expression -> . array_type LBRACE RBRACE
    (200) expression -> . expression DOT IDENTIFIER
    (201) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> . expression LBRACKET expression RBRACKET
    (203) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (137) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (163) type_name -> . IDENTIFIER
    (164) type_name -> . slice_type
    (165) type_name -> . array_type
    (166) type_name -> . map_type
    (197) array_type -> . LBRACKET INT RBRACKET primitive_type

    RPAREN          reduce using rule 7 (empty -> .)
    LPAREN          shift and go to state 54
    INT             shift and go to state 55
    FLOAT64         shift and go to state 56
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 57
    TRUE            shift and go to state 58
    FALSE           shift and go to state 59
    LNOT            shift and go to state 60
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    argument_list                  shift and go to state 124
    expression_list                shift and go to state 125
    empty                          shift and go to state 126
    expression                     shift and go to state 127
    slice_type                     shift and go to state 53
    map_type                       shift and go to state 61
    type_name                      shift and go to state 62
    array_type                     shift and go to state 63

state 81

    (36) expression -> expression binary_operator . expression
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (125) expression -> . LNOT expression
    (126) expression -> . IDENTIFIER PLUSPLUS
    (127) expression -> . IDENTIFIER MINUSMINUS
    (138) expression -> . map_type LBRACE expression_map_list RBRACE
    (139) expression -> . map_type LBRACE RBRACE
    (161) expression -> . type_name LBRACE keyed_element_list RBRACE
    (162) expression -> . type_name LBRACE RBRACE
    (198) expression -> . array_type LBRACE expression_list RBRACE
    (199) expression -> . array_type LBRACE RBRACE
    (200) expression -> . expression DOT IDENTIFIER
    (201) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> . expression LBRACKET expression RBRACKET
    (203) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (137) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (163) type_name -> . IDENTIFIER
    (164) type_name -> . slice_type
    (165) type_name -> . array_type
    (166) type_name -> . map_type
    (197) array_type -> . LBRACKET INT RBRACKET primitive_type

    LPAREN          shift and go to state 54
    INT             shift and go to state 55
    FLOAT64         shift and go to state 56
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 57
    TRUE            shift and go to state 58
    FALSE           shift and go to state 59
    LNOT            shift and go to state 60
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    expression                     shift and go to state 128
    slice_type                     shift and go to state 53
    map_type                       shift and go to state 61
    type_name                      shift and go to state 62
    array_type                     shift and go to state 63

state 82

    (200) expression -> expression DOT . IDENTIFIER
    (201) expression -> expression DOT . IDENTIFIER LPAREN argument_list RPAREN

    IDENTIFIER      shift and go to state 129


state 83

    (202) expression -> expression LBRACKET . expression RBRACKET
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (125) expression -> . LNOT expression
    (126) expression -> . IDENTIFIER PLUSPLUS
    (127) expression -> . IDENTIFIER MINUSMINUS
    (138) expression -> . map_type LBRACE expression_map_list RBRACE
    (139) expression -> . map_type LBRACE RBRACE
    (161) expression -> . type_name LBRACE keyed_element_list RBRACE
    (162) expression -> . type_name LBRACE RBRACE
    (198) expression -> . array_type LBRACE expression_list RBRACE
    (199) expression -> . array_type LBRACE RBRACE
    (200) expression -> . expression DOT IDENTIFIER
    (201) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> . expression LBRACKET expression RBRACKET
    (203) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (137) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (163) type_name -> . IDENTIFIER
    (164) type_name -> . slice_type
    (165) type_name -> . array_type
    (166) type_name -> . map_type
    (197) array_type -> . LBRACKET INT RBRACKET primitive_type

    LPAREN          shift and go to state 54
    INT             shift and go to state 55
    FLOAT64         shift and go to state 56
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 57
    TRUE            shift and go to state 58
    FALSE           shift and go to state 59
    LNOT            shift and go to state 60
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    expression                     shift and go to state 130
    slice_type                     shift and go to state 53
    map_type                       shift and go to state 61
    type_name                      shift and go to state 62
    array_type                     shift and go to state 63

state 84

    (37) binary_operator -> PLUS .

    LPAREN          reduce using rule 37 (binary_operator -> PLUS .)
    INT             reduce using rule 37 (binary_operator -> PLUS .)
    FLOAT64         reduce using rule 37 (binary_operator -> PLUS .)
    IDENTIFIER      reduce using rule 37 (binary_operator -> PLUS .)
    STRING          reduce using rule 37 (binary_operator -> PLUS .)
    TRUE            reduce using rule 37 (binary_operator -> PLUS .)
    FALSE           reduce using rule 37 (binary_operator -> PLUS .)
    LNOT            reduce using rule 37 (binary_operator -> PLUS .)
    LBRACKET        reduce using rule 37 (binary_operator -> PLUS .)
    MAP             reduce using rule 37 (binary_operator -> PLUS .)


state 85

    (38) binary_operator -> MINUS .

    LPAREN          reduce using rule 38 (binary_operator -> MINUS .)
    INT             reduce using rule 38 (binary_operator -> MINUS .)
    FLOAT64         reduce using rule 38 (binary_operator -> MINUS .)
    IDENTIFIER      reduce using rule 38 (binary_operator -> MINUS .)
    STRING          reduce using rule 38 (binary_operator -> MINUS .)
    TRUE            reduce using rule 38 (binary_operator -> MINUS .)
    FALSE           reduce using rule 38 (binary_operator -> MINUS .)
    LNOT            reduce using rule 38 (binary_operator -> MINUS .)
    LBRACKET        reduce using rule 38 (binary_operator -> MINUS .)
    MAP             reduce using rule 38 (binary_operator -> MINUS .)


state 86

    (39) binary_operator -> TIMES .

    LPAREN          reduce using rule 39 (binary_operator -> TIMES .)
    INT             reduce using rule 39 (binary_operator -> TIMES .)
    FLOAT64         reduce using rule 39 (binary_operator -> TIMES .)
    IDENTIFIER      reduce using rule 39 (binary_operator -> TIMES .)
    STRING          reduce using rule 39 (binary_operator -> TIMES .)
    TRUE            reduce using rule 39 (binary_operator -> TIMES .)
    FALSE           reduce using rule 39 (binary_operator -> TIMES .)
    LNOT            reduce using rule 39 (binary_operator -> TIMES .)
    LBRACKET        reduce using rule 39 (binary_operator -> TIMES .)
    MAP             reduce using rule 39 (binary_operator -> TIMES .)
=======
    (124) method_declaration -> FUNC LPAREN . receiver RPAREN IDENTIFIER LPAREN parameter_list RPAREN return_type block
    (125) receiver -> . IDENTIFIER type
    (126) receiver -> . IDENTIFIER TIMES IDENTIFIER

    IDENTIFIER      shift and go to state 140

    receiver                       shift and go to state 139

state 80

    (54) assignment -> IDENTIFIER ASSIGN . expression
    (82) expression -> . binary_expression
    (83) expression -> . relational_expression
    (84) expression -> . logical_expression
    (85) expression -> . bitwise_expression
    (86) expression -> . PLUS expression
    (87) expression -> . MINUS expression
    (88) expression -> . LNOT expression
    (89) expression -> . LBRACKET RBRACKET primitive_type LBRACE expression_list RBRACE
    (90) expression -> . LBRACKET RBRACKET primitive_type LBRACE RBRACE
    (91) expression -> . LPAREN expression RPAREN
    (92) expression -> . INT
    (93) expression -> . FLOAT64
    (94) expression -> . TRUE
    (95) expression -> . FALSE
    (96) expression -> . IDENTIFIER
    (97) expression -> . STRING
    (98) expression -> . IDENTIFIER PLUSPLUS
    (99) expression -> . IDENTIFIER MINUSMINUS
    (100) expression -> . expression DOT IDENTIFIER
    (103) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (133) expression -> . IDENTIFIER LBRACE keyed_element_list RBRACE
    (134) expression -> . IDENTIFIER LBRACE RBRACE
    (135) binary_expression -> . expression PLUS expression
    (136) binary_expression -> . expression MINUS expression
    (137) binary_expression -> . expression TIMES expression
    (138) binary_expression -> . expression DIVIDE expression
    (139) binary_expression -> . expression MODULE expression
    (144) relational_expression -> . expression EQ expression
    (145) relational_expression -> . expression NEQ expression
    (146) relational_expression -> . expression LT expression
    (147) relational_expression -> . expression LE expression
    (148) relational_expression -> . expression GT expression
    (149) relational_expression -> . expression GE expression
    (150) logical_expression -> . expression LAND expression
    (151) logical_expression -> . expression LOR expression
    (152) bitwise_expression -> . expression AND expression
    (153) bitwise_expression -> . expression OR expression
    (154) bitwise_expression -> . expression XOR expression
    (155) bitwise_expression -> . expression AND_NOT expression
    (156) bitwise_expression -> . expression LSHIFT expression
    (157) bitwise_expression -> . expression RSHIFT expression

    PLUS            shift and go to state 37
    MINUS           shift and go to state 38
    LNOT            shift and go to state 39
    LBRACKET        shift and go to state 40
    LPAREN          shift and go to state 29
    INT             shift and go to state 41
    FLOAT64         shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44
    IDENTIFIER      shift and go to state 97
    STRING          shift and go to state 11

    expression                     shift and go to state 141
    binary_expression              shift and go to state 33
    relational_expression          shift and go to state 34
    logical_expression             shift and go to state 35
    bitwise_expression             shift and go to state 36

state 81

    (55) assignment -> IDENTIFIER SHORT_ASSIGN . expression
    (82) expression -> . binary_expression
    (83) expression -> . relational_expression
    (84) expression -> . logical_expression
    (85) expression -> . bitwise_expression
    (86) expression -> . PLUS expression
    (87) expression -> . MINUS expression
    (88) expression -> . LNOT expression
    (89) expression -> . LBRACKET RBRACKET primitive_type LBRACE expression_list RBRACE
    (90) expression -> . LBRACKET RBRACKET primitive_type LBRACE RBRACE
    (91) expression -> . LPAREN expression RPAREN
    (92) expression -> . INT
    (93) expression -> . FLOAT64
    (94) expression -> . TRUE
    (95) expression -> . FALSE
    (96) expression -> . IDENTIFIER
    (97) expression -> . STRING
    (98) expression -> . IDENTIFIER PLUSPLUS
    (99) expression -> . IDENTIFIER MINUSMINUS
    (100) expression -> . expression DOT IDENTIFIER
    (103) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (133) expression -> . IDENTIFIER LBRACE keyed_element_list RBRACE
    (134) expression -> . IDENTIFIER LBRACE RBRACE
    (135) binary_expression -> . expression PLUS expression
    (136) binary_expression -> . expression MINUS expression
    (137) binary_expression -> . expression TIMES expression
    (138) binary_expression -> . expression DIVIDE expression
    (139) binary_expression -> . expression MODULE expression
    (144) relational_expression -> . expression EQ expression
    (145) relational_expression -> . expression NEQ expression
    (146) relational_expression -> . expression LT expression
    (147) relational_expression -> . expression LE expression
    (148) relational_expression -> . expression GT expression
    (149) relational_expression -> . expression GE expression
    (150) logical_expression -> . expression LAND expression
    (151) logical_expression -> . expression LOR expression
    (152) bitwise_expression -> . expression AND expression
    (153) bitwise_expression -> . expression OR expression
    (154) bitwise_expression -> . expression XOR expression
    (155) bitwise_expression -> . expression AND_NOT expression
    (156) bitwise_expression -> . expression LSHIFT expression
    (157) bitwise_expression -> . expression RSHIFT expression

    PLUS            shift and go to state 37
    MINUS           shift and go to state 38
    LNOT            shift and go to state 39
    LBRACKET        shift and go to state 40
    LPAREN          shift and go to state 29
    INT             shift and go to state 41
    FLOAT64         shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44
    IDENTIFIER      shift and go to state 97
    STRING          shift and go to state 11

    expression                     shift and go to state 142
    binary_expression              shift and go to state 33
    relational_expression          shift and go to state 34
    logical_expression             shift and go to state 35
    bitwise_expression             shift and go to state 36

state 82

    (56) assignment_compound -> IDENTIFIER PLUS_ASSIGN . expression
    (82) expression -> . binary_expression
    (83) expression -> . relational_expression
    (84) expression -> . logical_expression
    (85) expression -> . bitwise_expression
    (86) expression -> . PLUS expression
    (87) expression -> . MINUS expression
    (88) expression -> . LNOT expression
    (89) expression -> . LBRACKET RBRACKET primitive_type LBRACE expression_list RBRACE
    (90) expression -> . LBRACKET RBRACKET primitive_type LBRACE RBRACE
    (91) expression -> . LPAREN expression RPAREN
    (92) expression -> . INT
    (93) expression -> . FLOAT64
    (94) expression -> . TRUE
    (95) expression -> . FALSE
    (96) expression -> . IDENTIFIER
    (97) expression -> . STRING
    (98) expression -> . IDENTIFIER PLUSPLUS
    (99) expression -> . IDENTIFIER MINUSMINUS
    (100) expression -> . expression DOT IDENTIFIER
    (103) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (133) expression -> . IDENTIFIER LBRACE keyed_element_list RBRACE
    (134) expression -> . IDENTIFIER LBRACE RBRACE
    (135) binary_expression -> . expression PLUS expression
    (136) binary_expression -> . expression MINUS expression
    (137) binary_expression -> . expression TIMES expression
    (138) binary_expression -> . expression DIVIDE expression
    (139) binary_expression -> . expression MODULE expression
    (144) relational_expression -> . expression EQ expression
    (145) relational_expression -> . expression NEQ expression
    (146) relational_expression -> . expression LT expression
    (147) relational_expression -> . expression LE expression
    (148) relational_expression -> . expression GT expression
    (149) relational_expression -> . expression GE expression
    (150) logical_expression -> . expression LAND expression
    (151) logical_expression -> . expression LOR expression
    (152) bitwise_expression -> . expression AND expression
    (153) bitwise_expression -> . expression OR expression
    (154) bitwise_expression -> . expression XOR expression
    (155) bitwise_expression -> . expression AND_NOT expression
    (156) bitwise_expression -> . expression LSHIFT expression
    (157) bitwise_expression -> . expression RSHIFT expression

    PLUS            shift and go to state 37
    MINUS           shift and go to state 38
    LNOT            shift and go to state 39
    LBRACKET        shift and go to state 40
    LPAREN          shift and go to state 29
    INT             shift and go to state 41
    FLOAT64         shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44
    IDENTIFIER      shift and go to state 97
    STRING          shift and go to state 11

    expression                     shift and go to state 143
    binary_expression              shift and go to state 33
    relational_expression          shift and go to state 34
    logical_expression             shift and go to state 35
    bitwise_expression             shift and go to state 36

state 83

    (57) assignment_compound -> IDENTIFIER MINUS_ASSIGN . expression
    (82) expression -> . binary_expression
    (83) expression -> . relational_expression
    (84) expression -> . logical_expression
    (85) expression -> . bitwise_expression
    (86) expression -> . PLUS expression
    (87) expression -> . MINUS expression
    (88) expression -> . LNOT expression
    (89) expression -> . LBRACKET RBRACKET primitive_type LBRACE expression_list RBRACE
    (90) expression -> . LBRACKET RBRACKET primitive_type LBRACE RBRACE
    (91) expression -> . LPAREN expression RPAREN
    (92) expression -> . INT
    (93) expression -> . FLOAT64
    (94) expression -> . TRUE
    (95) expression -> . FALSE
    (96) expression -> . IDENTIFIER
    (97) expression -> . STRING
    (98) expression -> . IDENTIFIER PLUSPLUS
    (99) expression -> . IDENTIFIER MINUSMINUS
    (100) expression -> . expression DOT IDENTIFIER
    (103) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (133) expression -> . IDENTIFIER LBRACE keyed_element_list RBRACE
    (134) expression -> . IDENTIFIER LBRACE RBRACE
    (135) binary_expression -> . expression PLUS expression
    (136) binary_expression -> . expression MINUS expression
    (137) binary_expression -> . expression TIMES expression
    (138) binary_expression -> . expression DIVIDE expression
    (139) binary_expression -> . expression MODULE expression
    (144) relational_expression -> . expression EQ expression
    (145) relational_expression -> . expression NEQ expression
    (146) relational_expression -> . expression LT expression
    (147) relational_expression -> . expression LE expression
    (148) relational_expression -> . expression GT expression
    (149) relational_expression -> . expression GE expression
    (150) logical_expression -> . expression LAND expression
    (151) logical_expression -> . expression LOR expression
    (152) bitwise_expression -> . expression AND expression
    (153) bitwise_expression -> . expression OR expression
    (154) bitwise_expression -> . expression XOR expression
    (155) bitwise_expression -> . expression AND_NOT expression
    (156) bitwise_expression -> . expression LSHIFT expression
    (157) bitwise_expression -> . expression RSHIFT expression

    PLUS            shift and go to state 37
    MINUS           shift and go to state 38
    LNOT            shift and go to state 39
    LBRACKET        shift and go to state 40
    LPAREN          shift and go to state 29
    INT             shift and go to state 41
    FLOAT64         shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44
    IDENTIFIER      shift and go to state 97
    STRING          shift and go to state 11

    expression                     shift and go to state 144
    binary_expression              shift and go to state 33
    relational_expression          shift and go to state 34
    logical_expression             shift and go to state 35
    bitwise_expression             shift and go to state 36

state 84

    (58) assignment_compound -> IDENTIFIER MULT_ASSIGN . expression
    (82) expression -> . binary_expression
    (83) expression -> . relational_expression
    (84) expression -> . logical_expression
    (85) expression -> . bitwise_expression
    (86) expression -> . PLUS expression
    (87) expression -> . MINUS expression
    (88) expression -> . LNOT expression
    (89) expression -> . LBRACKET RBRACKET primitive_type LBRACE expression_list RBRACE
    (90) expression -> . LBRACKET RBRACKET primitive_type LBRACE RBRACE
    (91) expression -> . LPAREN expression RPAREN
    (92) expression -> . INT
    (93) expression -> . FLOAT64
    (94) expression -> . TRUE
    (95) expression -> . FALSE
    (96) expression -> . IDENTIFIER
    (97) expression -> . STRING
    (98) expression -> . IDENTIFIER PLUSPLUS
    (99) expression -> . IDENTIFIER MINUSMINUS
    (100) expression -> . expression DOT IDENTIFIER
    (103) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (133) expression -> . IDENTIFIER LBRACE keyed_element_list RBRACE
    (134) expression -> . IDENTIFIER LBRACE RBRACE
    (135) binary_expression -> . expression PLUS expression
    (136) binary_expression -> . expression MINUS expression
    (137) binary_expression -> . expression TIMES expression
    (138) binary_expression -> . expression DIVIDE expression
    (139) binary_expression -> . expression MODULE expression
    (144) relational_expression -> . expression EQ expression
    (145) relational_expression -> . expression NEQ expression
    (146) relational_expression -> . expression LT expression
    (147) relational_expression -> . expression LE expression
    (148) relational_expression -> . expression GT expression
    (149) relational_expression -> . expression GE expression
    (150) logical_expression -> . expression LAND expression
    (151) logical_expression -> . expression LOR expression
    (152) bitwise_expression -> . expression AND expression
    (153) bitwise_expression -> . expression OR expression
    (154) bitwise_expression -> . expression XOR expression
    (155) bitwise_expression -> . expression AND_NOT expression
    (156) bitwise_expression -> . expression LSHIFT expression
    (157) bitwise_expression -> . expression RSHIFT expression

    PLUS            shift and go to state 37
    MINUS           shift and go to state 38
    LNOT            shift and go to state 39
    LBRACKET        shift and go to state 40
    LPAREN          shift and go to state 29
    INT             shift and go to state 41
    FLOAT64         shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44
    IDENTIFIER      shift and go to state 97
    STRING          shift and go to state 11

    expression                     shift and go to state 145
    binary_expression              shift and go to state 33
    relational_expression          shift and go to state 34
    logical_expression             shift and go to state 35
    bitwise_expression             shift and go to state 36

state 85

    (59) assignment_compound -> IDENTIFIER DIV_ASSIGN . expression
    (82) expression -> . binary_expression
    (83) expression -> . relational_expression
    (84) expression -> . logical_expression
    (85) expression -> . bitwise_expression
    (86) expression -> . PLUS expression
    (87) expression -> . MINUS expression
    (88) expression -> . LNOT expression
    (89) expression -> . LBRACKET RBRACKET primitive_type LBRACE expression_list RBRACE
    (90) expression -> . LBRACKET RBRACKET primitive_type LBRACE RBRACE
    (91) expression -> . LPAREN expression RPAREN
    (92) expression -> . INT
    (93) expression -> . FLOAT64
    (94) expression -> . TRUE
    (95) expression -> . FALSE
    (96) expression -> . IDENTIFIER
    (97) expression -> . STRING
    (98) expression -> . IDENTIFIER PLUSPLUS
    (99) expression -> . IDENTIFIER MINUSMINUS
    (100) expression -> . expression DOT IDENTIFIER
    (103) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (133) expression -> . IDENTIFIER LBRACE keyed_element_list RBRACE
    (134) expression -> . IDENTIFIER LBRACE RBRACE
    (135) binary_expression -> . expression PLUS expression
    (136) binary_expression -> . expression MINUS expression
    (137) binary_expression -> . expression TIMES expression
    (138) binary_expression -> . expression DIVIDE expression
    (139) binary_expression -> . expression MODULE expression
    (144) relational_expression -> . expression EQ expression
    (145) relational_expression -> . expression NEQ expression
    (146) relational_expression -> . expression LT expression
    (147) relational_expression -> . expression LE expression
    (148) relational_expression -> . expression GT expression
    (149) relational_expression -> . expression GE expression
    (150) logical_expression -> . expression LAND expression
    (151) logical_expression -> . expression LOR expression
    (152) bitwise_expression -> . expression AND expression
    (153) bitwise_expression -> . expression OR expression
    (154) bitwise_expression -> . expression XOR expression
    (155) bitwise_expression -> . expression AND_NOT expression
    (156) bitwise_expression -> . expression LSHIFT expression
    (157) bitwise_expression -> . expression RSHIFT expression

    PLUS            shift and go to state 37
    MINUS           shift and go to state 38
    LNOT            shift and go to state 39
    LBRACKET        shift and go to state 40
    LPAREN          shift and go to state 29
    INT             shift and go to state 41
    FLOAT64         shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44
    IDENTIFIER      shift and go to state 97
    STRING          shift and go to state 11

    expression                     shift and go to state 146
    binary_expression              shift and go to state 33
    relational_expression          shift and go to state 34
    logical_expression             shift and go to state 35
    bitwise_expression             shift and go to state 36

state 86

    (60) assignment_compound -> IDENTIFIER MOD_ASSIGN . expression
    (82) expression -> . binary_expression
    (83) expression -> . relational_expression
    (84) expression -> . logical_expression
    (85) expression -> . bitwise_expression
    (86) expression -> . PLUS expression
    (87) expression -> . MINUS expression
    (88) expression -> . LNOT expression
    (89) expression -> . LBRACKET RBRACKET primitive_type LBRACE expression_list RBRACE
    (90) expression -> . LBRACKET RBRACKET primitive_type LBRACE RBRACE
    (91) expression -> . LPAREN expression RPAREN
    (92) expression -> . INT
    (93) expression -> . FLOAT64
    (94) expression -> . TRUE
    (95) expression -> . FALSE
    (96) expression -> . IDENTIFIER
    (97) expression -> . STRING
    (98) expression -> . IDENTIFIER PLUSPLUS
    (99) expression -> . IDENTIFIER MINUSMINUS
    (100) expression -> . expression DOT IDENTIFIER
    (103) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (133) expression -> . IDENTIFIER LBRACE keyed_element_list RBRACE
    (134) expression -> . IDENTIFIER LBRACE RBRACE
    (135) binary_expression -> . expression PLUS expression
    (136) binary_expression -> . expression MINUS expression
    (137) binary_expression -> . expression TIMES expression
    (138) binary_expression -> . expression DIVIDE expression
    (139) binary_expression -> . expression MODULE expression
    (144) relational_expression -> . expression EQ expression
    (145) relational_expression -> . expression NEQ expression
    (146) relational_expression -> . expression LT expression
    (147) relational_expression -> . expression LE expression
    (148) relational_expression -> . expression GT expression
    (149) relational_expression -> . expression GE expression
    (150) logical_expression -> . expression LAND expression
    (151) logical_expression -> . expression LOR expression
    (152) bitwise_expression -> . expression AND expression
    (153) bitwise_expression -> . expression OR expression
    (154) bitwise_expression -> . expression XOR expression
    (155) bitwise_expression -> . expression AND_NOT expression
    (156) bitwise_expression -> . expression LSHIFT expression
    (157) bitwise_expression -> . expression RSHIFT expression

    PLUS            shift and go to state 37
    MINUS           shift and go to state 38
    LNOT            shift and go to state 39
    LBRACKET        shift and go to state 40
    LPAREN          shift and go to state 29
    INT             shift and go to state 41
    FLOAT64         shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44
    IDENTIFIER      shift and go to state 97
    STRING          shift and go to state 11
>>>>>>> Stashed changes

    expression                     shift and go to state 147
    binary_expression              shift and go to state 33
    relational_expression          shift and go to state 34
    logical_expression             shift and go to state 35
    bitwise_expression             shift and go to state 36

state 87

<<<<<<< Updated upstream
    (40) binary_operator -> DIVIDE .

    LPAREN          reduce using rule 40 (binary_operator -> DIVIDE .)
    INT             reduce using rule 40 (binary_operator -> DIVIDE .)
    FLOAT64         reduce using rule 40 (binary_operator -> DIVIDE .)
    IDENTIFIER      reduce using rule 40 (binary_operator -> DIVIDE .)
    STRING          reduce using rule 40 (binary_operator -> DIVIDE .)
    TRUE            reduce using rule 40 (binary_operator -> DIVIDE .)
    FALSE           reduce using rule 40 (binary_operator -> DIVIDE .)
    LNOT            reduce using rule 40 (binary_operator -> DIVIDE .)
    LBRACKET        reduce using rule 40 (binary_operator -> DIVIDE .)
    MAP             reduce using rule 40 (binary_operator -> DIVIDE .)
=======
    (61) assignment_compound -> IDENTIFIER AND_ASSIGN . expression
    (82) expression -> . binary_expression
    (83) expression -> . relational_expression
    (84) expression -> . logical_expression
    (85) expression -> . bitwise_expression
    (86) expression -> . PLUS expression
    (87) expression -> . MINUS expression
    (88) expression -> . LNOT expression
    (89) expression -> . LBRACKET RBRACKET primitive_type LBRACE expression_list RBRACE
    (90) expression -> . LBRACKET RBRACKET primitive_type LBRACE RBRACE
    (91) expression -> . LPAREN expression RPAREN
    (92) expression -> . INT
    (93) expression -> . FLOAT64
    (94) expression -> . TRUE
    (95) expression -> . FALSE
    (96) expression -> . IDENTIFIER
    (97) expression -> . STRING
    (98) expression -> . IDENTIFIER PLUSPLUS
    (99) expression -> . IDENTIFIER MINUSMINUS
    (100) expression -> . expression DOT IDENTIFIER
    (103) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (133) expression -> . IDENTIFIER LBRACE keyed_element_list RBRACE
    (134) expression -> . IDENTIFIER LBRACE RBRACE
    (135) binary_expression -> . expression PLUS expression
    (136) binary_expression -> . expression MINUS expression
    (137) binary_expression -> . expression TIMES expression
    (138) binary_expression -> . expression DIVIDE expression
    (139) binary_expression -> . expression MODULE expression
    (144) relational_expression -> . expression EQ expression
    (145) relational_expression -> . expression NEQ expression
    (146) relational_expression -> . expression LT expression
    (147) relational_expression -> . expression LE expression
    (148) relational_expression -> . expression GT expression
    (149) relational_expression -> . expression GE expression
    (150) logical_expression -> . expression LAND expression
    (151) logical_expression -> . expression LOR expression
    (152) bitwise_expression -> . expression AND expression
    (153) bitwise_expression -> . expression OR expression
    (154) bitwise_expression -> . expression XOR expression
    (155) bitwise_expression -> . expression AND_NOT expression
    (156) bitwise_expression -> . expression LSHIFT expression
    (157) bitwise_expression -> . expression RSHIFT expression

    PLUS            shift and go to state 37
    MINUS           shift and go to state 38
    LNOT            shift and go to state 39
    LBRACKET        shift and go to state 40
    LPAREN          shift and go to state 29
    INT             shift and go to state 41
    FLOAT64         shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44
    IDENTIFIER      shift and go to state 97
    STRING          shift and go to state 11
>>>>>>> Stashed changes

    expression                     shift and go to state 148
    binary_expression              shift and go to state 33
    relational_expression          shift and go to state 34
    logical_expression             shift and go to state 35
    bitwise_expression             shift and go to state 36

state 88

<<<<<<< Updated upstream
    (41) binary_operator -> MODULE .

    LPAREN          reduce using rule 41 (binary_operator -> MODULE .)
    INT             reduce using rule 41 (binary_operator -> MODULE .)
    FLOAT64         reduce using rule 41 (binary_operator -> MODULE .)
    IDENTIFIER      reduce using rule 41 (binary_operator -> MODULE .)
    STRING          reduce using rule 41 (binary_operator -> MODULE .)
    TRUE            reduce using rule 41 (binary_operator -> MODULE .)
    FALSE           reduce using rule 41 (binary_operator -> MODULE .)
    LNOT            reduce using rule 41 (binary_operator -> MODULE .)
    LBRACKET        reduce using rule 41 (binary_operator -> MODULE .)
    MAP             reduce using rule 41 (binary_operator -> MODULE .)


state 89

    (42) binary_operator -> EQ .

    LPAREN          reduce using rule 42 (binary_operator -> EQ .)
    INT             reduce using rule 42 (binary_operator -> EQ .)
    FLOAT64         reduce using rule 42 (binary_operator -> EQ .)
    IDENTIFIER      reduce using rule 42 (binary_operator -> EQ .)
    STRING          reduce using rule 42 (binary_operator -> EQ .)
    TRUE            reduce using rule 42 (binary_operator -> EQ .)
    FALSE           reduce using rule 42 (binary_operator -> EQ .)
    LNOT            reduce using rule 42 (binary_operator -> EQ .)
    LBRACKET        reduce using rule 42 (binary_operator -> EQ .)
    MAP             reduce using rule 42 (binary_operator -> EQ .)


state 90

    (43) binary_operator -> NEQ .

    LPAREN          reduce using rule 43 (binary_operator -> NEQ .)
    INT             reduce using rule 43 (binary_operator -> NEQ .)
    FLOAT64         reduce using rule 43 (binary_operator -> NEQ .)
    IDENTIFIER      reduce using rule 43 (binary_operator -> NEQ .)
    STRING          reduce using rule 43 (binary_operator -> NEQ .)
    TRUE            reduce using rule 43 (binary_operator -> NEQ .)
    FALSE           reduce using rule 43 (binary_operator -> NEQ .)
    LNOT            reduce using rule 43 (binary_operator -> NEQ .)
    LBRACKET        reduce using rule 43 (binary_operator -> NEQ .)
    MAP             reduce using rule 43 (binary_operator -> NEQ .)
=======
    (62) assignment_compound -> IDENTIFIER OR_ASSIGN . expression
    (82) expression -> . binary_expression
    (83) expression -> . relational_expression
    (84) expression -> . logical_expression
    (85) expression -> . bitwise_expression
    (86) expression -> . PLUS expression
    (87) expression -> . MINUS expression
    (88) expression -> . LNOT expression
    (89) expression -> . LBRACKET RBRACKET primitive_type LBRACE expression_list RBRACE
    (90) expression -> . LBRACKET RBRACKET primitive_type LBRACE RBRACE
    (91) expression -> . LPAREN expression RPAREN
    (92) expression -> . INT
    (93) expression -> . FLOAT64
    (94) expression -> . TRUE
    (95) expression -> . FALSE
    (96) expression -> . IDENTIFIER
    (97) expression -> . STRING
    (98) expression -> . IDENTIFIER PLUSPLUS
    (99) expression -> . IDENTIFIER MINUSMINUS
    (100) expression -> . expression DOT IDENTIFIER
    (103) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (133) expression -> . IDENTIFIER LBRACE keyed_element_list RBRACE
    (134) expression -> . IDENTIFIER LBRACE RBRACE
    (135) binary_expression -> . expression PLUS expression
    (136) binary_expression -> . expression MINUS expression
    (137) binary_expression -> . expression TIMES expression
    (138) binary_expression -> . expression DIVIDE expression
    (139) binary_expression -> . expression MODULE expression
    (144) relational_expression -> . expression EQ expression
    (145) relational_expression -> . expression NEQ expression
    (146) relational_expression -> . expression LT expression
    (147) relational_expression -> . expression LE expression
    (148) relational_expression -> . expression GT expression
    (149) relational_expression -> . expression GE expression
    (150) logical_expression -> . expression LAND expression
    (151) logical_expression -> . expression LOR expression
    (152) bitwise_expression -> . expression AND expression
    (153) bitwise_expression -> . expression OR expression
    (154) bitwise_expression -> . expression XOR expression
    (155) bitwise_expression -> . expression AND_NOT expression
    (156) bitwise_expression -> . expression LSHIFT expression
    (157) bitwise_expression -> . expression RSHIFT expression

    PLUS            shift and go to state 37
    MINUS           shift and go to state 38
    LNOT            shift and go to state 39
    LBRACKET        shift and go to state 40
    LPAREN          shift and go to state 29
    INT             shift and go to state 41
    FLOAT64         shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44
    IDENTIFIER      shift and go to state 97
    STRING          shift and go to state 11

    expression                     shift and go to state 149
    binary_expression              shift and go to state 33
    relational_expression          shift and go to state 34
    logical_expression             shift and go to state 35
    bitwise_expression             shift and go to state 36

state 89

    (63) assignment_compound -> IDENTIFIER XOR_ASSIGN . expression
    (82) expression -> . binary_expression
    (83) expression -> . relational_expression
    (84) expression -> . logical_expression
    (85) expression -> . bitwise_expression
    (86) expression -> . PLUS expression
    (87) expression -> . MINUS expression
    (88) expression -> . LNOT expression
    (89) expression -> . LBRACKET RBRACKET primitive_type LBRACE expression_list RBRACE
    (90) expression -> . LBRACKET RBRACKET primitive_type LBRACE RBRACE
    (91) expression -> . LPAREN expression RPAREN
    (92) expression -> . INT
    (93) expression -> . FLOAT64
    (94) expression -> . TRUE
    (95) expression -> . FALSE
    (96) expression -> . IDENTIFIER
    (97) expression -> . STRING
    (98) expression -> . IDENTIFIER PLUSPLUS
    (99) expression -> . IDENTIFIER MINUSMINUS
    (100) expression -> . expression DOT IDENTIFIER
    (103) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (133) expression -> . IDENTIFIER LBRACE keyed_element_list RBRACE
    (134) expression -> . IDENTIFIER LBRACE RBRACE
    (135) binary_expression -> . expression PLUS expression
    (136) binary_expression -> . expression MINUS expression
    (137) binary_expression -> . expression TIMES expression
    (138) binary_expression -> . expression DIVIDE expression
    (139) binary_expression -> . expression MODULE expression
    (144) relational_expression -> . expression EQ expression
    (145) relational_expression -> . expression NEQ expression
    (146) relational_expression -> . expression LT expression
    (147) relational_expression -> . expression LE expression
    (148) relational_expression -> . expression GT expression
    (149) relational_expression -> . expression GE expression
    (150) logical_expression -> . expression LAND expression
    (151) logical_expression -> . expression LOR expression
    (152) bitwise_expression -> . expression AND expression
    (153) bitwise_expression -> . expression OR expression
    (154) bitwise_expression -> . expression XOR expression
    (155) bitwise_expression -> . expression AND_NOT expression
    (156) bitwise_expression -> . expression LSHIFT expression
    (157) bitwise_expression -> . expression RSHIFT expression

    PLUS            shift and go to state 37
    MINUS           shift and go to state 38
    LNOT            shift and go to state 39
    LBRACKET        shift and go to state 40
    LPAREN          shift and go to state 29
    INT             shift and go to state 41
    FLOAT64         shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44
    IDENTIFIER      shift and go to state 97
    STRING          shift and go to state 11

    expression                     shift and go to state 150
    binary_expression              shift and go to state 33
    relational_expression          shift and go to state 34
    logical_expression             shift and go to state 35
    bitwise_expression             shift and go to state 36

state 90

    (64) assignment_compound -> IDENTIFIER LSHIFT_ASSIGN . expression
    (82) expression -> . binary_expression
    (83) expression -> . relational_expression
    (84) expression -> . logical_expression
    (85) expression -> . bitwise_expression
    (86) expression -> . PLUS expression
    (87) expression -> . MINUS expression
    (88) expression -> . LNOT expression
    (89) expression -> . LBRACKET RBRACKET primitive_type LBRACE expression_list RBRACE
    (90) expression -> . LBRACKET RBRACKET primitive_type LBRACE RBRACE
    (91) expression -> . LPAREN expression RPAREN
    (92) expression -> . INT
    (93) expression -> . FLOAT64
    (94) expression -> . TRUE
    (95) expression -> . FALSE
    (96) expression -> . IDENTIFIER
    (97) expression -> . STRING
    (98) expression -> . IDENTIFIER PLUSPLUS
    (99) expression -> . IDENTIFIER MINUSMINUS
    (100) expression -> . expression DOT IDENTIFIER
    (103) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (133) expression -> . IDENTIFIER LBRACE keyed_element_list RBRACE
    (134) expression -> . IDENTIFIER LBRACE RBRACE
    (135) binary_expression -> . expression PLUS expression
    (136) binary_expression -> . expression MINUS expression
    (137) binary_expression -> . expression TIMES expression
    (138) binary_expression -> . expression DIVIDE expression
    (139) binary_expression -> . expression MODULE expression
    (144) relational_expression -> . expression EQ expression
    (145) relational_expression -> . expression NEQ expression
    (146) relational_expression -> . expression LT expression
    (147) relational_expression -> . expression LE expression
    (148) relational_expression -> . expression GT expression
    (149) relational_expression -> . expression GE expression
    (150) logical_expression -> . expression LAND expression
    (151) logical_expression -> . expression LOR expression
    (152) bitwise_expression -> . expression AND expression
    (153) bitwise_expression -> . expression OR expression
    (154) bitwise_expression -> . expression XOR expression
    (155) bitwise_expression -> . expression AND_NOT expression
    (156) bitwise_expression -> . expression LSHIFT expression
    (157) bitwise_expression -> . expression RSHIFT expression

    PLUS            shift and go to state 37
    MINUS           shift and go to state 38
    LNOT            shift and go to state 39
    LBRACKET        shift and go to state 40
    LPAREN          shift and go to state 29
    INT             shift and go to state 41
    FLOAT64         shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44
    IDENTIFIER      shift and go to state 97
    STRING          shift and go to state 11
>>>>>>> Stashed changes

    expression                     shift and go to state 151
    binary_expression              shift and go to state 33
    relational_expression          shift and go to state 34
    logical_expression             shift and go to state 35
    bitwise_expression             shift and go to state 36

state 91

<<<<<<< Updated upstream
    (44) binary_operator -> LT .

    LPAREN          reduce using rule 44 (binary_operator -> LT .)
    INT             reduce using rule 44 (binary_operator -> LT .)
    FLOAT64         reduce using rule 44 (binary_operator -> LT .)
    IDENTIFIER      reduce using rule 44 (binary_operator -> LT .)
    STRING          reduce using rule 44 (binary_operator -> LT .)
    TRUE            reduce using rule 44 (binary_operator -> LT .)
    FALSE           reduce using rule 44 (binary_operator -> LT .)
    LNOT            reduce using rule 44 (binary_operator -> LT .)
    LBRACKET        reduce using rule 44 (binary_operator -> LT .)
    MAP             reduce using rule 44 (binary_operator -> LT .)
=======
    (65) assignment_compound -> IDENTIFIER RSHIFT_ASSIGN . expression
    (82) expression -> . binary_expression
    (83) expression -> . relational_expression
    (84) expression -> . logical_expression
    (85) expression -> . bitwise_expression
    (86) expression -> . PLUS expression
    (87) expression -> . MINUS expression
    (88) expression -> . LNOT expression
    (89) expression -> . LBRACKET RBRACKET primitive_type LBRACE expression_list RBRACE
    (90) expression -> . LBRACKET RBRACKET primitive_type LBRACE RBRACE
    (91) expression -> . LPAREN expression RPAREN
    (92) expression -> . INT
    (93) expression -> . FLOAT64
    (94) expression -> . TRUE
    (95) expression -> . FALSE
    (96) expression -> . IDENTIFIER
    (97) expression -> . STRING
    (98) expression -> . IDENTIFIER PLUSPLUS
    (99) expression -> . IDENTIFIER MINUSMINUS
    (100) expression -> . expression DOT IDENTIFIER
    (103) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (133) expression -> . IDENTIFIER LBRACE keyed_element_list RBRACE
    (134) expression -> . IDENTIFIER LBRACE RBRACE
    (135) binary_expression -> . expression PLUS expression
    (136) binary_expression -> . expression MINUS expression
    (137) binary_expression -> . expression TIMES expression
    (138) binary_expression -> . expression DIVIDE expression
    (139) binary_expression -> . expression MODULE expression
    (144) relational_expression -> . expression EQ expression
    (145) relational_expression -> . expression NEQ expression
    (146) relational_expression -> . expression LT expression
    (147) relational_expression -> . expression LE expression
    (148) relational_expression -> . expression GT expression
    (149) relational_expression -> . expression GE expression
    (150) logical_expression -> . expression LAND expression
    (151) logical_expression -> . expression LOR expression
    (152) bitwise_expression -> . expression AND expression
    (153) bitwise_expression -> . expression OR expression
    (154) bitwise_expression -> . expression XOR expression
    (155) bitwise_expression -> . expression AND_NOT expression
    (156) bitwise_expression -> . expression LSHIFT expression
    (157) bitwise_expression -> . expression RSHIFT expression

    PLUS            shift and go to state 37
    MINUS           shift and go to state 38
    LNOT            shift and go to state 39
    LBRACKET        shift and go to state 40
    LPAREN          shift and go to state 29
    INT             shift and go to state 41
    FLOAT64         shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44
    IDENTIFIER      shift and go to state 97
    STRING          shift and go to state 11
>>>>>>> Stashed changes

    expression                     shift and go to state 152
    binary_expression              shift and go to state 33
    relational_expression          shift and go to state 34
    logical_expression             shift and go to state 35
    bitwise_expression             shift and go to state 36

state 92

<<<<<<< Updated upstream
    (45) binary_operator -> LE .

    LPAREN          reduce using rule 45 (binary_operator -> LE .)
    INT             reduce using rule 45 (binary_operator -> LE .)
    FLOAT64         reduce using rule 45 (binary_operator -> LE .)
    IDENTIFIER      reduce using rule 45 (binary_operator -> LE .)
    STRING          reduce using rule 45 (binary_operator -> LE .)
    TRUE            reduce using rule 45 (binary_operator -> LE .)
    FALSE           reduce using rule 45 (binary_operator -> LE .)
    LNOT            reduce using rule 45 (binary_operator -> LE .)
    LBRACKET        reduce using rule 45 (binary_operator -> LE .)
    MAP             reduce using rule 45 (binary_operator -> LE .)
=======
    (98) expression -> IDENTIFIER PLUSPLUS .

    DOT             reduce using rule 98 (expression -> IDENTIFIER PLUSPLUS .)
    PLUS            reduce using rule 98 (expression -> IDENTIFIER PLUSPLUS .)
    MINUS           reduce using rule 98 (expression -> IDENTIFIER PLUSPLUS .)
    TIMES           reduce using rule 98 (expression -> IDENTIFIER PLUSPLUS .)
    DIVIDE          reduce using rule 98 (expression -> IDENTIFIER PLUSPLUS .)
    MODULE          reduce using rule 98 (expression -> IDENTIFIER PLUSPLUS .)
    EQ              reduce using rule 98 (expression -> IDENTIFIER PLUSPLUS .)
    NEQ             reduce using rule 98 (expression -> IDENTIFIER PLUSPLUS .)
    LT              reduce using rule 98 (expression -> IDENTIFIER PLUSPLUS .)
    LE              reduce using rule 98 (expression -> IDENTIFIER PLUSPLUS .)
    GT              reduce using rule 98 (expression -> IDENTIFIER PLUSPLUS .)
    GE              reduce using rule 98 (expression -> IDENTIFIER PLUSPLUS .)
    LAND            reduce using rule 98 (expression -> IDENTIFIER PLUSPLUS .)
    LOR             reduce using rule 98 (expression -> IDENTIFIER PLUSPLUS .)
    AND             reduce using rule 98 (expression -> IDENTIFIER PLUSPLUS .)
    OR              reduce using rule 98 (expression -> IDENTIFIER PLUSPLUS .)
    XOR             reduce using rule 98 (expression -> IDENTIFIER PLUSPLUS .)
    AND_NOT         reduce using rule 98 (expression -> IDENTIFIER PLUSPLUS .)
    LSHIFT          reduce using rule 98 (expression -> IDENTIFIER PLUSPLUS .)
    RSHIFT          reduce using rule 98 (expression -> IDENTIFIER PLUSPLUS .)
    SEMICOLON       reduce using rule 98 (expression -> IDENTIFIER PLUSPLUS .)
    FUNC            reduce using rule 98 (expression -> IDENTIFIER PLUSPLUS .)
    TYPE            reduce using rule 98 (expression -> IDENTIFIER PLUSPLUS .)
    IDENTIFIER      reduce using rule 98 (expression -> IDENTIFIER PLUSPLUS .)
    VAR             reduce using rule 98 (expression -> IDENTIFIER PLUSPLUS .)
    CONST           reduce using rule 98 (expression -> IDENTIFIER PLUSPLUS .)
    LNOT            reduce using rule 98 (expression -> IDENTIFIER PLUSPLUS .)
    LBRACKET        reduce using rule 98 (expression -> IDENTIFIER PLUSPLUS .)
    LPAREN          reduce using rule 98 (expression -> IDENTIFIER PLUSPLUS .)
    INT             reduce using rule 98 (expression -> IDENTIFIER PLUSPLUS .)
    FLOAT64         reduce using rule 98 (expression -> IDENTIFIER PLUSPLUS .)
    TRUE            reduce using rule 98 (expression -> IDENTIFIER PLUSPLUS .)
    FALSE           reduce using rule 98 (expression -> IDENTIFIER PLUSPLUS .)
    STRING          reduce using rule 98 (expression -> IDENTIFIER PLUSPLUS .)
    RETURN          reduce using rule 98 (expression -> IDENTIFIER PLUSPLUS .)
    FOR             reduce using rule 98 (expression -> IDENTIFIER PLUSPLUS .)
    IF              reduce using rule 98 (expression -> IDENTIFIER PLUSPLUS .)
    SWITCH          reduce using rule 98 (expression -> IDENTIFIER PLUSPLUS .)
    BREAK           reduce using rule 98 (expression -> IDENTIFIER PLUSPLUS .)
    CONTINUE        reduce using rule 98 (expression -> IDENTIFIER PLUSPLUS .)
    FALLTHROUGH     reduce using rule 98 (expression -> IDENTIFIER PLUSPLUS .)
    $end            reduce using rule 98 (expression -> IDENTIFIER PLUSPLUS .)
    RPAREN          reduce using rule 98 (expression -> IDENTIFIER PLUSPLUS .)
    COMMA           reduce using rule 98 (expression -> IDENTIFIER PLUSPLUS .)
    RBRACE          reduce using rule 98 (expression -> IDENTIFIER PLUSPLUS .)
    CASE            reduce using rule 98 (expression -> IDENTIFIER PLUSPLUS .)
    DEFAULT         reduce using rule 98 (expression -> IDENTIFIER PLUSPLUS .)
    LBRACE          reduce using rule 98 (expression -> IDENTIFIER PLUSPLUS .)
    COLON           reduce using rule 98 (expression -> IDENTIFIER PLUSPLUS .)
>>>>>>> Stashed changes


state 93

<<<<<<< Updated upstream
    (46) binary_operator -> GT .

    LPAREN          reduce using rule 46 (binary_operator -> GT .)
    INT             reduce using rule 46 (binary_operator -> GT .)
    FLOAT64         reduce using rule 46 (binary_operator -> GT .)
    IDENTIFIER      reduce using rule 46 (binary_operator -> GT .)
    STRING          reduce using rule 46 (binary_operator -> GT .)
    TRUE            reduce using rule 46 (binary_operator -> GT .)
    FALSE           reduce using rule 46 (binary_operator -> GT .)
    LNOT            reduce using rule 46 (binary_operator -> GT .)
    LBRACKET        reduce using rule 46 (binary_operator -> GT .)
    MAP             reduce using rule 46 (binary_operator -> GT .)
=======
    (99) expression -> IDENTIFIER MINUSMINUS .

    DOT             reduce using rule 99 (expression -> IDENTIFIER MINUSMINUS .)
    PLUS            reduce using rule 99 (expression -> IDENTIFIER MINUSMINUS .)
    MINUS           reduce using rule 99 (expression -> IDENTIFIER MINUSMINUS .)
    TIMES           reduce using rule 99 (expression -> IDENTIFIER MINUSMINUS .)
    DIVIDE          reduce using rule 99 (expression -> IDENTIFIER MINUSMINUS .)
    MODULE          reduce using rule 99 (expression -> IDENTIFIER MINUSMINUS .)
    EQ              reduce using rule 99 (expression -> IDENTIFIER MINUSMINUS .)
    NEQ             reduce using rule 99 (expression -> IDENTIFIER MINUSMINUS .)
    LT              reduce using rule 99 (expression -> IDENTIFIER MINUSMINUS .)
    LE              reduce using rule 99 (expression -> IDENTIFIER MINUSMINUS .)
    GT              reduce using rule 99 (expression -> IDENTIFIER MINUSMINUS .)
    GE              reduce using rule 99 (expression -> IDENTIFIER MINUSMINUS .)
    LAND            reduce using rule 99 (expression -> IDENTIFIER MINUSMINUS .)
    LOR             reduce using rule 99 (expression -> IDENTIFIER MINUSMINUS .)
    AND             reduce using rule 99 (expression -> IDENTIFIER MINUSMINUS .)
    OR              reduce using rule 99 (expression -> IDENTIFIER MINUSMINUS .)
    XOR             reduce using rule 99 (expression -> IDENTIFIER MINUSMINUS .)
    AND_NOT         reduce using rule 99 (expression -> IDENTIFIER MINUSMINUS .)
    LSHIFT          reduce using rule 99 (expression -> IDENTIFIER MINUSMINUS .)
    RSHIFT          reduce using rule 99 (expression -> IDENTIFIER MINUSMINUS .)
    SEMICOLON       reduce using rule 99 (expression -> IDENTIFIER MINUSMINUS .)
    FUNC            reduce using rule 99 (expression -> IDENTIFIER MINUSMINUS .)
    TYPE            reduce using rule 99 (expression -> IDENTIFIER MINUSMINUS .)
    IDENTIFIER      reduce using rule 99 (expression -> IDENTIFIER MINUSMINUS .)
    VAR             reduce using rule 99 (expression -> IDENTIFIER MINUSMINUS .)
    CONST           reduce using rule 99 (expression -> IDENTIFIER MINUSMINUS .)
    LNOT            reduce using rule 99 (expression -> IDENTIFIER MINUSMINUS .)
    LBRACKET        reduce using rule 99 (expression -> IDENTIFIER MINUSMINUS .)
    LPAREN          reduce using rule 99 (expression -> IDENTIFIER MINUSMINUS .)
    INT             reduce using rule 99 (expression -> IDENTIFIER MINUSMINUS .)
    FLOAT64         reduce using rule 99 (expression -> IDENTIFIER MINUSMINUS .)
    TRUE            reduce using rule 99 (expression -> IDENTIFIER MINUSMINUS .)
    FALSE           reduce using rule 99 (expression -> IDENTIFIER MINUSMINUS .)
    STRING          reduce using rule 99 (expression -> IDENTIFIER MINUSMINUS .)
    RETURN          reduce using rule 99 (expression -> IDENTIFIER MINUSMINUS .)
    FOR             reduce using rule 99 (expression -> IDENTIFIER MINUSMINUS .)
    IF              reduce using rule 99 (expression -> IDENTIFIER MINUSMINUS .)
    SWITCH          reduce using rule 99 (expression -> IDENTIFIER MINUSMINUS .)
    BREAK           reduce using rule 99 (expression -> IDENTIFIER MINUSMINUS .)
    CONTINUE        reduce using rule 99 (expression -> IDENTIFIER MINUSMINUS .)
    FALLTHROUGH     reduce using rule 99 (expression -> IDENTIFIER MINUSMINUS .)
    $end            reduce using rule 99 (expression -> IDENTIFIER MINUSMINUS .)
    RPAREN          reduce using rule 99 (expression -> IDENTIFIER MINUSMINUS .)
    COMMA           reduce using rule 99 (expression -> IDENTIFIER MINUSMINUS .)
    RBRACE          reduce using rule 99 (expression -> IDENTIFIER MINUSMINUS .)
    CASE            reduce using rule 99 (expression -> IDENTIFIER MINUSMINUS .)
    DEFAULT         reduce using rule 99 (expression -> IDENTIFIER MINUSMINUS .)
    LBRACE          reduce using rule 99 (expression -> IDENTIFIER MINUSMINUS .)
    COLON           reduce using rule 99 (expression -> IDENTIFIER MINUSMINUS .)
>>>>>>> Stashed changes


state 94

<<<<<<< Updated upstream
    (47) binary_operator -> GE .

    LPAREN          reduce using rule 47 (binary_operator -> GE .)
    INT             reduce using rule 47 (binary_operator -> GE .)
    FLOAT64         reduce using rule 47 (binary_operator -> GE .)
    IDENTIFIER      reduce using rule 47 (binary_operator -> GE .)
    STRING          reduce using rule 47 (binary_operator -> GE .)
    TRUE            reduce using rule 47 (binary_operator -> GE .)
    FALSE           reduce using rule 47 (binary_operator -> GE .)
    LNOT            reduce using rule 47 (binary_operator -> GE .)
    LBRACKET        reduce using rule 47 (binary_operator -> GE .)
    MAP             reduce using rule 47 (binary_operator -> GE .)


state 95

    (48) binary_operator -> LAND .

    LPAREN          reduce using rule 48 (binary_operator -> LAND .)
    INT             reduce using rule 48 (binary_operator -> LAND .)
    FLOAT64         reduce using rule 48 (binary_operator -> LAND .)
    IDENTIFIER      reduce using rule 48 (binary_operator -> LAND .)
    STRING          reduce using rule 48 (binary_operator -> LAND .)
    TRUE            reduce using rule 48 (binary_operator -> LAND .)
    FALSE           reduce using rule 48 (binary_operator -> LAND .)
    LNOT            reduce using rule 48 (binary_operator -> LAND .)
    LBRACKET        reduce using rule 48 (binary_operator -> LAND .)
    MAP             reduce using rule 48 (binary_operator -> LAND .)


state 96

    (49) binary_operator -> LOR .

    LPAREN          reduce using rule 49 (binary_operator -> LOR .)
    INT             reduce using rule 49 (binary_operator -> LOR .)
    FLOAT64         reduce using rule 49 (binary_operator -> LOR .)
    IDENTIFIER      reduce using rule 49 (binary_operator -> LOR .)
    STRING          reduce using rule 49 (binary_operator -> LOR .)
    TRUE            reduce using rule 49 (binary_operator -> LOR .)
    FALSE           reduce using rule 49 (binary_operator -> LOR .)
    LNOT            reduce using rule 49 (binary_operator -> LOR .)
    LBRACKET        reduce using rule 49 (binary_operator -> LOR .)
    MAP             reduce using rule 49 (binary_operator -> LOR .)
=======
    (103) expression -> IDENTIFIER LPAREN . argument_list RPAREN
    (104) argument_list -> . expression_list
    (105) argument_list -> . empty
    (101) expression_list -> . expression_list COMMA expression
    (102) expression_list -> . expression
    (7) empty -> .
    (82) expression -> . binary_expression
    (83) expression -> . relational_expression
    (84) expression -> . logical_expression
    (85) expression -> . bitwise_expression
    (86) expression -> . PLUS expression
    (87) expression -> . MINUS expression
    (88) expression -> . LNOT expression
    (89) expression -> . LBRACKET RBRACKET primitive_type LBRACE expression_list RBRACE
    (90) expression -> . LBRACKET RBRACKET primitive_type LBRACE RBRACE
    (91) expression -> . LPAREN expression RPAREN
    (92) expression -> . INT
    (93) expression -> . FLOAT64
    (94) expression -> . TRUE
    (95) expression -> . FALSE
    (96) expression -> . IDENTIFIER
    (97) expression -> . STRING
    (98) expression -> . IDENTIFIER PLUSPLUS
    (99) expression -> . IDENTIFIER MINUSMINUS
    (100) expression -> . expression DOT IDENTIFIER
    (103) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (133) expression -> . IDENTIFIER LBRACE keyed_element_list RBRACE
    (134) expression -> . IDENTIFIER LBRACE RBRACE
    (135) binary_expression -> . expression PLUS expression
    (136) binary_expression -> . expression MINUS expression
    (137) binary_expression -> . expression TIMES expression
    (138) binary_expression -> . expression DIVIDE expression
    (139) binary_expression -> . expression MODULE expression
    (144) relational_expression -> . expression EQ expression
    (145) relational_expression -> . expression NEQ expression
    (146) relational_expression -> . expression LT expression
    (147) relational_expression -> . expression LE expression
    (148) relational_expression -> . expression GT expression
    (149) relational_expression -> . expression GE expression
    (150) logical_expression -> . expression LAND expression
    (151) logical_expression -> . expression LOR expression
    (152) bitwise_expression -> . expression AND expression
    (153) bitwise_expression -> . expression OR expression
    (154) bitwise_expression -> . expression XOR expression
    (155) bitwise_expression -> . expression AND_NOT expression
    (156) bitwise_expression -> . expression LSHIFT expression
    (157) bitwise_expression -> . expression RSHIFT expression

    RPAREN          reduce using rule 7 (empty -> .)
    PLUS            shift and go to state 37
    MINUS           shift and go to state 38
    LNOT            shift and go to state 39
    LBRACKET        shift and go to state 40
    LPAREN          shift and go to state 29
    INT             shift and go to state 41
    FLOAT64         shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44
    IDENTIFIER      shift and go to state 97
    STRING          shift and go to state 11

    argument_list                  shift and go to state 153
    expression_list                shift and go to state 154
    empty                          shift and go to state 155
    expression                     shift and go to state 156
    binary_expression              shift and go to state 33
    relational_expression          shift and go to state 34
    logical_expression             shift and go to state 35
    bitwise_expression             shift and go to state 36

state 95

    (133) expression -> IDENTIFIER LBRACE . keyed_element_list RBRACE
    (134) expression -> IDENTIFIER LBRACE . RBRACE
    (128) keyed_element_list -> . keyed_element_list COMMA keyed_element
    (129) keyed_element_list -> . keyed_element
    (130) keyed_element -> . IDENTIFIER COLON expression
    (131) keyed_element -> . INT COLON expression
    (132) keyed_element -> . expression
    (82) expression -> . binary_expression
    (83) expression -> . relational_expression
    (84) expression -> . logical_expression
    (85) expression -> . bitwise_expression
    (86) expression -> . PLUS expression
    (87) expression -> . MINUS expression
    (88) expression -> . LNOT expression
    (89) expression -> . LBRACKET RBRACKET primitive_type LBRACE expression_list RBRACE
    (90) expression -> . LBRACKET RBRACKET primitive_type LBRACE RBRACE
    (91) expression -> . LPAREN expression RPAREN
    (92) expression -> . INT
    (93) expression -> . FLOAT64
    (94) expression -> . TRUE
    (95) expression -> . FALSE
    (96) expression -> . IDENTIFIER
    (97) expression -> . STRING
    (98) expression -> . IDENTIFIER PLUSPLUS
    (99) expression -> . IDENTIFIER MINUSMINUS
    (100) expression -> . expression DOT IDENTIFIER
    (103) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (133) expression -> . IDENTIFIER LBRACE keyed_element_list RBRACE
    (134) expression -> . IDENTIFIER LBRACE RBRACE
    (135) binary_expression -> . expression PLUS expression
    (136) binary_expression -> . expression MINUS expression
    (137) binary_expression -> . expression TIMES expression
    (138) binary_expression -> . expression DIVIDE expression
    (139) binary_expression -> . expression MODULE expression
    (144) relational_expression -> . expression EQ expression
    (145) relational_expression -> . expression NEQ expression
    (146) relational_expression -> . expression LT expression
    (147) relational_expression -> . expression LE expression
    (148) relational_expression -> . expression GT expression
    (149) relational_expression -> . expression GE expression
    (150) logical_expression -> . expression LAND expression
    (151) logical_expression -> . expression LOR expression
    (152) bitwise_expression -> . expression AND expression
    (153) bitwise_expression -> . expression OR expression
    (154) bitwise_expression -> . expression XOR expression
    (155) bitwise_expression -> . expression AND_NOT expression
    (156) bitwise_expression -> . expression LSHIFT expression
    (157) bitwise_expression -> . expression RSHIFT expression

    RBRACE          shift and go to state 159
    IDENTIFIER      shift and go to state 157
    INT             shift and go to state 162
    PLUS            shift and go to state 37
    MINUS           shift and go to state 38
    LNOT            shift and go to state 39
    LBRACKET        shift and go to state 40
    LPAREN          shift and go to state 29
    FLOAT64         shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44
    STRING          shift and go to state 11

    keyed_element_list             shift and go to state 158
    keyed_element                  shift and go to state 160
    expression                     shift and go to state 161
    binary_expression              shift and go to state 33
    relational_expression          shift and go to state 34
    logical_expression             shift and go to state 35
    bitwise_expression             shift and go to state 36

state 96

    (91) expression -> LPAREN expression . RPAREN
    (100) expression -> expression . DOT IDENTIFIER
    (135) binary_expression -> expression . PLUS expression
    (136) binary_expression -> expression . MINUS expression
    (137) binary_expression -> expression . TIMES expression
    (138) binary_expression -> expression . DIVIDE expression
    (139) binary_expression -> expression . MODULE expression
    (144) relational_expression -> expression . EQ expression
    (145) relational_expression -> expression . NEQ expression
    (146) relational_expression -> expression . LT expression
    (147) relational_expression -> expression . LE expression
    (148) relational_expression -> expression . GT expression
    (149) relational_expression -> expression . GE expression
    (150) logical_expression -> expression . LAND expression
    (151) logical_expression -> expression . LOR expression
    (152) bitwise_expression -> expression . AND expression
    (153) bitwise_expression -> expression . OR expression
    (154) bitwise_expression -> expression . XOR expression
    (155) bitwise_expression -> expression . AND_NOT expression
    (156) bitwise_expression -> expression . LSHIFT expression
    (157) bitwise_expression -> expression . RSHIFT expression

    RPAREN          shift and go to state 163
    DOT             shift and go to state 58
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    TIMES           shift and go to state 61
    DIVIDE          shift and go to state 62
    MODULE          shift and go to state 63
    EQ              shift and go to state 64
    NEQ             shift and go to state 65
    LT              shift and go to state 66
    LE              shift and go to state 67
    GT              shift and go to state 68
    GE              shift and go to state 69
    LAND            shift and go to state 70
    LOR             shift and go to state 71
    AND             shift and go to state 72
    OR              shift and go to state 73
    XOR             shift and go to state 74
    AND_NOT         shift and go to state 75
    LSHIFT          shift and go to state 76
    RSHIFT          shift and go to state 77
>>>>>>> Stashed changes


state 97

<<<<<<< Updated upstream
    (50) binary_operator -> AND .

    LPAREN          reduce using rule 50 (binary_operator -> AND .)
    INT             reduce using rule 50 (binary_operator -> AND .)
    FLOAT64         reduce using rule 50 (binary_operator -> AND .)
    IDENTIFIER      reduce using rule 50 (binary_operator -> AND .)
    STRING          reduce using rule 50 (binary_operator -> AND .)
    TRUE            reduce using rule 50 (binary_operator -> AND .)
    FALSE           reduce using rule 50 (binary_operator -> AND .)
    LNOT            reduce using rule 50 (binary_operator -> AND .)
    LBRACKET        reduce using rule 50 (binary_operator -> AND .)
    MAP             reduce using rule 50 (binary_operator -> AND .)
=======
    (96) expression -> IDENTIFIER .
    (98) expression -> IDENTIFIER . PLUSPLUS
    (99) expression -> IDENTIFIER . MINUSMINUS
    (103) expression -> IDENTIFIER . LPAREN argument_list RPAREN
    (133) expression -> IDENTIFIER . LBRACE keyed_element_list RBRACE
    (134) expression -> IDENTIFIER . LBRACE RBRACE

  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
    RPAREN          reduce using rule 96 (expression -> IDENTIFIER .)
    DOT             reduce using rule 96 (expression -> IDENTIFIER .)
    PLUS            reduce using rule 96 (expression -> IDENTIFIER .)
    MINUS           reduce using rule 96 (expression -> IDENTIFIER .)
    TIMES           reduce using rule 96 (expression -> IDENTIFIER .)
    DIVIDE          reduce using rule 96 (expression -> IDENTIFIER .)
    MODULE          reduce using rule 96 (expression -> IDENTIFIER .)
    EQ              reduce using rule 96 (expression -> IDENTIFIER .)
    NEQ             reduce using rule 96 (expression -> IDENTIFIER .)
    LT              reduce using rule 96 (expression -> IDENTIFIER .)
    LE              reduce using rule 96 (expression -> IDENTIFIER .)
    GT              reduce using rule 96 (expression -> IDENTIFIER .)
    GE              reduce using rule 96 (expression -> IDENTIFIER .)
    LAND            reduce using rule 96 (expression -> IDENTIFIER .)
    LOR             reduce using rule 96 (expression -> IDENTIFIER .)
    AND             reduce using rule 96 (expression -> IDENTIFIER .)
    OR              reduce using rule 96 (expression -> IDENTIFIER .)
    XOR             reduce using rule 96 (expression -> IDENTIFIER .)
    AND_NOT         reduce using rule 96 (expression -> IDENTIFIER .)
    LSHIFT          reduce using rule 96 (expression -> IDENTIFIER .)
    RSHIFT          reduce using rule 96 (expression -> IDENTIFIER .)
    SEMICOLON       reduce using rule 96 (expression -> IDENTIFIER .)
    FUNC            reduce using rule 96 (expression -> IDENTIFIER .)
    TYPE            reduce using rule 96 (expression -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 96 (expression -> IDENTIFIER .)
    VAR             reduce using rule 96 (expression -> IDENTIFIER .)
    CONST           reduce using rule 96 (expression -> IDENTIFIER .)
    LNOT            reduce using rule 96 (expression -> IDENTIFIER .)
    LBRACKET        reduce using rule 96 (expression -> IDENTIFIER .)
    INT             reduce using rule 96 (expression -> IDENTIFIER .)
    FLOAT64         reduce using rule 96 (expression -> IDENTIFIER .)
    TRUE            reduce using rule 96 (expression -> IDENTIFIER .)
    FALSE           reduce using rule 96 (expression -> IDENTIFIER .)
    STRING          reduce using rule 96 (expression -> IDENTIFIER .)
    RETURN          reduce using rule 96 (expression -> IDENTIFIER .)
    FOR             reduce using rule 96 (expression -> IDENTIFIER .)
    IF              reduce using rule 96 (expression -> IDENTIFIER .)
    SWITCH          reduce using rule 96 (expression -> IDENTIFIER .)
    BREAK           reduce using rule 96 (expression -> IDENTIFIER .)
    CONTINUE        reduce using rule 96 (expression -> IDENTIFIER .)
    FALLTHROUGH     reduce using rule 96 (expression -> IDENTIFIER .)
    $end            reduce using rule 96 (expression -> IDENTIFIER .)
    COMMA           reduce using rule 96 (expression -> IDENTIFIER .)
    RBRACE          reduce using rule 96 (expression -> IDENTIFIER .)
    CASE            reduce using rule 96 (expression -> IDENTIFIER .)
    DEFAULT         reduce using rule 96 (expression -> IDENTIFIER .)
    COLON           reduce using rule 96 (expression -> IDENTIFIER .)
    PLUSPLUS        shift and go to state 92
    MINUSMINUS      shift and go to state 93
    LPAREN          shift and go to state 94
    LBRACE          shift and go to state 95

  ! LPAREN          [ reduce using rule 96 (expression -> IDENTIFIER .) ]
  ! LBRACE          [ reduce using rule 96 (expression -> IDENTIFIER .) ]
>>>>>>> Stashed changes


state 98

<<<<<<< Updated upstream
    (51) binary_operator -> OR .

    LPAREN          reduce using rule 51 (binary_operator -> OR .)
    INT             reduce using rule 51 (binary_operator -> OR .)
    FLOAT64         reduce using rule 51 (binary_operator -> OR .)
    IDENTIFIER      reduce using rule 51 (binary_operator -> OR .)
    STRING          reduce using rule 51 (binary_operator -> OR .)
    TRUE            reduce using rule 51 (binary_operator -> OR .)
    FALSE           reduce using rule 51 (binary_operator -> OR .)
    LNOT            reduce using rule 51 (binary_operator -> OR .)
    LBRACKET        reduce using rule 51 (binary_operator -> OR .)
    MAP             reduce using rule 51 (binary_operator -> OR .)
=======
    (112) type_declaration -> TYPE IDENTIFIER . struct_type optional_semicolon
    (113) type_declaration -> TYPE IDENTIFIER . primitive_type optional_semicolon
    (114) type_declaration -> TYPE IDENTIFIER . slice_type optional_semicolon
    (115) type_declaration -> TYPE IDENTIFIER . array_type optional_semicolon
    (116) type_declaration -> TYPE IDENTIFIER . map_type optional_semicolon
    (117) type_declaration -> TYPE IDENTIFIER . IDENTIFIER optional_semicolon
    (118) struct_type -> . STRUCT LBRACE RBRACE
    (119) struct_type -> . STRUCT LBRACE field_list RBRACE
    (76) primitive_type -> . INT_TYPE
    (77) primitive_type -> . FLOAT64_TYPE
    (78) primitive_type -> . STRING_TYPE
    (79) primitive_type -> . BOOL_TYPE
    (80) slice_type -> . LBRACKET RBRACKET primitive_type
    (81) array_type -> . LBRACKET INT RBRACKET type
    (127) map_type -> . MAP LBRACKET primitive_type RBRACKET type

    IDENTIFIER      shift and go to state 164
    STRUCT          shift and go to state 170
    INT_TYPE        shift and go to state 171
    FLOAT64_TYPE    shift and go to state 172
    STRING_TYPE     shift and go to state 173
    BOOL_TYPE       shift and go to state 174
    LBRACKET        shift and go to state 175
    MAP             shift and go to state 176
>>>>>>> Stashed changes

    struct_type                    shift and go to state 165
    primitive_type                 shift and go to state 166
    slice_type                     shift and go to state 167
    array_type                     shift and go to state 168
    map_type                       shift and go to state 169

state 99

<<<<<<< Updated upstream
    (52) binary_operator -> XOR .

    LPAREN          reduce using rule 52 (binary_operator -> XOR .)
    INT             reduce using rule 52 (binary_operator -> XOR .)
    FLOAT64         reduce using rule 52 (binary_operator -> XOR .)
    IDENTIFIER      reduce using rule 52 (binary_operator -> XOR .)
    STRING          reduce using rule 52 (binary_operator -> XOR .)
    TRUE            reduce using rule 52 (binary_operator -> XOR .)
    FALSE           reduce using rule 52 (binary_operator -> XOR .)
    LNOT            reduce using rule 52 (binary_operator -> XOR .)
    LBRACKET        reduce using rule 52 (binary_operator -> XOR .)
    MAP             reduce using rule 52 (binary_operator -> XOR .)


state 100

    (53) binary_operator -> AND_NOT .

    LPAREN          reduce using rule 53 (binary_operator -> AND_NOT .)
    INT             reduce using rule 53 (binary_operator -> AND_NOT .)
    FLOAT64         reduce using rule 53 (binary_operator -> AND_NOT .)
    IDENTIFIER      reduce using rule 53 (binary_operator -> AND_NOT .)
    STRING          reduce using rule 53 (binary_operator -> AND_NOT .)
    TRUE            reduce using rule 53 (binary_operator -> AND_NOT .)
    FALSE           reduce using rule 53 (binary_operator -> AND_NOT .)
    LNOT            reduce using rule 53 (binary_operator -> AND_NOT .)
    LBRACKET        reduce using rule 53 (binary_operator -> AND_NOT .)
    MAP             reduce using rule 53 (binary_operator -> AND_NOT .)
=======
    (66) variable_declaration -> VAR IDENTIFIER . type ASSIGN expression
    (68) variable_declaration -> VAR IDENTIFIER . ASSIGN expression
    (70) type -> . primitive_type
    (71) type -> . slice_type
    (72) type -> . array_type
    (73) type -> . map_type
    (74) type -> . struct_type
    (75) type -> . IDENTIFIER
    (76) primitive_type -> . INT_TYPE
    (77) primitive_type -> . FLOAT64_TYPE
    (78) primitive_type -> . STRING_TYPE
    (79) primitive_type -> . BOOL_TYPE
    (80) slice_type -> . LBRACKET RBRACKET primitive_type
    (81) array_type -> . LBRACKET INT RBRACKET type
    (127) map_type -> . MAP LBRACKET primitive_type RBRACKET type
    (118) struct_type -> . STRUCT LBRACE RBRACE
    (119) struct_type -> . STRUCT LBRACE field_list RBRACE

    ASSIGN          shift and go to state 179
    IDENTIFIER      shift and go to state 177
    INT_TYPE        shift and go to state 171
    FLOAT64_TYPE    shift and go to state 172
    STRING_TYPE     shift and go to state 173
    BOOL_TYPE       shift and go to state 174
    LBRACKET        shift and go to state 175
    MAP             shift and go to state 176
    STRUCT          shift and go to state 170

    type                           shift and go to state 178
    primitive_type                 shift and go to state 180
    slice_type                     shift and go to state 181
    array_type                     shift and go to state 182
    map_type                       shift and go to state 183
    struct_type                    shift and go to state 184

state 100

    (67) variable_declaration -> CONST IDENTIFIER . type ASSIGN expression
    (69) variable_declaration -> CONST IDENTIFIER . ASSIGN expression
    (70) type -> . primitive_type
    (71) type -> . slice_type
    (72) type -> . array_type
    (73) type -> . map_type
    (74) type -> . struct_type
    (75) type -> . IDENTIFIER
    (76) primitive_type -> . INT_TYPE
    (77) primitive_type -> . FLOAT64_TYPE
    (78) primitive_type -> . STRING_TYPE
    (79) primitive_type -> . BOOL_TYPE
    (80) slice_type -> . LBRACKET RBRACKET primitive_type
    (81) array_type -> . LBRACKET INT RBRACKET type
    (127) map_type -> . MAP LBRACKET primitive_type RBRACKET type
    (118) struct_type -> . STRUCT LBRACE RBRACE
    (119) struct_type -> . STRUCT LBRACE field_list RBRACE

    ASSIGN          shift and go to state 186
    IDENTIFIER      shift and go to state 177
    INT_TYPE        shift and go to state 171
    FLOAT64_TYPE    shift and go to state 172
    STRING_TYPE     shift and go to state 173
    BOOL_TYPE       shift and go to state 174
    LBRACKET        shift and go to state 175
    MAP             shift and go to state 176
    STRUCT          shift and go to state 170
>>>>>>> Stashed changes

    type                           shift and go to state 185
    primitive_type                 shift and go to state 180
    slice_type                     shift and go to state 181
    array_type                     shift and go to state 182
    map_type                       shift and go to state 183
    struct_type                    shift and go to state 184

state 101

<<<<<<< Updated upstream
    (54) binary_operator -> LSHIFT .

    LPAREN          reduce using rule 54 (binary_operator -> LSHIFT .)
    INT             reduce using rule 54 (binary_operator -> LSHIFT .)
    FLOAT64         reduce using rule 54 (binary_operator -> LSHIFT .)
    IDENTIFIER      reduce using rule 54 (binary_operator -> LSHIFT .)
    STRING          reduce using rule 54 (binary_operator -> LSHIFT .)
    TRUE            reduce using rule 54 (binary_operator -> LSHIFT .)
    FALSE           reduce using rule 54 (binary_operator -> LSHIFT .)
    LNOT            reduce using rule 54 (binary_operator -> LSHIFT .)
    LBRACKET        reduce using rule 54 (binary_operator -> LSHIFT .)
    MAP             reduce using rule 54 (binary_operator -> LSHIFT .)
=======
    (86) expression -> PLUS expression .
    (100) expression -> expression . DOT IDENTIFIER
    (135) binary_expression -> expression . PLUS expression
    (136) binary_expression -> expression . MINUS expression
    (137) binary_expression -> expression . TIMES expression
    (138) binary_expression -> expression . DIVIDE expression
    (139) binary_expression -> expression . MODULE expression
    (144) relational_expression -> expression . EQ expression
    (145) relational_expression -> expression . NEQ expression
    (146) relational_expression -> expression . LT expression
    (147) relational_expression -> expression . LE expression
    (148) relational_expression -> expression . GT expression
    (149) relational_expression -> expression . GE expression
    (150) logical_expression -> expression . LAND expression
    (151) logical_expression -> expression . LOR expression
    (152) bitwise_expression -> expression . AND expression
    (153) bitwise_expression -> expression . OR expression
    (154) bitwise_expression -> expression . XOR expression
    (155) bitwise_expression -> expression . AND_NOT expression
    (156) bitwise_expression -> expression . LSHIFT expression
    (157) bitwise_expression -> expression . RSHIFT expression

    DOT             reduce using rule 86 (expression -> PLUS expression .)
    AND_NOT         reduce using rule 86 (expression -> PLUS expression .)
    SEMICOLON       reduce using rule 86 (expression -> PLUS expression .)
    FUNC            reduce using rule 86 (expression -> PLUS expression .)
    TYPE            reduce using rule 86 (expression -> PLUS expression .)
    IDENTIFIER      reduce using rule 86 (expression -> PLUS expression .)
    VAR             reduce using rule 86 (expression -> PLUS expression .)
    CONST           reduce using rule 86 (expression -> PLUS expression .)
    LNOT            reduce using rule 86 (expression -> PLUS expression .)
    LBRACKET        reduce using rule 86 (expression -> PLUS expression .)
    LPAREN          reduce using rule 86 (expression -> PLUS expression .)
    INT             reduce using rule 86 (expression -> PLUS expression .)
    FLOAT64         reduce using rule 86 (expression -> PLUS expression .)
    TRUE            reduce using rule 86 (expression -> PLUS expression .)
    FALSE           reduce using rule 86 (expression -> PLUS expression .)
    STRING          reduce using rule 86 (expression -> PLUS expression .)
    RETURN          reduce using rule 86 (expression -> PLUS expression .)
    FOR             reduce using rule 86 (expression -> PLUS expression .)
    IF              reduce using rule 86 (expression -> PLUS expression .)
    SWITCH          reduce using rule 86 (expression -> PLUS expression .)
    BREAK           reduce using rule 86 (expression -> PLUS expression .)
    CONTINUE        reduce using rule 86 (expression -> PLUS expression .)
    FALLTHROUGH     reduce using rule 86 (expression -> PLUS expression .)
    $end            reduce using rule 86 (expression -> PLUS expression .)
    RPAREN          reduce using rule 86 (expression -> PLUS expression .)
    COMMA           reduce using rule 86 (expression -> PLUS expression .)
    RBRACE          reduce using rule 86 (expression -> PLUS expression .)
    CASE            reduce using rule 86 (expression -> PLUS expression .)
    DEFAULT         reduce using rule 86 (expression -> PLUS expression .)
    LBRACE          reduce using rule 86 (expression -> PLUS expression .)
    COLON           reduce using rule 86 (expression -> PLUS expression .)
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    TIMES           shift and go to state 61
    DIVIDE          shift and go to state 62
    MODULE          shift and go to state 63
    EQ              shift and go to state 64
    NEQ             shift and go to state 65
    LT              shift and go to state 66
    LE              shift and go to state 67
    GT              shift and go to state 68
    GE              shift and go to state 69
    LAND            shift and go to state 70
    LOR             shift and go to state 71
    AND             shift and go to state 72
    OR              shift and go to state 73
    XOR             shift and go to state 74
    LSHIFT          shift and go to state 76
    RSHIFT          shift and go to state 77

  ! PLUS            [ reduce using rule 86 (expression -> PLUS expression .) ]
  ! MINUS           [ reduce using rule 86 (expression -> PLUS expression .) ]
  ! TIMES           [ reduce using rule 86 (expression -> PLUS expression .) ]
  ! DIVIDE          [ reduce using rule 86 (expression -> PLUS expression .) ]
  ! MODULE          [ reduce using rule 86 (expression -> PLUS expression .) ]
  ! EQ              [ reduce using rule 86 (expression -> PLUS expression .) ]
  ! NEQ             [ reduce using rule 86 (expression -> PLUS expression .) ]
  ! LT              [ reduce using rule 86 (expression -> PLUS expression .) ]
  ! LE              [ reduce using rule 86 (expression -> PLUS expression .) ]
  ! GT              [ reduce using rule 86 (expression -> PLUS expression .) ]
  ! GE              [ reduce using rule 86 (expression -> PLUS expression .) ]
  ! LAND            [ reduce using rule 86 (expression -> PLUS expression .) ]
  ! LOR             [ reduce using rule 86 (expression -> PLUS expression .) ]
  ! AND             [ reduce using rule 86 (expression -> PLUS expression .) ]
  ! OR              [ reduce using rule 86 (expression -> PLUS expression .) ]
  ! XOR             [ reduce using rule 86 (expression -> PLUS expression .) ]
  ! LSHIFT          [ reduce using rule 86 (expression -> PLUS expression .) ]
  ! RSHIFT          [ reduce using rule 86 (expression -> PLUS expression .) ]
  ! DOT             [ shift and go to state 58 ]
  ! AND_NOT         [ shift and go to state 75 ]
>>>>>>> Stashed changes


state 102

<<<<<<< Updated upstream
    (55) binary_operator -> RSHIFT .

    LPAREN          reduce using rule 55 (binary_operator -> RSHIFT .)
    INT             reduce using rule 55 (binary_operator -> RSHIFT .)
    FLOAT64         reduce using rule 55 (binary_operator -> RSHIFT .)
    IDENTIFIER      reduce using rule 55 (binary_operator -> RSHIFT .)
    STRING          reduce using rule 55 (binary_operator -> RSHIFT .)
    TRUE            reduce using rule 55 (binary_operator -> RSHIFT .)
    FALSE           reduce using rule 55 (binary_operator -> RSHIFT .)
    LNOT            reduce using rule 55 (binary_operator -> RSHIFT .)
    LBRACKET        reduce using rule 55 (binary_operator -> RSHIFT .)
    MAP             reduce using rule 55 (binary_operator -> RSHIFT .)
=======
    (87) expression -> MINUS expression .
    (100) expression -> expression . DOT IDENTIFIER
    (135) binary_expression -> expression . PLUS expression
    (136) binary_expression -> expression . MINUS expression
    (137) binary_expression -> expression . TIMES expression
    (138) binary_expression -> expression . DIVIDE expression
    (139) binary_expression -> expression . MODULE expression
    (144) relational_expression -> expression . EQ expression
    (145) relational_expression -> expression . NEQ expression
    (146) relational_expression -> expression . LT expression
    (147) relational_expression -> expression . LE expression
    (148) relational_expression -> expression . GT expression
    (149) relational_expression -> expression . GE expression
    (150) logical_expression -> expression . LAND expression
    (151) logical_expression -> expression . LOR expression
    (152) bitwise_expression -> expression . AND expression
    (153) bitwise_expression -> expression . OR expression
    (154) bitwise_expression -> expression . XOR expression
    (155) bitwise_expression -> expression . AND_NOT expression
    (156) bitwise_expression -> expression . LSHIFT expression
    (157) bitwise_expression -> expression . RSHIFT expression

    DOT             reduce using rule 87 (expression -> MINUS expression .)
    AND_NOT         reduce using rule 87 (expression -> MINUS expression .)
    SEMICOLON       reduce using rule 87 (expression -> MINUS expression .)
    FUNC            reduce using rule 87 (expression -> MINUS expression .)
    TYPE            reduce using rule 87 (expression -> MINUS expression .)
    IDENTIFIER      reduce using rule 87 (expression -> MINUS expression .)
    VAR             reduce using rule 87 (expression -> MINUS expression .)
    CONST           reduce using rule 87 (expression -> MINUS expression .)
    LNOT            reduce using rule 87 (expression -> MINUS expression .)
    LBRACKET        reduce using rule 87 (expression -> MINUS expression .)
    LPAREN          reduce using rule 87 (expression -> MINUS expression .)
    INT             reduce using rule 87 (expression -> MINUS expression .)
    FLOAT64         reduce using rule 87 (expression -> MINUS expression .)
    TRUE            reduce using rule 87 (expression -> MINUS expression .)
    FALSE           reduce using rule 87 (expression -> MINUS expression .)
    STRING          reduce using rule 87 (expression -> MINUS expression .)
    RETURN          reduce using rule 87 (expression -> MINUS expression .)
    FOR             reduce using rule 87 (expression -> MINUS expression .)
    IF              reduce using rule 87 (expression -> MINUS expression .)
    SWITCH          reduce using rule 87 (expression -> MINUS expression .)
    BREAK           reduce using rule 87 (expression -> MINUS expression .)
    CONTINUE        reduce using rule 87 (expression -> MINUS expression .)
    FALLTHROUGH     reduce using rule 87 (expression -> MINUS expression .)
    $end            reduce using rule 87 (expression -> MINUS expression .)
    RPAREN          reduce using rule 87 (expression -> MINUS expression .)
    COMMA           reduce using rule 87 (expression -> MINUS expression .)
    RBRACE          reduce using rule 87 (expression -> MINUS expression .)
    CASE            reduce using rule 87 (expression -> MINUS expression .)
    DEFAULT         reduce using rule 87 (expression -> MINUS expression .)
    LBRACE          reduce using rule 87 (expression -> MINUS expression .)
    COLON           reduce using rule 87 (expression -> MINUS expression .)
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    TIMES           shift and go to state 61
    DIVIDE          shift and go to state 62
    MODULE          shift and go to state 63
    EQ              shift and go to state 64
    NEQ             shift and go to state 65
    LT              shift and go to state 66
    LE              shift and go to state 67
    GT              shift and go to state 68
    GE              shift and go to state 69
    LAND            shift and go to state 70
    LOR             shift and go to state 71
    AND             shift and go to state 72
    OR              shift and go to state 73
    XOR             shift and go to state 74
    LSHIFT          shift and go to state 76
    RSHIFT          shift and go to state 77

  ! PLUS            [ reduce using rule 87 (expression -> MINUS expression .) ]
  ! MINUS           [ reduce using rule 87 (expression -> MINUS expression .) ]
  ! TIMES           [ reduce using rule 87 (expression -> MINUS expression .) ]
  ! DIVIDE          [ reduce using rule 87 (expression -> MINUS expression .) ]
  ! MODULE          [ reduce using rule 87 (expression -> MINUS expression .) ]
  ! EQ              [ reduce using rule 87 (expression -> MINUS expression .) ]
  ! NEQ             [ reduce using rule 87 (expression -> MINUS expression .) ]
  ! LT              [ reduce using rule 87 (expression -> MINUS expression .) ]
  ! LE              [ reduce using rule 87 (expression -> MINUS expression .) ]
  ! GT              [ reduce using rule 87 (expression -> MINUS expression .) ]
  ! GE              [ reduce using rule 87 (expression -> MINUS expression .) ]
  ! LAND            [ reduce using rule 87 (expression -> MINUS expression .) ]
  ! LOR             [ reduce using rule 87 (expression -> MINUS expression .) ]
  ! AND             [ reduce using rule 87 (expression -> MINUS expression .) ]
  ! OR              [ reduce using rule 87 (expression -> MINUS expression .) ]
  ! XOR             [ reduce using rule 87 (expression -> MINUS expression .) ]
  ! LSHIFT          [ reduce using rule 87 (expression -> MINUS expression .) ]
  ! RSHIFT          [ reduce using rule 87 (expression -> MINUS expression .) ]
  ! DOT             [ shift and go to state 58 ]
  ! AND_NOT         [ shift and go to state 75 ]
>>>>>>> Stashed changes


state 103

<<<<<<< Updated upstream
    (66) expression -> slice_type LBRACE . expression_list RBRACE
    (67) expression -> slice_type LBRACE . RBRACE
    (68) expression_list -> . expression
    (69) expression_list -> . expression_list COMMA expression
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (125) expression -> . LNOT expression
    (126) expression -> . IDENTIFIER PLUSPLUS
    (127) expression -> . IDENTIFIER MINUSMINUS
    (138) expression -> . map_type LBRACE expression_map_list RBRACE
    (139) expression -> . map_type LBRACE RBRACE
    (161) expression -> . type_name LBRACE keyed_element_list RBRACE
    (162) expression -> . type_name LBRACE RBRACE
    (198) expression -> . array_type LBRACE expression_list RBRACE
    (199) expression -> . array_type LBRACE RBRACE
    (200) expression -> . expression DOT IDENTIFIER
    (201) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> . expression LBRACKET expression RBRACKET
    (203) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (137) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (163) type_name -> . IDENTIFIER
    (164) type_name -> . slice_type
    (165) type_name -> . array_type
    (166) type_name -> . map_type
    (197) array_type -> . LBRACKET INT RBRACKET primitive_type

    RBRACE          shift and go to state 132
    LPAREN          shift and go to state 54
    INT             shift and go to state 55
    FLOAT64         shift and go to state 56
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 57
    TRUE            shift and go to state 58
    FALSE           shift and go to state 59
    LNOT            shift and go to state 60
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39
=======
    (88) expression -> LNOT expression .
    (100) expression -> expression . DOT IDENTIFIER
    (135) binary_expression -> expression . PLUS expression
    (136) binary_expression -> expression . MINUS expression
    (137) binary_expression -> expression . TIMES expression
    (138) binary_expression -> expression . DIVIDE expression
    (139) binary_expression -> expression . MODULE expression
    (144) relational_expression -> expression . EQ expression
    (145) relational_expression -> expression . NEQ expression
    (146) relational_expression -> expression . LT expression
    (147) relational_expression -> expression . LE expression
    (148) relational_expression -> expression . GT expression
    (149) relational_expression -> expression . GE expression
    (150) logical_expression -> expression . LAND expression
    (151) logical_expression -> expression . LOR expression
    (152) bitwise_expression -> expression . AND expression
    (153) bitwise_expression -> expression . OR expression
    (154) bitwise_expression -> expression . XOR expression
    (155) bitwise_expression -> expression . AND_NOT expression
    (156) bitwise_expression -> expression . LSHIFT expression
    (157) bitwise_expression -> expression . RSHIFT expression

    DOT             reduce using rule 88 (expression -> LNOT expression .)
    AND_NOT         reduce using rule 88 (expression -> LNOT expression .)
    SEMICOLON       reduce using rule 88 (expression -> LNOT expression .)
    FUNC            reduce using rule 88 (expression -> LNOT expression .)
    TYPE            reduce using rule 88 (expression -> LNOT expression .)
    IDENTIFIER      reduce using rule 88 (expression -> LNOT expression .)
    VAR             reduce using rule 88 (expression -> LNOT expression .)
    CONST           reduce using rule 88 (expression -> LNOT expression .)
    LNOT            reduce using rule 88 (expression -> LNOT expression .)
    LBRACKET        reduce using rule 88 (expression -> LNOT expression .)
    LPAREN          reduce using rule 88 (expression -> LNOT expression .)
    INT             reduce using rule 88 (expression -> LNOT expression .)
    FLOAT64         reduce using rule 88 (expression -> LNOT expression .)
    TRUE            reduce using rule 88 (expression -> LNOT expression .)
    FALSE           reduce using rule 88 (expression -> LNOT expression .)
    STRING          reduce using rule 88 (expression -> LNOT expression .)
    RETURN          reduce using rule 88 (expression -> LNOT expression .)
    FOR             reduce using rule 88 (expression -> LNOT expression .)
    IF              reduce using rule 88 (expression -> LNOT expression .)
    SWITCH          reduce using rule 88 (expression -> LNOT expression .)
    BREAK           reduce using rule 88 (expression -> LNOT expression .)
    CONTINUE        reduce using rule 88 (expression -> LNOT expression .)
    FALLTHROUGH     reduce using rule 88 (expression -> LNOT expression .)
    $end            reduce using rule 88 (expression -> LNOT expression .)
    RPAREN          reduce using rule 88 (expression -> LNOT expression .)
    COMMA           reduce using rule 88 (expression -> LNOT expression .)
    RBRACE          reduce using rule 88 (expression -> LNOT expression .)
    CASE            reduce using rule 88 (expression -> LNOT expression .)
    DEFAULT         reduce using rule 88 (expression -> LNOT expression .)
    LBRACE          reduce using rule 88 (expression -> LNOT expression .)
    COLON           reduce using rule 88 (expression -> LNOT expression .)
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    TIMES           shift and go to state 61
    DIVIDE          shift and go to state 62
    MODULE          shift and go to state 63
    EQ              shift and go to state 64
    NEQ             shift and go to state 65
    LT              shift and go to state 66
    LE              shift and go to state 67
    GT              shift and go to state 68
    GE              shift and go to state 69
    LAND            shift and go to state 70
    LOR             shift and go to state 71
    AND             shift and go to state 72
    OR              shift and go to state 73
    XOR             shift and go to state 74
    LSHIFT          shift and go to state 76
    RSHIFT          shift and go to state 77

  ! PLUS            [ reduce using rule 88 (expression -> LNOT expression .) ]
  ! MINUS           [ reduce using rule 88 (expression -> LNOT expression .) ]
  ! TIMES           [ reduce using rule 88 (expression -> LNOT expression .) ]
  ! DIVIDE          [ reduce using rule 88 (expression -> LNOT expression .) ]
  ! MODULE          [ reduce using rule 88 (expression -> LNOT expression .) ]
  ! EQ              [ reduce using rule 88 (expression -> LNOT expression .) ]
  ! NEQ             [ reduce using rule 88 (expression -> LNOT expression .) ]
  ! LT              [ reduce using rule 88 (expression -> LNOT expression .) ]
  ! LE              [ reduce using rule 88 (expression -> LNOT expression .) ]
  ! GT              [ reduce using rule 88 (expression -> LNOT expression .) ]
  ! GE              [ reduce using rule 88 (expression -> LNOT expression .) ]
  ! LAND            [ reduce using rule 88 (expression -> LNOT expression .) ]
  ! LOR             [ reduce using rule 88 (expression -> LNOT expression .) ]
  ! AND             [ reduce using rule 88 (expression -> LNOT expression .) ]
  ! OR              [ reduce using rule 88 (expression -> LNOT expression .) ]
  ! XOR             [ reduce using rule 88 (expression -> LNOT expression .) ]
  ! LSHIFT          [ reduce using rule 88 (expression -> LNOT expression .) ]
  ! RSHIFT          [ reduce using rule 88 (expression -> LNOT expression .) ]
  ! DOT             [ shift and go to state 58 ]
  ! AND_NOT         [ shift and go to state 75 ]
>>>>>>> Stashed changes

    slice_type                     shift and go to state 53
    expression_list                shift and go to state 131
    expression                     shift and go to state 127
    map_type                       shift and go to state 61
    type_name                      shift and go to state 62
    array_type                     shift and go to state 63

state 104

<<<<<<< Updated upstream
    (70) expression -> LPAREN expression . RPAREN
    (36) expression -> expression . binary_operator expression
    (200) expression -> expression . DOT IDENTIFIER
    (201) expression -> expression . DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> expression . LBRACKET expression RBRACKET
    (37) binary_operator -> . PLUS
    (38) binary_operator -> . MINUS
    (39) binary_operator -> . TIMES
    (40) binary_operator -> . DIVIDE
    (41) binary_operator -> . MODULE
    (42) binary_operator -> . EQ
    (43) binary_operator -> . NEQ
    (44) binary_operator -> . LT
    (45) binary_operator -> . LE
    (46) binary_operator -> . GT
    (47) binary_operator -> . GE
    (48) binary_operator -> . LAND
    (49) binary_operator -> . LOR
    (50) binary_operator -> . AND
    (51) binary_operator -> . OR
    (52) binary_operator -> . XOR
    (53) binary_operator -> . AND_NOT
    (54) binary_operator -> . LSHIFT
    (55) binary_operator -> . RSHIFT

    RPAREN          shift and go to state 133
    DOT             shift and go to state 82
    LBRACKET        shift and go to state 83
    PLUS            shift and go to state 84
    MINUS           shift and go to state 85
    TIMES           shift and go to state 86
    DIVIDE          shift and go to state 87
    MODULE          shift and go to state 88
    EQ              shift and go to state 89
    NEQ             shift and go to state 90
    LT              shift and go to state 91
    LE              shift and go to state 92
    GT              shift and go to state 93
    GE              shift and go to state 94
    LAND            shift and go to state 95
    LOR             shift and go to state 96
    AND             shift and go to state 97
    OR              shift and go to state 98
    XOR             shift and go to state 99
    AND_NOT         shift and go to state 100
    LSHIFT          shift and go to state 101
    RSHIFT          shift and go to state 102

    binary_operator                shift and go to state 81

state 105

    (125) expression -> LNOT expression .
    (36) expression -> expression . binary_operator expression
    (200) expression -> expression . DOT IDENTIFIER
    (201) expression -> expression . DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> expression . LBRACKET expression RBRACKET
    (37) binary_operator -> . PLUS
    (38) binary_operator -> . MINUS
    (39) binary_operator -> . TIMES
    (40) binary_operator -> . DIVIDE
    (41) binary_operator -> . MODULE
    (42) binary_operator -> . EQ
    (43) binary_operator -> . NEQ
    (44) binary_operator -> . LT
    (45) binary_operator -> . LE
    (46) binary_operator -> . GT
    (47) binary_operator -> . GE
    (48) binary_operator -> . LAND
    (49) binary_operator -> . LOR
    (50) binary_operator -> . AND
    (51) binary_operator -> . OR
    (52) binary_operator -> . XOR
    (53) binary_operator -> . AND_NOT
    (54) binary_operator -> . LSHIFT
    (55) binary_operator -> . RSHIFT

  ! shift/reduce conflict for DOT resolved as shift
  ! shift/reduce conflict for LBRACKET resolved as shift
=======
    (89) expression -> LBRACKET RBRACKET . primitive_type LBRACE expression_list RBRACE
    (90) expression -> LBRACKET RBRACKET . primitive_type LBRACE RBRACE
    (76) primitive_type -> . INT_TYPE
    (77) primitive_type -> . FLOAT64_TYPE
    (78) primitive_type -> . STRING_TYPE
    (79) primitive_type -> . BOOL_TYPE

    INT_TYPE        shift and go to state 171
    FLOAT64_TYPE    shift and go to state 172
    STRING_TYPE     shift and go to state 173
    BOOL_TYPE       shift and go to state 174

    primitive_type                 shift and go to state 187

state 105

    (40) return_statement -> RETURN return_list .
    (42) return_list -> return_list . COMMA expression

    SEMICOLON       reduce using rule 40 (return_statement -> RETURN return_list .)
    FUNC            reduce using rule 40 (return_statement -> RETURN return_list .)
    TYPE            reduce using rule 40 (return_statement -> RETURN return_list .)
    IDENTIFIER      reduce using rule 40 (return_statement -> RETURN return_list .)
    VAR             reduce using rule 40 (return_statement -> RETURN return_list .)
    CONST           reduce using rule 40 (return_statement -> RETURN return_list .)
    PLUS            reduce using rule 40 (return_statement -> RETURN return_list .)
    MINUS           reduce using rule 40 (return_statement -> RETURN return_list .)
    LNOT            reduce using rule 40 (return_statement -> RETURN return_list .)
    LBRACKET        reduce using rule 40 (return_statement -> RETURN return_list .)
    LPAREN          reduce using rule 40 (return_statement -> RETURN return_list .)
    INT             reduce using rule 40 (return_statement -> RETURN return_list .)
    FLOAT64         reduce using rule 40 (return_statement -> RETURN return_list .)
    TRUE            reduce using rule 40 (return_statement -> RETURN return_list .)
    FALSE           reduce using rule 40 (return_statement -> RETURN return_list .)
    STRING          reduce using rule 40 (return_statement -> RETURN return_list .)
    RETURN          reduce using rule 40 (return_statement -> RETURN return_list .)
    FOR             reduce using rule 40 (return_statement -> RETURN return_list .)
    IF              reduce using rule 40 (return_statement -> RETURN return_list .)
    SWITCH          reduce using rule 40 (return_statement -> RETURN return_list .)
    BREAK           reduce using rule 40 (return_statement -> RETURN return_list .)
    CONTINUE        reduce using rule 40 (return_statement -> RETURN return_list .)
    FALLTHROUGH     reduce using rule 40 (return_statement -> RETURN return_list .)
    $end            reduce using rule 40 (return_statement -> RETURN return_list .)
    RBRACE          reduce using rule 40 (return_statement -> RETURN return_list .)
    CASE            reduce using rule 40 (return_statement -> RETURN return_list .)
    DEFAULT         reduce using rule 40 (return_statement -> RETURN return_list .)
    COMMA           shift and go to state 188


state 106

    (41) return_list -> expression .
    (100) expression -> expression . DOT IDENTIFIER
    (135) binary_expression -> expression . PLUS expression
    (136) binary_expression -> expression . MINUS expression
    (137) binary_expression -> expression . TIMES expression
    (138) binary_expression -> expression . DIVIDE expression
    (139) binary_expression -> expression . MODULE expression
    (144) relational_expression -> expression . EQ expression
    (145) relational_expression -> expression . NEQ expression
    (146) relational_expression -> expression . LT expression
    (147) relational_expression -> expression . LE expression
    (148) relational_expression -> expression . GT expression
    (149) relational_expression -> expression . GE expression
    (150) logical_expression -> expression . LAND expression
    (151) logical_expression -> expression . LOR expression
    (152) bitwise_expression -> expression . AND expression
    (153) bitwise_expression -> expression . OR expression
    (154) bitwise_expression -> expression . XOR expression
    (155) bitwise_expression -> expression . AND_NOT expression
    (156) bitwise_expression -> expression . LSHIFT expression
    (157) bitwise_expression -> expression . RSHIFT expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    COMMA           reduce using rule 41 (return_list -> expression .)
    SEMICOLON       reduce using rule 41 (return_list -> expression .)
    FUNC            reduce using rule 41 (return_list -> expression .)
    TYPE            reduce using rule 41 (return_list -> expression .)
    IDENTIFIER      reduce using rule 41 (return_list -> expression .)
    VAR             reduce using rule 41 (return_list -> expression .)
    CONST           reduce using rule 41 (return_list -> expression .)
    LNOT            reduce using rule 41 (return_list -> expression .)
    LBRACKET        reduce using rule 41 (return_list -> expression .)
    LPAREN          reduce using rule 41 (return_list -> expression .)
    INT             reduce using rule 41 (return_list -> expression .)
    FLOAT64         reduce using rule 41 (return_list -> expression .)
    TRUE            reduce using rule 41 (return_list -> expression .)
    FALSE           reduce using rule 41 (return_list -> expression .)
    STRING          reduce using rule 41 (return_list -> expression .)
    RETURN          reduce using rule 41 (return_list -> expression .)
    FOR             reduce using rule 41 (return_list -> expression .)
    IF              reduce using rule 41 (return_list -> expression .)
    SWITCH          reduce using rule 41 (return_list -> expression .)
    BREAK           reduce using rule 41 (return_list -> expression .)
    CONTINUE        reduce using rule 41 (return_list -> expression .)
    FALLTHROUGH     reduce using rule 41 (return_list -> expression .)
    $end            reduce using rule 41 (return_list -> expression .)
    RBRACE          reduce using rule 41 (return_list -> expression .)
    CASE            reduce using rule 41 (return_list -> expression .)
    DEFAULT         reduce using rule 41 (return_list -> expression .)
    DOT             shift and go to state 58
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    TIMES           shift and go to state 61
    DIVIDE          shift and go to state 62
    MODULE          shift and go to state 63
    EQ              shift and go to state 64
    NEQ             shift and go to state 65
    LT              shift and go to state 66
    LE              shift and go to state 67
    GT              shift and go to state 68
    GE              shift and go to state 69
    LAND            shift and go to state 70
    LOR             shift and go to state 71
    AND             shift and go to state 72
    OR              shift and go to state 73
    XOR             shift and go to state 74
    AND_NOT         shift and go to state 75
    LSHIFT          shift and go to state 76
    RSHIFT          shift and go to state 77

  ! PLUS            [ reduce using rule 41 (return_list -> expression .) ]
  ! MINUS           [ reduce using rule 41 (return_list -> expression .) ]


state 107

    (33) for_statement -> FOR expression . block
    (100) expression -> expression . DOT IDENTIFIER
    (135) binary_expression -> expression . PLUS expression
    (136) binary_expression -> expression . MINUS expression
    (137) binary_expression -> expression . TIMES expression
    (138) binary_expression -> expression . DIVIDE expression
    (139) binary_expression -> expression . MODULE expression
    (144) relational_expression -> expression . EQ expression
    (145) relational_expression -> expression . NEQ expression
    (146) relational_expression -> expression . LT expression
    (147) relational_expression -> expression . LE expression
    (148) relational_expression -> expression . GT expression
    (149) relational_expression -> expression . GE expression
    (150) logical_expression -> expression . LAND expression
    (151) logical_expression -> expression . LOR expression
    (152) bitwise_expression -> expression . AND expression
    (153) bitwise_expression -> expression . OR expression
    (154) bitwise_expression -> expression . XOR expression
    (155) bitwise_expression -> expression . AND_NOT expression
    (156) bitwise_expression -> expression . LSHIFT expression
    (157) bitwise_expression -> expression . RSHIFT expression
    (16) block -> . LBRACE enter_block exit_block RBRACE
    (17) block -> . LBRACE enter_block statement_list exit_block RBRACE

    DOT             shift and go to state 58
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    TIMES           shift and go to state 61
    DIVIDE          shift and go to state 62
    MODULE          shift and go to state 63
    EQ              shift and go to state 64
    NEQ             shift and go to state 65
    LT              shift and go to state 66
    LE              shift and go to state 67
    GT              shift and go to state 68
    GE              shift and go to state 69
    LAND            shift and go to state 70
    LOR             shift and go to state 71
    AND             shift and go to state 72
    OR              shift and go to state 73
    XOR             shift and go to state 74
    AND_NOT         shift and go to state 75
    LSHIFT          shift and go to state 76
    RSHIFT          shift and go to state 77
    LBRACE          shift and go to state 110

    block                          shift and go to state 189

state 108

    (34) for_statement -> FOR block .

    SEMICOLON       reduce using rule 34 (for_statement -> FOR block .)
    FUNC            reduce using rule 34 (for_statement -> FOR block .)
    TYPE            reduce using rule 34 (for_statement -> FOR block .)
    IDENTIFIER      reduce using rule 34 (for_statement -> FOR block .)
    VAR             reduce using rule 34 (for_statement -> FOR block .)
    CONST           reduce using rule 34 (for_statement -> FOR block .)
    PLUS            reduce using rule 34 (for_statement -> FOR block .)
    MINUS           reduce using rule 34 (for_statement -> FOR block .)
    LNOT            reduce using rule 34 (for_statement -> FOR block .)
    LBRACKET        reduce using rule 34 (for_statement -> FOR block .)
    LPAREN          reduce using rule 34 (for_statement -> FOR block .)
    INT             reduce using rule 34 (for_statement -> FOR block .)
    FLOAT64         reduce using rule 34 (for_statement -> FOR block .)
    TRUE            reduce using rule 34 (for_statement -> FOR block .)
    FALSE           reduce using rule 34 (for_statement -> FOR block .)
    STRING          reduce using rule 34 (for_statement -> FOR block .)
    RETURN          reduce using rule 34 (for_statement -> FOR block .)
    FOR             reduce using rule 34 (for_statement -> FOR block .)
    IF              reduce using rule 34 (for_statement -> FOR block .)
    SWITCH          reduce using rule 34 (for_statement -> FOR block .)
    BREAK           reduce using rule 34 (for_statement -> FOR block .)
    CONTINUE        reduce using rule 34 (for_statement -> FOR block .)
    FALLTHROUGH     reduce using rule 34 (for_statement -> FOR block .)
    $end            reduce using rule 34 (for_statement -> FOR block .)
    RBRACE          reduce using rule 34 (for_statement -> FOR block .)
    CASE            reduce using rule 34 (for_statement -> FOR block .)
    DEFAULT         reduce using rule 34 (for_statement -> FOR block .)


state 109

    (35) for_statement -> FOR for_clause . block
    (16) block -> . LBRACE enter_block exit_block RBRACE
    (17) block -> . LBRACE enter_block statement_list exit_block RBRACE

    LBRACE          shift and go to state 110

    block                          shift and go to state 190

state 110

    (16) block -> LBRACE . enter_block exit_block RBRACE
    (17) block -> LBRACE . enter_block statement_list exit_block RBRACE
    (167) enter_block -> .

    IDENTIFIER      reduce using rule 167 (enter_block -> .)
    VAR             reduce using rule 167 (enter_block -> .)
    CONST           reduce using rule 167 (enter_block -> .)
    PLUS            reduce using rule 167 (enter_block -> .)
    MINUS           reduce using rule 167 (enter_block -> .)
    LNOT            reduce using rule 167 (enter_block -> .)
    LBRACKET        reduce using rule 167 (enter_block -> .)
    LPAREN          reduce using rule 167 (enter_block -> .)
    INT             reduce using rule 167 (enter_block -> .)
    FLOAT64         reduce using rule 167 (enter_block -> .)
    TRUE            reduce using rule 167 (enter_block -> .)
    FALSE           reduce using rule 167 (enter_block -> .)
    STRING          reduce using rule 167 (enter_block -> .)
    RETURN          reduce using rule 167 (enter_block -> .)
    FOR             reduce using rule 167 (enter_block -> .)
    IF              reduce using rule 167 (enter_block -> .)
    SWITCH          reduce using rule 167 (enter_block -> .)
    BREAK           reduce using rule 167 (enter_block -> .)
    CONTINUE        reduce using rule 167 (enter_block -> .)
    FALLTHROUGH     reduce using rule 167 (enter_block -> .)
    RBRACE          reduce using rule 167 (enter_block -> .)

    enter_block                    shift and go to state 191

state 111

    (96) expression -> IDENTIFIER .
    (98) expression -> IDENTIFIER . PLUSPLUS
    (99) expression -> IDENTIFIER . MINUSMINUS
    (103) expression -> IDENTIFIER . LPAREN argument_list RPAREN
    (133) expression -> IDENTIFIER . LBRACE keyed_element_list RBRACE
    (134) expression -> IDENTIFIER . LBRACE RBRACE
    (54) assignment -> IDENTIFIER . ASSIGN expression
    (55) assignment -> IDENTIFIER . SHORT_ASSIGN expression

  ! shift/reduce conflict for LBRACE resolved as shift
    DOT             reduce using rule 96 (expression -> IDENTIFIER .)
    PLUS            reduce using rule 96 (expression -> IDENTIFIER .)
    MINUS           reduce using rule 96 (expression -> IDENTIFIER .)
    TIMES           reduce using rule 96 (expression -> IDENTIFIER .)
    DIVIDE          reduce using rule 96 (expression -> IDENTIFIER .)
    MODULE          reduce using rule 96 (expression -> IDENTIFIER .)
    EQ              reduce using rule 96 (expression -> IDENTIFIER .)
    NEQ             reduce using rule 96 (expression -> IDENTIFIER .)
    LT              reduce using rule 96 (expression -> IDENTIFIER .)
    LE              reduce using rule 96 (expression -> IDENTIFIER .)
    GT              reduce using rule 96 (expression -> IDENTIFIER .)
    GE              reduce using rule 96 (expression -> IDENTIFIER .)
    LAND            reduce using rule 96 (expression -> IDENTIFIER .)
    LOR             reduce using rule 96 (expression -> IDENTIFIER .)
    AND             reduce using rule 96 (expression -> IDENTIFIER .)
    OR              reduce using rule 96 (expression -> IDENTIFIER .)
    XOR             reduce using rule 96 (expression -> IDENTIFIER .)
    AND_NOT         reduce using rule 96 (expression -> IDENTIFIER .)
    LSHIFT          reduce using rule 96 (expression -> IDENTIFIER .)
    RSHIFT          reduce using rule 96 (expression -> IDENTIFIER .)
    PLUSPLUS        shift and go to state 92
    MINUSMINUS      shift and go to state 93
    LPAREN          shift and go to state 94
    LBRACE          shift and go to state 95
    ASSIGN          shift and go to state 80
    SHORT_ASSIGN    shift and go to state 81

  ! LBRACE          [ reduce using rule 96 (expression -> IDENTIFIER .) ]


state 112

    (36) for_clause -> assignment . SEMICOLON expression SEMICOLON assignment

    SEMICOLON       shift and go to state 192


state 113

    (37) for_clause -> SEMICOLON . expression SEMICOLON assignment
    (38) for_clause -> SEMICOLON . expression SEMICOLON
    (82) expression -> . binary_expression
    (83) expression -> . relational_expression
    (84) expression -> . logical_expression
    (85) expression -> . bitwise_expression
    (86) expression -> . PLUS expression
    (87) expression -> . MINUS expression
    (88) expression -> . LNOT expression
    (89) expression -> . LBRACKET RBRACKET primitive_type LBRACE expression_list RBRACE
    (90) expression -> . LBRACKET RBRACKET primitive_type LBRACE RBRACE
    (91) expression -> . LPAREN expression RPAREN
    (92) expression -> . INT
    (93) expression -> . FLOAT64
    (94) expression -> . TRUE
    (95) expression -> . FALSE
    (96) expression -> . IDENTIFIER
    (97) expression -> . STRING
    (98) expression -> . IDENTIFIER PLUSPLUS
    (99) expression -> . IDENTIFIER MINUSMINUS
    (100) expression -> . expression DOT IDENTIFIER
    (103) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (133) expression -> . IDENTIFIER LBRACE keyed_element_list RBRACE
    (134) expression -> . IDENTIFIER LBRACE RBRACE
    (135) binary_expression -> . expression PLUS expression
    (136) binary_expression -> . expression MINUS expression
    (137) binary_expression -> . expression TIMES expression
    (138) binary_expression -> . expression DIVIDE expression
    (139) binary_expression -> . expression MODULE expression
    (144) relational_expression -> . expression EQ expression
    (145) relational_expression -> . expression NEQ expression
    (146) relational_expression -> . expression LT expression
    (147) relational_expression -> . expression LE expression
    (148) relational_expression -> . expression GT expression
    (149) relational_expression -> . expression GE expression
    (150) logical_expression -> . expression LAND expression
    (151) logical_expression -> . expression LOR expression
    (152) bitwise_expression -> . expression AND expression
    (153) bitwise_expression -> . expression OR expression
    (154) bitwise_expression -> . expression XOR expression
    (155) bitwise_expression -> . expression AND_NOT expression
    (156) bitwise_expression -> . expression LSHIFT expression
    (157) bitwise_expression -> . expression RSHIFT expression

    PLUS            shift and go to state 37
    MINUS           shift and go to state 38
    LNOT            shift and go to state 39
    LBRACKET        shift and go to state 40
    LPAREN          shift and go to state 29
    INT             shift and go to state 41
    FLOAT64         shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44
    IDENTIFIER      shift and go to state 97
    STRING          shift and go to state 11

    expression                     shift and go to state 193
    binary_expression              shift and go to state 33
    relational_expression          shift and go to state 34
    logical_expression             shift and go to state 35
    bitwise_expression             shift and go to state 36

state 114

    (106) if_statement -> IF expression . block
    (107) if_statement -> IF expression . block ELSE block
    (108) if_statement -> IF expression . block ELSE if_statement
    (100) expression -> expression . DOT IDENTIFIER
    (135) binary_expression -> expression . PLUS expression
    (136) binary_expression -> expression . MINUS expression
    (137) binary_expression -> expression . TIMES expression
    (138) binary_expression -> expression . DIVIDE expression
    (139) binary_expression -> expression . MODULE expression
    (144) relational_expression -> expression . EQ expression
    (145) relational_expression -> expression . NEQ expression
    (146) relational_expression -> expression . LT expression
    (147) relational_expression -> expression . LE expression
    (148) relational_expression -> expression . GT expression
    (149) relational_expression -> expression . GE expression
    (150) logical_expression -> expression . LAND expression
    (151) logical_expression -> expression . LOR expression
    (152) bitwise_expression -> expression . AND expression
    (153) bitwise_expression -> expression . OR expression
    (154) bitwise_expression -> expression . XOR expression
    (155) bitwise_expression -> expression . AND_NOT expression
    (156) bitwise_expression -> expression . LSHIFT expression
    (157) bitwise_expression -> expression . RSHIFT expression
    (16) block -> . LBRACE enter_block exit_block RBRACE
    (17) block -> . LBRACE enter_block statement_list exit_block RBRACE

    DOT             shift and go to state 58
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    TIMES           shift and go to state 61
    DIVIDE          shift and go to state 62
    MODULE          shift and go to state 63
    EQ              shift and go to state 64
    NEQ             shift and go to state 65
    LT              shift and go to state 66
    LE              shift and go to state 67
    GT              shift and go to state 68
    GE              shift and go to state 69
    LAND            shift and go to state 70
    LOR             shift and go to state 71
    AND             shift and go to state 72
    OR              shift and go to state 73
    XOR             shift and go to state 74
    AND_NOT         shift and go to state 75
    LSHIFT          shift and go to state 76
    RSHIFT          shift and go to state 77
    LBRACE          shift and go to state 110

    block                          shift and go to state 194

state 115

    (109) if_statement -> IF assignment . SEMICOLON expression block
    (110) if_statement -> IF assignment . SEMICOLON expression block ELSE block
    (111) if_statement -> IF assignment . SEMICOLON expression block ELSE if_statement

    SEMICOLON       shift and go to state 195


state 116

    (189) switch_statement -> SWITCH enter_block . switch_header LBRACE case_clauses RBRACE exit_block
    (187) switch_header -> . switch_expression
    (188) switch_header -> . switch_init
    (185) switch_expression -> . switch_primary
    (186) switch_expression -> . empty
    (184) switch_init -> . assignment SEMICOLON switch_expression
    (178) switch_primary -> . IDENTIFIER
    (179) switch_primary -> . INT
    (180) switch_primary -> . FLOAT64
    (181) switch_primary -> . STRING
    (182) switch_primary -> . TRUE
    (183) switch_primary -> . FALSE
    (7) empty -> .
    (54) assignment -> . IDENTIFIER ASSIGN expression
    (55) assignment -> . IDENTIFIER SHORT_ASSIGN expression

    IDENTIFIER      shift and go to state 202
    INT             shift and go to state 203
    FLOAT64         shift and go to state 204
    STRING          shift and go to state 205
    TRUE            shift and go to state 206
    FALSE           shift and go to state 207
    LBRACE          reduce using rule 7 (empty -> .)

    switch_header                  shift and go to state 196
    switch_expression              shift and go to state 197
    switch_init                    shift and go to state 198
    switch_primary                 shift and go to state 199
    empty                          shift and go to state 200
    assignment                     shift and go to state 201

state 117

    (6) simple_import -> IMPORT STRING optional_semicolon .

    IMPORT          reduce using rule 6 (simple_import -> IMPORT STRING optional_semicolon .)
    FUNC            reduce using rule 6 (simple_import -> IMPORT STRING optional_semicolon .)
    TYPE            reduce using rule 6 (simple_import -> IMPORT STRING optional_semicolon .)
    IDENTIFIER      reduce using rule 6 (simple_import -> IMPORT STRING optional_semicolon .)
    VAR             reduce using rule 6 (simple_import -> IMPORT STRING optional_semicolon .)
    CONST           reduce using rule 6 (simple_import -> IMPORT STRING optional_semicolon .)
    PLUS            reduce using rule 6 (simple_import -> IMPORT STRING optional_semicolon .)
    MINUS           reduce using rule 6 (simple_import -> IMPORT STRING optional_semicolon .)
    LNOT            reduce using rule 6 (simple_import -> IMPORT STRING optional_semicolon .)
    LBRACKET        reduce using rule 6 (simple_import -> IMPORT STRING optional_semicolon .)
    LPAREN          reduce using rule 6 (simple_import -> IMPORT STRING optional_semicolon .)
    INT             reduce using rule 6 (simple_import -> IMPORT STRING optional_semicolon .)
    FLOAT64         reduce using rule 6 (simple_import -> IMPORT STRING optional_semicolon .)
    TRUE            reduce using rule 6 (simple_import -> IMPORT STRING optional_semicolon .)
    FALSE           reduce using rule 6 (simple_import -> IMPORT STRING optional_semicolon .)
    STRING          reduce using rule 6 (simple_import -> IMPORT STRING optional_semicolon .)
    RETURN          reduce using rule 6 (simple_import -> IMPORT STRING optional_semicolon .)
    FOR             reduce using rule 6 (simple_import -> IMPORT STRING optional_semicolon .)
    IF              reduce using rule 6 (simple_import -> IMPORT STRING optional_semicolon .)
    SWITCH          reduce using rule 6 (simple_import -> IMPORT STRING optional_semicolon .)
    BREAK           reduce using rule 6 (simple_import -> IMPORT STRING optional_semicolon .)
    CONTINUE        reduce using rule 6 (simple_import -> IMPORT STRING optional_semicolon .)
    FALLTHROUGH     reduce using rule 6 (simple_import -> IMPORT STRING optional_semicolon .)
    $end            reduce using rule 6 (simple_import -> IMPORT STRING optional_semicolon .)


state 118

    (100) expression -> expression DOT IDENTIFIER .

    DOT             reduce using rule 100 (expression -> expression DOT IDENTIFIER .)
    PLUS            reduce using rule 100 (expression -> expression DOT IDENTIFIER .)
    MINUS           reduce using rule 100 (expression -> expression DOT IDENTIFIER .)
    TIMES           reduce using rule 100 (expression -> expression DOT IDENTIFIER .)
    DIVIDE          reduce using rule 100 (expression -> expression DOT IDENTIFIER .)
    MODULE          reduce using rule 100 (expression -> expression DOT IDENTIFIER .)
    EQ              reduce using rule 100 (expression -> expression DOT IDENTIFIER .)
    NEQ             reduce using rule 100 (expression -> expression DOT IDENTIFIER .)
    LT              reduce using rule 100 (expression -> expression DOT IDENTIFIER .)
    LE              reduce using rule 100 (expression -> expression DOT IDENTIFIER .)
    GT              reduce using rule 100 (expression -> expression DOT IDENTIFIER .)
    GE              reduce using rule 100 (expression -> expression DOT IDENTIFIER .)
    LAND            reduce using rule 100 (expression -> expression DOT IDENTIFIER .)
    LOR             reduce using rule 100 (expression -> expression DOT IDENTIFIER .)
    AND             reduce using rule 100 (expression -> expression DOT IDENTIFIER .)
    OR              reduce using rule 100 (expression -> expression DOT IDENTIFIER .)
    XOR             reduce using rule 100 (expression -> expression DOT IDENTIFIER .)
    AND_NOT         reduce using rule 100 (expression -> expression DOT IDENTIFIER .)
    LSHIFT          reduce using rule 100 (expression -> expression DOT IDENTIFIER .)
    RSHIFT          reduce using rule 100 (expression -> expression DOT IDENTIFIER .)
    SEMICOLON       reduce using rule 100 (expression -> expression DOT IDENTIFIER .)
    FUNC            reduce using rule 100 (expression -> expression DOT IDENTIFIER .)
    TYPE            reduce using rule 100 (expression -> expression DOT IDENTIFIER .)
    IDENTIFIER      reduce using rule 100 (expression -> expression DOT IDENTIFIER .)
    VAR             reduce using rule 100 (expression -> expression DOT IDENTIFIER .)
    CONST           reduce using rule 100 (expression -> expression DOT IDENTIFIER .)
    LNOT            reduce using rule 100 (expression -> expression DOT IDENTIFIER .)
    LBRACKET        reduce using rule 100 (expression -> expression DOT IDENTIFIER .)
    LPAREN          reduce using rule 100 (expression -> expression DOT IDENTIFIER .)
    INT             reduce using rule 100 (expression -> expression DOT IDENTIFIER .)
    FLOAT64         reduce using rule 100 (expression -> expression DOT IDENTIFIER .)
    TRUE            reduce using rule 100 (expression -> expression DOT IDENTIFIER .)
    FALSE           reduce using rule 100 (expression -> expression DOT IDENTIFIER .)
    STRING          reduce using rule 100 (expression -> expression DOT IDENTIFIER .)
    RETURN          reduce using rule 100 (expression -> expression DOT IDENTIFIER .)
    FOR             reduce using rule 100 (expression -> expression DOT IDENTIFIER .)
    IF              reduce using rule 100 (expression -> expression DOT IDENTIFIER .)
    SWITCH          reduce using rule 100 (expression -> expression DOT IDENTIFIER .)
    BREAK           reduce using rule 100 (expression -> expression DOT IDENTIFIER .)
    CONTINUE        reduce using rule 100 (expression -> expression DOT IDENTIFIER .)
    FALLTHROUGH     reduce using rule 100 (expression -> expression DOT IDENTIFIER .)
    $end            reduce using rule 100 (expression -> expression DOT IDENTIFIER .)
    RPAREN          reduce using rule 100 (expression -> expression DOT IDENTIFIER .)
    COMMA           reduce using rule 100 (expression -> expression DOT IDENTIFIER .)
    RBRACE          reduce using rule 100 (expression -> expression DOT IDENTIFIER .)
    CASE            reduce using rule 100 (expression -> expression DOT IDENTIFIER .)
    DEFAULT         reduce using rule 100 (expression -> expression DOT IDENTIFIER .)
    LBRACE          reduce using rule 100 (expression -> expression DOT IDENTIFIER .)
    COLON           reduce using rule 100 (expression -> expression DOT IDENTIFIER .)


state 119

    (135) binary_expression -> expression PLUS expression .
    (100) expression -> expression . DOT IDENTIFIER
    (135) binary_expression -> expression . PLUS expression
    (136) binary_expression -> expression . MINUS expression
    (137) binary_expression -> expression . TIMES expression
    (138) binary_expression -> expression . DIVIDE expression
    (139) binary_expression -> expression . MODULE expression
    (144) relational_expression -> expression . EQ expression
    (145) relational_expression -> expression . NEQ expression
    (146) relational_expression -> expression . LT expression
    (147) relational_expression -> expression . LE expression
    (148) relational_expression -> expression . GT expression
    (149) relational_expression -> expression . GE expression
    (150) logical_expression -> expression . LAND expression
    (151) logical_expression -> expression . LOR expression
    (152) bitwise_expression -> expression . AND expression
    (153) bitwise_expression -> expression . OR expression
    (154) bitwise_expression -> expression . XOR expression
    (155) bitwise_expression -> expression . AND_NOT expression
    (156) bitwise_expression -> expression . LSHIFT expression
    (157) bitwise_expression -> expression . RSHIFT expression

    DOT             reduce using rule 135 (binary_expression -> expression PLUS expression .)
    PLUS            reduce using rule 135 (binary_expression -> expression PLUS expression .)
    MINUS           reduce using rule 135 (binary_expression -> expression PLUS expression .)
    TIMES           reduce using rule 135 (binary_expression -> expression PLUS expression .)
    DIVIDE          reduce using rule 135 (binary_expression -> expression PLUS expression .)
    MODULE          reduce using rule 135 (binary_expression -> expression PLUS expression .)
    AND_NOT         reduce using rule 135 (binary_expression -> expression PLUS expression .)
    SEMICOLON       reduce using rule 135 (binary_expression -> expression PLUS expression .)
    FUNC            reduce using rule 135 (binary_expression -> expression PLUS expression .)
    TYPE            reduce using rule 135 (binary_expression -> expression PLUS expression .)
    IDENTIFIER      reduce using rule 135 (binary_expression -> expression PLUS expression .)
    VAR             reduce using rule 135 (binary_expression -> expression PLUS expression .)
    CONST           reduce using rule 135 (binary_expression -> expression PLUS expression .)
    LNOT            reduce using rule 135 (binary_expression -> expression PLUS expression .)
    LBRACKET        reduce using rule 135 (binary_expression -> expression PLUS expression .)
    LPAREN          reduce using rule 135 (binary_expression -> expression PLUS expression .)
    INT             reduce using rule 135 (binary_expression -> expression PLUS expression .)
    FLOAT64         reduce using rule 135 (binary_expression -> expression PLUS expression .)
    TRUE            reduce using rule 135 (binary_expression -> expression PLUS expression .)
    FALSE           reduce using rule 135 (binary_expression -> expression PLUS expression .)
    STRING          reduce using rule 135 (binary_expression -> expression PLUS expression .)
    RETURN          reduce using rule 135 (binary_expression -> expression PLUS expression .)
    FOR             reduce using rule 135 (binary_expression -> expression PLUS expression .)
    IF              reduce using rule 135 (binary_expression -> expression PLUS expression .)
    SWITCH          reduce using rule 135 (binary_expression -> expression PLUS expression .)
    BREAK           reduce using rule 135 (binary_expression -> expression PLUS expression .)
    CONTINUE        reduce using rule 135 (binary_expression -> expression PLUS expression .)
    FALLTHROUGH     reduce using rule 135 (binary_expression -> expression PLUS expression .)
    $end            reduce using rule 135 (binary_expression -> expression PLUS expression .)
    RPAREN          reduce using rule 135 (binary_expression -> expression PLUS expression .)
    COMMA           reduce using rule 135 (binary_expression -> expression PLUS expression .)
    RBRACE          reduce using rule 135 (binary_expression -> expression PLUS expression .)
    CASE            reduce using rule 135 (binary_expression -> expression PLUS expression .)
    DEFAULT         reduce using rule 135 (binary_expression -> expression PLUS expression .)
    LBRACE          reduce using rule 135 (binary_expression -> expression PLUS expression .)
    COLON           reduce using rule 135 (binary_expression -> expression PLUS expression .)
    EQ              shift and go to state 64
    NEQ             shift and go to state 65
    LT              shift and go to state 66
    LE              shift and go to state 67
    GT              shift and go to state 68
    GE              shift and go to state 69
    LAND            shift and go to state 70
    LOR             shift and go to state 71
    AND             shift and go to state 72
    OR              shift and go to state 73
    XOR             shift and go to state 74
    LSHIFT          shift and go to state 76
    RSHIFT          shift and go to state 77

  ! EQ              [ reduce using rule 135 (binary_expression -> expression PLUS expression .) ]
  ! NEQ             [ reduce using rule 135 (binary_expression -> expression PLUS expression .) ]
  ! LT              [ reduce using rule 135 (binary_expression -> expression PLUS expression .) ]
  ! LE              [ reduce using rule 135 (binary_expression -> expression PLUS expression .) ]
  ! GT              [ reduce using rule 135 (binary_expression -> expression PLUS expression .) ]
  ! GE              [ reduce using rule 135 (binary_expression -> expression PLUS expression .) ]
  ! LAND            [ reduce using rule 135 (binary_expression -> expression PLUS expression .) ]
  ! LOR             [ reduce using rule 135 (binary_expression -> expression PLUS expression .) ]
  ! AND             [ reduce using rule 135 (binary_expression -> expression PLUS expression .) ]
  ! OR              [ reduce using rule 135 (binary_expression -> expression PLUS expression .) ]
  ! XOR             [ reduce using rule 135 (binary_expression -> expression PLUS expression .) ]
  ! LSHIFT          [ reduce using rule 135 (binary_expression -> expression PLUS expression .) ]
  ! RSHIFT          [ reduce using rule 135 (binary_expression -> expression PLUS expression .) ]
  ! DOT             [ shift and go to state 58 ]
  ! PLUS            [ shift and go to state 59 ]
  ! MINUS           [ shift and go to state 60 ]
  ! TIMES           [ shift and go to state 61 ]
  ! DIVIDE          [ shift and go to state 62 ]
  ! MODULE          [ shift and go to state 63 ]
  ! AND_NOT         [ shift and go to state 75 ]


state 120

    (136) binary_expression -> expression MINUS expression .
    (100) expression -> expression . DOT IDENTIFIER
    (135) binary_expression -> expression . PLUS expression
    (136) binary_expression -> expression . MINUS expression
    (137) binary_expression -> expression . TIMES expression
    (138) binary_expression -> expression . DIVIDE expression
    (139) binary_expression -> expression . MODULE expression
    (144) relational_expression -> expression . EQ expression
    (145) relational_expression -> expression . NEQ expression
    (146) relational_expression -> expression . LT expression
    (147) relational_expression -> expression . LE expression
    (148) relational_expression -> expression . GT expression
    (149) relational_expression -> expression . GE expression
    (150) logical_expression -> expression . LAND expression
    (151) logical_expression -> expression . LOR expression
    (152) bitwise_expression -> expression . AND expression
    (153) bitwise_expression -> expression . OR expression
    (154) bitwise_expression -> expression . XOR expression
    (155) bitwise_expression -> expression . AND_NOT expression
    (156) bitwise_expression -> expression . LSHIFT expression
    (157) bitwise_expression -> expression . RSHIFT expression

    DOT             reduce using rule 136 (binary_expression -> expression MINUS expression .)
    PLUS            reduce using rule 136 (binary_expression -> expression MINUS expression .)
    MINUS           reduce using rule 136 (binary_expression -> expression MINUS expression .)
    TIMES           reduce using rule 136 (binary_expression -> expression MINUS expression .)
    DIVIDE          reduce using rule 136 (binary_expression -> expression MINUS expression .)
    MODULE          reduce using rule 136 (binary_expression -> expression MINUS expression .)
    AND_NOT         reduce using rule 136 (binary_expression -> expression MINUS expression .)
    SEMICOLON       reduce using rule 136 (binary_expression -> expression MINUS expression .)
    FUNC            reduce using rule 136 (binary_expression -> expression MINUS expression .)
    TYPE            reduce using rule 136 (binary_expression -> expression MINUS expression .)
    IDENTIFIER      reduce using rule 136 (binary_expression -> expression MINUS expression .)
    VAR             reduce using rule 136 (binary_expression -> expression MINUS expression .)
    CONST           reduce using rule 136 (binary_expression -> expression MINUS expression .)
    LNOT            reduce using rule 136 (binary_expression -> expression MINUS expression .)
    LBRACKET        reduce using rule 136 (binary_expression -> expression MINUS expression .)
    LPAREN          reduce using rule 136 (binary_expression -> expression MINUS expression .)
    INT             reduce using rule 136 (binary_expression -> expression MINUS expression .)
    FLOAT64         reduce using rule 136 (binary_expression -> expression MINUS expression .)
    TRUE            reduce using rule 136 (binary_expression -> expression MINUS expression .)
    FALSE           reduce using rule 136 (binary_expression -> expression MINUS expression .)
    STRING          reduce using rule 136 (binary_expression -> expression MINUS expression .)
    RETURN          reduce using rule 136 (binary_expression -> expression MINUS expression .)
    FOR             reduce using rule 136 (binary_expression -> expression MINUS expression .)
    IF              reduce using rule 136 (binary_expression -> expression MINUS expression .)
    SWITCH          reduce using rule 136 (binary_expression -> expression MINUS expression .)
    BREAK           reduce using rule 136 (binary_expression -> expression MINUS expression .)
    CONTINUE        reduce using rule 136 (binary_expression -> expression MINUS expression .)
    FALLTHROUGH     reduce using rule 136 (binary_expression -> expression MINUS expression .)
    $end            reduce using rule 136 (binary_expression -> expression MINUS expression .)
    RPAREN          reduce using rule 136 (binary_expression -> expression MINUS expression .)
    COMMA           reduce using rule 136 (binary_expression -> expression MINUS expression .)
    RBRACE          reduce using rule 136 (binary_expression -> expression MINUS expression .)
    CASE            reduce using rule 136 (binary_expression -> expression MINUS expression .)
    DEFAULT         reduce using rule 136 (binary_expression -> expression MINUS expression .)
    LBRACE          reduce using rule 136 (binary_expression -> expression MINUS expression .)
    COLON           reduce using rule 136 (binary_expression -> expression MINUS expression .)
    EQ              shift and go to state 64
    NEQ             shift and go to state 65
    LT              shift and go to state 66
    LE              shift and go to state 67
    GT              shift and go to state 68
    GE              shift and go to state 69
    LAND            shift and go to state 70
    LOR             shift and go to state 71
    AND             shift and go to state 72
    OR              shift and go to state 73
    XOR             shift and go to state 74
    LSHIFT          shift and go to state 76
    RSHIFT          shift and go to state 77

  ! EQ              [ reduce using rule 136 (binary_expression -> expression MINUS expression .) ]
  ! NEQ             [ reduce using rule 136 (binary_expression -> expression MINUS expression .) ]
  ! LT              [ reduce using rule 136 (binary_expression -> expression MINUS expression .) ]
  ! LE              [ reduce using rule 136 (binary_expression -> expression MINUS expression .) ]
  ! GT              [ reduce using rule 136 (binary_expression -> expression MINUS expression .) ]
  ! GE              [ reduce using rule 136 (binary_expression -> expression MINUS expression .) ]
  ! LAND            [ reduce using rule 136 (binary_expression -> expression MINUS expression .) ]
  ! LOR             [ reduce using rule 136 (binary_expression -> expression MINUS expression .) ]
  ! AND             [ reduce using rule 136 (binary_expression -> expression MINUS expression .) ]
  ! OR              [ reduce using rule 136 (binary_expression -> expression MINUS expression .) ]
  ! XOR             [ reduce using rule 136 (binary_expression -> expression MINUS expression .) ]
  ! LSHIFT          [ reduce using rule 136 (binary_expression -> expression MINUS expression .) ]
  ! RSHIFT          [ reduce using rule 136 (binary_expression -> expression MINUS expression .) ]
  ! DOT             [ shift and go to state 58 ]
  ! PLUS            [ shift and go to state 59 ]
  ! MINUS           [ shift and go to state 60 ]
  ! TIMES           [ shift and go to state 61 ]
  ! DIVIDE          [ shift and go to state 62 ]
  ! MODULE          [ shift and go to state 63 ]
  ! AND_NOT         [ shift and go to state 75 ]


state 121

    (137) binary_expression -> expression TIMES expression .
    (100) expression -> expression . DOT IDENTIFIER
    (135) binary_expression -> expression . PLUS expression
    (136) binary_expression -> expression . MINUS expression
    (137) binary_expression -> expression . TIMES expression
    (138) binary_expression -> expression . DIVIDE expression
    (139) binary_expression -> expression . MODULE expression
    (144) relational_expression -> expression . EQ expression
    (145) relational_expression -> expression . NEQ expression
    (146) relational_expression -> expression . LT expression
    (147) relational_expression -> expression . LE expression
    (148) relational_expression -> expression . GT expression
    (149) relational_expression -> expression . GE expression
    (150) logical_expression -> expression . LAND expression
    (151) logical_expression -> expression . LOR expression
    (152) bitwise_expression -> expression . AND expression
    (153) bitwise_expression -> expression . OR expression
    (154) bitwise_expression -> expression . XOR expression
    (155) bitwise_expression -> expression . AND_NOT expression
    (156) bitwise_expression -> expression . LSHIFT expression
    (157) bitwise_expression -> expression . RSHIFT expression

    DOT             reduce using rule 137 (binary_expression -> expression TIMES expression .)
    TIMES           reduce using rule 137 (binary_expression -> expression TIMES expression .)
    DIVIDE          reduce using rule 137 (binary_expression -> expression TIMES expression .)
    MODULE          reduce using rule 137 (binary_expression -> expression TIMES expression .)
    AND_NOT         reduce using rule 137 (binary_expression -> expression TIMES expression .)
    SEMICOLON       reduce using rule 137 (binary_expression -> expression TIMES expression .)
    FUNC            reduce using rule 137 (binary_expression -> expression TIMES expression .)
    TYPE            reduce using rule 137 (binary_expression -> expression TIMES expression .)
    IDENTIFIER      reduce using rule 137 (binary_expression -> expression TIMES expression .)
    VAR             reduce using rule 137 (binary_expression -> expression TIMES expression .)
    CONST           reduce using rule 137 (binary_expression -> expression TIMES expression .)
    LNOT            reduce using rule 137 (binary_expression -> expression TIMES expression .)
    LBRACKET        reduce using rule 137 (binary_expression -> expression TIMES expression .)
    LPAREN          reduce using rule 137 (binary_expression -> expression TIMES expression .)
    INT             reduce using rule 137 (binary_expression -> expression TIMES expression .)
    FLOAT64         reduce using rule 137 (binary_expression -> expression TIMES expression .)
    TRUE            reduce using rule 137 (binary_expression -> expression TIMES expression .)
    FALSE           reduce using rule 137 (binary_expression -> expression TIMES expression .)
    STRING          reduce using rule 137 (binary_expression -> expression TIMES expression .)
    RETURN          reduce using rule 137 (binary_expression -> expression TIMES expression .)
    FOR             reduce using rule 137 (binary_expression -> expression TIMES expression .)
    IF              reduce using rule 137 (binary_expression -> expression TIMES expression .)
    SWITCH          reduce using rule 137 (binary_expression -> expression TIMES expression .)
    BREAK           reduce using rule 137 (binary_expression -> expression TIMES expression .)
    CONTINUE        reduce using rule 137 (binary_expression -> expression TIMES expression .)
    FALLTHROUGH     reduce using rule 137 (binary_expression -> expression TIMES expression .)
    $end            reduce using rule 137 (binary_expression -> expression TIMES expression .)
    RPAREN          reduce using rule 137 (binary_expression -> expression TIMES expression .)
    COMMA           reduce using rule 137 (binary_expression -> expression TIMES expression .)
    RBRACE          reduce using rule 137 (binary_expression -> expression TIMES expression .)
    CASE            reduce using rule 137 (binary_expression -> expression TIMES expression .)
    DEFAULT         reduce using rule 137 (binary_expression -> expression TIMES expression .)
    LBRACE          reduce using rule 137 (binary_expression -> expression TIMES expression .)
    COLON           reduce using rule 137 (binary_expression -> expression TIMES expression .)
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    EQ              shift and go to state 64
    NEQ             shift and go to state 65
    LT              shift and go to state 66
    LE              shift and go to state 67
    GT              shift and go to state 68
    GE              shift and go to state 69
    LAND            shift and go to state 70
    LOR             shift and go to state 71
    AND             shift and go to state 72
    OR              shift and go to state 73
    XOR             shift and go to state 74
    LSHIFT          shift and go to state 76
    RSHIFT          shift and go to state 77

  ! PLUS            [ reduce using rule 137 (binary_expression -> expression TIMES expression .) ]
  ! MINUS           [ reduce using rule 137 (binary_expression -> expression TIMES expression .) ]
  ! EQ              [ reduce using rule 137 (binary_expression -> expression TIMES expression .) ]
  ! NEQ             [ reduce using rule 137 (binary_expression -> expression TIMES expression .) ]
  ! LT              [ reduce using rule 137 (binary_expression -> expression TIMES expression .) ]
  ! LE              [ reduce using rule 137 (binary_expression -> expression TIMES expression .) ]
  ! GT              [ reduce using rule 137 (binary_expression -> expression TIMES expression .) ]
  ! GE              [ reduce using rule 137 (binary_expression -> expression TIMES expression .) ]
  ! LAND            [ reduce using rule 137 (binary_expression -> expression TIMES expression .) ]
  ! LOR             [ reduce using rule 137 (binary_expression -> expression TIMES expression .) ]
  ! AND             [ reduce using rule 137 (binary_expression -> expression TIMES expression .) ]
  ! OR              [ reduce using rule 137 (binary_expression -> expression TIMES expression .) ]
  ! XOR             [ reduce using rule 137 (binary_expression -> expression TIMES expression .) ]
  ! LSHIFT          [ reduce using rule 137 (binary_expression -> expression TIMES expression .) ]
  ! RSHIFT          [ reduce using rule 137 (binary_expression -> expression TIMES expression .) ]
  ! DOT             [ shift and go to state 58 ]
  ! TIMES           [ shift and go to state 61 ]
  ! DIVIDE          [ shift and go to state 62 ]
  ! MODULE          [ shift and go to state 63 ]
  ! AND_NOT         [ shift and go to state 75 ]


state 122

    (138) binary_expression -> expression DIVIDE expression .
    (100) expression -> expression . DOT IDENTIFIER
    (135) binary_expression -> expression . PLUS expression
    (136) binary_expression -> expression . MINUS expression
    (137) binary_expression -> expression . TIMES expression
    (138) binary_expression -> expression . DIVIDE expression
    (139) binary_expression -> expression . MODULE expression
    (144) relational_expression -> expression . EQ expression
    (145) relational_expression -> expression . NEQ expression
    (146) relational_expression -> expression . LT expression
    (147) relational_expression -> expression . LE expression
    (148) relational_expression -> expression . GT expression
    (149) relational_expression -> expression . GE expression
    (150) logical_expression -> expression . LAND expression
    (151) logical_expression -> expression . LOR expression
    (152) bitwise_expression -> expression . AND expression
    (153) bitwise_expression -> expression . OR expression
    (154) bitwise_expression -> expression . XOR expression
    (155) bitwise_expression -> expression . AND_NOT expression
    (156) bitwise_expression -> expression . LSHIFT expression
    (157) bitwise_expression -> expression . RSHIFT expression

    DOT             reduce using rule 138 (binary_expression -> expression DIVIDE expression .)
    TIMES           reduce using rule 138 (binary_expression -> expression DIVIDE expression .)
    DIVIDE          reduce using rule 138 (binary_expression -> expression DIVIDE expression .)
    MODULE          reduce using rule 138 (binary_expression -> expression DIVIDE expression .)
    AND_NOT         reduce using rule 138 (binary_expression -> expression DIVIDE expression .)
    SEMICOLON       reduce using rule 138 (binary_expression -> expression DIVIDE expression .)
    FUNC            reduce using rule 138 (binary_expression -> expression DIVIDE expression .)
    TYPE            reduce using rule 138 (binary_expression -> expression DIVIDE expression .)
    IDENTIFIER      reduce using rule 138 (binary_expression -> expression DIVIDE expression .)
    VAR             reduce using rule 138 (binary_expression -> expression DIVIDE expression .)
    CONST           reduce using rule 138 (binary_expression -> expression DIVIDE expression .)
    LNOT            reduce using rule 138 (binary_expression -> expression DIVIDE expression .)
    LBRACKET        reduce using rule 138 (binary_expression -> expression DIVIDE expression .)
    LPAREN          reduce using rule 138 (binary_expression -> expression DIVIDE expression .)
    INT             reduce using rule 138 (binary_expression -> expression DIVIDE expression .)
    FLOAT64         reduce using rule 138 (binary_expression -> expression DIVIDE expression .)
    TRUE            reduce using rule 138 (binary_expression -> expression DIVIDE expression .)
    FALSE           reduce using rule 138 (binary_expression -> expression DIVIDE expression .)
    STRING          reduce using rule 138 (binary_expression -> expression DIVIDE expression .)
    RETURN          reduce using rule 138 (binary_expression -> expression DIVIDE expression .)
    FOR             reduce using rule 138 (binary_expression -> expression DIVIDE expression .)
    IF              reduce using rule 138 (binary_expression -> expression DIVIDE expression .)
    SWITCH          reduce using rule 138 (binary_expression -> expression DIVIDE expression .)
    BREAK           reduce using rule 138 (binary_expression -> expression DIVIDE expression .)
    CONTINUE        reduce using rule 138 (binary_expression -> expression DIVIDE expression .)
    FALLTHROUGH     reduce using rule 138 (binary_expression -> expression DIVIDE expression .)
    $end            reduce using rule 138 (binary_expression -> expression DIVIDE expression .)
    RPAREN          reduce using rule 138 (binary_expression -> expression DIVIDE expression .)
    COMMA           reduce using rule 138 (binary_expression -> expression DIVIDE expression .)
    RBRACE          reduce using rule 138 (binary_expression -> expression DIVIDE expression .)
    CASE            reduce using rule 138 (binary_expression -> expression DIVIDE expression .)
    DEFAULT         reduce using rule 138 (binary_expression -> expression DIVIDE expression .)
    LBRACE          reduce using rule 138 (binary_expression -> expression DIVIDE expression .)
    COLON           reduce using rule 138 (binary_expression -> expression DIVIDE expression .)
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    EQ              shift and go to state 64
    NEQ             shift and go to state 65
    LT              shift and go to state 66
    LE              shift and go to state 67
    GT              shift and go to state 68
    GE              shift and go to state 69
    LAND            shift and go to state 70
    LOR             shift and go to state 71
    AND             shift and go to state 72
    OR              shift and go to state 73
    XOR             shift and go to state 74
    LSHIFT          shift and go to state 76
    RSHIFT          shift and go to state 77

  ! PLUS            [ reduce using rule 138 (binary_expression -> expression DIVIDE expression .) ]
  ! MINUS           [ reduce using rule 138 (binary_expression -> expression DIVIDE expression .) ]
  ! EQ              [ reduce using rule 138 (binary_expression -> expression DIVIDE expression .) ]
  ! NEQ             [ reduce using rule 138 (binary_expression -> expression DIVIDE expression .) ]
  ! LT              [ reduce using rule 138 (binary_expression -> expression DIVIDE expression .) ]
  ! LE              [ reduce using rule 138 (binary_expression -> expression DIVIDE expression .) ]
  ! GT              [ reduce using rule 138 (binary_expression -> expression DIVIDE expression .) ]
  ! GE              [ reduce using rule 138 (binary_expression -> expression DIVIDE expression .) ]
  ! LAND            [ reduce using rule 138 (binary_expression -> expression DIVIDE expression .) ]
  ! LOR             [ reduce using rule 138 (binary_expression -> expression DIVIDE expression .) ]
  ! AND             [ reduce using rule 138 (binary_expression -> expression DIVIDE expression .) ]
  ! OR              [ reduce using rule 138 (binary_expression -> expression DIVIDE expression .) ]
  ! XOR             [ reduce using rule 138 (binary_expression -> expression DIVIDE expression .) ]
  ! LSHIFT          [ reduce using rule 138 (binary_expression -> expression DIVIDE expression .) ]
  ! RSHIFT          [ reduce using rule 138 (binary_expression -> expression DIVIDE expression .) ]
  ! DOT             [ shift and go to state 58 ]
  ! TIMES           [ shift and go to state 61 ]
  ! DIVIDE          [ shift and go to state 62 ]
  ! MODULE          [ shift and go to state 63 ]
  ! AND_NOT         [ shift and go to state 75 ]


state 123

    (139) binary_expression -> expression MODULE expression .
    (100) expression -> expression . DOT IDENTIFIER
    (135) binary_expression -> expression . PLUS expression
    (136) binary_expression -> expression . MINUS expression
    (137) binary_expression -> expression . TIMES expression
    (138) binary_expression -> expression . DIVIDE expression
    (139) binary_expression -> expression . MODULE expression
    (144) relational_expression -> expression . EQ expression
    (145) relational_expression -> expression . NEQ expression
    (146) relational_expression -> expression . LT expression
    (147) relational_expression -> expression . LE expression
    (148) relational_expression -> expression . GT expression
    (149) relational_expression -> expression . GE expression
    (150) logical_expression -> expression . LAND expression
    (151) logical_expression -> expression . LOR expression
    (152) bitwise_expression -> expression . AND expression
    (153) bitwise_expression -> expression . OR expression
    (154) bitwise_expression -> expression . XOR expression
    (155) bitwise_expression -> expression . AND_NOT expression
    (156) bitwise_expression -> expression . LSHIFT expression
    (157) bitwise_expression -> expression . RSHIFT expression

    DOT             reduce using rule 139 (binary_expression -> expression MODULE expression .)
    TIMES           reduce using rule 139 (binary_expression -> expression MODULE expression .)
    DIVIDE          reduce using rule 139 (binary_expression -> expression MODULE expression .)
    MODULE          reduce using rule 139 (binary_expression -> expression MODULE expression .)
    AND_NOT         reduce using rule 139 (binary_expression -> expression MODULE expression .)
    SEMICOLON       reduce using rule 139 (binary_expression -> expression MODULE expression .)
    FUNC            reduce using rule 139 (binary_expression -> expression MODULE expression .)
    TYPE            reduce using rule 139 (binary_expression -> expression MODULE expression .)
    IDENTIFIER      reduce using rule 139 (binary_expression -> expression MODULE expression .)
    VAR             reduce using rule 139 (binary_expression -> expression MODULE expression .)
    CONST           reduce using rule 139 (binary_expression -> expression MODULE expression .)
    LNOT            reduce using rule 139 (binary_expression -> expression MODULE expression .)
    LBRACKET        reduce using rule 139 (binary_expression -> expression MODULE expression .)
    LPAREN          reduce using rule 139 (binary_expression -> expression MODULE expression .)
    INT             reduce using rule 139 (binary_expression -> expression MODULE expression .)
    FLOAT64         reduce using rule 139 (binary_expression -> expression MODULE expression .)
    TRUE            reduce using rule 139 (binary_expression -> expression MODULE expression .)
    FALSE           reduce using rule 139 (binary_expression -> expression MODULE expression .)
    STRING          reduce using rule 139 (binary_expression -> expression MODULE expression .)
    RETURN          reduce using rule 139 (binary_expression -> expression MODULE expression .)
    FOR             reduce using rule 139 (binary_expression -> expression MODULE expression .)
    IF              reduce using rule 139 (binary_expression -> expression MODULE expression .)
    SWITCH          reduce using rule 139 (binary_expression -> expression MODULE expression .)
    BREAK           reduce using rule 139 (binary_expression -> expression MODULE expression .)
    CONTINUE        reduce using rule 139 (binary_expression -> expression MODULE expression .)
    FALLTHROUGH     reduce using rule 139 (binary_expression -> expression MODULE expression .)
    $end            reduce using rule 139 (binary_expression -> expression MODULE expression .)
    RPAREN          reduce using rule 139 (binary_expression -> expression MODULE expression .)
    COMMA           reduce using rule 139 (binary_expression -> expression MODULE expression .)
    RBRACE          reduce using rule 139 (binary_expression -> expression MODULE expression .)
    CASE            reduce using rule 139 (binary_expression -> expression MODULE expression .)
    DEFAULT         reduce using rule 139 (binary_expression -> expression MODULE expression .)
    LBRACE          reduce using rule 139 (binary_expression -> expression MODULE expression .)
    COLON           reduce using rule 139 (binary_expression -> expression MODULE expression .)
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    EQ              shift and go to state 64
    NEQ             shift and go to state 65
    LT              shift and go to state 66
    LE              shift and go to state 67
    GT              shift and go to state 68
    GE              shift and go to state 69
    LAND            shift and go to state 70
    LOR             shift and go to state 71
    AND             shift and go to state 72
    OR              shift and go to state 73
    XOR             shift and go to state 74
    LSHIFT          shift and go to state 76
    RSHIFT          shift and go to state 77

  ! PLUS            [ reduce using rule 139 (binary_expression -> expression MODULE expression .) ]
  ! MINUS           [ reduce using rule 139 (binary_expression -> expression MODULE expression .) ]
  ! EQ              [ reduce using rule 139 (binary_expression -> expression MODULE expression .) ]
  ! NEQ             [ reduce using rule 139 (binary_expression -> expression MODULE expression .) ]
  ! LT              [ reduce using rule 139 (binary_expression -> expression MODULE expression .) ]
  ! LE              [ reduce using rule 139 (binary_expression -> expression MODULE expression .) ]
  ! GT              [ reduce using rule 139 (binary_expression -> expression MODULE expression .) ]
  ! GE              [ reduce using rule 139 (binary_expression -> expression MODULE expression .) ]
  ! LAND            [ reduce using rule 139 (binary_expression -> expression MODULE expression .) ]
  ! LOR             [ reduce using rule 139 (binary_expression -> expression MODULE expression .) ]
  ! AND             [ reduce using rule 139 (binary_expression -> expression MODULE expression .) ]
  ! OR              [ reduce using rule 139 (binary_expression -> expression MODULE expression .) ]
  ! XOR             [ reduce using rule 139 (binary_expression -> expression MODULE expression .) ]
  ! LSHIFT          [ reduce using rule 139 (binary_expression -> expression MODULE expression .) ]
  ! RSHIFT          [ reduce using rule 139 (binary_expression -> expression MODULE expression .) ]
  ! DOT             [ shift and go to state 58 ]
  ! TIMES           [ shift and go to state 61 ]
  ! DIVIDE          [ shift and go to state 62 ]
  ! MODULE          [ shift and go to state 63 ]
  ! AND_NOT         [ shift and go to state 75 ]


state 124

    (144) relational_expression -> expression EQ expression .
    (100) expression -> expression . DOT IDENTIFIER
    (135) binary_expression -> expression . PLUS expression
    (136) binary_expression -> expression . MINUS expression
    (137) binary_expression -> expression . TIMES expression
    (138) binary_expression -> expression . DIVIDE expression
    (139) binary_expression -> expression . MODULE expression
    (144) relational_expression -> expression . EQ expression
    (145) relational_expression -> expression . NEQ expression
    (146) relational_expression -> expression . LT expression
    (147) relational_expression -> expression . LE expression
    (148) relational_expression -> expression . GT expression
    (149) relational_expression -> expression . GE expression
    (150) logical_expression -> expression . LAND expression
    (151) logical_expression -> expression . LOR expression
    (152) bitwise_expression -> expression . AND expression
    (153) bitwise_expression -> expression . OR expression
    (154) bitwise_expression -> expression . XOR expression
    (155) bitwise_expression -> expression . AND_NOT expression
    (156) bitwise_expression -> expression . LSHIFT expression
    (157) bitwise_expression -> expression . RSHIFT expression

    DOT             reduce using rule 144 (relational_expression -> expression EQ expression .)
    PLUS            reduce using rule 144 (relational_expression -> expression EQ expression .)
    MINUS           reduce using rule 144 (relational_expression -> expression EQ expression .)
    TIMES           reduce using rule 144 (relational_expression -> expression EQ expression .)
    DIVIDE          reduce using rule 144 (relational_expression -> expression EQ expression .)
    MODULE          reduce using rule 144 (relational_expression -> expression EQ expression .)
    EQ              reduce using rule 144 (relational_expression -> expression EQ expression .)
    NEQ             reduce using rule 144 (relational_expression -> expression EQ expression .)
    LT              reduce using rule 144 (relational_expression -> expression EQ expression .)
    LE              reduce using rule 144 (relational_expression -> expression EQ expression .)
    GT              reduce using rule 144 (relational_expression -> expression EQ expression .)
    GE              reduce using rule 144 (relational_expression -> expression EQ expression .)
    AND             reduce using rule 144 (relational_expression -> expression EQ expression .)
    OR              reduce using rule 144 (relational_expression -> expression EQ expression .)
    XOR             reduce using rule 144 (relational_expression -> expression EQ expression .)
    AND_NOT         reduce using rule 144 (relational_expression -> expression EQ expression .)
    LSHIFT          reduce using rule 144 (relational_expression -> expression EQ expression .)
    RSHIFT          reduce using rule 144 (relational_expression -> expression EQ expression .)
    SEMICOLON       reduce using rule 144 (relational_expression -> expression EQ expression .)
    FUNC            reduce using rule 144 (relational_expression -> expression EQ expression .)
    TYPE            reduce using rule 144 (relational_expression -> expression EQ expression .)
    IDENTIFIER      reduce using rule 144 (relational_expression -> expression EQ expression .)
    VAR             reduce using rule 144 (relational_expression -> expression EQ expression .)
    CONST           reduce using rule 144 (relational_expression -> expression EQ expression .)
    LNOT            reduce using rule 144 (relational_expression -> expression EQ expression .)
    LBRACKET        reduce using rule 144 (relational_expression -> expression EQ expression .)
    LPAREN          reduce using rule 144 (relational_expression -> expression EQ expression .)
    INT             reduce using rule 144 (relational_expression -> expression EQ expression .)
    FLOAT64         reduce using rule 144 (relational_expression -> expression EQ expression .)
    TRUE            reduce using rule 144 (relational_expression -> expression EQ expression .)
    FALSE           reduce using rule 144 (relational_expression -> expression EQ expression .)
    STRING          reduce using rule 144 (relational_expression -> expression EQ expression .)
    RETURN          reduce using rule 144 (relational_expression -> expression EQ expression .)
    FOR             reduce using rule 144 (relational_expression -> expression EQ expression .)
    IF              reduce using rule 144 (relational_expression -> expression EQ expression .)
    SWITCH          reduce using rule 144 (relational_expression -> expression EQ expression .)
    BREAK           reduce using rule 144 (relational_expression -> expression EQ expression .)
    CONTINUE        reduce using rule 144 (relational_expression -> expression EQ expression .)
    FALLTHROUGH     reduce using rule 144 (relational_expression -> expression EQ expression .)
    $end            reduce using rule 144 (relational_expression -> expression EQ expression .)
    RPAREN          reduce using rule 144 (relational_expression -> expression EQ expression .)
    COMMA           reduce using rule 144 (relational_expression -> expression EQ expression .)
    RBRACE          reduce using rule 144 (relational_expression -> expression EQ expression .)
    CASE            reduce using rule 144 (relational_expression -> expression EQ expression .)
    DEFAULT         reduce using rule 144 (relational_expression -> expression EQ expression .)
    LBRACE          reduce using rule 144 (relational_expression -> expression EQ expression .)
    COLON           reduce using rule 144 (relational_expression -> expression EQ expression .)
    LAND            shift and go to state 70
    LOR             shift and go to state 71

  ! LAND            [ reduce using rule 144 (relational_expression -> expression EQ expression .) ]
  ! LOR             [ reduce using rule 144 (relational_expression -> expression EQ expression .) ]
  ! DOT             [ shift and go to state 58 ]
  ! PLUS            [ shift and go to state 59 ]
  ! MINUS           [ shift and go to state 60 ]
  ! TIMES           [ shift and go to state 61 ]
  ! DIVIDE          [ shift and go to state 62 ]
  ! MODULE          [ shift and go to state 63 ]
  ! EQ              [ shift and go to state 64 ]
  ! NEQ             [ shift and go to state 65 ]
  ! LT              [ shift and go to state 66 ]
  ! LE              [ shift and go to state 67 ]
  ! GT              [ shift and go to state 68 ]
  ! GE              [ shift and go to state 69 ]
  ! AND             [ shift and go to state 72 ]
  ! OR              [ shift and go to state 73 ]
  ! XOR             [ shift and go to state 74 ]
  ! AND_NOT         [ shift and go to state 75 ]
  ! LSHIFT          [ shift and go to state 76 ]
  ! RSHIFT          [ shift and go to state 77 ]


state 125

    (145) relational_expression -> expression NEQ expression .
    (100) expression -> expression . DOT IDENTIFIER
    (135) binary_expression -> expression . PLUS expression
    (136) binary_expression -> expression . MINUS expression
    (137) binary_expression -> expression . TIMES expression
    (138) binary_expression -> expression . DIVIDE expression
    (139) binary_expression -> expression . MODULE expression
    (144) relational_expression -> expression . EQ expression
    (145) relational_expression -> expression . NEQ expression
    (146) relational_expression -> expression . LT expression
    (147) relational_expression -> expression . LE expression
    (148) relational_expression -> expression . GT expression
    (149) relational_expression -> expression . GE expression
    (150) logical_expression -> expression . LAND expression
    (151) logical_expression -> expression . LOR expression
    (152) bitwise_expression -> expression . AND expression
    (153) bitwise_expression -> expression . OR expression
    (154) bitwise_expression -> expression . XOR expression
    (155) bitwise_expression -> expression . AND_NOT expression
    (156) bitwise_expression -> expression . LSHIFT expression
    (157) bitwise_expression -> expression . RSHIFT expression

    DOT             reduce using rule 145 (relational_expression -> expression NEQ expression .)
    PLUS            reduce using rule 145 (relational_expression -> expression NEQ expression .)
    MINUS           reduce using rule 145 (relational_expression -> expression NEQ expression .)
    TIMES           reduce using rule 145 (relational_expression -> expression NEQ expression .)
    DIVIDE          reduce using rule 145 (relational_expression -> expression NEQ expression .)
    MODULE          reduce using rule 145 (relational_expression -> expression NEQ expression .)
    EQ              reduce using rule 145 (relational_expression -> expression NEQ expression .)
    NEQ             reduce using rule 145 (relational_expression -> expression NEQ expression .)
    LT              reduce using rule 145 (relational_expression -> expression NEQ expression .)
    LE              reduce using rule 145 (relational_expression -> expression NEQ expression .)
    GT              reduce using rule 145 (relational_expression -> expression NEQ expression .)
    GE              reduce using rule 145 (relational_expression -> expression NEQ expression .)
    AND             reduce using rule 145 (relational_expression -> expression NEQ expression .)
    OR              reduce using rule 145 (relational_expression -> expression NEQ expression .)
    XOR             reduce using rule 145 (relational_expression -> expression NEQ expression .)
    AND_NOT         reduce using rule 145 (relational_expression -> expression NEQ expression .)
    LSHIFT          reduce using rule 145 (relational_expression -> expression NEQ expression .)
    RSHIFT          reduce using rule 145 (relational_expression -> expression NEQ expression .)
    SEMICOLON       reduce using rule 145 (relational_expression -> expression NEQ expression .)
    FUNC            reduce using rule 145 (relational_expression -> expression NEQ expression .)
    TYPE            reduce using rule 145 (relational_expression -> expression NEQ expression .)
    IDENTIFIER      reduce using rule 145 (relational_expression -> expression NEQ expression .)
    VAR             reduce using rule 145 (relational_expression -> expression NEQ expression .)
    CONST           reduce using rule 145 (relational_expression -> expression NEQ expression .)
    LNOT            reduce using rule 145 (relational_expression -> expression NEQ expression .)
    LBRACKET        reduce using rule 145 (relational_expression -> expression NEQ expression .)
    LPAREN          reduce using rule 145 (relational_expression -> expression NEQ expression .)
    INT             reduce using rule 145 (relational_expression -> expression NEQ expression .)
    FLOAT64         reduce using rule 145 (relational_expression -> expression NEQ expression .)
    TRUE            reduce using rule 145 (relational_expression -> expression NEQ expression .)
    FALSE           reduce using rule 145 (relational_expression -> expression NEQ expression .)
    STRING          reduce using rule 145 (relational_expression -> expression NEQ expression .)
    RETURN          reduce using rule 145 (relational_expression -> expression NEQ expression .)
    FOR             reduce using rule 145 (relational_expression -> expression NEQ expression .)
    IF              reduce using rule 145 (relational_expression -> expression NEQ expression .)
    SWITCH          reduce using rule 145 (relational_expression -> expression NEQ expression .)
    BREAK           reduce using rule 145 (relational_expression -> expression NEQ expression .)
    CONTINUE        reduce using rule 145 (relational_expression -> expression NEQ expression .)
    FALLTHROUGH     reduce using rule 145 (relational_expression -> expression NEQ expression .)
    $end            reduce using rule 145 (relational_expression -> expression NEQ expression .)
    RPAREN          reduce using rule 145 (relational_expression -> expression NEQ expression .)
    COMMA           reduce using rule 145 (relational_expression -> expression NEQ expression .)
    RBRACE          reduce using rule 145 (relational_expression -> expression NEQ expression .)
    CASE            reduce using rule 145 (relational_expression -> expression NEQ expression .)
    DEFAULT         reduce using rule 145 (relational_expression -> expression NEQ expression .)
    LBRACE          reduce using rule 145 (relational_expression -> expression NEQ expression .)
    COLON           reduce using rule 145 (relational_expression -> expression NEQ expression .)
    LAND            shift and go to state 70
    LOR             shift and go to state 71

  ! LAND            [ reduce using rule 145 (relational_expression -> expression NEQ expression .) ]
  ! LOR             [ reduce using rule 145 (relational_expression -> expression NEQ expression .) ]
  ! DOT             [ shift and go to state 58 ]
  ! PLUS            [ shift and go to state 59 ]
  ! MINUS           [ shift and go to state 60 ]
  ! TIMES           [ shift and go to state 61 ]
  ! DIVIDE          [ shift and go to state 62 ]
  ! MODULE          [ shift and go to state 63 ]
  ! EQ              [ shift and go to state 64 ]
  ! NEQ             [ shift and go to state 65 ]
  ! LT              [ shift and go to state 66 ]
  ! LE              [ shift and go to state 67 ]
  ! GT              [ shift and go to state 68 ]
  ! GE              [ shift and go to state 69 ]
  ! AND             [ shift and go to state 72 ]
  ! OR              [ shift and go to state 73 ]
  ! XOR             [ shift and go to state 74 ]
  ! AND_NOT         [ shift and go to state 75 ]
  ! LSHIFT          [ shift and go to state 76 ]
  ! RSHIFT          [ shift and go to state 77 ]


state 126

    (146) relational_expression -> expression LT expression .
    (100) expression -> expression . DOT IDENTIFIER
    (135) binary_expression -> expression . PLUS expression
    (136) binary_expression -> expression . MINUS expression
    (137) binary_expression -> expression . TIMES expression
    (138) binary_expression -> expression . DIVIDE expression
    (139) binary_expression -> expression . MODULE expression
    (144) relational_expression -> expression . EQ expression
    (145) relational_expression -> expression . NEQ expression
    (146) relational_expression -> expression . LT expression
    (147) relational_expression -> expression . LE expression
    (148) relational_expression -> expression . GT expression
    (149) relational_expression -> expression . GE expression
    (150) logical_expression -> expression . LAND expression
    (151) logical_expression -> expression . LOR expression
    (152) bitwise_expression -> expression . AND expression
    (153) bitwise_expression -> expression . OR expression
    (154) bitwise_expression -> expression . XOR expression
    (155) bitwise_expression -> expression . AND_NOT expression
    (156) bitwise_expression -> expression . LSHIFT expression
    (157) bitwise_expression -> expression . RSHIFT expression

    DOT             reduce using rule 146 (relational_expression -> expression LT expression .)
    PLUS            reduce using rule 146 (relational_expression -> expression LT expression .)
    MINUS           reduce using rule 146 (relational_expression -> expression LT expression .)
    TIMES           reduce using rule 146 (relational_expression -> expression LT expression .)
    DIVIDE          reduce using rule 146 (relational_expression -> expression LT expression .)
    MODULE          reduce using rule 146 (relational_expression -> expression LT expression .)
    LT              reduce using rule 146 (relational_expression -> expression LT expression .)
    LE              reduce using rule 146 (relational_expression -> expression LT expression .)
    GT              reduce using rule 146 (relational_expression -> expression LT expression .)
    GE              reduce using rule 146 (relational_expression -> expression LT expression .)
    AND             reduce using rule 146 (relational_expression -> expression LT expression .)
    OR              reduce using rule 146 (relational_expression -> expression LT expression .)
    XOR             reduce using rule 146 (relational_expression -> expression LT expression .)
    AND_NOT         reduce using rule 146 (relational_expression -> expression LT expression .)
    LSHIFT          reduce using rule 146 (relational_expression -> expression LT expression .)
    RSHIFT          reduce using rule 146 (relational_expression -> expression LT expression .)
    SEMICOLON       reduce using rule 146 (relational_expression -> expression LT expression .)
    FUNC            reduce using rule 146 (relational_expression -> expression LT expression .)
    TYPE            reduce using rule 146 (relational_expression -> expression LT expression .)
    IDENTIFIER      reduce using rule 146 (relational_expression -> expression LT expression .)
    VAR             reduce using rule 146 (relational_expression -> expression LT expression .)
    CONST           reduce using rule 146 (relational_expression -> expression LT expression .)
    LNOT            reduce using rule 146 (relational_expression -> expression LT expression .)
    LBRACKET        reduce using rule 146 (relational_expression -> expression LT expression .)
    LPAREN          reduce using rule 146 (relational_expression -> expression LT expression .)
    INT             reduce using rule 146 (relational_expression -> expression LT expression .)
    FLOAT64         reduce using rule 146 (relational_expression -> expression LT expression .)
    TRUE            reduce using rule 146 (relational_expression -> expression LT expression .)
    FALSE           reduce using rule 146 (relational_expression -> expression LT expression .)
    STRING          reduce using rule 146 (relational_expression -> expression LT expression .)
    RETURN          reduce using rule 146 (relational_expression -> expression LT expression .)
    FOR             reduce using rule 146 (relational_expression -> expression LT expression .)
    IF              reduce using rule 146 (relational_expression -> expression LT expression .)
    SWITCH          reduce using rule 146 (relational_expression -> expression LT expression .)
    BREAK           reduce using rule 146 (relational_expression -> expression LT expression .)
    CONTINUE        reduce using rule 146 (relational_expression -> expression LT expression .)
    FALLTHROUGH     reduce using rule 146 (relational_expression -> expression LT expression .)
    $end            reduce using rule 146 (relational_expression -> expression LT expression .)
    RPAREN          reduce using rule 146 (relational_expression -> expression LT expression .)
    COMMA           reduce using rule 146 (relational_expression -> expression LT expression .)
    RBRACE          reduce using rule 146 (relational_expression -> expression LT expression .)
    CASE            reduce using rule 146 (relational_expression -> expression LT expression .)
    DEFAULT         reduce using rule 146 (relational_expression -> expression LT expression .)
    LBRACE          reduce using rule 146 (relational_expression -> expression LT expression .)
    COLON           reduce using rule 146 (relational_expression -> expression LT expression .)
    EQ              shift and go to state 64
    NEQ             shift and go to state 65
    LAND            shift and go to state 70
    LOR             shift and go to state 71

  ! EQ              [ reduce using rule 146 (relational_expression -> expression LT expression .) ]
  ! NEQ             [ reduce using rule 146 (relational_expression -> expression LT expression .) ]
  ! LAND            [ reduce using rule 146 (relational_expression -> expression LT expression .) ]
  ! LOR             [ reduce using rule 146 (relational_expression -> expression LT expression .) ]
  ! DOT             [ shift and go to state 58 ]
  ! PLUS            [ shift and go to state 59 ]
  ! MINUS           [ shift and go to state 60 ]
  ! TIMES           [ shift and go to state 61 ]
  ! DIVIDE          [ shift and go to state 62 ]
  ! MODULE          [ shift and go to state 63 ]
  ! LT              [ shift and go to state 66 ]
  ! LE              [ shift and go to state 67 ]
  ! GT              [ shift and go to state 68 ]
  ! GE              [ shift and go to state 69 ]
  ! AND             [ shift and go to state 72 ]
  ! OR              [ shift and go to state 73 ]
  ! XOR             [ shift and go to state 74 ]
  ! AND_NOT         [ shift and go to state 75 ]
  ! LSHIFT          [ shift and go to state 76 ]
  ! RSHIFT          [ shift and go to state 77 ]


state 127

    (147) relational_expression -> expression LE expression .
    (100) expression -> expression . DOT IDENTIFIER
    (135) binary_expression -> expression . PLUS expression
    (136) binary_expression -> expression . MINUS expression
    (137) binary_expression -> expression . TIMES expression
    (138) binary_expression -> expression . DIVIDE expression
    (139) binary_expression -> expression . MODULE expression
    (144) relational_expression -> expression . EQ expression
    (145) relational_expression -> expression . NEQ expression
    (146) relational_expression -> expression . LT expression
    (147) relational_expression -> expression . LE expression
    (148) relational_expression -> expression . GT expression
    (149) relational_expression -> expression . GE expression
    (150) logical_expression -> expression . LAND expression
    (151) logical_expression -> expression . LOR expression
    (152) bitwise_expression -> expression . AND expression
    (153) bitwise_expression -> expression . OR expression
    (154) bitwise_expression -> expression . XOR expression
    (155) bitwise_expression -> expression . AND_NOT expression
    (156) bitwise_expression -> expression . LSHIFT expression
    (157) bitwise_expression -> expression . RSHIFT expression

    DOT             reduce using rule 147 (relational_expression -> expression LE expression .)
    PLUS            reduce using rule 147 (relational_expression -> expression LE expression .)
    MINUS           reduce using rule 147 (relational_expression -> expression LE expression .)
    TIMES           reduce using rule 147 (relational_expression -> expression LE expression .)
    DIVIDE          reduce using rule 147 (relational_expression -> expression LE expression .)
    MODULE          reduce using rule 147 (relational_expression -> expression LE expression .)
    LT              reduce using rule 147 (relational_expression -> expression LE expression .)
    LE              reduce using rule 147 (relational_expression -> expression LE expression .)
    GT              reduce using rule 147 (relational_expression -> expression LE expression .)
    GE              reduce using rule 147 (relational_expression -> expression LE expression .)
    AND             reduce using rule 147 (relational_expression -> expression LE expression .)
    OR              reduce using rule 147 (relational_expression -> expression LE expression .)
    XOR             reduce using rule 147 (relational_expression -> expression LE expression .)
    AND_NOT         reduce using rule 147 (relational_expression -> expression LE expression .)
    LSHIFT          reduce using rule 147 (relational_expression -> expression LE expression .)
    RSHIFT          reduce using rule 147 (relational_expression -> expression LE expression .)
    SEMICOLON       reduce using rule 147 (relational_expression -> expression LE expression .)
    FUNC            reduce using rule 147 (relational_expression -> expression LE expression .)
    TYPE            reduce using rule 147 (relational_expression -> expression LE expression .)
    IDENTIFIER      reduce using rule 147 (relational_expression -> expression LE expression .)
    VAR             reduce using rule 147 (relational_expression -> expression LE expression .)
    CONST           reduce using rule 147 (relational_expression -> expression LE expression .)
    LNOT            reduce using rule 147 (relational_expression -> expression LE expression .)
    LBRACKET        reduce using rule 147 (relational_expression -> expression LE expression .)
    LPAREN          reduce using rule 147 (relational_expression -> expression LE expression .)
    INT             reduce using rule 147 (relational_expression -> expression LE expression .)
    FLOAT64         reduce using rule 147 (relational_expression -> expression LE expression .)
    TRUE            reduce using rule 147 (relational_expression -> expression LE expression .)
    FALSE           reduce using rule 147 (relational_expression -> expression LE expression .)
    STRING          reduce using rule 147 (relational_expression -> expression LE expression .)
    RETURN          reduce using rule 147 (relational_expression -> expression LE expression .)
    FOR             reduce using rule 147 (relational_expression -> expression LE expression .)
    IF              reduce using rule 147 (relational_expression -> expression LE expression .)
    SWITCH          reduce using rule 147 (relational_expression -> expression LE expression .)
    BREAK           reduce using rule 147 (relational_expression -> expression LE expression .)
    CONTINUE        reduce using rule 147 (relational_expression -> expression LE expression .)
    FALLTHROUGH     reduce using rule 147 (relational_expression -> expression LE expression .)
    $end            reduce using rule 147 (relational_expression -> expression LE expression .)
    RPAREN          reduce using rule 147 (relational_expression -> expression LE expression .)
    COMMA           reduce using rule 147 (relational_expression -> expression LE expression .)
    RBRACE          reduce using rule 147 (relational_expression -> expression LE expression .)
    CASE            reduce using rule 147 (relational_expression -> expression LE expression .)
    DEFAULT         reduce using rule 147 (relational_expression -> expression LE expression .)
    LBRACE          reduce using rule 147 (relational_expression -> expression LE expression .)
    COLON           reduce using rule 147 (relational_expression -> expression LE expression .)
    EQ              shift and go to state 64
    NEQ             shift and go to state 65
    LAND            shift and go to state 70
    LOR             shift and go to state 71

  ! EQ              [ reduce using rule 147 (relational_expression -> expression LE expression .) ]
  ! NEQ             [ reduce using rule 147 (relational_expression -> expression LE expression .) ]
  ! LAND            [ reduce using rule 147 (relational_expression -> expression LE expression .) ]
  ! LOR             [ reduce using rule 147 (relational_expression -> expression LE expression .) ]
  ! DOT             [ shift and go to state 58 ]
  ! PLUS            [ shift and go to state 59 ]
  ! MINUS           [ shift and go to state 60 ]
  ! TIMES           [ shift and go to state 61 ]
  ! DIVIDE          [ shift and go to state 62 ]
  ! MODULE          [ shift and go to state 63 ]
  ! LT              [ shift and go to state 66 ]
  ! LE              [ shift and go to state 67 ]
  ! GT              [ shift and go to state 68 ]
  ! GE              [ shift and go to state 69 ]
  ! AND             [ shift and go to state 72 ]
  ! OR              [ shift and go to state 73 ]
  ! XOR             [ shift and go to state 74 ]
  ! AND_NOT         [ shift and go to state 75 ]
  ! LSHIFT          [ shift and go to state 76 ]
  ! RSHIFT          [ shift and go to state 77 ]


state 128

    (148) relational_expression -> expression GT expression .
    (100) expression -> expression . DOT IDENTIFIER
    (135) binary_expression -> expression . PLUS expression
    (136) binary_expression -> expression . MINUS expression
    (137) binary_expression -> expression . TIMES expression
    (138) binary_expression -> expression . DIVIDE expression
    (139) binary_expression -> expression . MODULE expression
    (144) relational_expression -> expression . EQ expression
    (145) relational_expression -> expression . NEQ expression
    (146) relational_expression -> expression . LT expression
    (147) relational_expression -> expression . LE expression
    (148) relational_expression -> expression . GT expression
    (149) relational_expression -> expression . GE expression
    (150) logical_expression -> expression . LAND expression
    (151) logical_expression -> expression . LOR expression
    (152) bitwise_expression -> expression . AND expression
    (153) bitwise_expression -> expression . OR expression
    (154) bitwise_expression -> expression . XOR expression
    (155) bitwise_expression -> expression . AND_NOT expression
    (156) bitwise_expression -> expression . LSHIFT expression
    (157) bitwise_expression -> expression . RSHIFT expression

    DOT             reduce using rule 148 (relational_expression -> expression GT expression .)
    PLUS            reduce using rule 148 (relational_expression -> expression GT expression .)
    MINUS           reduce using rule 148 (relational_expression -> expression GT expression .)
    TIMES           reduce using rule 148 (relational_expression -> expression GT expression .)
    DIVIDE          reduce using rule 148 (relational_expression -> expression GT expression .)
    MODULE          reduce using rule 148 (relational_expression -> expression GT expression .)
    LT              reduce using rule 148 (relational_expression -> expression GT expression .)
    LE              reduce using rule 148 (relational_expression -> expression GT expression .)
    GT              reduce using rule 148 (relational_expression -> expression GT expression .)
    GE              reduce using rule 148 (relational_expression -> expression GT expression .)
    AND             reduce using rule 148 (relational_expression -> expression GT expression .)
    OR              reduce using rule 148 (relational_expression -> expression GT expression .)
    XOR             reduce using rule 148 (relational_expression -> expression GT expression .)
    AND_NOT         reduce using rule 148 (relational_expression -> expression GT expression .)
    LSHIFT          reduce using rule 148 (relational_expression -> expression GT expression .)
    RSHIFT          reduce using rule 148 (relational_expression -> expression GT expression .)
    SEMICOLON       reduce using rule 148 (relational_expression -> expression GT expression .)
    FUNC            reduce using rule 148 (relational_expression -> expression GT expression .)
    TYPE            reduce using rule 148 (relational_expression -> expression GT expression .)
    IDENTIFIER      reduce using rule 148 (relational_expression -> expression GT expression .)
    VAR             reduce using rule 148 (relational_expression -> expression GT expression .)
    CONST           reduce using rule 148 (relational_expression -> expression GT expression .)
    LNOT            reduce using rule 148 (relational_expression -> expression GT expression .)
    LBRACKET        reduce using rule 148 (relational_expression -> expression GT expression .)
    LPAREN          reduce using rule 148 (relational_expression -> expression GT expression .)
    INT             reduce using rule 148 (relational_expression -> expression GT expression .)
    FLOAT64         reduce using rule 148 (relational_expression -> expression GT expression .)
    TRUE            reduce using rule 148 (relational_expression -> expression GT expression .)
    FALSE           reduce using rule 148 (relational_expression -> expression GT expression .)
    STRING          reduce using rule 148 (relational_expression -> expression GT expression .)
    RETURN          reduce using rule 148 (relational_expression -> expression GT expression .)
    FOR             reduce using rule 148 (relational_expression -> expression GT expression .)
    IF              reduce using rule 148 (relational_expression -> expression GT expression .)
    SWITCH          reduce using rule 148 (relational_expression -> expression GT expression .)
    BREAK           reduce using rule 148 (relational_expression -> expression GT expression .)
    CONTINUE        reduce using rule 148 (relational_expression -> expression GT expression .)
    FALLTHROUGH     reduce using rule 148 (relational_expression -> expression GT expression .)
    $end            reduce using rule 148 (relational_expression -> expression GT expression .)
    RPAREN          reduce using rule 148 (relational_expression -> expression GT expression .)
    COMMA           reduce using rule 148 (relational_expression -> expression GT expression .)
    RBRACE          reduce using rule 148 (relational_expression -> expression GT expression .)
    CASE            reduce using rule 148 (relational_expression -> expression GT expression .)
    DEFAULT         reduce using rule 148 (relational_expression -> expression GT expression .)
    LBRACE          reduce using rule 148 (relational_expression -> expression GT expression .)
    COLON           reduce using rule 148 (relational_expression -> expression GT expression .)
    EQ              shift and go to state 64
    NEQ             shift and go to state 65
    LAND            shift and go to state 70
    LOR             shift and go to state 71

  ! EQ              [ reduce using rule 148 (relational_expression -> expression GT expression .) ]
  ! NEQ             [ reduce using rule 148 (relational_expression -> expression GT expression .) ]
  ! LAND            [ reduce using rule 148 (relational_expression -> expression GT expression .) ]
  ! LOR             [ reduce using rule 148 (relational_expression -> expression GT expression .) ]
  ! DOT             [ shift and go to state 58 ]
  ! PLUS            [ shift and go to state 59 ]
  ! MINUS           [ shift and go to state 60 ]
  ! TIMES           [ shift and go to state 61 ]
  ! DIVIDE          [ shift and go to state 62 ]
  ! MODULE          [ shift and go to state 63 ]
  ! LT              [ shift and go to state 66 ]
  ! LE              [ shift and go to state 67 ]
  ! GT              [ shift and go to state 68 ]
  ! GE              [ shift and go to state 69 ]
  ! AND             [ shift and go to state 72 ]
  ! OR              [ shift and go to state 73 ]
  ! XOR             [ shift and go to state 74 ]
  ! AND_NOT         [ shift and go to state 75 ]
  ! LSHIFT          [ shift and go to state 76 ]
  ! RSHIFT          [ shift and go to state 77 ]


state 129

    (149) relational_expression -> expression GE expression .
    (100) expression -> expression . DOT IDENTIFIER
    (135) binary_expression -> expression . PLUS expression
    (136) binary_expression -> expression . MINUS expression
    (137) binary_expression -> expression . TIMES expression
    (138) binary_expression -> expression . DIVIDE expression
    (139) binary_expression -> expression . MODULE expression
    (144) relational_expression -> expression . EQ expression
    (145) relational_expression -> expression . NEQ expression
    (146) relational_expression -> expression . LT expression
    (147) relational_expression -> expression . LE expression
    (148) relational_expression -> expression . GT expression
    (149) relational_expression -> expression . GE expression
    (150) logical_expression -> expression . LAND expression
    (151) logical_expression -> expression . LOR expression
    (152) bitwise_expression -> expression . AND expression
    (153) bitwise_expression -> expression . OR expression
    (154) bitwise_expression -> expression . XOR expression
    (155) bitwise_expression -> expression . AND_NOT expression
    (156) bitwise_expression -> expression . LSHIFT expression
    (157) bitwise_expression -> expression . RSHIFT expression

    DOT             reduce using rule 149 (relational_expression -> expression GE expression .)
    PLUS            reduce using rule 149 (relational_expression -> expression GE expression .)
    MINUS           reduce using rule 149 (relational_expression -> expression GE expression .)
    TIMES           reduce using rule 149 (relational_expression -> expression GE expression .)
    DIVIDE          reduce using rule 149 (relational_expression -> expression GE expression .)
    MODULE          reduce using rule 149 (relational_expression -> expression GE expression .)
    LT              reduce using rule 149 (relational_expression -> expression GE expression .)
    LE              reduce using rule 149 (relational_expression -> expression GE expression .)
    GT              reduce using rule 149 (relational_expression -> expression GE expression .)
    GE              reduce using rule 149 (relational_expression -> expression GE expression .)
    AND             reduce using rule 149 (relational_expression -> expression GE expression .)
    OR              reduce using rule 149 (relational_expression -> expression GE expression .)
    XOR             reduce using rule 149 (relational_expression -> expression GE expression .)
    AND_NOT         reduce using rule 149 (relational_expression -> expression GE expression .)
    LSHIFT          reduce using rule 149 (relational_expression -> expression GE expression .)
    RSHIFT          reduce using rule 149 (relational_expression -> expression GE expression .)
    SEMICOLON       reduce using rule 149 (relational_expression -> expression GE expression .)
    FUNC            reduce using rule 149 (relational_expression -> expression GE expression .)
    TYPE            reduce using rule 149 (relational_expression -> expression GE expression .)
    IDENTIFIER      reduce using rule 149 (relational_expression -> expression GE expression .)
    VAR             reduce using rule 149 (relational_expression -> expression GE expression .)
    CONST           reduce using rule 149 (relational_expression -> expression GE expression .)
    LNOT            reduce using rule 149 (relational_expression -> expression GE expression .)
    LBRACKET        reduce using rule 149 (relational_expression -> expression GE expression .)
    LPAREN          reduce using rule 149 (relational_expression -> expression GE expression .)
    INT             reduce using rule 149 (relational_expression -> expression GE expression .)
    FLOAT64         reduce using rule 149 (relational_expression -> expression GE expression .)
    TRUE            reduce using rule 149 (relational_expression -> expression GE expression .)
    FALSE           reduce using rule 149 (relational_expression -> expression GE expression .)
    STRING          reduce using rule 149 (relational_expression -> expression GE expression .)
    RETURN          reduce using rule 149 (relational_expression -> expression GE expression .)
    FOR             reduce using rule 149 (relational_expression -> expression GE expression .)
    IF              reduce using rule 149 (relational_expression -> expression GE expression .)
    SWITCH          reduce using rule 149 (relational_expression -> expression GE expression .)
    BREAK           reduce using rule 149 (relational_expression -> expression GE expression .)
    CONTINUE        reduce using rule 149 (relational_expression -> expression GE expression .)
    FALLTHROUGH     reduce using rule 149 (relational_expression -> expression GE expression .)
    $end            reduce using rule 149 (relational_expression -> expression GE expression .)
    RPAREN          reduce using rule 149 (relational_expression -> expression GE expression .)
    COMMA           reduce using rule 149 (relational_expression -> expression GE expression .)
    RBRACE          reduce using rule 149 (relational_expression -> expression GE expression .)
    CASE            reduce using rule 149 (relational_expression -> expression GE expression .)
    DEFAULT         reduce using rule 149 (relational_expression -> expression GE expression .)
    LBRACE          reduce using rule 149 (relational_expression -> expression GE expression .)
    COLON           reduce using rule 149 (relational_expression -> expression GE expression .)
    EQ              shift and go to state 64
    NEQ             shift and go to state 65
    LAND            shift and go to state 70
    LOR             shift and go to state 71

  ! EQ              [ reduce using rule 149 (relational_expression -> expression GE expression .) ]
  ! NEQ             [ reduce using rule 149 (relational_expression -> expression GE expression .) ]
  ! LAND            [ reduce using rule 149 (relational_expression -> expression GE expression .) ]
  ! LOR             [ reduce using rule 149 (relational_expression -> expression GE expression .) ]
  ! DOT             [ shift and go to state 58 ]
  ! PLUS            [ shift and go to state 59 ]
  ! MINUS           [ shift and go to state 60 ]
  ! TIMES           [ shift and go to state 61 ]
  ! DIVIDE          [ shift and go to state 62 ]
  ! MODULE          [ shift and go to state 63 ]
  ! LT              [ shift and go to state 66 ]
  ! LE              [ shift and go to state 67 ]
  ! GT              [ shift and go to state 68 ]
  ! GE              [ shift and go to state 69 ]
  ! AND             [ shift and go to state 72 ]
  ! OR              [ shift and go to state 73 ]
  ! XOR             [ shift and go to state 74 ]
  ! AND_NOT         [ shift and go to state 75 ]
  ! LSHIFT          [ shift and go to state 76 ]
  ! RSHIFT          [ shift and go to state 77 ]


state 130

    (150) logical_expression -> expression LAND expression .
    (100) expression -> expression . DOT IDENTIFIER
    (135) binary_expression -> expression . PLUS expression
    (136) binary_expression -> expression . MINUS expression
    (137) binary_expression -> expression . TIMES expression
    (138) binary_expression -> expression . DIVIDE expression
    (139) binary_expression -> expression . MODULE expression
    (144) relational_expression -> expression . EQ expression
    (145) relational_expression -> expression . NEQ expression
    (146) relational_expression -> expression . LT expression
    (147) relational_expression -> expression . LE expression
    (148) relational_expression -> expression . GT expression
    (149) relational_expression -> expression . GE expression
    (150) logical_expression -> expression . LAND expression
    (151) logical_expression -> expression . LOR expression
    (152) bitwise_expression -> expression . AND expression
    (153) bitwise_expression -> expression . OR expression
    (154) bitwise_expression -> expression . XOR expression
    (155) bitwise_expression -> expression . AND_NOT expression
    (156) bitwise_expression -> expression . LSHIFT expression
    (157) bitwise_expression -> expression . RSHIFT expression

    DOT             reduce using rule 150 (logical_expression -> expression LAND expression .)
    PLUS            reduce using rule 150 (logical_expression -> expression LAND expression .)
    MINUS           reduce using rule 150 (logical_expression -> expression LAND expression .)
    TIMES           reduce using rule 150 (logical_expression -> expression LAND expression .)
    DIVIDE          reduce using rule 150 (logical_expression -> expression LAND expression .)
    MODULE          reduce using rule 150 (logical_expression -> expression LAND expression .)
    EQ              reduce using rule 150 (logical_expression -> expression LAND expression .)
    NEQ             reduce using rule 150 (logical_expression -> expression LAND expression .)
    LT              reduce using rule 150 (logical_expression -> expression LAND expression .)
    LE              reduce using rule 150 (logical_expression -> expression LAND expression .)
    GT              reduce using rule 150 (logical_expression -> expression LAND expression .)
    GE              reduce using rule 150 (logical_expression -> expression LAND expression .)
    LAND            reduce using rule 150 (logical_expression -> expression LAND expression .)
    AND             reduce using rule 150 (logical_expression -> expression LAND expression .)
    OR              reduce using rule 150 (logical_expression -> expression LAND expression .)
    XOR             reduce using rule 150 (logical_expression -> expression LAND expression .)
    AND_NOT         reduce using rule 150 (logical_expression -> expression LAND expression .)
    LSHIFT          reduce using rule 150 (logical_expression -> expression LAND expression .)
    RSHIFT          reduce using rule 150 (logical_expression -> expression LAND expression .)
    SEMICOLON       reduce using rule 150 (logical_expression -> expression LAND expression .)
    FUNC            reduce using rule 150 (logical_expression -> expression LAND expression .)
    TYPE            reduce using rule 150 (logical_expression -> expression LAND expression .)
    IDENTIFIER      reduce using rule 150 (logical_expression -> expression LAND expression .)
    VAR             reduce using rule 150 (logical_expression -> expression LAND expression .)
    CONST           reduce using rule 150 (logical_expression -> expression LAND expression .)
    LNOT            reduce using rule 150 (logical_expression -> expression LAND expression .)
    LBRACKET        reduce using rule 150 (logical_expression -> expression LAND expression .)
    LPAREN          reduce using rule 150 (logical_expression -> expression LAND expression .)
    INT             reduce using rule 150 (logical_expression -> expression LAND expression .)
    FLOAT64         reduce using rule 150 (logical_expression -> expression LAND expression .)
    TRUE            reduce using rule 150 (logical_expression -> expression LAND expression .)
    FALSE           reduce using rule 150 (logical_expression -> expression LAND expression .)
    STRING          reduce using rule 150 (logical_expression -> expression LAND expression .)
    RETURN          reduce using rule 150 (logical_expression -> expression LAND expression .)
    FOR             reduce using rule 150 (logical_expression -> expression LAND expression .)
    IF              reduce using rule 150 (logical_expression -> expression LAND expression .)
    SWITCH          reduce using rule 150 (logical_expression -> expression LAND expression .)
    BREAK           reduce using rule 150 (logical_expression -> expression LAND expression .)
    CONTINUE        reduce using rule 150 (logical_expression -> expression LAND expression .)
    FALLTHROUGH     reduce using rule 150 (logical_expression -> expression LAND expression .)
    $end            reduce using rule 150 (logical_expression -> expression LAND expression .)
    RPAREN          reduce using rule 150 (logical_expression -> expression LAND expression .)
    COMMA           reduce using rule 150 (logical_expression -> expression LAND expression .)
    RBRACE          reduce using rule 150 (logical_expression -> expression LAND expression .)
    CASE            reduce using rule 150 (logical_expression -> expression LAND expression .)
    DEFAULT         reduce using rule 150 (logical_expression -> expression LAND expression .)
    LBRACE          reduce using rule 150 (logical_expression -> expression LAND expression .)
    COLON           reduce using rule 150 (logical_expression -> expression LAND expression .)
    LOR             shift and go to state 71

  ! LOR             [ reduce using rule 150 (logical_expression -> expression LAND expression .) ]
  ! DOT             [ shift and go to state 58 ]
  ! PLUS            [ shift and go to state 59 ]
  ! MINUS           [ shift and go to state 60 ]
  ! TIMES           [ shift and go to state 61 ]
  ! DIVIDE          [ shift and go to state 62 ]
  ! MODULE          [ shift and go to state 63 ]
  ! EQ              [ shift and go to state 64 ]
  ! NEQ             [ shift and go to state 65 ]
  ! LT              [ shift and go to state 66 ]
  ! LE              [ shift and go to state 67 ]
  ! GT              [ shift and go to state 68 ]
  ! GE              [ shift and go to state 69 ]
  ! LAND            [ shift and go to state 70 ]
  ! AND             [ shift and go to state 72 ]
  ! OR              [ shift and go to state 73 ]
  ! XOR             [ shift and go to state 74 ]
  ! AND_NOT         [ shift and go to state 75 ]
  ! LSHIFT          [ shift and go to state 76 ]
  ! RSHIFT          [ shift and go to state 77 ]


state 131

    (151) logical_expression -> expression LOR expression .
    (100) expression -> expression . DOT IDENTIFIER
    (135) binary_expression -> expression . PLUS expression
    (136) binary_expression -> expression . MINUS expression
    (137) binary_expression -> expression . TIMES expression
    (138) binary_expression -> expression . DIVIDE expression
    (139) binary_expression -> expression . MODULE expression
    (144) relational_expression -> expression . EQ expression
    (145) relational_expression -> expression . NEQ expression
    (146) relational_expression -> expression . LT expression
    (147) relational_expression -> expression . LE expression
    (148) relational_expression -> expression . GT expression
    (149) relational_expression -> expression . GE expression
    (150) logical_expression -> expression . LAND expression
    (151) logical_expression -> expression . LOR expression
    (152) bitwise_expression -> expression . AND expression
    (153) bitwise_expression -> expression . OR expression
    (154) bitwise_expression -> expression . XOR expression
    (155) bitwise_expression -> expression . AND_NOT expression
    (156) bitwise_expression -> expression . LSHIFT expression
    (157) bitwise_expression -> expression . RSHIFT expression

    DOT             reduce using rule 151 (logical_expression -> expression LOR expression .)
    PLUS            reduce using rule 151 (logical_expression -> expression LOR expression .)
    MINUS           reduce using rule 151 (logical_expression -> expression LOR expression .)
    TIMES           reduce using rule 151 (logical_expression -> expression LOR expression .)
    DIVIDE          reduce using rule 151 (logical_expression -> expression LOR expression .)
    MODULE          reduce using rule 151 (logical_expression -> expression LOR expression .)
    EQ              reduce using rule 151 (logical_expression -> expression LOR expression .)
    NEQ             reduce using rule 151 (logical_expression -> expression LOR expression .)
    LT              reduce using rule 151 (logical_expression -> expression LOR expression .)
    LE              reduce using rule 151 (logical_expression -> expression LOR expression .)
    GT              reduce using rule 151 (logical_expression -> expression LOR expression .)
    GE              reduce using rule 151 (logical_expression -> expression LOR expression .)
    LAND            reduce using rule 151 (logical_expression -> expression LOR expression .)
    LOR             reduce using rule 151 (logical_expression -> expression LOR expression .)
    AND             reduce using rule 151 (logical_expression -> expression LOR expression .)
    OR              reduce using rule 151 (logical_expression -> expression LOR expression .)
    XOR             reduce using rule 151 (logical_expression -> expression LOR expression .)
    AND_NOT         reduce using rule 151 (logical_expression -> expression LOR expression .)
    LSHIFT          reduce using rule 151 (logical_expression -> expression LOR expression .)
    RSHIFT          reduce using rule 151 (logical_expression -> expression LOR expression .)
    SEMICOLON       reduce using rule 151 (logical_expression -> expression LOR expression .)
    FUNC            reduce using rule 151 (logical_expression -> expression LOR expression .)
    TYPE            reduce using rule 151 (logical_expression -> expression LOR expression .)
    IDENTIFIER      reduce using rule 151 (logical_expression -> expression LOR expression .)
    VAR             reduce using rule 151 (logical_expression -> expression LOR expression .)
    CONST           reduce using rule 151 (logical_expression -> expression LOR expression .)
    LNOT            reduce using rule 151 (logical_expression -> expression LOR expression .)
    LBRACKET        reduce using rule 151 (logical_expression -> expression LOR expression .)
    LPAREN          reduce using rule 151 (logical_expression -> expression LOR expression .)
    INT             reduce using rule 151 (logical_expression -> expression LOR expression .)
    FLOAT64         reduce using rule 151 (logical_expression -> expression LOR expression .)
    TRUE            reduce using rule 151 (logical_expression -> expression LOR expression .)
    FALSE           reduce using rule 151 (logical_expression -> expression LOR expression .)
    STRING          reduce using rule 151 (logical_expression -> expression LOR expression .)
    RETURN          reduce using rule 151 (logical_expression -> expression LOR expression .)
    FOR             reduce using rule 151 (logical_expression -> expression LOR expression .)
    IF              reduce using rule 151 (logical_expression -> expression LOR expression .)
    SWITCH          reduce using rule 151 (logical_expression -> expression LOR expression .)
    BREAK           reduce using rule 151 (logical_expression -> expression LOR expression .)
    CONTINUE        reduce using rule 151 (logical_expression -> expression LOR expression .)
    FALLTHROUGH     reduce using rule 151 (logical_expression -> expression LOR expression .)
    $end            reduce using rule 151 (logical_expression -> expression LOR expression .)
    RPAREN          reduce using rule 151 (logical_expression -> expression LOR expression .)
    COMMA           reduce using rule 151 (logical_expression -> expression LOR expression .)
    RBRACE          reduce using rule 151 (logical_expression -> expression LOR expression .)
    CASE            reduce using rule 151 (logical_expression -> expression LOR expression .)
    DEFAULT         reduce using rule 151 (logical_expression -> expression LOR expression .)
    LBRACE          reduce using rule 151 (logical_expression -> expression LOR expression .)
    COLON           reduce using rule 151 (logical_expression -> expression LOR expression .)

  ! DOT             [ shift and go to state 58 ]
  ! PLUS            [ shift and go to state 59 ]
  ! MINUS           [ shift and go to state 60 ]
  ! TIMES           [ shift and go to state 61 ]
  ! DIVIDE          [ shift and go to state 62 ]
  ! MODULE          [ shift and go to state 63 ]
  ! EQ              [ shift and go to state 64 ]
  ! NEQ             [ shift and go to state 65 ]
  ! LT              [ shift and go to state 66 ]
  ! LE              [ shift and go to state 67 ]
  ! GT              [ shift and go to state 68 ]
  ! GE              [ shift and go to state 69 ]
  ! LAND            [ shift and go to state 70 ]
  ! LOR             [ shift and go to state 71 ]
  ! AND             [ shift and go to state 72 ]
  ! OR              [ shift and go to state 73 ]
  ! XOR             [ shift and go to state 74 ]
  ! AND_NOT         [ shift and go to state 75 ]
  ! LSHIFT          [ shift and go to state 76 ]
  ! RSHIFT          [ shift and go to state 77 ]


state 132

    (152) bitwise_expression -> expression AND expression .
    (100) expression -> expression . DOT IDENTIFIER
    (135) binary_expression -> expression . PLUS expression
    (136) binary_expression -> expression . MINUS expression
    (137) binary_expression -> expression . TIMES expression
    (138) binary_expression -> expression . DIVIDE expression
    (139) binary_expression -> expression . MODULE expression
    (144) relational_expression -> expression . EQ expression
    (145) relational_expression -> expression . NEQ expression
    (146) relational_expression -> expression . LT expression
    (147) relational_expression -> expression . LE expression
    (148) relational_expression -> expression . GT expression
    (149) relational_expression -> expression . GE expression
    (150) logical_expression -> expression . LAND expression
    (151) logical_expression -> expression . LOR expression
    (152) bitwise_expression -> expression . AND expression
    (153) bitwise_expression -> expression . OR expression
    (154) bitwise_expression -> expression . XOR expression
    (155) bitwise_expression -> expression . AND_NOT expression
    (156) bitwise_expression -> expression . LSHIFT expression
    (157) bitwise_expression -> expression . RSHIFT expression

    DOT             reduce using rule 152 (bitwise_expression -> expression AND expression .)
    PLUS            reduce using rule 152 (bitwise_expression -> expression AND expression .)
    MINUS           reduce using rule 152 (bitwise_expression -> expression AND expression .)
    TIMES           reduce using rule 152 (bitwise_expression -> expression AND expression .)
    DIVIDE          reduce using rule 152 (bitwise_expression -> expression AND expression .)
    MODULE          reduce using rule 152 (bitwise_expression -> expression AND expression .)
    AND             reduce using rule 152 (bitwise_expression -> expression AND expression .)
    AND_NOT         reduce using rule 152 (bitwise_expression -> expression AND expression .)
    LSHIFT          reduce using rule 152 (bitwise_expression -> expression AND expression .)
    RSHIFT          reduce using rule 152 (bitwise_expression -> expression AND expression .)
    SEMICOLON       reduce using rule 152 (bitwise_expression -> expression AND expression .)
    FUNC            reduce using rule 152 (bitwise_expression -> expression AND expression .)
    TYPE            reduce using rule 152 (bitwise_expression -> expression AND expression .)
    IDENTIFIER      reduce using rule 152 (bitwise_expression -> expression AND expression .)
    VAR             reduce using rule 152 (bitwise_expression -> expression AND expression .)
    CONST           reduce using rule 152 (bitwise_expression -> expression AND expression .)
    LNOT            reduce using rule 152 (bitwise_expression -> expression AND expression .)
    LBRACKET        reduce using rule 152 (bitwise_expression -> expression AND expression .)
    LPAREN          reduce using rule 152 (bitwise_expression -> expression AND expression .)
    INT             reduce using rule 152 (bitwise_expression -> expression AND expression .)
    FLOAT64         reduce using rule 152 (bitwise_expression -> expression AND expression .)
    TRUE            reduce using rule 152 (bitwise_expression -> expression AND expression .)
    FALSE           reduce using rule 152 (bitwise_expression -> expression AND expression .)
    STRING          reduce using rule 152 (bitwise_expression -> expression AND expression .)
    RETURN          reduce using rule 152 (bitwise_expression -> expression AND expression .)
    FOR             reduce using rule 152 (bitwise_expression -> expression AND expression .)
    IF              reduce using rule 152 (bitwise_expression -> expression AND expression .)
    SWITCH          reduce using rule 152 (bitwise_expression -> expression AND expression .)
    BREAK           reduce using rule 152 (bitwise_expression -> expression AND expression .)
    CONTINUE        reduce using rule 152 (bitwise_expression -> expression AND expression .)
    FALLTHROUGH     reduce using rule 152 (bitwise_expression -> expression AND expression .)
    $end            reduce using rule 152 (bitwise_expression -> expression AND expression .)
    RPAREN          reduce using rule 152 (bitwise_expression -> expression AND expression .)
    COMMA           reduce using rule 152 (bitwise_expression -> expression AND expression .)
    RBRACE          reduce using rule 152 (bitwise_expression -> expression AND expression .)
    CASE            reduce using rule 152 (bitwise_expression -> expression AND expression .)
    DEFAULT         reduce using rule 152 (bitwise_expression -> expression AND expression .)
    LBRACE          reduce using rule 152 (bitwise_expression -> expression AND expression .)
    COLON           reduce using rule 152 (bitwise_expression -> expression AND expression .)
    EQ              shift and go to state 64
    NEQ             shift and go to state 65
    LT              shift and go to state 66
    LE              shift and go to state 67
    GT              shift and go to state 68
    GE              shift and go to state 69
    LAND            shift and go to state 70
    LOR             shift and go to state 71
    OR              shift and go to state 73
    XOR             shift and go to state 74

  ! EQ              [ reduce using rule 152 (bitwise_expression -> expression AND expression .) ]
  ! NEQ             [ reduce using rule 152 (bitwise_expression -> expression AND expression .) ]
  ! LT              [ reduce using rule 152 (bitwise_expression -> expression AND expression .) ]
  ! LE              [ reduce using rule 152 (bitwise_expression -> expression AND expression .) ]
  ! GT              [ reduce using rule 152 (bitwise_expression -> expression AND expression .) ]
  ! GE              [ reduce using rule 152 (bitwise_expression -> expression AND expression .) ]
  ! LAND            [ reduce using rule 152 (bitwise_expression -> expression AND expression .) ]
  ! LOR             [ reduce using rule 152 (bitwise_expression -> expression AND expression .) ]
  ! OR              [ reduce using rule 152 (bitwise_expression -> expression AND expression .) ]
  ! XOR             [ reduce using rule 152 (bitwise_expression -> expression AND expression .) ]
  ! DOT             [ shift and go to state 58 ]
  ! PLUS            [ shift and go to state 59 ]
  ! MINUS           [ shift and go to state 60 ]
  ! TIMES           [ shift and go to state 61 ]
  ! DIVIDE          [ shift and go to state 62 ]
  ! MODULE          [ shift and go to state 63 ]
  ! AND             [ shift and go to state 72 ]
  ! AND_NOT         [ shift and go to state 75 ]
  ! LSHIFT          [ shift and go to state 76 ]
  ! RSHIFT          [ shift and go to state 77 ]


state 133

    (153) bitwise_expression -> expression OR expression .
    (100) expression -> expression . DOT IDENTIFIER
    (135) binary_expression -> expression . PLUS expression
    (136) binary_expression -> expression . MINUS expression
    (137) binary_expression -> expression . TIMES expression
    (138) binary_expression -> expression . DIVIDE expression
    (139) binary_expression -> expression . MODULE expression
    (144) relational_expression -> expression . EQ expression
    (145) relational_expression -> expression . NEQ expression
    (146) relational_expression -> expression . LT expression
    (147) relational_expression -> expression . LE expression
    (148) relational_expression -> expression . GT expression
    (149) relational_expression -> expression . GE expression
    (150) logical_expression -> expression . LAND expression
    (151) logical_expression -> expression . LOR expression
    (152) bitwise_expression -> expression . AND expression
    (153) bitwise_expression -> expression . OR expression
    (154) bitwise_expression -> expression . XOR expression
    (155) bitwise_expression -> expression . AND_NOT expression
    (156) bitwise_expression -> expression . LSHIFT expression
    (157) bitwise_expression -> expression . RSHIFT expression

    DOT             reduce using rule 153 (bitwise_expression -> expression OR expression .)
    PLUS            reduce using rule 153 (bitwise_expression -> expression OR expression .)
    MINUS           reduce using rule 153 (bitwise_expression -> expression OR expression .)
    TIMES           reduce using rule 153 (bitwise_expression -> expression OR expression .)
    DIVIDE          reduce using rule 153 (bitwise_expression -> expression OR expression .)
    MODULE          reduce using rule 153 (bitwise_expression -> expression OR expression .)
    AND             reduce using rule 153 (bitwise_expression -> expression OR expression .)
    OR              reduce using rule 153 (bitwise_expression -> expression OR expression .)
    XOR             reduce using rule 153 (bitwise_expression -> expression OR expression .)
    AND_NOT         reduce using rule 153 (bitwise_expression -> expression OR expression .)
    LSHIFT          reduce using rule 153 (bitwise_expression -> expression OR expression .)
    RSHIFT          reduce using rule 153 (bitwise_expression -> expression OR expression .)
    SEMICOLON       reduce using rule 153 (bitwise_expression -> expression OR expression .)
    FUNC            reduce using rule 153 (bitwise_expression -> expression OR expression .)
    TYPE            reduce using rule 153 (bitwise_expression -> expression OR expression .)
    IDENTIFIER      reduce using rule 153 (bitwise_expression -> expression OR expression .)
    VAR             reduce using rule 153 (bitwise_expression -> expression OR expression .)
    CONST           reduce using rule 153 (bitwise_expression -> expression OR expression .)
    LNOT            reduce using rule 153 (bitwise_expression -> expression OR expression .)
    LBRACKET        reduce using rule 153 (bitwise_expression -> expression OR expression .)
    LPAREN          reduce using rule 153 (bitwise_expression -> expression OR expression .)
    INT             reduce using rule 153 (bitwise_expression -> expression OR expression .)
    FLOAT64         reduce using rule 153 (bitwise_expression -> expression OR expression .)
    TRUE            reduce using rule 153 (bitwise_expression -> expression OR expression .)
    FALSE           reduce using rule 153 (bitwise_expression -> expression OR expression .)
    STRING          reduce using rule 153 (bitwise_expression -> expression OR expression .)
    RETURN          reduce using rule 153 (bitwise_expression -> expression OR expression .)
    FOR             reduce using rule 153 (bitwise_expression -> expression OR expression .)
    IF              reduce using rule 153 (bitwise_expression -> expression OR expression .)
    SWITCH          reduce using rule 153 (bitwise_expression -> expression OR expression .)
    BREAK           reduce using rule 153 (bitwise_expression -> expression OR expression .)
    CONTINUE        reduce using rule 153 (bitwise_expression -> expression OR expression .)
    FALLTHROUGH     reduce using rule 153 (bitwise_expression -> expression OR expression .)
    $end            reduce using rule 153 (bitwise_expression -> expression OR expression .)
    RPAREN          reduce using rule 153 (bitwise_expression -> expression OR expression .)
    COMMA           reduce using rule 153 (bitwise_expression -> expression OR expression .)
    RBRACE          reduce using rule 153 (bitwise_expression -> expression OR expression .)
    CASE            reduce using rule 153 (bitwise_expression -> expression OR expression .)
    DEFAULT         reduce using rule 153 (bitwise_expression -> expression OR expression .)
    LBRACE          reduce using rule 153 (bitwise_expression -> expression OR expression .)
    COLON           reduce using rule 153 (bitwise_expression -> expression OR expression .)
    EQ              shift and go to state 64
    NEQ             shift and go to state 65
    LT              shift and go to state 66
    LE              shift and go to state 67
    GT              shift and go to state 68
    GE              shift and go to state 69
    LAND            shift and go to state 70
    LOR             shift and go to state 71

  ! EQ              [ reduce using rule 153 (bitwise_expression -> expression OR expression .) ]
  ! NEQ             [ reduce using rule 153 (bitwise_expression -> expression OR expression .) ]
  ! LT              [ reduce using rule 153 (bitwise_expression -> expression OR expression .) ]
  ! LE              [ reduce using rule 153 (bitwise_expression -> expression OR expression .) ]
  ! GT              [ reduce using rule 153 (bitwise_expression -> expression OR expression .) ]
  ! GE              [ reduce using rule 153 (bitwise_expression -> expression OR expression .) ]
  ! LAND            [ reduce using rule 153 (bitwise_expression -> expression OR expression .) ]
  ! LOR             [ reduce using rule 153 (bitwise_expression -> expression OR expression .) ]
  ! DOT             [ shift and go to state 58 ]
  ! PLUS            [ shift and go to state 59 ]
  ! MINUS           [ shift and go to state 60 ]
  ! TIMES           [ shift and go to state 61 ]
  ! DIVIDE          [ shift and go to state 62 ]
  ! MODULE          [ shift and go to state 63 ]
  ! AND             [ shift and go to state 72 ]
  ! OR              [ shift and go to state 73 ]
  ! XOR             [ shift and go to state 74 ]
  ! AND_NOT         [ shift and go to state 75 ]
  ! LSHIFT          [ shift and go to state 76 ]
  ! RSHIFT          [ shift and go to state 77 ]


state 134

    (154) bitwise_expression -> expression XOR expression .
    (100) expression -> expression . DOT IDENTIFIER
    (135) binary_expression -> expression . PLUS expression
    (136) binary_expression -> expression . MINUS expression
    (137) binary_expression -> expression . TIMES expression
    (138) binary_expression -> expression . DIVIDE expression
    (139) binary_expression -> expression . MODULE expression
    (144) relational_expression -> expression . EQ expression
    (145) relational_expression -> expression . NEQ expression
    (146) relational_expression -> expression . LT expression
    (147) relational_expression -> expression . LE expression
    (148) relational_expression -> expression . GT expression
    (149) relational_expression -> expression . GE expression
    (150) logical_expression -> expression . LAND expression
    (151) logical_expression -> expression . LOR expression
    (152) bitwise_expression -> expression . AND expression
    (153) bitwise_expression -> expression . OR expression
    (154) bitwise_expression -> expression . XOR expression
    (155) bitwise_expression -> expression . AND_NOT expression
    (156) bitwise_expression -> expression . LSHIFT expression
    (157) bitwise_expression -> expression . RSHIFT expression

    DOT             reduce using rule 154 (bitwise_expression -> expression XOR expression .)
    PLUS            reduce using rule 154 (bitwise_expression -> expression XOR expression .)
    MINUS           reduce using rule 154 (bitwise_expression -> expression XOR expression .)
    TIMES           reduce using rule 154 (bitwise_expression -> expression XOR expression .)
    DIVIDE          reduce using rule 154 (bitwise_expression -> expression XOR expression .)
    MODULE          reduce using rule 154 (bitwise_expression -> expression XOR expression .)
    AND             reduce using rule 154 (bitwise_expression -> expression XOR expression .)
    XOR             reduce using rule 154 (bitwise_expression -> expression XOR expression .)
    AND_NOT         reduce using rule 154 (bitwise_expression -> expression XOR expression .)
    LSHIFT          reduce using rule 154 (bitwise_expression -> expression XOR expression .)
    RSHIFT          reduce using rule 154 (bitwise_expression -> expression XOR expression .)
    SEMICOLON       reduce using rule 154 (bitwise_expression -> expression XOR expression .)
    FUNC            reduce using rule 154 (bitwise_expression -> expression XOR expression .)
    TYPE            reduce using rule 154 (bitwise_expression -> expression XOR expression .)
    IDENTIFIER      reduce using rule 154 (bitwise_expression -> expression XOR expression .)
    VAR             reduce using rule 154 (bitwise_expression -> expression XOR expression .)
    CONST           reduce using rule 154 (bitwise_expression -> expression XOR expression .)
    LNOT            reduce using rule 154 (bitwise_expression -> expression XOR expression .)
    LBRACKET        reduce using rule 154 (bitwise_expression -> expression XOR expression .)
    LPAREN          reduce using rule 154 (bitwise_expression -> expression XOR expression .)
    INT             reduce using rule 154 (bitwise_expression -> expression XOR expression .)
    FLOAT64         reduce using rule 154 (bitwise_expression -> expression XOR expression .)
    TRUE            reduce using rule 154 (bitwise_expression -> expression XOR expression .)
    FALSE           reduce using rule 154 (bitwise_expression -> expression XOR expression .)
    STRING          reduce using rule 154 (bitwise_expression -> expression XOR expression .)
    RETURN          reduce using rule 154 (bitwise_expression -> expression XOR expression .)
    FOR             reduce using rule 154 (bitwise_expression -> expression XOR expression .)
    IF              reduce using rule 154 (bitwise_expression -> expression XOR expression .)
    SWITCH          reduce using rule 154 (bitwise_expression -> expression XOR expression .)
    BREAK           reduce using rule 154 (bitwise_expression -> expression XOR expression .)
    CONTINUE        reduce using rule 154 (bitwise_expression -> expression XOR expression .)
    FALLTHROUGH     reduce using rule 154 (bitwise_expression -> expression XOR expression .)
    $end            reduce using rule 154 (bitwise_expression -> expression XOR expression .)
    RPAREN          reduce using rule 154 (bitwise_expression -> expression XOR expression .)
    COMMA           reduce using rule 154 (bitwise_expression -> expression XOR expression .)
    RBRACE          reduce using rule 154 (bitwise_expression -> expression XOR expression .)
    CASE            reduce using rule 154 (bitwise_expression -> expression XOR expression .)
    DEFAULT         reduce using rule 154 (bitwise_expression -> expression XOR expression .)
    LBRACE          reduce using rule 154 (bitwise_expression -> expression XOR expression .)
    COLON           reduce using rule 154 (bitwise_expression -> expression XOR expression .)
    EQ              shift and go to state 64
    NEQ             shift and go to state 65
    LT              shift and go to state 66
    LE              shift and go to state 67
    GT              shift and go to state 68
    GE              shift and go to state 69
    LAND            shift and go to state 70
    LOR             shift and go to state 71
    OR              shift and go to state 73

  ! EQ              [ reduce using rule 154 (bitwise_expression -> expression XOR expression .) ]
  ! NEQ             [ reduce using rule 154 (bitwise_expression -> expression XOR expression .) ]
  ! LT              [ reduce using rule 154 (bitwise_expression -> expression XOR expression .) ]
  ! LE              [ reduce using rule 154 (bitwise_expression -> expression XOR expression .) ]
  ! GT              [ reduce using rule 154 (bitwise_expression -> expression XOR expression .) ]
  ! GE              [ reduce using rule 154 (bitwise_expression -> expression XOR expression .) ]
  ! LAND            [ reduce using rule 154 (bitwise_expression -> expression XOR expression .) ]
  ! LOR             [ reduce using rule 154 (bitwise_expression -> expression XOR expression .) ]
  ! OR              [ reduce using rule 154 (bitwise_expression -> expression XOR expression .) ]
  ! DOT             [ shift and go to state 58 ]
  ! PLUS            [ shift and go to state 59 ]
  ! MINUS           [ shift and go to state 60 ]
  ! TIMES           [ shift and go to state 61 ]
  ! DIVIDE          [ shift and go to state 62 ]
  ! MODULE          [ shift and go to state 63 ]
  ! AND             [ shift and go to state 72 ]
  ! XOR             [ shift and go to state 74 ]
  ! AND_NOT         [ shift and go to state 75 ]
  ! LSHIFT          [ shift and go to state 76 ]
  ! RSHIFT          [ shift and go to state 77 ]


state 135

    (155) bitwise_expression -> expression AND_NOT expression .
    (100) expression -> expression . DOT IDENTIFIER
    (135) binary_expression -> expression . PLUS expression
    (136) binary_expression -> expression . MINUS expression
    (137) binary_expression -> expression . TIMES expression
    (138) binary_expression -> expression . DIVIDE expression
    (139) binary_expression -> expression . MODULE expression
    (144) relational_expression -> expression . EQ expression
    (145) relational_expression -> expression . NEQ expression
    (146) relational_expression -> expression . LT expression
    (147) relational_expression -> expression . LE expression
    (148) relational_expression -> expression . GT expression
    (149) relational_expression -> expression . GE expression
    (150) logical_expression -> expression . LAND expression
    (151) logical_expression -> expression . LOR expression
    (152) bitwise_expression -> expression . AND expression
    (153) bitwise_expression -> expression . OR expression
    (154) bitwise_expression -> expression . XOR expression
    (155) bitwise_expression -> expression . AND_NOT expression
    (156) bitwise_expression -> expression . LSHIFT expression
    (157) bitwise_expression -> expression . RSHIFT expression

  ! shift/reduce conflict for DOT resolved as shift
>>>>>>> Stashed changes
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NEQ resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for LAND resolved as shift
  ! shift/reduce conflict for LOR resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for XOR resolved as shift
  ! shift/reduce conflict for AND_NOT resolved as shift
  ! shift/reduce conflict for LSHIFT resolved as shift
  ! shift/reduce conflict for RSHIFT resolved as shift
<<<<<<< Updated upstream
    VAR             reduce using rule 125 (expression -> LNOT expression .)
    CONST           reduce using rule 125 (expression -> LNOT expression .)
    FUNC            reduce using rule 125 (expression -> LNOT expression .)
    TYPE            reduce using rule 125 (expression -> LNOT expression .)
    $end            reduce using rule 125 (expression -> LNOT expression .)
    RPAREN          reduce using rule 125 (expression -> LNOT expression .)
    COMMA           reduce using rule 125 (expression -> LNOT expression .)
    RBRACKET        reduce using rule 125 (expression -> LNOT expression .)
    RBRACE          reduce using rule 125 (expression -> LNOT expression .)
    COLON           reduce using rule 125 (expression -> LNOT expression .)
    BREAK           reduce using rule 125 (expression -> LNOT expression .)
    CONTINUE        reduce using rule 125 (expression -> LNOT expression .)
    IDENTIFIER      reduce using rule 125 (expression -> LNOT expression .)
    LPAREN          reduce using rule 125 (expression -> LNOT expression .)
    INT             reduce using rule 125 (expression -> LNOT expression .)
    FLOAT64         reduce using rule 125 (expression -> LNOT expression .)
    STRING          reduce using rule 125 (expression -> LNOT expression .)
    TRUE            reduce using rule 125 (expression -> LNOT expression .)
    FALSE           reduce using rule 125 (expression -> LNOT expression .)
    LNOT            reduce using rule 125 (expression -> LNOT expression .)
    IF              reduce using rule 125 (expression -> LNOT expression .)
    SWITCH          reduce using rule 125 (expression -> LNOT expression .)
    RETURN          reduce using rule 125 (expression -> LNOT expression .)
    MAP             reduce using rule 125 (expression -> LNOT expression .)
    FOR             reduce using rule 125 (expression -> LNOT expression .)
    LBRACE          reduce using rule 125 (expression -> LNOT expression .)
    CASE            reduce using rule 125 (expression -> LNOT expression .)
    DEFAULT         reduce using rule 125 (expression -> LNOT expression .)
    SEMICOLON       reduce using rule 125 (expression -> LNOT expression .)
    DOT             shift and go to state 82
    LBRACKET        shift and go to state 83
    PLUS            shift and go to state 84
    MINUS           shift and go to state 85
    TIMES           shift and go to state 86
    DIVIDE          shift and go to state 87
    MODULE          shift and go to state 88
    EQ              shift and go to state 89
    NEQ             shift and go to state 90
    LT              shift and go to state 91
    LE              shift and go to state 92
    GT              shift and go to state 93
    GE              shift and go to state 94
    LAND            shift and go to state 95
    LOR             shift and go to state 96
    AND             shift and go to state 97
    OR              shift and go to state 98
    XOR             shift and go to state 99
    AND_NOT         shift and go to state 100
    LSHIFT          shift and go to state 101
    RSHIFT          shift and go to state 102

  ! DOT             [ reduce using rule 125 (expression -> LNOT expression .) ]
  ! LBRACKET        [ reduce using rule 125 (expression -> LNOT expression .) ]
  ! PLUS            [ reduce using rule 125 (expression -> LNOT expression .) ]
  ! MINUS           [ reduce using rule 125 (expression -> LNOT expression .) ]
  ! TIMES           [ reduce using rule 125 (expression -> LNOT expression .) ]
  ! DIVIDE          [ reduce using rule 125 (expression -> LNOT expression .) ]
  ! MODULE          [ reduce using rule 125 (expression -> LNOT expression .) ]
  ! EQ              [ reduce using rule 125 (expression -> LNOT expression .) ]
  ! NEQ             [ reduce using rule 125 (expression -> LNOT expression .) ]
  ! LT              [ reduce using rule 125 (expression -> LNOT expression .) ]
  ! LE              [ reduce using rule 125 (expression -> LNOT expression .) ]
  ! GT              [ reduce using rule 125 (expression -> LNOT expression .) ]
  ! GE              [ reduce using rule 125 (expression -> LNOT expression .) ]
  ! LAND            [ reduce using rule 125 (expression -> LNOT expression .) ]
  ! LOR             [ reduce using rule 125 (expression -> LNOT expression .) ]
  ! AND             [ reduce using rule 125 (expression -> LNOT expression .) ]
  ! OR              [ reduce using rule 125 (expression -> LNOT expression .) ]
  ! XOR             [ reduce using rule 125 (expression -> LNOT expression .) ]
  ! AND_NOT         [ reduce using rule 125 (expression -> LNOT expression .) ]
  ! LSHIFT          [ reduce using rule 125 (expression -> LNOT expression .) ]
  ! RSHIFT          [ reduce using rule 125 (expression -> LNOT expression .) ]

    binary_operator                shift and go to state 81

state 106

    (138) expression -> map_type LBRACE . expression_map_list RBRACE
    (139) expression -> map_type LBRACE . RBRACE
    (140) expression_map_list -> . key_value
    (141) expression_map_list -> . expression_map_list COMMA key_value
    (142) key_value -> . expression COLON expression
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (125) expression -> . LNOT expression
    (126) expression -> . IDENTIFIER PLUSPLUS
    (127) expression -> . IDENTIFIER MINUSMINUS
    (138) expression -> . map_type LBRACE expression_map_list RBRACE
    (139) expression -> . map_type LBRACE RBRACE
    (161) expression -> . type_name LBRACE keyed_element_list RBRACE
    (162) expression -> . type_name LBRACE RBRACE
    (198) expression -> . array_type LBRACE expression_list RBRACE
    (199) expression -> . array_type LBRACE RBRACE
    (200) expression -> . expression DOT IDENTIFIER
    (201) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> . expression LBRACKET expression RBRACKET
    (203) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (137) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (163) type_name -> . IDENTIFIER
    (164) type_name -> . slice_type
    (165) type_name -> . array_type
    (166) type_name -> . map_type
    (197) array_type -> . LBRACKET INT RBRACKET primitive_type

    RBRACE          shift and go to state 135
    LPAREN          shift and go to state 54
    INT             shift and go to state 55
    FLOAT64         shift and go to state 56
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 57
    TRUE            shift and go to state 58
    FALSE           shift and go to state 59
    LNOT            shift and go to state 60
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    map_type                       shift and go to state 61
    expression_map_list            shift and go to state 134
    key_value                      shift and go to state 136
    expression                     shift and go to state 137
    slice_type                     shift and go to state 53
    type_name                      shift and go to state 62
    array_type                     shift and go to state 63

state 107

    (161) expression -> type_name LBRACE . keyed_element_list RBRACE
    (162) expression -> type_name LBRACE . RBRACE
    (156) keyed_element_list -> . keyed_element
    (157) keyed_element_list -> . keyed_element_list COMMA keyed_element
    (158) keyed_element -> . IDENTIFIER COLON expression
    (159) keyed_element -> . INT COLON expression
    (160) keyed_element -> . expression
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (125) expression -> . LNOT expression
    (126) expression -> . IDENTIFIER PLUSPLUS
    (127) expression -> . IDENTIFIER MINUSMINUS
    (138) expression -> . map_type LBRACE expression_map_list RBRACE
    (139) expression -> . map_type LBRACE RBRACE
    (161) expression -> . type_name LBRACE keyed_element_list RBRACE
    (162) expression -> . type_name LBRACE RBRACE
    (198) expression -> . array_type LBRACE expression_list RBRACE
    (199) expression -> . array_type LBRACE RBRACE
    (200) expression -> . expression DOT IDENTIFIER
    (201) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> . expression LBRACKET expression RBRACKET
    (203) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (137) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (163) type_name -> . IDENTIFIER
    (164) type_name -> . slice_type
    (165) type_name -> . array_type
    (166) type_name -> . map_type
    (197) array_type -> . LBRACKET INT RBRACKET primitive_type

    RBRACE          shift and go to state 139
    IDENTIFIER      shift and go to state 141
    INT             shift and go to state 143
    LPAREN          shift and go to state 54
    FLOAT64         shift and go to state 56
    STRING          shift and go to state 57
    TRUE            shift and go to state 58
    FALSE           shift and go to state 59
    LNOT            shift and go to state 60
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    type_name                      shift and go to state 62
    keyed_element_list             shift and go to state 138
    keyed_element                  shift and go to state 140
    expression                     shift and go to state 142
    slice_type                     shift and go to state 53
    map_type                       shift and go to state 61
    array_type                     shift and go to state 63

state 108

    (198) expression -> array_type LBRACE . expression_list RBRACE
    (199) expression -> array_type LBRACE . RBRACE
    (68) expression_list -> . expression
    (69) expression_list -> . expression_list COMMA expression
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (125) expression -> . LNOT expression
    (126) expression -> . IDENTIFIER PLUSPLUS
    (127) expression -> . IDENTIFIER MINUSMINUS
    (138) expression -> . map_type LBRACE expression_map_list RBRACE
    (139) expression -> . map_type LBRACE RBRACE
    (161) expression -> . type_name LBRACE keyed_element_list RBRACE
    (162) expression -> . type_name LBRACE RBRACE
    (198) expression -> . array_type LBRACE expression_list RBRACE
    (199) expression -> . array_type LBRACE RBRACE
    (200) expression -> . expression DOT IDENTIFIER
    (201) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> . expression LBRACKET expression RBRACKET
    (203) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (137) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (163) type_name -> . IDENTIFIER
    (164) type_name -> . slice_type
    (165) type_name -> . array_type
    (166) type_name -> . map_type
    (197) array_type -> . LBRACKET INT RBRACKET primitive_type

    RBRACE          shift and go to state 145
    LPAREN          shift and go to state 54
    INT             shift and go to state 55
    FLOAT64         shift and go to state 56
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 57
    TRUE            shift and go to state 58
    FALSE           shift and go to state 59
    LNOT            shift and go to state 60
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    array_type                     shift and go to state 63
    expression_list                shift and go to state 144
    expression                     shift and go to state 127
    slice_type                     shift and go to state 53
    map_type                       shift and go to state 61
    type_name                      shift and go to state 62

state 109

    (65) slice_type -> LBRACKET RBRACKET primitive_type .

    ASSIGN          reduce using rule 65 (slice_type -> LBRACKET RBRACKET primitive_type .)
    VAR             reduce using rule 65 (slice_type -> LBRACKET RBRACKET primitive_type .)
    CONST           reduce using rule 65 (slice_type -> LBRACKET RBRACKET primitive_type .)
    FUNC            reduce using rule 65 (slice_type -> LBRACKET RBRACKET primitive_type .)
    TYPE            reduce using rule 65 (slice_type -> LBRACKET RBRACKET primitive_type .)
    $end            reduce using rule 65 (slice_type -> LBRACKET RBRACKET primitive_type .)
    LBRACE          reduce using rule 65 (slice_type -> LBRACKET RBRACKET primitive_type .)
    RPAREN          reduce using rule 65 (slice_type -> LBRACKET RBRACKET primitive_type .)
    COMMA           reduce using rule 65 (slice_type -> LBRACKET RBRACKET primitive_type .)
    RBRACE          reduce using rule 65 (slice_type -> LBRACKET RBRACKET primitive_type .)
    IDENTIFIER      reduce using rule 65 (slice_type -> LBRACKET RBRACKET primitive_type .)
    BREAK           reduce using rule 65 (slice_type -> LBRACKET RBRACKET primitive_type .)
    CONTINUE        reduce using rule 65 (slice_type -> LBRACKET RBRACKET primitive_type .)
    LPAREN          reduce using rule 65 (slice_type -> LBRACKET RBRACKET primitive_type .)
    INT             reduce using rule 65 (slice_type -> LBRACKET RBRACKET primitive_type .)
    FLOAT64         reduce using rule 65 (slice_type -> LBRACKET RBRACKET primitive_type .)
    STRING          reduce using rule 65 (slice_type -> LBRACKET RBRACKET primitive_type .)
    TRUE            reduce using rule 65 (slice_type -> LBRACKET RBRACKET primitive_type .)
    FALSE           reduce using rule 65 (slice_type -> LBRACKET RBRACKET primitive_type .)
    LNOT            reduce using rule 65 (slice_type -> LBRACKET RBRACKET primitive_type .)
    IF              reduce using rule 65 (slice_type -> LBRACKET RBRACKET primitive_type .)
    SWITCH          reduce using rule 65 (slice_type -> LBRACKET RBRACKET primitive_type .)
    RETURN          reduce using rule 65 (slice_type -> LBRACKET RBRACKET primitive_type .)
    LBRACKET        reduce using rule 65 (slice_type -> LBRACKET RBRACKET primitive_type .)
    MAP             reduce using rule 65 (slice_type -> LBRACKET RBRACKET primitive_type .)
    FOR             reduce using rule 65 (slice_type -> LBRACKET RBRACKET primitive_type .)
    SEMICOLON       reduce using rule 65 (slice_type -> LBRACKET RBRACKET primitive_type .)
    CASE            reduce using rule 65 (slice_type -> LBRACKET RBRACKET primitive_type .)
    DEFAULT         reduce using rule 65 (slice_type -> LBRACKET RBRACKET primitive_type .)


state 110

    (197) array_type -> LBRACKET INT RBRACKET . primitive_type
    (61) primitive_type -> . INT_TYPE
    (62) primitive_type -> . FLOAT64_TYPE
    (63) primitive_type -> . STRING_TYPE
    (64) primitive_type -> . BOOL_TYPE

    INT_TYPE        shift and go to state 34
    FLOAT64_TYPE    shift and go to state 35
    STRING_TYPE     shift and go to state 36
    BOOL_TYPE       shift and go to state 37

    primitive_type                 shift and go to state 146

state 111

    (137) map_type -> MAP LBRACKET primitive_type . RBRACKET primitive_type

    RBRACKET        shift and go to state 147


state 112

    (18) global_const_dec -> CONST IDENTIFIER type ASSIGN expression .
    (36) expression -> expression . binary_operator expression
    (200) expression -> expression . DOT IDENTIFIER
    (201) expression -> expression . DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> expression . LBRACKET expression RBRACKET
    (37) binary_operator -> . PLUS
    (38) binary_operator -> . MINUS
    (39) binary_operator -> . TIMES
    (40) binary_operator -> . DIVIDE
    (41) binary_operator -> . MODULE
    (42) binary_operator -> . EQ
    (43) binary_operator -> . NEQ
    (44) binary_operator -> . LT
    (45) binary_operator -> . LE
    (46) binary_operator -> . GT
    (47) binary_operator -> . GE
    (48) binary_operator -> . LAND
    (49) binary_operator -> . LOR
    (50) binary_operator -> . AND
    (51) binary_operator -> . OR
    (52) binary_operator -> . XOR
    (53) binary_operator -> . AND_NOT
    (54) binary_operator -> . LSHIFT
    (55) binary_operator -> . RSHIFT

    VAR             reduce using rule 18 (global_const_dec -> CONST IDENTIFIER type ASSIGN expression .)
    CONST           reduce using rule 18 (global_const_dec -> CONST IDENTIFIER type ASSIGN expression .)
    FUNC            reduce using rule 18 (global_const_dec -> CONST IDENTIFIER type ASSIGN expression .)
    TYPE            reduce using rule 18 (global_const_dec -> CONST IDENTIFIER type ASSIGN expression .)
    $end            reduce using rule 18 (global_const_dec -> CONST IDENTIFIER type ASSIGN expression .)
    DOT             shift and go to state 82
    LBRACKET        shift and go to state 83
    PLUS            shift and go to state 84
    MINUS           shift and go to state 85
    TIMES           shift and go to state 86
    DIVIDE          shift and go to state 87
    MODULE          shift and go to state 88
    EQ              shift and go to state 89
    NEQ             shift and go to state 90
    LT              shift and go to state 91
    LE              shift and go to state 92
    GT              shift and go to state 93
    GE              shift and go to state 94
    LAND            shift and go to state 95
    LOR             shift and go to state 96
    AND             shift and go to state 97
    OR              shift and go to state 98
    XOR             shift and go to state 99
    AND_NOT         shift and go to state 100
    LSHIFT          shift and go to state 101
    RSHIFT          shift and go to state 102

    binary_operator                shift and go to state 81

state 113

    (116) parameter -> IDENTIFIER type .

    RPAREN          reduce using rule 116 (parameter -> IDENTIFIER type .)
    COMMA           reduce using rule 116 (parameter -> IDENTIFIER type .)


state 114

    (117) parameter -> IDENTIFIER ELLIPSIS . primitive_type
    (61) primitive_type -> . INT_TYPE
    (62) primitive_type -> . FLOAT64_TYPE
    (63) primitive_type -> . STRING_TYPE
    (64) primitive_type -> . BOOL_TYPE

    INT_TYPE        shift and go to state 34
    FLOAT64_TYPE    shift and go to state 35
    STRING_TYPE     shift and go to state 36
    BOOL_TYPE       shift and go to state 37

    primitive_type                 shift and go to state 148

state 115

    (112) function_declaration -> FUNC IDENTIFIER LPAREN parameter_list RPAREN . return_type block
    (118) return_type -> . type
    (119) return_type -> . LPAREN type_list RPAREN
    (120) return_type -> . empty
    (57) type -> . primitive_type
    (58) type -> . slice_type
    (59) type -> . array_type
    (60) type -> . map_type
    (7) empty -> .
    (61) primitive_type -> . INT_TYPE
    (62) primitive_type -> . FLOAT64_TYPE
    (63) primitive_type -> . STRING_TYPE
    (64) primitive_type -> . BOOL_TYPE
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (197) array_type -> . LBRACKET INT RBRACKET primitive_type
    (137) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type

    LPAREN          shift and go to state 149
    LBRACE          reduce using rule 7 (empty -> .)
    INT_TYPE        shift and go to state 34
    FLOAT64_TYPE    shift and go to state 35
    STRING_TYPE     shift and go to state 36
    BOOL_TYPE       shift and go to state 37
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    return_type                    shift and go to state 150
    type                           shift and go to state 151
    empty                          shift and go to state 152
    primitive_type                 shift and go to state 30
    slice_type                     shift and go to state 31
    array_type                     shift and go to state 32
    map_type                       shift and go to state 33

state 116

    (113) parameter_list -> parameter_list COMMA . parameter
    (116) parameter -> . IDENTIFIER type
    (117) parameter -> . IDENTIFIER ELLIPSIS primitive_type

    IDENTIFIER      shift and go to state 69

    parameter                      shift and go to state 153

state 117

    (146) method_declaration -> FUNC LPAREN receiver RPAREN IDENTIFIER . LPAREN parameter_list RPAREN return_type block

    LPAREN          shift and go to state 154


state 118

    (148) receiver -> IDENTIFIER TIMES IDENTIFIER .

    RPAREN          reduce using rule 148 (receiver -> IDENTIFIER TIMES IDENTIFIER .)


state 119

    (149) receiver -> IDENTIFIER TIMES type .

    RPAREN          reduce using rule 149 (receiver -> IDENTIFIER TIMES type .)


state 120

    (154) struct_type -> STRUCT LBRACE RBRACE .

    VAR             reduce using rule 154 (struct_type -> STRUCT LBRACE RBRACE .)
    CONST           reduce using rule 154 (struct_type -> STRUCT LBRACE RBRACE .)
    FUNC            reduce using rule 154 (struct_type -> STRUCT LBRACE RBRACE .)
    TYPE            reduce using rule 154 (struct_type -> STRUCT LBRACE RBRACE .)
    $end            reduce using rule 154 (struct_type -> STRUCT LBRACE RBRACE .)


state 121

    (155) struct_type -> STRUCT LBRACE field_list . RBRACE
    (144) field_list -> field_list . field_declaration
    (145) field_declaration -> . IDENTIFIER type

    RBRACE          shift and go to state 155
    IDENTIFIER      shift and go to state 123

    field_declaration              shift and go to state 156

state 122

    (143) field_list -> field_declaration .

    RBRACE          reduce using rule 143 (field_list -> field_declaration .)
    IDENTIFIER      reduce using rule 143 (field_list -> field_declaration .)


state 123

    (145) field_declaration -> IDENTIFIER . type
    (57) type -> . primitive_type
    (58) type -> . slice_type
    (59) type -> . array_type
    (60) type -> . map_type
    (61) primitive_type -> . INT_TYPE
    (62) primitive_type -> . FLOAT64_TYPE
    (63) primitive_type -> . STRING_TYPE
    (64) primitive_type -> . BOOL_TYPE
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (197) array_type -> . LBRACKET INT RBRACKET primitive_type
    (137) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type

    INT_TYPE        shift and go to state 34
    FLOAT64_TYPE    shift and go to state 35
    STRING_TYPE     shift and go to state 36
    BOOL_TYPE       shift and go to state 37
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    type                           shift and go to state 157
    primitive_type                 shift and go to state 30
    slice_type                     shift and go to state 31
    array_type                     shift and go to state 32
    map_type                       shift and go to state 33

state 124

    (203) expression -> IDENTIFIER LPAREN argument_list . RPAREN

    RPAREN          shift and go to state 158


state 125

    (204) argument_list -> expression_list .
    (69) expression_list -> expression_list . COMMA expression

    RPAREN          reduce using rule 204 (argument_list -> expression_list .)
    COMMA           shift and go to state 159


state 126

    (205) argument_list -> empty .

    RPAREN          reduce using rule 205 (argument_list -> empty .)


state 127

    (68) expression_list -> expression .
    (36) expression -> expression . binary_operator expression
    (200) expression -> expression . DOT IDENTIFIER
    (201) expression -> expression . DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> expression . LBRACKET expression RBRACKET
    (37) binary_operator -> . PLUS
    (38) binary_operator -> . MINUS
    (39) binary_operator -> . TIMES
    (40) binary_operator -> . DIVIDE
    (41) binary_operator -> . MODULE
    (42) binary_operator -> . EQ
    (43) binary_operator -> . NEQ
    (44) binary_operator -> . LT
    (45) binary_operator -> . LE
    (46) binary_operator -> . GT
    (47) binary_operator -> . GE
    (48) binary_operator -> . LAND
    (49) binary_operator -> . LOR
    (50) binary_operator -> . AND
    (51) binary_operator -> . OR
    (52) binary_operator -> . XOR
    (53) binary_operator -> . AND_NOT
    (54) binary_operator -> . LSHIFT
    (55) binary_operator -> . RSHIFT

    COMMA           reduce using rule 68 (expression_list -> expression .)
    RPAREN          reduce using rule 68 (expression_list -> expression .)
    RBRACE          reduce using rule 68 (expression_list -> expression .)
    DOT             shift and go to state 82
    LBRACKET        shift and go to state 83
    PLUS            shift and go to state 84
    MINUS           shift and go to state 85
    TIMES           shift and go to state 86
    DIVIDE          shift and go to state 87
    MODULE          shift and go to state 88
    EQ              shift and go to state 89
    NEQ             shift and go to state 90
    LT              shift and go to state 91
    LE              shift and go to state 92
    GT              shift and go to state 93
    GE              shift and go to state 94
    LAND            shift and go to state 95
    LOR             shift and go to state 96
    AND             shift and go to state 97
    OR              shift and go to state 98
    XOR             shift and go to state 99
    AND_NOT         shift and go to state 100
    LSHIFT          shift and go to state 101
    RSHIFT          shift and go to state 102

    binary_operator                shift and go to state 81

state 128

    (36) expression -> expression binary_operator expression .
    (36) expression -> expression . binary_operator expression
    (200) expression -> expression . DOT IDENTIFIER
    (201) expression -> expression . DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> expression . LBRACKET expression RBRACKET
    (37) binary_operator -> . PLUS
    (38) binary_operator -> . MINUS
    (39) binary_operator -> . TIMES
    (40) binary_operator -> . DIVIDE
    (41) binary_operator -> . MODULE
    (42) binary_operator -> . EQ
    (43) binary_operator -> . NEQ
    (44) binary_operator -> . LT
    (45) binary_operator -> . LE
    (46) binary_operator -> . GT
    (47) binary_operator -> . GE
    (48) binary_operator -> . LAND
    (49) binary_operator -> . LOR
    (50) binary_operator -> . AND
    (51) binary_operator -> . OR
    (52) binary_operator -> . XOR
    (53) binary_operator -> . AND_NOT
    (54) binary_operator -> . LSHIFT
    (55) binary_operator -> . RSHIFT

  ! shift/reduce conflict for DOT resolved as shift
  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NEQ resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for LAND resolved as shift
  ! shift/reduce conflict for LOR resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for XOR resolved as shift
  ! shift/reduce conflict for AND_NOT resolved as shift
  ! shift/reduce conflict for LSHIFT resolved as shift
  ! shift/reduce conflict for RSHIFT resolved as shift
    VAR             reduce using rule 36 (expression -> expression binary_operator expression .)
    CONST           reduce using rule 36 (expression -> expression binary_operator expression .)
    FUNC            reduce using rule 36 (expression -> expression binary_operator expression .)
    TYPE            reduce using rule 36 (expression -> expression binary_operator expression .)
    $end            reduce using rule 36 (expression -> expression binary_operator expression .)
    RPAREN          reduce using rule 36 (expression -> expression binary_operator expression .)
    COMMA           reduce using rule 36 (expression -> expression binary_operator expression .)
    RBRACKET        reduce using rule 36 (expression -> expression binary_operator expression .)
    RBRACE          reduce using rule 36 (expression -> expression binary_operator expression .)
    COLON           reduce using rule 36 (expression -> expression binary_operator expression .)
    BREAK           reduce using rule 36 (expression -> expression binary_operator expression .)
    CONTINUE        reduce using rule 36 (expression -> expression binary_operator expression .)
    IDENTIFIER      reduce using rule 36 (expression -> expression binary_operator expression .)
    LPAREN          reduce using rule 36 (expression -> expression binary_operator expression .)
    INT             reduce using rule 36 (expression -> expression binary_operator expression .)
    FLOAT64         reduce using rule 36 (expression -> expression binary_operator expression .)
    STRING          reduce using rule 36 (expression -> expression binary_operator expression .)
    TRUE            reduce using rule 36 (expression -> expression binary_operator expression .)
    FALSE           reduce using rule 36 (expression -> expression binary_operator expression .)
    LNOT            reduce using rule 36 (expression -> expression binary_operator expression .)
    IF              reduce using rule 36 (expression -> expression binary_operator expression .)
    SWITCH          reduce using rule 36 (expression -> expression binary_operator expression .)
    RETURN          reduce using rule 36 (expression -> expression binary_operator expression .)
    MAP             reduce using rule 36 (expression -> expression binary_operator expression .)
    FOR             reduce using rule 36 (expression -> expression binary_operator expression .)
    LBRACE          reduce using rule 36 (expression -> expression binary_operator expression .)
    CASE            reduce using rule 36 (expression -> expression binary_operator expression .)
    DEFAULT         reduce using rule 36 (expression -> expression binary_operator expression .)
    SEMICOLON       reduce using rule 36 (expression -> expression binary_operator expression .)
    DOT             shift and go to state 82
    LBRACKET        shift and go to state 83
    PLUS            shift and go to state 84
    MINUS           shift and go to state 85
    TIMES           shift and go to state 86
    DIVIDE          shift and go to state 87
    MODULE          shift and go to state 88
    EQ              shift and go to state 89
    NEQ             shift and go to state 90
    LT              shift and go to state 91
    LE              shift and go to state 92
    GT              shift and go to state 93
    GE              shift and go to state 94
    LAND            shift and go to state 95
    LOR             shift and go to state 96
    AND             shift and go to state 97
    OR              shift and go to state 98
    XOR             shift and go to state 99
    AND_NOT         shift and go to state 100
    LSHIFT          shift and go to state 101
    RSHIFT          shift and go to state 102

  ! DOT             [ reduce using rule 36 (expression -> expression binary_operator expression .) ]
  ! LBRACKET        [ reduce using rule 36 (expression -> expression binary_operator expression .) ]
  ! PLUS            [ reduce using rule 36 (expression -> expression binary_operator expression .) ]
  ! MINUS           [ reduce using rule 36 (expression -> expression binary_operator expression .) ]
  ! TIMES           [ reduce using rule 36 (expression -> expression binary_operator expression .) ]
  ! DIVIDE          [ reduce using rule 36 (expression -> expression binary_operator expression .) ]
  ! MODULE          [ reduce using rule 36 (expression -> expression binary_operator expression .) ]
  ! EQ              [ reduce using rule 36 (expression -> expression binary_operator expression .) ]
  ! NEQ             [ reduce using rule 36 (expression -> expression binary_operator expression .) ]
  ! LT              [ reduce using rule 36 (expression -> expression binary_operator expression .) ]
  ! LE              [ reduce using rule 36 (expression -> expression binary_operator expression .) ]
  ! GT              [ reduce using rule 36 (expression -> expression binary_operator expression .) ]
  ! GE              [ reduce using rule 36 (expression -> expression binary_operator expression .) ]
  ! LAND            [ reduce using rule 36 (expression -> expression binary_operator expression .) ]
  ! LOR             [ reduce using rule 36 (expression -> expression binary_operator expression .) ]
  ! AND             [ reduce using rule 36 (expression -> expression binary_operator expression .) ]
  ! OR              [ reduce using rule 36 (expression -> expression binary_operator expression .) ]
  ! XOR             [ reduce using rule 36 (expression -> expression binary_operator expression .) ]
  ! AND_NOT         [ reduce using rule 36 (expression -> expression binary_operator expression .) ]
  ! LSHIFT          [ reduce using rule 36 (expression -> expression binary_operator expression .) ]
  ! RSHIFT          [ reduce using rule 36 (expression -> expression binary_operator expression .) ]

    binary_operator                shift and go to state 81

state 129

    (200) expression -> expression DOT IDENTIFIER .
    (201) expression -> expression DOT IDENTIFIER . LPAREN argument_list RPAREN

  ! shift/reduce conflict for LPAREN resolved as shift
    DOT             reduce using rule 200 (expression -> expression DOT IDENTIFIER .)
    LBRACKET        reduce using rule 200 (expression -> expression DOT IDENTIFIER .)
    PLUS            reduce using rule 200 (expression -> expression DOT IDENTIFIER .)
    MINUS           reduce using rule 200 (expression -> expression DOT IDENTIFIER .)
    TIMES           reduce using rule 200 (expression -> expression DOT IDENTIFIER .)
    DIVIDE          reduce using rule 200 (expression -> expression DOT IDENTIFIER .)
    MODULE          reduce using rule 200 (expression -> expression DOT IDENTIFIER .)
    EQ              reduce using rule 200 (expression -> expression DOT IDENTIFIER .)
    NEQ             reduce using rule 200 (expression -> expression DOT IDENTIFIER .)
    LT              reduce using rule 200 (expression -> expression DOT IDENTIFIER .)
    LE              reduce using rule 200 (expression -> expression DOT IDENTIFIER .)
    GT              reduce using rule 200 (expression -> expression DOT IDENTIFIER .)
    GE              reduce using rule 200 (expression -> expression DOT IDENTIFIER .)
    LAND            reduce using rule 200 (expression -> expression DOT IDENTIFIER .)
    LOR             reduce using rule 200 (expression -> expression DOT IDENTIFIER .)
    AND             reduce using rule 200 (expression -> expression DOT IDENTIFIER .)
    OR              reduce using rule 200 (expression -> expression DOT IDENTIFIER .)
    XOR             reduce using rule 200 (expression -> expression DOT IDENTIFIER .)
    AND_NOT         reduce using rule 200 (expression -> expression DOT IDENTIFIER .)
    LSHIFT          reduce using rule 200 (expression -> expression DOT IDENTIFIER .)
    RSHIFT          reduce using rule 200 (expression -> expression DOT IDENTIFIER .)
    VAR             reduce using rule 200 (expression -> expression DOT IDENTIFIER .)
    CONST           reduce using rule 200 (expression -> expression DOT IDENTIFIER .)
    FUNC            reduce using rule 200 (expression -> expression DOT IDENTIFIER .)
    TYPE            reduce using rule 200 (expression -> expression DOT IDENTIFIER .)
    $end            reduce using rule 200 (expression -> expression DOT IDENTIFIER .)
    RPAREN          reduce using rule 200 (expression -> expression DOT IDENTIFIER .)
    COMMA           reduce using rule 200 (expression -> expression DOT IDENTIFIER .)
    RBRACKET        reduce using rule 200 (expression -> expression DOT IDENTIFIER .)
    RBRACE          reduce using rule 200 (expression -> expression DOT IDENTIFIER .)
    COLON           reduce using rule 200 (expression -> expression DOT IDENTIFIER .)
    BREAK           reduce using rule 200 (expression -> expression DOT IDENTIFIER .)
    CONTINUE        reduce using rule 200 (expression -> expression DOT IDENTIFIER .)
    IDENTIFIER      reduce using rule 200 (expression -> expression DOT IDENTIFIER .)
    INT             reduce using rule 200 (expression -> expression DOT IDENTIFIER .)
    FLOAT64         reduce using rule 200 (expression -> expression DOT IDENTIFIER .)
    STRING          reduce using rule 200 (expression -> expression DOT IDENTIFIER .)
    TRUE            reduce using rule 200 (expression -> expression DOT IDENTIFIER .)
    FALSE           reduce using rule 200 (expression -> expression DOT IDENTIFIER .)
    LNOT            reduce using rule 200 (expression -> expression DOT IDENTIFIER .)
    IF              reduce using rule 200 (expression -> expression DOT IDENTIFIER .)
    SWITCH          reduce using rule 200 (expression -> expression DOT IDENTIFIER .)
    RETURN          reduce using rule 200 (expression -> expression DOT IDENTIFIER .)
    MAP             reduce using rule 200 (expression -> expression DOT IDENTIFIER .)
    FOR             reduce using rule 200 (expression -> expression DOT IDENTIFIER .)
    LBRACE          reduce using rule 200 (expression -> expression DOT IDENTIFIER .)
    CASE            reduce using rule 200 (expression -> expression DOT IDENTIFIER .)
    DEFAULT         reduce using rule 200 (expression -> expression DOT IDENTIFIER .)
    SEMICOLON       reduce using rule 200 (expression -> expression DOT IDENTIFIER .)
    LPAREN          shift and go to state 160

  ! LPAREN          [ reduce using rule 200 (expression -> expression DOT IDENTIFIER .) ]


state 130

    (202) expression -> expression LBRACKET expression . RBRACKET
    (36) expression -> expression . binary_operator expression
    (200) expression -> expression . DOT IDENTIFIER
    (201) expression -> expression . DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> expression . LBRACKET expression RBRACKET
    (37) binary_operator -> . PLUS
    (38) binary_operator -> . MINUS
    (39) binary_operator -> . TIMES
    (40) binary_operator -> . DIVIDE
    (41) binary_operator -> . MODULE
    (42) binary_operator -> . EQ
    (43) binary_operator -> . NEQ
    (44) binary_operator -> . LT
    (45) binary_operator -> . LE
    (46) binary_operator -> . GT
    (47) binary_operator -> . GE
    (48) binary_operator -> . LAND
    (49) binary_operator -> . LOR
    (50) binary_operator -> . AND
    (51) binary_operator -> . OR
    (52) binary_operator -> . XOR
    (53) binary_operator -> . AND_NOT
    (54) binary_operator -> . LSHIFT
    (55) binary_operator -> . RSHIFT

    RBRACKET        shift and go to state 161
    DOT             shift and go to state 82
    LBRACKET        shift and go to state 83
    PLUS            shift and go to state 84
    MINUS           shift and go to state 85
    TIMES           shift and go to state 86
    DIVIDE          shift and go to state 87
    MODULE          shift and go to state 88
    EQ              shift and go to state 89
    NEQ             shift and go to state 90
    LT              shift and go to state 91
    LE              shift and go to state 92
    GT              shift and go to state 93
    GE              shift and go to state 94
    LAND            shift and go to state 95
    LOR             shift and go to state 96
    AND             shift and go to state 97
    OR              shift and go to state 98
    XOR             shift and go to state 99
    AND_NOT         shift and go to state 100
    LSHIFT          shift and go to state 101
    RSHIFT          shift and go to state 102

    binary_operator                shift and go to state 81

state 131

    (66) expression -> slice_type LBRACE expression_list . RBRACE
    (69) expression_list -> expression_list . COMMA expression

    RBRACE          shift and go to state 162
    COMMA           shift and go to state 159


state 132

    (67) expression -> slice_type LBRACE RBRACE .

    DOT             reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    LBRACKET        reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    PLUS            reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    MINUS           reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    TIMES           reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    DIVIDE          reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    MODULE          reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    EQ              reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    NEQ             reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    LT              reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    LE              reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    GT              reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    GE              reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    LAND            reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    LOR             reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    AND             reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    OR              reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    XOR             reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    AND_NOT         reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    LSHIFT          reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    RSHIFT          reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    VAR             reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    CONST           reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    FUNC            reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    TYPE            reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    $end            reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    RPAREN          reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    COMMA           reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    RBRACKET        reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    RBRACE          reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    COLON           reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    BREAK           reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    CONTINUE        reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    IDENTIFIER      reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    LPAREN          reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    INT             reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    FLOAT64         reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    STRING          reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    TRUE            reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    FALSE           reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    LNOT            reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    IF              reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    SWITCH          reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    RETURN          reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    MAP             reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    FOR             reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    LBRACE          reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    CASE            reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    DEFAULT         reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)
    SEMICOLON       reduce using rule 67 (expression -> slice_type LBRACE RBRACE .)


state 133

    (70) expression -> LPAREN expression RPAREN .

    DOT             reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    LBRACKET        reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    PLUS            reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    TIMES           reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    MODULE          reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    EQ              reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    NEQ             reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    LT              reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    LE              reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    GT              reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    GE              reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    LAND            reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    LOR             reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    AND             reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    OR              reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    XOR             reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    AND_NOT         reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    LSHIFT          reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    RSHIFT          reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    VAR             reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    CONST           reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    FUNC            reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    TYPE            reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    $end            reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    COMMA           reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    RBRACKET        reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    RBRACE          reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    COLON           reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    BREAK           reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    CONTINUE        reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    IDENTIFIER      reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    LPAREN          reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    INT             reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    FLOAT64         reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    STRING          reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    TRUE            reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    FALSE           reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    LNOT            reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    IF              reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    SWITCH          reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    RETURN          reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    MAP             reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    FOR             reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    LBRACE          reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    CASE            reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    DEFAULT         reduce using rule 70 (expression -> LPAREN expression RPAREN .)
    SEMICOLON       reduce using rule 70 (expression -> LPAREN expression RPAREN .)


state 134

    (138) expression -> map_type LBRACE expression_map_list . RBRACE
    (141) expression_map_list -> expression_map_list . COMMA key_value

    RBRACE          shift and go to state 163
    COMMA           shift and go to state 164


state 135

    (139) expression -> map_type LBRACE RBRACE .

    DOT             reduce using rule 139 (expression -> map_type LBRACE RBRACE .)
    LBRACKET        reduce using rule 139 (expression -> map_type LBRACE RBRACE .)
    PLUS            reduce using rule 139 (expression -> map_type LBRACE RBRACE .)
    MINUS           reduce using rule 139 (expression -> map_type LBRACE RBRACE .)
    TIMES           reduce using rule 139 (expression -> map_type LBRACE RBRACE .)
    DIVIDE          reduce using rule 139 (expression -> map_type LBRACE RBRACE .)
    MODULE          reduce using rule 139 (expression -> map_type LBRACE RBRACE .)
    EQ              reduce using rule 139 (expression -> map_type LBRACE RBRACE .)
    NEQ             reduce using rule 139 (expression -> map_type LBRACE RBRACE .)
    LT              reduce using rule 139 (expression -> map_type LBRACE RBRACE .)
    LE              reduce using rule 139 (expression -> map_type LBRACE RBRACE .)
    GT              reduce using rule 139 (expression -> map_type LBRACE RBRACE .)
    GE              reduce using rule 139 (expression -> map_type LBRACE RBRACE .)
    LAND            reduce using rule 139 (expression -> map_type LBRACE RBRACE .)
    LOR             reduce using rule 139 (expression -> map_type LBRACE RBRACE .)
    AND             reduce using rule 139 (expression -> map_type LBRACE RBRACE .)
    OR              reduce using rule 139 (expression -> map_type LBRACE RBRACE .)
    XOR             reduce using rule 139 (expression -> map_type LBRACE RBRACE .)
    AND_NOT         reduce using rule 139 (expression -> map_type LBRACE RBRACE .)
    LSHIFT          reduce using rule 139 (expression -> map_type LBRACE RBRACE .)
    RSHIFT          reduce using rule 139 (expression -> map_type LBRACE RBRACE .)
    VAR             reduce using rule 139 (expression -> map_type LBRACE RBRACE .)
    CONST           reduce using rule 139 (expression -> map_type LBRACE RBRACE .)
    FUNC            reduce using rule 139 (expression -> map_type LBRACE RBRACE .)
    TYPE            reduce using rule 139 (expression -> map_type LBRACE RBRACE .)
    $end            reduce using rule 139 (expression -> map_type LBRACE RBRACE .)
    RPAREN          reduce using rule 139 (expression -> map_type LBRACE RBRACE .)
    COMMA           reduce using rule 139 (expression -> map_type LBRACE RBRACE .)
    RBRACKET        reduce using rule 139 (expression -> map_type LBRACE RBRACE .)
    RBRACE          reduce using rule 139 (expression -> map_type LBRACE RBRACE .)
    COLON           reduce using rule 139 (expression -> map_type LBRACE RBRACE .)
    BREAK           reduce using rule 139 (expression -> map_type LBRACE RBRACE .)
    CONTINUE        reduce using rule 139 (expression -> map_type LBRACE RBRACE .)
    IDENTIFIER      reduce using rule 139 (expression -> map_type LBRACE RBRACE .)
    LPAREN          reduce using rule 139 (expression -> map_type LBRACE RBRACE .)
    INT             reduce using rule 139 (expression -> map_type LBRACE RBRACE .)
    FLOAT64         reduce using rule 139 (expression -> map_type LBRACE RBRACE .)
    STRING          reduce using rule 139 (expression -> map_type LBRACE RBRACE .)
    TRUE            reduce using rule 139 (expression -> map_type LBRACE RBRACE .)
    FALSE           reduce using rule 139 (expression -> map_type LBRACE RBRACE .)
    LNOT            reduce using rule 139 (expression -> map_type LBRACE RBRACE .)
    IF              reduce using rule 139 (expression -> map_type LBRACE RBRACE .)
    SWITCH          reduce using rule 139 (expression -> map_type LBRACE RBRACE .)
    RETURN          reduce using rule 139 (expression -> map_type LBRACE RBRACE .)
    MAP             reduce using rule 139 (expression -> map_type LBRACE RBRACE .)
    FOR             reduce using rule 139 (expression -> map_type LBRACE RBRACE .)
    LBRACE          reduce using rule 139 (expression -> map_type LBRACE RBRACE .)
    CASE            reduce using rule 139 (expression -> map_type LBRACE RBRACE .)
    DEFAULT         reduce using rule 139 (expression -> map_type LBRACE RBRACE .)
    SEMICOLON       reduce using rule 139 (expression -> map_type LBRACE RBRACE .)
=======
    SEMICOLON       reduce using rule 155 (bitwise_expression -> expression AND_NOT expression .)
    FUNC            reduce using rule 155 (bitwise_expression -> expression AND_NOT expression .)
    TYPE            reduce using rule 155 (bitwise_expression -> expression AND_NOT expression .)
    IDENTIFIER      reduce using rule 155 (bitwise_expression -> expression AND_NOT expression .)
    VAR             reduce using rule 155 (bitwise_expression -> expression AND_NOT expression .)
    CONST           reduce using rule 155 (bitwise_expression -> expression AND_NOT expression .)
    LNOT            reduce using rule 155 (bitwise_expression -> expression AND_NOT expression .)
    LBRACKET        reduce using rule 155 (bitwise_expression -> expression AND_NOT expression .)
    LPAREN          reduce using rule 155 (bitwise_expression -> expression AND_NOT expression .)
    INT             reduce using rule 155 (bitwise_expression -> expression AND_NOT expression .)
    FLOAT64         reduce using rule 155 (bitwise_expression -> expression AND_NOT expression .)
    TRUE            reduce using rule 155 (bitwise_expression -> expression AND_NOT expression .)
    FALSE           reduce using rule 155 (bitwise_expression -> expression AND_NOT expression .)
    STRING          reduce using rule 155 (bitwise_expression -> expression AND_NOT expression .)
    RETURN          reduce using rule 155 (bitwise_expression -> expression AND_NOT expression .)
    FOR             reduce using rule 155 (bitwise_expression -> expression AND_NOT expression .)
    IF              reduce using rule 155 (bitwise_expression -> expression AND_NOT expression .)
    SWITCH          reduce using rule 155 (bitwise_expression -> expression AND_NOT expression .)
    BREAK           reduce using rule 155 (bitwise_expression -> expression AND_NOT expression .)
    CONTINUE        reduce using rule 155 (bitwise_expression -> expression AND_NOT expression .)
    FALLTHROUGH     reduce using rule 155 (bitwise_expression -> expression AND_NOT expression .)
    $end            reduce using rule 155 (bitwise_expression -> expression AND_NOT expression .)
    RPAREN          reduce using rule 155 (bitwise_expression -> expression AND_NOT expression .)
    COMMA           reduce using rule 155 (bitwise_expression -> expression AND_NOT expression .)
    RBRACE          reduce using rule 155 (bitwise_expression -> expression AND_NOT expression .)
    CASE            reduce using rule 155 (bitwise_expression -> expression AND_NOT expression .)
    DEFAULT         reduce using rule 155 (bitwise_expression -> expression AND_NOT expression .)
    LBRACE          reduce using rule 155 (bitwise_expression -> expression AND_NOT expression .)
    COLON           reduce using rule 155 (bitwise_expression -> expression AND_NOT expression .)
    DOT             shift and go to state 58
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    TIMES           shift and go to state 61
    DIVIDE          shift and go to state 62
    MODULE          shift and go to state 63
    EQ              shift and go to state 64
    NEQ             shift and go to state 65
    LT              shift and go to state 66
    LE              shift and go to state 67
    GT              shift and go to state 68
    GE              shift and go to state 69
    LAND            shift and go to state 70
    LOR             shift and go to state 71
    AND             shift and go to state 72
    OR              shift and go to state 73
    XOR             shift and go to state 74
    AND_NOT         shift and go to state 75
    LSHIFT          shift and go to state 76
    RSHIFT          shift and go to state 77

  ! DOT             [ reduce using rule 155 (bitwise_expression -> expression AND_NOT expression .) ]
  ! PLUS            [ reduce using rule 155 (bitwise_expression -> expression AND_NOT expression .) ]
  ! MINUS           [ reduce using rule 155 (bitwise_expression -> expression AND_NOT expression .) ]
  ! TIMES           [ reduce using rule 155 (bitwise_expression -> expression AND_NOT expression .) ]
  ! DIVIDE          [ reduce using rule 155 (bitwise_expression -> expression AND_NOT expression .) ]
  ! MODULE          [ reduce using rule 155 (bitwise_expression -> expression AND_NOT expression .) ]
  ! EQ              [ reduce using rule 155 (bitwise_expression -> expression AND_NOT expression .) ]
  ! NEQ             [ reduce using rule 155 (bitwise_expression -> expression AND_NOT expression .) ]
  ! LT              [ reduce using rule 155 (bitwise_expression -> expression AND_NOT expression .) ]
  ! LE              [ reduce using rule 155 (bitwise_expression -> expression AND_NOT expression .) ]
  ! GT              [ reduce using rule 155 (bitwise_expression -> expression AND_NOT expression .) ]
  ! GE              [ reduce using rule 155 (bitwise_expression -> expression AND_NOT expression .) ]
  ! LAND            [ reduce using rule 155 (bitwise_expression -> expression AND_NOT expression .) ]
  ! LOR             [ reduce using rule 155 (bitwise_expression -> expression AND_NOT expression .) ]
  ! AND             [ reduce using rule 155 (bitwise_expression -> expression AND_NOT expression .) ]
  ! OR              [ reduce using rule 155 (bitwise_expression -> expression AND_NOT expression .) ]
  ! XOR             [ reduce using rule 155 (bitwise_expression -> expression AND_NOT expression .) ]
  ! AND_NOT         [ reduce using rule 155 (bitwise_expression -> expression AND_NOT expression .) ]
  ! LSHIFT          [ reduce using rule 155 (bitwise_expression -> expression AND_NOT expression .) ]
  ! RSHIFT          [ reduce using rule 155 (bitwise_expression -> expression AND_NOT expression .) ]
>>>>>>> Stashed changes


state 136

<<<<<<< Updated upstream
    (140) expression_map_list -> key_value .

    RBRACE          reduce using rule 140 (expression_map_list -> key_value .)
    COMMA           reduce using rule 140 (expression_map_list -> key_value .)
=======
    (156) bitwise_expression -> expression LSHIFT expression .
    (100) expression -> expression . DOT IDENTIFIER
    (135) binary_expression -> expression . PLUS expression
    (136) binary_expression -> expression . MINUS expression
    (137) binary_expression -> expression . TIMES expression
    (138) binary_expression -> expression . DIVIDE expression
    (139) binary_expression -> expression . MODULE expression
    (144) relational_expression -> expression . EQ expression
    (145) relational_expression -> expression . NEQ expression
    (146) relational_expression -> expression . LT expression
    (147) relational_expression -> expression . LE expression
    (148) relational_expression -> expression . GT expression
    (149) relational_expression -> expression . GE expression
    (150) logical_expression -> expression . LAND expression
    (151) logical_expression -> expression . LOR expression
    (152) bitwise_expression -> expression . AND expression
    (153) bitwise_expression -> expression . OR expression
    (154) bitwise_expression -> expression . XOR expression
    (155) bitwise_expression -> expression . AND_NOT expression
    (156) bitwise_expression -> expression . LSHIFT expression
    (157) bitwise_expression -> expression . RSHIFT expression

    DOT             reduce using rule 156 (bitwise_expression -> expression LSHIFT expression .)
    PLUS            reduce using rule 156 (bitwise_expression -> expression LSHIFT expression .)
    MINUS           reduce using rule 156 (bitwise_expression -> expression LSHIFT expression .)
    TIMES           reduce using rule 156 (bitwise_expression -> expression LSHIFT expression .)
    DIVIDE          reduce using rule 156 (bitwise_expression -> expression LSHIFT expression .)
    MODULE          reduce using rule 156 (bitwise_expression -> expression LSHIFT expression .)
    AND_NOT         reduce using rule 156 (bitwise_expression -> expression LSHIFT expression .)
    LSHIFT          reduce using rule 156 (bitwise_expression -> expression LSHIFT expression .)
    RSHIFT          reduce using rule 156 (bitwise_expression -> expression LSHIFT expression .)
    SEMICOLON       reduce using rule 156 (bitwise_expression -> expression LSHIFT expression .)
    FUNC            reduce using rule 156 (bitwise_expression -> expression LSHIFT expression .)
    TYPE            reduce using rule 156 (bitwise_expression -> expression LSHIFT expression .)
    IDENTIFIER      reduce using rule 156 (bitwise_expression -> expression LSHIFT expression .)
    VAR             reduce using rule 156 (bitwise_expression -> expression LSHIFT expression .)
    CONST           reduce using rule 156 (bitwise_expression -> expression LSHIFT expression .)
    LNOT            reduce using rule 156 (bitwise_expression -> expression LSHIFT expression .)
    LBRACKET        reduce using rule 156 (bitwise_expression -> expression LSHIFT expression .)
    LPAREN          reduce using rule 156 (bitwise_expression -> expression LSHIFT expression .)
    INT             reduce using rule 156 (bitwise_expression -> expression LSHIFT expression .)
    FLOAT64         reduce using rule 156 (bitwise_expression -> expression LSHIFT expression .)
    TRUE            reduce using rule 156 (bitwise_expression -> expression LSHIFT expression .)
    FALSE           reduce using rule 156 (bitwise_expression -> expression LSHIFT expression .)
    STRING          reduce using rule 156 (bitwise_expression -> expression LSHIFT expression .)
    RETURN          reduce using rule 156 (bitwise_expression -> expression LSHIFT expression .)
    FOR             reduce using rule 156 (bitwise_expression -> expression LSHIFT expression .)
    IF              reduce using rule 156 (bitwise_expression -> expression LSHIFT expression .)
    SWITCH          reduce using rule 156 (bitwise_expression -> expression LSHIFT expression .)
    BREAK           reduce using rule 156 (bitwise_expression -> expression LSHIFT expression .)
    CONTINUE        reduce using rule 156 (bitwise_expression -> expression LSHIFT expression .)
    FALLTHROUGH     reduce using rule 156 (bitwise_expression -> expression LSHIFT expression .)
    $end            reduce using rule 156 (bitwise_expression -> expression LSHIFT expression .)
    RPAREN          reduce using rule 156 (bitwise_expression -> expression LSHIFT expression .)
    COMMA           reduce using rule 156 (bitwise_expression -> expression LSHIFT expression .)
    RBRACE          reduce using rule 156 (bitwise_expression -> expression LSHIFT expression .)
    CASE            reduce using rule 156 (bitwise_expression -> expression LSHIFT expression .)
    DEFAULT         reduce using rule 156 (bitwise_expression -> expression LSHIFT expression .)
    LBRACE          reduce using rule 156 (bitwise_expression -> expression LSHIFT expression .)
    COLON           reduce using rule 156 (bitwise_expression -> expression LSHIFT expression .)
    EQ              shift and go to state 64
    NEQ             shift and go to state 65
    LT              shift and go to state 66
    LE              shift and go to state 67
    GT              shift and go to state 68
    GE              shift and go to state 69
    LAND            shift and go to state 70
    LOR             shift and go to state 71
    AND             shift and go to state 72
    OR              shift and go to state 73
    XOR             shift and go to state 74

  ! EQ              [ reduce using rule 156 (bitwise_expression -> expression LSHIFT expression .) ]
  ! NEQ             [ reduce using rule 156 (bitwise_expression -> expression LSHIFT expression .) ]
  ! LT              [ reduce using rule 156 (bitwise_expression -> expression LSHIFT expression .) ]
  ! LE              [ reduce using rule 156 (bitwise_expression -> expression LSHIFT expression .) ]
  ! GT              [ reduce using rule 156 (bitwise_expression -> expression LSHIFT expression .) ]
  ! GE              [ reduce using rule 156 (bitwise_expression -> expression LSHIFT expression .) ]
  ! LAND            [ reduce using rule 156 (bitwise_expression -> expression LSHIFT expression .) ]
  ! LOR             [ reduce using rule 156 (bitwise_expression -> expression LSHIFT expression .) ]
  ! AND             [ reduce using rule 156 (bitwise_expression -> expression LSHIFT expression .) ]
  ! OR              [ reduce using rule 156 (bitwise_expression -> expression LSHIFT expression .) ]
  ! XOR             [ reduce using rule 156 (bitwise_expression -> expression LSHIFT expression .) ]
  ! DOT             [ shift and go to state 58 ]
  ! PLUS            [ shift and go to state 59 ]
  ! MINUS           [ shift and go to state 60 ]
  ! TIMES           [ shift and go to state 61 ]
  ! DIVIDE          [ shift and go to state 62 ]
  ! MODULE          [ shift and go to state 63 ]
  ! AND_NOT         [ shift and go to state 75 ]
  ! LSHIFT          [ shift and go to state 76 ]
  ! RSHIFT          [ shift and go to state 77 ]
>>>>>>> Stashed changes


state 137

<<<<<<< Updated upstream
    (142) key_value -> expression . COLON expression
    (36) expression -> expression . binary_operator expression
    (200) expression -> expression . DOT IDENTIFIER
    (201) expression -> expression . DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> expression . LBRACKET expression RBRACKET
    (37) binary_operator -> . PLUS
    (38) binary_operator -> . MINUS
    (39) binary_operator -> . TIMES
    (40) binary_operator -> . DIVIDE
    (41) binary_operator -> . MODULE
    (42) binary_operator -> . EQ
    (43) binary_operator -> . NEQ
    (44) binary_operator -> . LT
    (45) binary_operator -> . LE
    (46) binary_operator -> . GT
    (47) binary_operator -> . GE
    (48) binary_operator -> . LAND
    (49) binary_operator -> . LOR
    (50) binary_operator -> . AND
    (51) binary_operator -> . OR
    (52) binary_operator -> . XOR
    (53) binary_operator -> . AND_NOT
    (54) binary_operator -> . LSHIFT
    (55) binary_operator -> . RSHIFT

    COLON           shift and go to state 165
    DOT             shift and go to state 82
    LBRACKET        shift and go to state 83
    PLUS            shift and go to state 84
    MINUS           shift and go to state 85
    TIMES           shift and go to state 86
    DIVIDE          shift and go to state 87
    MODULE          shift and go to state 88
    EQ              shift and go to state 89
    NEQ             shift and go to state 90
    LT              shift and go to state 91
    LE              shift and go to state 92
    GT              shift and go to state 93
    GE              shift and go to state 94
    LAND            shift and go to state 95
    LOR             shift and go to state 96
    AND             shift and go to state 97
    OR              shift and go to state 98
    XOR             shift and go to state 99
    AND_NOT         shift and go to state 100
    LSHIFT          shift and go to state 101
    RSHIFT          shift and go to state 102
=======
    (157) bitwise_expression -> expression RSHIFT expression .
    (100) expression -> expression . DOT IDENTIFIER
    (135) binary_expression -> expression . PLUS expression
    (136) binary_expression -> expression . MINUS expression
    (137) binary_expression -> expression . TIMES expression
    (138) binary_expression -> expression . DIVIDE expression
    (139) binary_expression -> expression . MODULE expression
    (144) relational_expression -> expression . EQ expression
    (145) relational_expression -> expression . NEQ expression
    (146) relational_expression -> expression . LT expression
    (147) relational_expression -> expression . LE expression
    (148) relational_expression -> expression . GT expression
    (149) relational_expression -> expression . GE expression
    (150) logical_expression -> expression . LAND expression
    (151) logical_expression -> expression . LOR expression
    (152) bitwise_expression -> expression . AND expression
    (153) bitwise_expression -> expression . OR expression
    (154) bitwise_expression -> expression . XOR expression
    (155) bitwise_expression -> expression . AND_NOT expression
    (156) bitwise_expression -> expression . LSHIFT expression
    (157) bitwise_expression -> expression . RSHIFT expression

    DOT             reduce using rule 157 (bitwise_expression -> expression RSHIFT expression .)
    PLUS            reduce using rule 157 (bitwise_expression -> expression RSHIFT expression .)
    MINUS           reduce using rule 157 (bitwise_expression -> expression RSHIFT expression .)
    TIMES           reduce using rule 157 (bitwise_expression -> expression RSHIFT expression .)
    DIVIDE          reduce using rule 157 (bitwise_expression -> expression RSHIFT expression .)
    MODULE          reduce using rule 157 (bitwise_expression -> expression RSHIFT expression .)
    AND_NOT         reduce using rule 157 (bitwise_expression -> expression RSHIFT expression .)
    LSHIFT          reduce using rule 157 (bitwise_expression -> expression RSHIFT expression .)
    RSHIFT          reduce using rule 157 (bitwise_expression -> expression RSHIFT expression .)
    SEMICOLON       reduce using rule 157 (bitwise_expression -> expression RSHIFT expression .)
    FUNC            reduce using rule 157 (bitwise_expression -> expression RSHIFT expression .)
    TYPE            reduce using rule 157 (bitwise_expression -> expression RSHIFT expression .)
    IDENTIFIER      reduce using rule 157 (bitwise_expression -> expression RSHIFT expression .)
    VAR             reduce using rule 157 (bitwise_expression -> expression RSHIFT expression .)
    CONST           reduce using rule 157 (bitwise_expression -> expression RSHIFT expression .)
    LNOT            reduce using rule 157 (bitwise_expression -> expression RSHIFT expression .)
    LBRACKET        reduce using rule 157 (bitwise_expression -> expression RSHIFT expression .)
    LPAREN          reduce using rule 157 (bitwise_expression -> expression RSHIFT expression .)
    INT             reduce using rule 157 (bitwise_expression -> expression RSHIFT expression .)
    FLOAT64         reduce using rule 157 (bitwise_expression -> expression RSHIFT expression .)
    TRUE            reduce using rule 157 (bitwise_expression -> expression RSHIFT expression .)
    FALSE           reduce using rule 157 (bitwise_expression -> expression RSHIFT expression .)
    STRING          reduce using rule 157 (bitwise_expression -> expression RSHIFT expression .)
    RETURN          reduce using rule 157 (bitwise_expression -> expression RSHIFT expression .)
    FOR             reduce using rule 157 (bitwise_expression -> expression RSHIFT expression .)
    IF              reduce using rule 157 (bitwise_expression -> expression RSHIFT expression .)
    SWITCH          reduce using rule 157 (bitwise_expression -> expression RSHIFT expression .)
    BREAK           reduce using rule 157 (bitwise_expression -> expression RSHIFT expression .)
    CONTINUE        reduce using rule 157 (bitwise_expression -> expression RSHIFT expression .)
    FALLTHROUGH     reduce using rule 157 (bitwise_expression -> expression RSHIFT expression .)
    $end            reduce using rule 157 (bitwise_expression -> expression RSHIFT expression .)
    RPAREN          reduce using rule 157 (bitwise_expression -> expression RSHIFT expression .)
    COMMA           reduce using rule 157 (bitwise_expression -> expression RSHIFT expression .)
    RBRACE          reduce using rule 157 (bitwise_expression -> expression RSHIFT expression .)
    CASE            reduce using rule 157 (bitwise_expression -> expression RSHIFT expression .)
    DEFAULT         reduce using rule 157 (bitwise_expression -> expression RSHIFT expression .)
    LBRACE          reduce using rule 157 (bitwise_expression -> expression RSHIFT expression .)
    COLON           reduce using rule 157 (bitwise_expression -> expression RSHIFT expression .)
    EQ              shift and go to state 64
    NEQ             shift and go to state 65
    LT              shift and go to state 66
    LE              shift and go to state 67
    GT              shift and go to state 68
    GE              shift and go to state 69
    LAND            shift and go to state 70
    LOR             shift and go to state 71
    AND             shift and go to state 72
    OR              shift and go to state 73
    XOR             shift and go to state 74

  ! EQ              [ reduce using rule 157 (bitwise_expression -> expression RSHIFT expression .) ]
  ! NEQ             [ reduce using rule 157 (bitwise_expression -> expression RSHIFT expression .) ]
  ! LT              [ reduce using rule 157 (bitwise_expression -> expression RSHIFT expression .) ]
  ! LE              [ reduce using rule 157 (bitwise_expression -> expression RSHIFT expression .) ]
  ! GT              [ reduce using rule 157 (bitwise_expression -> expression RSHIFT expression .) ]
  ! GE              [ reduce using rule 157 (bitwise_expression -> expression RSHIFT expression .) ]
  ! LAND            [ reduce using rule 157 (bitwise_expression -> expression RSHIFT expression .) ]
  ! LOR             [ reduce using rule 157 (bitwise_expression -> expression RSHIFT expression .) ]
  ! AND             [ reduce using rule 157 (bitwise_expression -> expression RSHIFT expression .) ]
  ! OR              [ reduce using rule 157 (bitwise_expression -> expression RSHIFT expression .) ]
  ! XOR             [ reduce using rule 157 (bitwise_expression -> expression RSHIFT expression .) ]
  ! DOT             [ shift and go to state 58 ]
  ! PLUS            [ shift and go to state 59 ]
  ! MINUS           [ shift and go to state 60 ]
  ! TIMES           [ shift and go to state 61 ]
  ! DIVIDE          [ shift and go to state 62 ]
  ! MODULE          [ shift and go to state 63 ]
  ! AND_NOT         [ shift and go to state 75 ]
  ! LSHIFT          [ shift and go to state 76 ]
  ! RSHIFT          [ shift and go to state 77 ]
>>>>>>> Stashed changes

    binary_operator                shift and go to state 81

state 138

<<<<<<< Updated upstream
    (161) expression -> type_name LBRACE keyed_element_list . RBRACE
    (157) keyed_element_list -> keyed_element_list . COMMA keyed_element

    RBRACE          shift and go to state 166
    COMMA           shift and go to state 167


state 139

    (162) expression -> type_name LBRACE RBRACE .

    DOT             reduce using rule 162 (expression -> type_name LBRACE RBRACE .)
    LBRACKET        reduce using rule 162 (expression -> type_name LBRACE RBRACE .)
    PLUS            reduce using rule 162 (expression -> type_name LBRACE RBRACE .)
    MINUS           reduce using rule 162 (expression -> type_name LBRACE RBRACE .)
    TIMES           reduce using rule 162 (expression -> type_name LBRACE RBRACE .)
    DIVIDE          reduce using rule 162 (expression -> type_name LBRACE RBRACE .)
    MODULE          reduce using rule 162 (expression -> type_name LBRACE RBRACE .)
    EQ              reduce using rule 162 (expression -> type_name LBRACE RBRACE .)
    NEQ             reduce using rule 162 (expression -> type_name LBRACE RBRACE .)
    LT              reduce using rule 162 (expression -> type_name LBRACE RBRACE .)
    LE              reduce using rule 162 (expression -> type_name LBRACE RBRACE .)
    GT              reduce using rule 162 (expression -> type_name LBRACE RBRACE .)
    GE              reduce using rule 162 (expression -> type_name LBRACE RBRACE .)
    LAND            reduce using rule 162 (expression -> type_name LBRACE RBRACE .)
    LOR             reduce using rule 162 (expression -> type_name LBRACE RBRACE .)
    AND             reduce using rule 162 (expression -> type_name LBRACE RBRACE .)
    OR              reduce using rule 162 (expression -> type_name LBRACE RBRACE .)
    XOR             reduce using rule 162 (expression -> type_name LBRACE RBRACE .)
    AND_NOT         reduce using rule 162 (expression -> type_name LBRACE RBRACE .)
    LSHIFT          reduce using rule 162 (expression -> type_name LBRACE RBRACE .)
    RSHIFT          reduce using rule 162 (expression -> type_name LBRACE RBRACE .)
    VAR             reduce using rule 162 (expression -> type_name LBRACE RBRACE .)
    CONST           reduce using rule 162 (expression -> type_name LBRACE RBRACE .)
    FUNC            reduce using rule 162 (expression -> type_name LBRACE RBRACE .)
    TYPE            reduce using rule 162 (expression -> type_name LBRACE RBRACE .)
    $end            reduce using rule 162 (expression -> type_name LBRACE RBRACE .)
    RPAREN          reduce using rule 162 (expression -> type_name LBRACE RBRACE .)
    COMMA           reduce using rule 162 (expression -> type_name LBRACE RBRACE .)
    RBRACKET        reduce using rule 162 (expression -> type_name LBRACE RBRACE .)
    RBRACE          reduce using rule 162 (expression -> type_name LBRACE RBRACE .)
    COLON           reduce using rule 162 (expression -> type_name LBRACE RBRACE .)
    BREAK           reduce using rule 162 (expression -> type_name LBRACE RBRACE .)
    CONTINUE        reduce using rule 162 (expression -> type_name LBRACE RBRACE .)
    IDENTIFIER      reduce using rule 162 (expression -> type_name LBRACE RBRACE .)
    LPAREN          reduce using rule 162 (expression -> type_name LBRACE RBRACE .)
    INT             reduce using rule 162 (expression -> type_name LBRACE RBRACE .)
    FLOAT64         reduce using rule 162 (expression -> type_name LBRACE RBRACE .)
    STRING          reduce using rule 162 (expression -> type_name LBRACE RBRACE .)
    TRUE            reduce using rule 162 (expression -> type_name LBRACE RBRACE .)
    FALSE           reduce using rule 162 (expression -> type_name LBRACE RBRACE .)
    LNOT            reduce using rule 162 (expression -> type_name LBRACE RBRACE .)
    IF              reduce using rule 162 (expression -> type_name LBRACE RBRACE .)
    SWITCH          reduce using rule 162 (expression -> type_name LBRACE RBRACE .)
    RETURN          reduce using rule 162 (expression -> type_name LBRACE RBRACE .)
    MAP             reduce using rule 162 (expression -> type_name LBRACE RBRACE .)
    FOR             reduce using rule 162 (expression -> type_name LBRACE RBRACE .)
    LBRACE          reduce using rule 162 (expression -> type_name LBRACE RBRACE .)
    CASE            reduce using rule 162 (expression -> type_name LBRACE RBRACE .)
    DEFAULT         reduce using rule 162 (expression -> type_name LBRACE RBRACE .)
    SEMICOLON       reduce using rule 162 (expression -> type_name LBRACE RBRACE .)
=======
    (43) function_declaration -> FUNC IDENTIFIER LPAREN . parameter_list RPAREN return_type block
    (44) parameter_list -> . parameter_list COMMA parameter
    (45) parameter_list -> . parameter
    (46) parameter_list -> . empty
    (47) parameter -> . IDENTIFIER type
    (48) parameter -> . IDENTIFIER ELLIPSIS primitive_type
    (7) empty -> .

    IDENTIFIER      shift and go to state 208
    RPAREN          reduce using rule 7 (empty -> .)
    COMMA           reduce using rule 7 (empty -> .)

    parameter_list                 shift and go to state 209
    parameter                      shift and go to state 210
    empty                          shift and go to state 211

state 139

    (124) method_declaration -> FUNC LPAREN receiver . RPAREN IDENTIFIER LPAREN parameter_list RPAREN return_type block

    RPAREN          shift and go to state 212
>>>>>>> Stashed changes


state 140

<<<<<<< Updated upstream
    (156) keyed_element_list -> keyed_element .

    RBRACE          reduce using rule 156 (keyed_element_list -> keyed_element .)
    COMMA           reduce using rule 156 (keyed_element_list -> keyed_element .)
=======
    (125) receiver -> IDENTIFIER . type
    (126) receiver -> IDENTIFIER . TIMES IDENTIFIER
    (70) type -> . primitive_type
    (71) type -> . slice_type
    (72) type -> . array_type
    (73) type -> . map_type
    (74) type -> . struct_type
    (75) type -> . IDENTIFIER
    (76) primitive_type -> . INT_TYPE
    (77) primitive_type -> . FLOAT64_TYPE
    (78) primitive_type -> . STRING_TYPE
    (79) primitive_type -> . BOOL_TYPE
    (80) slice_type -> . LBRACKET RBRACKET primitive_type
    (81) array_type -> . LBRACKET INT RBRACKET type
    (127) map_type -> . MAP LBRACKET primitive_type RBRACKET type
    (118) struct_type -> . STRUCT LBRACE RBRACE
    (119) struct_type -> . STRUCT LBRACE field_list RBRACE

    TIMES           shift and go to state 214
    IDENTIFIER      shift and go to state 177
    INT_TYPE        shift and go to state 171
    FLOAT64_TYPE    shift and go to state 172
    STRING_TYPE     shift and go to state 173
    BOOL_TYPE       shift and go to state 174
    LBRACKET        shift and go to state 175
    MAP             shift and go to state 176
    STRUCT          shift and go to state 170
>>>>>>> Stashed changes

    type                           shift and go to state 213
    primitive_type                 shift and go to state 180
    slice_type                     shift and go to state 181
    array_type                     shift and go to state 182
    map_type                       shift and go to state 183
    struct_type                    shift and go to state 184

state 141

<<<<<<< Updated upstream
    (158) keyed_element -> IDENTIFIER . COLON expression
    (73) expression -> IDENTIFIER .
    (126) expression -> IDENTIFIER . PLUSPLUS
    (127) expression -> IDENTIFIER . MINUSMINUS
    (203) expression -> IDENTIFIER . LPAREN argument_list RPAREN
    (163) type_name -> IDENTIFIER .

    COLON           shift and go to state 168
    DOT             reduce using rule 73 (expression -> IDENTIFIER .)
    LBRACKET        reduce using rule 73 (expression -> IDENTIFIER .)
    PLUS            reduce using rule 73 (expression -> IDENTIFIER .)
    MINUS           reduce using rule 73 (expression -> IDENTIFIER .)
    TIMES           reduce using rule 73 (expression -> IDENTIFIER .)
    DIVIDE          reduce using rule 73 (expression -> IDENTIFIER .)
    MODULE          reduce using rule 73 (expression -> IDENTIFIER .)
    EQ              reduce using rule 73 (expression -> IDENTIFIER .)
    NEQ             reduce using rule 73 (expression -> IDENTIFIER .)
    LT              reduce using rule 73 (expression -> IDENTIFIER .)
    LE              reduce using rule 73 (expression -> IDENTIFIER .)
    GT              reduce using rule 73 (expression -> IDENTIFIER .)
    GE              reduce using rule 73 (expression -> IDENTIFIER .)
    LAND            reduce using rule 73 (expression -> IDENTIFIER .)
    LOR             reduce using rule 73 (expression -> IDENTIFIER .)
    AND             reduce using rule 73 (expression -> IDENTIFIER .)
    OR              reduce using rule 73 (expression -> IDENTIFIER .)
    XOR             reduce using rule 73 (expression -> IDENTIFIER .)
    AND_NOT         reduce using rule 73 (expression -> IDENTIFIER .)
    LSHIFT          reduce using rule 73 (expression -> IDENTIFIER .)
    RSHIFT          reduce using rule 73 (expression -> IDENTIFIER .)
    RBRACE          reduce using rule 73 (expression -> IDENTIFIER .)
    COMMA           reduce using rule 73 (expression -> IDENTIFIER .)
    PLUSPLUS        shift and go to state 78
    MINUSMINUS      shift and go to state 79
    LPAREN          shift and go to state 80
    LBRACE          reduce using rule 163 (type_name -> IDENTIFIER .)
=======
    (54) assignment -> IDENTIFIER ASSIGN expression .
    (100) expression -> expression . DOT IDENTIFIER
    (135) binary_expression -> expression . PLUS expression
    (136) binary_expression -> expression . MINUS expression
    (137) binary_expression -> expression . TIMES expression
    (138) binary_expression -> expression . DIVIDE expression
    (139) binary_expression -> expression . MODULE expression
    (144) relational_expression -> expression . EQ expression
    (145) relational_expression -> expression . NEQ expression
    (146) relational_expression -> expression . LT expression
    (147) relational_expression -> expression . LE expression
    (148) relational_expression -> expression . GT expression
    (149) relational_expression -> expression . GE expression
    (150) logical_expression -> expression . LAND expression
    (151) logical_expression -> expression . LOR expression
    (152) bitwise_expression -> expression . AND expression
    (153) bitwise_expression -> expression . OR expression
    (154) bitwise_expression -> expression . XOR expression
    (155) bitwise_expression -> expression . AND_NOT expression
    (156) bitwise_expression -> expression . LSHIFT expression
    (157) bitwise_expression -> expression . RSHIFT expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    SEMICOLON       reduce using rule 54 (assignment -> IDENTIFIER ASSIGN expression .)
    FUNC            reduce using rule 54 (assignment -> IDENTIFIER ASSIGN expression .)
    TYPE            reduce using rule 54 (assignment -> IDENTIFIER ASSIGN expression .)
    IDENTIFIER      reduce using rule 54 (assignment -> IDENTIFIER ASSIGN expression .)
    VAR             reduce using rule 54 (assignment -> IDENTIFIER ASSIGN expression .)
    CONST           reduce using rule 54 (assignment -> IDENTIFIER ASSIGN expression .)
    LNOT            reduce using rule 54 (assignment -> IDENTIFIER ASSIGN expression .)
    LBRACKET        reduce using rule 54 (assignment -> IDENTIFIER ASSIGN expression .)
    LPAREN          reduce using rule 54 (assignment -> IDENTIFIER ASSIGN expression .)
    INT             reduce using rule 54 (assignment -> IDENTIFIER ASSIGN expression .)
    FLOAT64         reduce using rule 54 (assignment -> IDENTIFIER ASSIGN expression .)
    TRUE            reduce using rule 54 (assignment -> IDENTIFIER ASSIGN expression .)
    FALSE           reduce using rule 54 (assignment -> IDENTIFIER ASSIGN expression .)
    STRING          reduce using rule 54 (assignment -> IDENTIFIER ASSIGN expression .)
    RETURN          reduce using rule 54 (assignment -> IDENTIFIER ASSIGN expression .)
    FOR             reduce using rule 54 (assignment -> IDENTIFIER ASSIGN expression .)
    IF              reduce using rule 54 (assignment -> IDENTIFIER ASSIGN expression .)
    SWITCH          reduce using rule 54 (assignment -> IDENTIFIER ASSIGN expression .)
    BREAK           reduce using rule 54 (assignment -> IDENTIFIER ASSIGN expression .)
    CONTINUE        reduce using rule 54 (assignment -> IDENTIFIER ASSIGN expression .)
    FALLTHROUGH     reduce using rule 54 (assignment -> IDENTIFIER ASSIGN expression .)
    $end            reduce using rule 54 (assignment -> IDENTIFIER ASSIGN expression .)
    RBRACE          reduce using rule 54 (assignment -> IDENTIFIER ASSIGN expression .)
    LBRACE          reduce using rule 54 (assignment -> IDENTIFIER ASSIGN expression .)
    CASE            reduce using rule 54 (assignment -> IDENTIFIER ASSIGN expression .)
    DEFAULT         reduce using rule 54 (assignment -> IDENTIFIER ASSIGN expression .)
    DOT             shift and go to state 58
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    TIMES           shift and go to state 61
    DIVIDE          shift and go to state 62
    MODULE          shift and go to state 63
    EQ              shift and go to state 64
    NEQ             shift and go to state 65
    LT              shift and go to state 66
    LE              shift and go to state 67
    GT              shift and go to state 68
    GE              shift and go to state 69
    LAND            shift and go to state 70
    LOR             shift and go to state 71
    AND             shift and go to state 72
    OR              shift and go to state 73
    XOR             shift and go to state 74
    AND_NOT         shift and go to state 75
    LSHIFT          shift and go to state 76
    RSHIFT          shift and go to state 77

  ! PLUS            [ reduce using rule 54 (assignment -> IDENTIFIER ASSIGN expression .) ]
  ! MINUS           [ reduce using rule 54 (assignment -> IDENTIFIER ASSIGN expression .) ]
>>>>>>> Stashed changes


state 142

<<<<<<< Updated upstream
    (160) keyed_element -> expression .
    (36) expression -> expression . binary_operator expression
    (200) expression -> expression . DOT IDENTIFIER
    (201) expression -> expression . DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> expression . LBRACKET expression RBRACKET
    (37) binary_operator -> . PLUS
    (38) binary_operator -> . MINUS
    (39) binary_operator -> . TIMES
    (40) binary_operator -> . DIVIDE
    (41) binary_operator -> . MODULE
    (42) binary_operator -> . EQ
    (43) binary_operator -> . NEQ
    (44) binary_operator -> . LT
    (45) binary_operator -> . LE
    (46) binary_operator -> . GT
    (47) binary_operator -> . GE
    (48) binary_operator -> . LAND
    (49) binary_operator -> . LOR
    (50) binary_operator -> . AND
    (51) binary_operator -> . OR
    (52) binary_operator -> . XOR
    (53) binary_operator -> . AND_NOT
    (54) binary_operator -> . LSHIFT
    (55) binary_operator -> . RSHIFT

    RBRACE          reduce using rule 160 (keyed_element -> expression .)
    COMMA           reduce using rule 160 (keyed_element -> expression .)
    DOT             shift and go to state 82
    LBRACKET        shift and go to state 83
    PLUS            shift and go to state 84
    MINUS           shift and go to state 85
    TIMES           shift and go to state 86
    DIVIDE          shift and go to state 87
    MODULE          shift and go to state 88
    EQ              shift and go to state 89
    NEQ             shift and go to state 90
    LT              shift and go to state 91
    LE              shift and go to state 92
    GT              shift and go to state 93
    GE              shift and go to state 94
    LAND            shift and go to state 95
    LOR             shift and go to state 96
    AND             shift and go to state 97
    OR              shift and go to state 98
    XOR             shift and go to state 99
    AND_NOT         shift and go to state 100
    LSHIFT          shift and go to state 101
    RSHIFT          shift and go to state 102
=======
    (55) assignment -> IDENTIFIER SHORT_ASSIGN expression .
    (100) expression -> expression . DOT IDENTIFIER
    (135) binary_expression -> expression . PLUS expression
    (136) binary_expression -> expression . MINUS expression
    (137) binary_expression -> expression . TIMES expression
    (138) binary_expression -> expression . DIVIDE expression
    (139) binary_expression -> expression . MODULE expression
    (144) relational_expression -> expression . EQ expression
    (145) relational_expression -> expression . NEQ expression
    (146) relational_expression -> expression . LT expression
    (147) relational_expression -> expression . LE expression
    (148) relational_expression -> expression . GT expression
    (149) relational_expression -> expression . GE expression
    (150) logical_expression -> expression . LAND expression
    (151) logical_expression -> expression . LOR expression
    (152) bitwise_expression -> expression . AND expression
    (153) bitwise_expression -> expression . OR expression
    (154) bitwise_expression -> expression . XOR expression
    (155) bitwise_expression -> expression . AND_NOT expression
    (156) bitwise_expression -> expression . LSHIFT expression
    (157) bitwise_expression -> expression . RSHIFT expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    SEMICOLON       reduce using rule 55 (assignment -> IDENTIFIER SHORT_ASSIGN expression .)
    FUNC            reduce using rule 55 (assignment -> IDENTIFIER SHORT_ASSIGN expression .)
    TYPE            reduce using rule 55 (assignment -> IDENTIFIER SHORT_ASSIGN expression .)
    IDENTIFIER      reduce using rule 55 (assignment -> IDENTIFIER SHORT_ASSIGN expression .)
    VAR             reduce using rule 55 (assignment -> IDENTIFIER SHORT_ASSIGN expression .)
    CONST           reduce using rule 55 (assignment -> IDENTIFIER SHORT_ASSIGN expression .)
    LNOT            reduce using rule 55 (assignment -> IDENTIFIER SHORT_ASSIGN expression .)
    LBRACKET        reduce using rule 55 (assignment -> IDENTIFIER SHORT_ASSIGN expression .)
    LPAREN          reduce using rule 55 (assignment -> IDENTIFIER SHORT_ASSIGN expression .)
    INT             reduce using rule 55 (assignment -> IDENTIFIER SHORT_ASSIGN expression .)
    FLOAT64         reduce using rule 55 (assignment -> IDENTIFIER SHORT_ASSIGN expression .)
    TRUE            reduce using rule 55 (assignment -> IDENTIFIER SHORT_ASSIGN expression .)
    FALSE           reduce using rule 55 (assignment -> IDENTIFIER SHORT_ASSIGN expression .)
    STRING          reduce using rule 55 (assignment -> IDENTIFIER SHORT_ASSIGN expression .)
    RETURN          reduce using rule 55 (assignment -> IDENTIFIER SHORT_ASSIGN expression .)
    FOR             reduce using rule 55 (assignment -> IDENTIFIER SHORT_ASSIGN expression .)
    IF              reduce using rule 55 (assignment -> IDENTIFIER SHORT_ASSIGN expression .)
    SWITCH          reduce using rule 55 (assignment -> IDENTIFIER SHORT_ASSIGN expression .)
    BREAK           reduce using rule 55 (assignment -> IDENTIFIER SHORT_ASSIGN expression .)
    CONTINUE        reduce using rule 55 (assignment -> IDENTIFIER SHORT_ASSIGN expression .)
    FALLTHROUGH     reduce using rule 55 (assignment -> IDENTIFIER SHORT_ASSIGN expression .)
    $end            reduce using rule 55 (assignment -> IDENTIFIER SHORT_ASSIGN expression .)
    RBRACE          reduce using rule 55 (assignment -> IDENTIFIER SHORT_ASSIGN expression .)
    LBRACE          reduce using rule 55 (assignment -> IDENTIFIER SHORT_ASSIGN expression .)
    CASE            reduce using rule 55 (assignment -> IDENTIFIER SHORT_ASSIGN expression .)
    DEFAULT         reduce using rule 55 (assignment -> IDENTIFIER SHORT_ASSIGN expression .)
    DOT             shift and go to state 58
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    TIMES           shift and go to state 61
    DIVIDE          shift and go to state 62
    MODULE          shift and go to state 63
    EQ              shift and go to state 64
    NEQ             shift and go to state 65
    LT              shift and go to state 66
    LE              shift and go to state 67
    GT              shift and go to state 68
    GE              shift and go to state 69
    LAND            shift and go to state 70
    LOR             shift and go to state 71
    AND             shift and go to state 72
    OR              shift and go to state 73
    XOR             shift and go to state 74
    AND_NOT         shift and go to state 75
    LSHIFT          shift and go to state 76
    RSHIFT          shift and go to state 77

  ! PLUS            [ reduce using rule 55 (assignment -> IDENTIFIER SHORT_ASSIGN expression .) ]
  ! MINUS           [ reduce using rule 55 (assignment -> IDENTIFIER SHORT_ASSIGN expression .) ]
>>>>>>> Stashed changes

    binary_operator                shift and go to state 81

state 143

<<<<<<< Updated upstream
    (159) keyed_element -> INT . COLON expression
    (71) expression -> INT .

    COLON           shift and go to state 169
    DOT             reduce using rule 71 (expression -> INT .)
    LBRACKET        reduce using rule 71 (expression -> INT .)
    PLUS            reduce using rule 71 (expression -> INT .)
    MINUS           reduce using rule 71 (expression -> INT .)
    TIMES           reduce using rule 71 (expression -> INT .)
    DIVIDE          reduce using rule 71 (expression -> INT .)
    MODULE          reduce using rule 71 (expression -> INT .)
    EQ              reduce using rule 71 (expression -> INT .)
    NEQ             reduce using rule 71 (expression -> INT .)
    LT              reduce using rule 71 (expression -> INT .)
    LE              reduce using rule 71 (expression -> INT .)
    GT              reduce using rule 71 (expression -> INT .)
    GE              reduce using rule 71 (expression -> INT .)
    LAND            reduce using rule 71 (expression -> INT .)
    LOR             reduce using rule 71 (expression -> INT .)
    AND             reduce using rule 71 (expression -> INT .)
    OR              reduce using rule 71 (expression -> INT .)
    XOR             reduce using rule 71 (expression -> INT .)
    AND_NOT         reduce using rule 71 (expression -> INT .)
    LSHIFT          reduce using rule 71 (expression -> INT .)
    RSHIFT          reduce using rule 71 (expression -> INT .)
    RBRACE          reduce using rule 71 (expression -> INT .)
    COMMA           reduce using rule 71 (expression -> INT .)
=======
    (56) assignment_compound -> IDENTIFIER PLUS_ASSIGN expression .
    (100) expression -> expression . DOT IDENTIFIER
    (135) binary_expression -> expression . PLUS expression
    (136) binary_expression -> expression . MINUS expression
    (137) binary_expression -> expression . TIMES expression
    (138) binary_expression -> expression . DIVIDE expression
    (139) binary_expression -> expression . MODULE expression
    (144) relational_expression -> expression . EQ expression
    (145) relational_expression -> expression . NEQ expression
    (146) relational_expression -> expression . LT expression
    (147) relational_expression -> expression . LE expression
    (148) relational_expression -> expression . GT expression
    (149) relational_expression -> expression . GE expression
    (150) logical_expression -> expression . LAND expression
    (151) logical_expression -> expression . LOR expression
    (152) bitwise_expression -> expression . AND expression
    (153) bitwise_expression -> expression . OR expression
    (154) bitwise_expression -> expression . XOR expression
    (155) bitwise_expression -> expression . AND_NOT expression
    (156) bitwise_expression -> expression . LSHIFT expression
    (157) bitwise_expression -> expression . RSHIFT expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    SEMICOLON       reduce using rule 56 (assignment_compound -> IDENTIFIER PLUS_ASSIGN expression .)
    FUNC            reduce using rule 56 (assignment_compound -> IDENTIFIER PLUS_ASSIGN expression .)
    TYPE            reduce using rule 56 (assignment_compound -> IDENTIFIER PLUS_ASSIGN expression .)
    IDENTIFIER      reduce using rule 56 (assignment_compound -> IDENTIFIER PLUS_ASSIGN expression .)
    VAR             reduce using rule 56 (assignment_compound -> IDENTIFIER PLUS_ASSIGN expression .)
    CONST           reduce using rule 56 (assignment_compound -> IDENTIFIER PLUS_ASSIGN expression .)
    LNOT            reduce using rule 56 (assignment_compound -> IDENTIFIER PLUS_ASSIGN expression .)
    LBRACKET        reduce using rule 56 (assignment_compound -> IDENTIFIER PLUS_ASSIGN expression .)
    LPAREN          reduce using rule 56 (assignment_compound -> IDENTIFIER PLUS_ASSIGN expression .)
    INT             reduce using rule 56 (assignment_compound -> IDENTIFIER PLUS_ASSIGN expression .)
    FLOAT64         reduce using rule 56 (assignment_compound -> IDENTIFIER PLUS_ASSIGN expression .)
    TRUE            reduce using rule 56 (assignment_compound -> IDENTIFIER PLUS_ASSIGN expression .)
    FALSE           reduce using rule 56 (assignment_compound -> IDENTIFIER PLUS_ASSIGN expression .)
    STRING          reduce using rule 56 (assignment_compound -> IDENTIFIER PLUS_ASSIGN expression .)
    RETURN          reduce using rule 56 (assignment_compound -> IDENTIFIER PLUS_ASSIGN expression .)
    FOR             reduce using rule 56 (assignment_compound -> IDENTIFIER PLUS_ASSIGN expression .)
    IF              reduce using rule 56 (assignment_compound -> IDENTIFIER PLUS_ASSIGN expression .)
    SWITCH          reduce using rule 56 (assignment_compound -> IDENTIFIER PLUS_ASSIGN expression .)
    BREAK           reduce using rule 56 (assignment_compound -> IDENTIFIER PLUS_ASSIGN expression .)
    CONTINUE        reduce using rule 56 (assignment_compound -> IDENTIFIER PLUS_ASSIGN expression .)
    FALLTHROUGH     reduce using rule 56 (assignment_compound -> IDENTIFIER PLUS_ASSIGN expression .)
    $end            reduce using rule 56 (assignment_compound -> IDENTIFIER PLUS_ASSIGN expression .)
    RBRACE          reduce using rule 56 (assignment_compound -> IDENTIFIER PLUS_ASSIGN expression .)
    CASE            reduce using rule 56 (assignment_compound -> IDENTIFIER PLUS_ASSIGN expression .)
    DEFAULT         reduce using rule 56 (assignment_compound -> IDENTIFIER PLUS_ASSIGN expression .)
    DOT             shift and go to state 58
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    TIMES           shift and go to state 61
    DIVIDE          shift and go to state 62
    MODULE          shift and go to state 63
    EQ              shift and go to state 64
    NEQ             shift and go to state 65
    LT              shift and go to state 66
    LE              shift and go to state 67
    GT              shift and go to state 68
    GE              shift and go to state 69
    LAND            shift and go to state 70
    LOR             shift and go to state 71
    AND             shift and go to state 72
    OR              shift and go to state 73
    XOR             shift and go to state 74
    AND_NOT         shift and go to state 75
    LSHIFT          shift and go to state 76
    RSHIFT          shift and go to state 77

  ! PLUS            [ reduce using rule 56 (assignment_compound -> IDENTIFIER PLUS_ASSIGN expression .) ]
  ! MINUS           [ reduce using rule 56 (assignment_compound -> IDENTIFIER PLUS_ASSIGN expression .) ]
>>>>>>> Stashed changes


state 144

<<<<<<< Updated upstream
    (198) expression -> array_type LBRACE expression_list . RBRACE
    (69) expression_list -> expression_list . COMMA expression

    RBRACE          shift and go to state 170
    COMMA           shift and go to state 159
=======
    (57) assignment_compound -> IDENTIFIER MINUS_ASSIGN expression .
    (100) expression -> expression . DOT IDENTIFIER
    (135) binary_expression -> expression . PLUS expression
    (136) binary_expression -> expression . MINUS expression
    (137) binary_expression -> expression . TIMES expression
    (138) binary_expression -> expression . DIVIDE expression
    (139) binary_expression -> expression . MODULE expression
    (144) relational_expression -> expression . EQ expression
    (145) relational_expression -> expression . NEQ expression
    (146) relational_expression -> expression . LT expression
    (147) relational_expression -> expression . LE expression
    (148) relational_expression -> expression . GT expression
    (149) relational_expression -> expression . GE expression
    (150) logical_expression -> expression . LAND expression
    (151) logical_expression -> expression . LOR expression
    (152) bitwise_expression -> expression . AND expression
    (153) bitwise_expression -> expression . OR expression
    (154) bitwise_expression -> expression . XOR expression
    (155) bitwise_expression -> expression . AND_NOT expression
    (156) bitwise_expression -> expression . LSHIFT expression
    (157) bitwise_expression -> expression . RSHIFT expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    SEMICOLON       reduce using rule 57 (assignment_compound -> IDENTIFIER MINUS_ASSIGN expression .)
    FUNC            reduce using rule 57 (assignment_compound -> IDENTIFIER MINUS_ASSIGN expression .)
    TYPE            reduce using rule 57 (assignment_compound -> IDENTIFIER MINUS_ASSIGN expression .)
    IDENTIFIER      reduce using rule 57 (assignment_compound -> IDENTIFIER MINUS_ASSIGN expression .)
    VAR             reduce using rule 57 (assignment_compound -> IDENTIFIER MINUS_ASSIGN expression .)
    CONST           reduce using rule 57 (assignment_compound -> IDENTIFIER MINUS_ASSIGN expression .)
    LNOT            reduce using rule 57 (assignment_compound -> IDENTIFIER MINUS_ASSIGN expression .)
    LBRACKET        reduce using rule 57 (assignment_compound -> IDENTIFIER MINUS_ASSIGN expression .)
    LPAREN          reduce using rule 57 (assignment_compound -> IDENTIFIER MINUS_ASSIGN expression .)
    INT             reduce using rule 57 (assignment_compound -> IDENTIFIER MINUS_ASSIGN expression .)
    FLOAT64         reduce using rule 57 (assignment_compound -> IDENTIFIER MINUS_ASSIGN expression .)
    TRUE            reduce using rule 57 (assignment_compound -> IDENTIFIER MINUS_ASSIGN expression .)
    FALSE           reduce using rule 57 (assignment_compound -> IDENTIFIER MINUS_ASSIGN expression .)
    STRING          reduce using rule 57 (assignment_compound -> IDENTIFIER MINUS_ASSIGN expression .)
    RETURN          reduce using rule 57 (assignment_compound -> IDENTIFIER MINUS_ASSIGN expression .)
    FOR             reduce using rule 57 (assignment_compound -> IDENTIFIER MINUS_ASSIGN expression .)
    IF              reduce using rule 57 (assignment_compound -> IDENTIFIER MINUS_ASSIGN expression .)
    SWITCH          reduce using rule 57 (assignment_compound -> IDENTIFIER MINUS_ASSIGN expression .)
    BREAK           reduce using rule 57 (assignment_compound -> IDENTIFIER MINUS_ASSIGN expression .)
    CONTINUE        reduce using rule 57 (assignment_compound -> IDENTIFIER MINUS_ASSIGN expression .)
    FALLTHROUGH     reduce using rule 57 (assignment_compound -> IDENTIFIER MINUS_ASSIGN expression .)
    $end            reduce using rule 57 (assignment_compound -> IDENTIFIER MINUS_ASSIGN expression .)
    RBRACE          reduce using rule 57 (assignment_compound -> IDENTIFIER MINUS_ASSIGN expression .)
    CASE            reduce using rule 57 (assignment_compound -> IDENTIFIER MINUS_ASSIGN expression .)
    DEFAULT         reduce using rule 57 (assignment_compound -> IDENTIFIER MINUS_ASSIGN expression .)
    DOT             shift and go to state 58
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    TIMES           shift and go to state 61
    DIVIDE          shift and go to state 62
    MODULE          shift and go to state 63
    EQ              shift and go to state 64
    NEQ             shift and go to state 65
    LT              shift and go to state 66
    LE              shift and go to state 67
    GT              shift and go to state 68
    GE              shift and go to state 69
    LAND            shift and go to state 70
    LOR             shift and go to state 71
    AND             shift and go to state 72
    OR              shift and go to state 73
    XOR             shift and go to state 74
    AND_NOT         shift and go to state 75
    LSHIFT          shift and go to state 76
    RSHIFT          shift and go to state 77

  ! PLUS            [ reduce using rule 57 (assignment_compound -> IDENTIFIER MINUS_ASSIGN expression .) ]
  ! MINUS           [ reduce using rule 57 (assignment_compound -> IDENTIFIER MINUS_ASSIGN expression .) ]
>>>>>>> Stashed changes


state 145

<<<<<<< Updated upstream
    (199) expression -> array_type LBRACE RBRACE .

    DOT             reduce using rule 199 (expression -> array_type LBRACE RBRACE .)
    LBRACKET        reduce using rule 199 (expression -> array_type LBRACE RBRACE .)
    PLUS            reduce using rule 199 (expression -> array_type LBRACE RBRACE .)
    MINUS           reduce using rule 199 (expression -> array_type LBRACE RBRACE .)
    TIMES           reduce using rule 199 (expression -> array_type LBRACE RBRACE .)
    DIVIDE          reduce using rule 199 (expression -> array_type LBRACE RBRACE .)
    MODULE          reduce using rule 199 (expression -> array_type LBRACE RBRACE .)
    EQ              reduce using rule 199 (expression -> array_type LBRACE RBRACE .)
    NEQ             reduce using rule 199 (expression -> array_type LBRACE RBRACE .)
    LT              reduce using rule 199 (expression -> array_type LBRACE RBRACE .)
    LE              reduce using rule 199 (expression -> array_type LBRACE RBRACE .)
    GT              reduce using rule 199 (expression -> array_type LBRACE RBRACE .)
    GE              reduce using rule 199 (expression -> array_type LBRACE RBRACE .)
    LAND            reduce using rule 199 (expression -> array_type LBRACE RBRACE .)
    LOR             reduce using rule 199 (expression -> array_type LBRACE RBRACE .)
    AND             reduce using rule 199 (expression -> array_type LBRACE RBRACE .)
    OR              reduce using rule 199 (expression -> array_type LBRACE RBRACE .)
    XOR             reduce using rule 199 (expression -> array_type LBRACE RBRACE .)
    AND_NOT         reduce using rule 199 (expression -> array_type LBRACE RBRACE .)
    LSHIFT          reduce using rule 199 (expression -> array_type LBRACE RBRACE .)
    RSHIFT          reduce using rule 199 (expression -> array_type LBRACE RBRACE .)
    VAR             reduce using rule 199 (expression -> array_type LBRACE RBRACE .)
    CONST           reduce using rule 199 (expression -> array_type LBRACE RBRACE .)
    FUNC            reduce using rule 199 (expression -> array_type LBRACE RBRACE .)
    TYPE            reduce using rule 199 (expression -> array_type LBRACE RBRACE .)
    $end            reduce using rule 199 (expression -> array_type LBRACE RBRACE .)
    RPAREN          reduce using rule 199 (expression -> array_type LBRACE RBRACE .)
    COMMA           reduce using rule 199 (expression -> array_type LBRACE RBRACE .)
    RBRACKET        reduce using rule 199 (expression -> array_type LBRACE RBRACE .)
    RBRACE          reduce using rule 199 (expression -> array_type LBRACE RBRACE .)
    COLON           reduce using rule 199 (expression -> array_type LBRACE RBRACE .)
    BREAK           reduce using rule 199 (expression -> array_type LBRACE RBRACE .)
    CONTINUE        reduce using rule 199 (expression -> array_type LBRACE RBRACE .)
    IDENTIFIER      reduce using rule 199 (expression -> array_type LBRACE RBRACE .)
    LPAREN          reduce using rule 199 (expression -> array_type LBRACE RBRACE .)
    INT             reduce using rule 199 (expression -> array_type LBRACE RBRACE .)
    FLOAT64         reduce using rule 199 (expression -> array_type LBRACE RBRACE .)
    STRING          reduce using rule 199 (expression -> array_type LBRACE RBRACE .)
    TRUE            reduce using rule 199 (expression -> array_type LBRACE RBRACE .)
    FALSE           reduce using rule 199 (expression -> array_type LBRACE RBRACE .)
    LNOT            reduce using rule 199 (expression -> array_type LBRACE RBRACE .)
    IF              reduce using rule 199 (expression -> array_type LBRACE RBRACE .)
    SWITCH          reduce using rule 199 (expression -> array_type LBRACE RBRACE .)
    RETURN          reduce using rule 199 (expression -> array_type LBRACE RBRACE .)
    MAP             reduce using rule 199 (expression -> array_type LBRACE RBRACE .)
    FOR             reduce using rule 199 (expression -> array_type LBRACE RBRACE .)
    LBRACE          reduce using rule 199 (expression -> array_type LBRACE RBRACE .)
    CASE            reduce using rule 199 (expression -> array_type LBRACE RBRACE .)
    DEFAULT         reduce using rule 199 (expression -> array_type LBRACE RBRACE .)
    SEMICOLON       reduce using rule 199 (expression -> array_type LBRACE RBRACE .)
=======
    (58) assignment_compound -> IDENTIFIER MULT_ASSIGN expression .
    (100) expression -> expression . DOT IDENTIFIER
    (135) binary_expression -> expression . PLUS expression
    (136) binary_expression -> expression . MINUS expression
    (137) binary_expression -> expression . TIMES expression
    (138) binary_expression -> expression . DIVIDE expression
    (139) binary_expression -> expression . MODULE expression
    (144) relational_expression -> expression . EQ expression
    (145) relational_expression -> expression . NEQ expression
    (146) relational_expression -> expression . LT expression
    (147) relational_expression -> expression . LE expression
    (148) relational_expression -> expression . GT expression
    (149) relational_expression -> expression . GE expression
    (150) logical_expression -> expression . LAND expression
    (151) logical_expression -> expression . LOR expression
    (152) bitwise_expression -> expression . AND expression
    (153) bitwise_expression -> expression . OR expression
    (154) bitwise_expression -> expression . XOR expression
    (155) bitwise_expression -> expression . AND_NOT expression
    (156) bitwise_expression -> expression . LSHIFT expression
    (157) bitwise_expression -> expression . RSHIFT expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    SEMICOLON       reduce using rule 58 (assignment_compound -> IDENTIFIER MULT_ASSIGN expression .)
    FUNC            reduce using rule 58 (assignment_compound -> IDENTIFIER MULT_ASSIGN expression .)
    TYPE            reduce using rule 58 (assignment_compound -> IDENTIFIER MULT_ASSIGN expression .)
    IDENTIFIER      reduce using rule 58 (assignment_compound -> IDENTIFIER MULT_ASSIGN expression .)
    VAR             reduce using rule 58 (assignment_compound -> IDENTIFIER MULT_ASSIGN expression .)
    CONST           reduce using rule 58 (assignment_compound -> IDENTIFIER MULT_ASSIGN expression .)
    LNOT            reduce using rule 58 (assignment_compound -> IDENTIFIER MULT_ASSIGN expression .)
    LBRACKET        reduce using rule 58 (assignment_compound -> IDENTIFIER MULT_ASSIGN expression .)
    LPAREN          reduce using rule 58 (assignment_compound -> IDENTIFIER MULT_ASSIGN expression .)
    INT             reduce using rule 58 (assignment_compound -> IDENTIFIER MULT_ASSIGN expression .)
    FLOAT64         reduce using rule 58 (assignment_compound -> IDENTIFIER MULT_ASSIGN expression .)
    TRUE            reduce using rule 58 (assignment_compound -> IDENTIFIER MULT_ASSIGN expression .)
    FALSE           reduce using rule 58 (assignment_compound -> IDENTIFIER MULT_ASSIGN expression .)
    STRING          reduce using rule 58 (assignment_compound -> IDENTIFIER MULT_ASSIGN expression .)
    RETURN          reduce using rule 58 (assignment_compound -> IDENTIFIER MULT_ASSIGN expression .)
    FOR             reduce using rule 58 (assignment_compound -> IDENTIFIER MULT_ASSIGN expression .)
    IF              reduce using rule 58 (assignment_compound -> IDENTIFIER MULT_ASSIGN expression .)
    SWITCH          reduce using rule 58 (assignment_compound -> IDENTIFIER MULT_ASSIGN expression .)
    BREAK           reduce using rule 58 (assignment_compound -> IDENTIFIER MULT_ASSIGN expression .)
    CONTINUE        reduce using rule 58 (assignment_compound -> IDENTIFIER MULT_ASSIGN expression .)
    FALLTHROUGH     reduce using rule 58 (assignment_compound -> IDENTIFIER MULT_ASSIGN expression .)
    $end            reduce using rule 58 (assignment_compound -> IDENTIFIER MULT_ASSIGN expression .)
    RBRACE          reduce using rule 58 (assignment_compound -> IDENTIFIER MULT_ASSIGN expression .)
    CASE            reduce using rule 58 (assignment_compound -> IDENTIFIER MULT_ASSIGN expression .)
    DEFAULT         reduce using rule 58 (assignment_compound -> IDENTIFIER MULT_ASSIGN expression .)
    DOT             shift and go to state 58
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    TIMES           shift and go to state 61
    DIVIDE          shift and go to state 62
    MODULE          shift and go to state 63
    EQ              shift and go to state 64
    NEQ             shift and go to state 65
    LT              shift and go to state 66
    LE              shift and go to state 67
    GT              shift and go to state 68
    GE              shift and go to state 69
    LAND            shift and go to state 70
    LOR             shift and go to state 71
    AND             shift and go to state 72
    OR              shift and go to state 73
    XOR             shift and go to state 74
    AND_NOT         shift and go to state 75
    LSHIFT          shift and go to state 76
    RSHIFT          shift and go to state 77

  ! PLUS            [ reduce using rule 58 (assignment_compound -> IDENTIFIER MULT_ASSIGN expression .) ]
  ! MINUS           [ reduce using rule 58 (assignment_compound -> IDENTIFIER MULT_ASSIGN expression .) ]
>>>>>>> Stashed changes


state 146

<<<<<<< Updated upstream
    (197) array_type -> LBRACKET INT RBRACKET primitive_type .

    ASSIGN          reduce using rule 197 (array_type -> LBRACKET INT RBRACKET primitive_type .)
    VAR             reduce using rule 197 (array_type -> LBRACKET INT RBRACKET primitive_type .)
    CONST           reduce using rule 197 (array_type -> LBRACKET INT RBRACKET primitive_type .)
    FUNC            reduce using rule 197 (array_type -> LBRACKET INT RBRACKET primitive_type .)
    TYPE            reduce using rule 197 (array_type -> LBRACKET INT RBRACKET primitive_type .)
    $end            reduce using rule 197 (array_type -> LBRACKET INT RBRACKET primitive_type .)
    LBRACE          reduce using rule 197 (array_type -> LBRACKET INT RBRACKET primitive_type .)
    RPAREN          reduce using rule 197 (array_type -> LBRACKET INT RBRACKET primitive_type .)
    COMMA           reduce using rule 197 (array_type -> LBRACKET INT RBRACKET primitive_type .)
    RBRACE          reduce using rule 197 (array_type -> LBRACKET INT RBRACKET primitive_type .)
    IDENTIFIER      reduce using rule 197 (array_type -> LBRACKET INT RBRACKET primitive_type .)
    BREAK           reduce using rule 197 (array_type -> LBRACKET INT RBRACKET primitive_type .)
    CONTINUE        reduce using rule 197 (array_type -> LBRACKET INT RBRACKET primitive_type .)
    LPAREN          reduce using rule 197 (array_type -> LBRACKET INT RBRACKET primitive_type .)
    INT             reduce using rule 197 (array_type -> LBRACKET INT RBRACKET primitive_type .)
    FLOAT64         reduce using rule 197 (array_type -> LBRACKET INT RBRACKET primitive_type .)
    STRING          reduce using rule 197 (array_type -> LBRACKET INT RBRACKET primitive_type .)
    TRUE            reduce using rule 197 (array_type -> LBRACKET INT RBRACKET primitive_type .)
    FALSE           reduce using rule 197 (array_type -> LBRACKET INT RBRACKET primitive_type .)
    LNOT            reduce using rule 197 (array_type -> LBRACKET INT RBRACKET primitive_type .)
    IF              reduce using rule 197 (array_type -> LBRACKET INT RBRACKET primitive_type .)
    SWITCH          reduce using rule 197 (array_type -> LBRACKET INT RBRACKET primitive_type .)
    RETURN          reduce using rule 197 (array_type -> LBRACKET INT RBRACKET primitive_type .)
    LBRACKET        reduce using rule 197 (array_type -> LBRACKET INT RBRACKET primitive_type .)
    MAP             reduce using rule 197 (array_type -> LBRACKET INT RBRACKET primitive_type .)
    FOR             reduce using rule 197 (array_type -> LBRACKET INT RBRACKET primitive_type .)
    SEMICOLON       reduce using rule 197 (array_type -> LBRACKET INT RBRACKET primitive_type .)
    CASE            reduce using rule 197 (array_type -> LBRACKET INT RBRACKET primitive_type .)
    DEFAULT         reduce using rule 197 (array_type -> LBRACKET INT RBRACKET primitive_type .)
=======
    (59) assignment_compound -> IDENTIFIER DIV_ASSIGN expression .
    (100) expression -> expression . DOT IDENTIFIER
    (135) binary_expression -> expression . PLUS expression
    (136) binary_expression -> expression . MINUS expression
    (137) binary_expression -> expression . TIMES expression
    (138) binary_expression -> expression . DIVIDE expression
    (139) binary_expression -> expression . MODULE expression
    (144) relational_expression -> expression . EQ expression
    (145) relational_expression -> expression . NEQ expression
    (146) relational_expression -> expression . LT expression
    (147) relational_expression -> expression . LE expression
    (148) relational_expression -> expression . GT expression
    (149) relational_expression -> expression . GE expression
    (150) logical_expression -> expression . LAND expression
    (151) logical_expression -> expression . LOR expression
    (152) bitwise_expression -> expression . AND expression
    (153) bitwise_expression -> expression . OR expression
    (154) bitwise_expression -> expression . XOR expression
    (155) bitwise_expression -> expression . AND_NOT expression
    (156) bitwise_expression -> expression . LSHIFT expression
    (157) bitwise_expression -> expression . RSHIFT expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    SEMICOLON       reduce using rule 59 (assignment_compound -> IDENTIFIER DIV_ASSIGN expression .)
    FUNC            reduce using rule 59 (assignment_compound -> IDENTIFIER DIV_ASSIGN expression .)
    TYPE            reduce using rule 59 (assignment_compound -> IDENTIFIER DIV_ASSIGN expression .)
    IDENTIFIER      reduce using rule 59 (assignment_compound -> IDENTIFIER DIV_ASSIGN expression .)
    VAR             reduce using rule 59 (assignment_compound -> IDENTIFIER DIV_ASSIGN expression .)
    CONST           reduce using rule 59 (assignment_compound -> IDENTIFIER DIV_ASSIGN expression .)
    LNOT            reduce using rule 59 (assignment_compound -> IDENTIFIER DIV_ASSIGN expression .)
    LBRACKET        reduce using rule 59 (assignment_compound -> IDENTIFIER DIV_ASSIGN expression .)
    LPAREN          reduce using rule 59 (assignment_compound -> IDENTIFIER DIV_ASSIGN expression .)
    INT             reduce using rule 59 (assignment_compound -> IDENTIFIER DIV_ASSIGN expression .)
    FLOAT64         reduce using rule 59 (assignment_compound -> IDENTIFIER DIV_ASSIGN expression .)
    TRUE            reduce using rule 59 (assignment_compound -> IDENTIFIER DIV_ASSIGN expression .)
    FALSE           reduce using rule 59 (assignment_compound -> IDENTIFIER DIV_ASSIGN expression .)
    STRING          reduce using rule 59 (assignment_compound -> IDENTIFIER DIV_ASSIGN expression .)
    RETURN          reduce using rule 59 (assignment_compound -> IDENTIFIER DIV_ASSIGN expression .)
    FOR             reduce using rule 59 (assignment_compound -> IDENTIFIER DIV_ASSIGN expression .)
    IF              reduce using rule 59 (assignment_compound -> IDENTIFIER DIV_ASSIGN expression .)
    SWITCH          reduce using rule 59 (assignment_compound -> IDENTIFIER DIV_ASSIGN expression .)
    BREAK           reduce using rule 59 (assignment_compound -> IDENTIFIER DIV_ASSIGN expression .)
    CONTINUE        reduce using rule 59 (assignment_compound -> IDENTIFIER DIV_ASSIGN expression .)
    FALLTHROUGH     reduce using rule 59 (assignment_compound -> IDENTIFIER DIV_ASSIGN expression .)
    $end            reduce using rule 59 (assignment_compound -> IDENTIFIER DIV_ASSIGN expression .)
    RBRACE          reduce using rule 59 (assignment_compound -> IDENTIFIER DIV_ASSIGN expression .)
    CASE            reduce using rule 59 (assignment_compound -> IDENTIFIER DIV_ASSIGN expression .)
    DEFAULT         reduce using rule 59 (assignment_compound -> IDENTIFIER DIV_ASSIGN expression .)
    DOT             shift and go to state 58
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    TIMES           shift and go to state 61
    DIVIDE          shift and go to state 62
    MODULE          shift and go to state 63
    EQ              shift and go to state 64
    NEQ             shift and go to state 65
    LT              shift and go to state 66
    LE              shift and go to state 67
    GT              shift and go to state 68
    GE              shift and go to state 69
    LAND            shift and go to state 70
    LOR             shift and go to state 71
    AND             shift and go to state 72
    OR              shift and go to state 73
    XOR             shift and go to state 74
    AND_NOT         shift and go to state 75
    LSHIFT          shift and go to state 76
    RSHIFT          shift and go to state 77

  ! PLUS            [ reduce using rule 59 (assignment_compound -> IDENTIFIER DIV_ASSIGN expression .) ]
  ! MINUS           [ reduce using rule 59 (assignment_compound -> IDENTIFIER DIV_ASSIGN expression .) ]
>>>>>>> Stashed changes


state 147

<<<<<<< Updated upstream
    (137) map_type -> MAP LBRACKET primitive_type RBRACKET . primitive_type
    (61) primitive_type -> . INT_TYPE
    (62) primitive_type -> . FLOAT64_TYPE
    (63) primitive_type -> . STRING_TYPE
    (64) primitive_type -> . BOOL_TYPE

    INT_TYPE        shift and go to state 34
    FLOAT64_TYPE    shift and go to state 35
    STRING_TYPE     shift and go to state 36
    BOOL_TYPE       shift and go to state 37
=======
    (60) assignment_compound -> IDENTIFIER MOD_ASSIGN expression .
    (100) expression -> expression . DOT IDENTIFIER
    (135) binary_expression -> expression . PLUS expression
    (136) binary_expression -> expression . MINUS expression
    (137) binary_expression -> expression . TIMES expression
    (138) binary_expression -> expression . DIVIDE expression
    (139) binary_expression -> expression . MODULE expression
    (144) relational_expression -> expression . EQ expression
    (145) relational_expression -> expression . NEQ expression
    (146) relational_expression -> expression . LT expression
    (147) relational_expression -> expression . LE expression
    (148) relational_expression -> expression . GT expression
    (149) relational_expression -> expression . GE expression
    (150) logical_expression -> expression . LAND expression
    (151) logical_expression -> expression . LOR expression
    (152) bitwise_expression -> expression . AND expression
    (153) bitwise_expression -> expression . OR expression
    (154) bitwise_expression -> expression . XOR expression
    (155) bitwise_expression -> expression . AND_NOT expression
    (156) bitwise_expression -> expression . LSHIFT expression
    (157) bitwise_expression -> expression . RSHIFT expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    SEMICOLON       reduce using rule 60 (assignment_compound -> IDENTIFIER MOD_ASSIGN expression .)
    FUNC            reduce using rule 60 (assignment_compound -> IDENTIFIER MOD_ASSIGN expression .)
    TYPE            reduce using rule 60 (assignment_compound -> IDENTIFIER MOD_ASSIGN expression .)
    IDENTIFIER      reduce using rule 60 (assignment_compound -> IDENTIFIER MOD_ASSIGN expression .)
    VAR             reduce using rule 60 (assignment_compound -> IDENTIFIER MOD_ASSIGN expression .)
    CONST           reduce using rule 60 (assignment_compound -> IDENTIFIER MOD_ASSIGN expression .)
    LNOT            reduce using rule 60 (assignment_compound -> IDENTIFIER MOD_ASSIGN expression .)
    LBRACKET        reduce using rule 60 (assignment_compound -> IDENTIFIER MOD_ASSIGN expression .)
    LPAREN          reduce using rule 60 (assignment_compound -> IDENTIFIER MOD_ASSIGN expression .)
    INT             reduce using rule 60 (assignment_compound -> IDENTIFIER MOD_ASSIGN expression .)
    FLOAT64         reduce using rule 60 (assignment_compound -> IDENTIFIER MOD_ASSIGN expression .)
    TRUE            reduce using rule 60 (assignment_compound -> IDENTIFIER MOD_ASSIGN expression .)
    FALSE           reduce using rule 60 (assignment_compound -> IDENTIFIER MOD_ASSIGN expression .)
    STRING          reduce using rule 60 (assignment_compound -> IDENTIFIER MOD_ASSIGN expression .)
    RETURN          reduce using rule 60 (assignment_compound -> IDENTIFIER MOD_ASSIGN expression .)
    FOR             reduce using rule 60 (assignment_compound -> IDENTIFIER MOD_ASSIGN expression .)
    IF              reduce using rule 60 (assignment_compound -> IDENTIFIER MOD_ASSIGN expression .)
    SWITCH          reduce using rule 60 (assignment_compound -> IDENTIFIER MOD_ASSIGN expression .)
    BREAK           reduce using rule 60 (assignment_compound -> IDENTIFIER MOD_ASSIGN expression .)
    CONTINUE        reduce using rule 60 (assignment_compound -> IDENTIFIER MOD_ASSIGN expression .)
    FALLTHROUGH     reduce using rule 60 (assignment_compound -> IDENTIFIER MOD_ASSIGN expression .)
    $end            reduce using rule 60 (assignment_compound -> IDENTIFIER MOD_ASSIGN expression .)
    RBRACE          reduce using rule 60 (assignment_compound -> IDENTIFIER MOD_ASSIGN expression .)
    CASE            reduce using rule 60 (assignment_compound -> IDENTIFIER MOD_ASSIGN expression .)
    DEFAULT         reduce using rule 60 (assignment_compound -> IDENTIFIER MOD_ASSIGN expression .)
    DOT             shift and go to state 58
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    TIMES           shift and go to state 61
    DIVIDE          shift and go to state 62
    MODULE          shift and go to state 63
    EQ              shift and go to state 64
    NEQ             shift and go to state 65
    LT              shift and go to state 66
    LE              shift and go to state 67
    GT              shift and go to state 68
    GE              shift and go to state 69
    LAND            shift and go to state 70
    LOR             shift and go to state 71
    AND             shift and go to state 72
    OR              shift and go to state 73
    XOR             shift and go to state 74
    AND_NOT         shift and go to state 75
    LSHIFT          shift and go to state 76
    RSHIFT          shift and go to state 77

  ! PLUS            [ reduce using rule 60 (assignment_compound -> IDENTIFIER MOD_ASSIGN expression .) ]
  ! MINUS           [ reduce using rule 60 (assignment_compound -> IDENTIFIER MOD_ASSIGN expression .) ]
>>>>>>> Stashed changes

    primitive_type                 shift and go to state 171

state 148

<<<<<<< Updated upstream
    (117) parameter -> IDENTIFIER ELLIPSIS primitive_type .

    RPAREN          reduce using rule 117 (parameter -> IDENTIFIER ELLIPSIS primitive_type .)
    COMMA           reduce using rule 117 (parameter -> IDENTIFIER ELLIPSIS primitive_type .)
=======
    (61) assignment_compound -> IDENTIFIER AND_ASSIGN expression .
    (100) expression -> expression . DOT IDENTIFIER
    (135) binary_expression -> expression . PLUS expression
    (136) binary_expression -> expression . MINUS expression
    (137) binary_expression -> expression . TIMES expression
    (138) binary_expression -> expression . DIVIDE expression
    (139) binary_expression -> expression . MODULE expression
    (144) relational_expression -> expression . EQ expression
    (145) relational_expression -> expression . NEQ expression
    (146) relational_expression -> expression . LT expression
    (147) relational_expression -> expression . LE expression
    (148) relational_expression -> expression . GT expression
    (149) relational_expression -> expression . GE expression
    (150) logical_expression -> expression . LAND expression
    (151) logical_expression -> expression . LOR expression
    (152) bitwise_expression -> expression . AND expression
    (153) bitwise_expression -> expression . OR expression
    (154) bitwise_expression -> expression . XOR expression
    (155) bitwise_expression -> expression . AND_NOT expression
    (156) bitwise_expression -> expression . LSHIFT expression
    (157) bitwise_expression -> expression . RSHIFT expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    SEMICOLON       reduce using rule 61 (assignment_compound -> IDENTIFIER AND_ASSIGN expression .)
    FUNC            reduce using rule 61 (assignment_compound -> IDENTIFIER AND_ASSIGN expression .)
    TYPE            reduce using rule 61 (assignment_compound -> IDENTIFIER AND_ASSIGN expression .)
    IDENTIFIER      reduce using rule 61 (assignment_compound -> IDENTIFIER AND_ASSIGN expression .)
    VAR             reduce using rule 61 (assignment_compound -> IDENTIFIER AND_ASSIGN expression .)
    CONST           reduce using rule 61 (assignment_compound -> IDENTIFIER AND_ASSIGN expression .)
    LNOT            reduce using rule 61 (assignment_compound -> IDENTIFIER AND_ASSIGN expression .)
    LBRACKET        reduce using rule 61 (assignment_compound -> IDENTIFIER AND_ASSIGN expression .)
    LPAREN          reduce using rule 61 (assignment_compound -> IDENTIFIER AND_ASSIGN expression .)
    INT             reduce using rule 61 (assignment_compound -> IDENTIFIER AND_ASSIGN expression .)
    FLOAT64         reduce using rule 61 (assignment_compound -> IDENTIFIER AND_ASSIGN expression .)
    TRUE            reduce using rule 61 (assignment_compound -> IDENTIFIER AND_ASSIGN expression .)
    FALSE           reduce using rule 61 (assignment_compound -> IDENTIFIER AND_ASSIGN expression .)
    STRING          reduce using rule 61 (assignment_compound -> IDENTIFIER AND_ASSIGN expression .)
    RETURN          reduce using rule 61 (assignment_compound -> IDENTIFIER AND_ASSIGN expression .)
    FOR             reduce using rule 61 (assignment_compound -> IDENTIFIER AND_ASSIGN expression .)
    IF              reduce using rule 61 (assignment_compound -> IDENTIFIER AND_ASSIGN expression .)
    SWITCH          reduce using rule 61 (assignment_compound -> IDENTIFIER AND_ASSIGN expression .)
    BREAK           reduce using rule 61 (assignment_compound -> IDENTIFIER AND_ASSIGN expression .)
    CONTINUE        reduce using rule 61 (assignment_compound -> IDENTIFIER AND_ASSIGN expression .)
    FALLTHROUGH     reduce using rule 61 (assignment_compound -> IDENTIFIER AND_ASSIGN expression .)
    $end            reduce using rule 61 (assignment_compound -> IDENTIFIER AND_ASSIGN expression .)
    RBRACE          reduce using rule 61 (assignment_compound -> IDENTIFIER AND_ASSIGN expression .)
    CASE            reduce using rule 61 (assignment_compound -> IDENTIFIER AND_ASSIGN expression .)
    DEFAULT         reduce using rule 61 (assignment_compound -> IDENTIFIER AND_ASSIGN expression .)
    DOT             shift and go to state 58
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    TIMES           shift and go to state 61
    DIVIDE          shift and go to state 62
    MODULE          shift and go to state 63
    EQ              shift and go to state 64
    NEQ             shift and go to state 65
    LT              shift and go to state 66
    LE              shift and go to state 67
    GT              shift and go to state 68
    GE              shift and go to state 69
    LAND            shift and go to state 70
    LOR             shift and go to state 71
    AND             shift and go to state 72
    OR              shift and go to state 73
    XOR             shift and go to state 74
    AND_NOT         shift and go to state 75
    LSHIFT          shift and go to state 76
    RSHIFT          shift and go to state 77

  ! PLUS            [ reduce using rule 61 (assignment_compound -> IDENTIFIER AND_ASSIGN expression .) ]
  ! MINUS           [ reduce using rule 61 (assignment_compound -> IDENTIFIER AND_ASSIGN expression .) ]
>>>>>>> Stashed changes


state 149

<<<<<<< Updated upstream
    (119) return_type -> LPAREN . type_list RPAREN
    (121) type_list -> . type
    (122) type_list -> . type_list COMMA type
    (57) type -> . primitive_type
    (58) type -> . slice_type
    (59) type -> . array_type
    (60) type -> . map_type
    (61) primitive_type -> . INT_TYPE
    (62) primitive_type -> . FLOAT64_TYPE
    (63) primitive_type -> . STRING_TYPE
    (64) primitive_type -> . BOOL_TYPE
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (197) array_type -> . LBRACKET INT RBRACKET primitive_type
    (137) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type

    INT_TYPE        shift and go to state 34
    FLOAT64_TYPE    shift and go to state 35
    STRING_TYPE     shift and go to state 36
    BOOL_TYPE       shift and go to state 37
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39
=======
    (62) assignment_compound -> IDENTIFIER OR_ASSIGN expression .
    (100) expression -> expression . DOT IDENTIFIER
    (135) binary_expression -> expression . PLUS expression
    (136) binary_expression -> expression . MINUS expression
    (137) binary_expression -> expression . TIMES expression
    (138) binary_expression -> expression . DIVIDE expression
    (139) binary_expression -> expression . MODULE expression
    (144) relational_expression -> expression . EQ expression
    (145) relational_expression -> expression . NEQ expression
    (146) relational_expression -> expression . LT expression
    (147) relational_expression -> expression . LE expression
    (148) relational_expression -> expression . GT expression
    (149) relational_expression -> expression . GE expression
    (150) logical_expression -> expression . LAND expression
    (151) logical_expression -> expression . LOR expression
    (152) bitwise_expression -> expression . AND expression
    (153) bitwise_expression -> expression . OR expression
    (154) bitwise_expression -> expression . XOR expression
    (155) bitwise_expression -> expression . AND_NOT expression
    (156) bitwise_expression -> expression . LSHIFT expression
    (157) bitwise_expression -> expression . RSHIFT expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    SEMICOLON       reduce using rule 62 (assignment_compound -> IDENTIFIER OR_ASSIGN expression .)
    FUNC            reduce using rule 62 (assignment_compound -> IDENTIFIER OR_ASSIGN expression .)
    TYPE            reduce using rule 62 (assignment_compound -> IDENTIFIER OR_ASSIGN expression .)
    IDENTIFIER      reduce using rule 62 (assignment_compound -> IDENTIFIER OR_ASSIGN expression .)
    VAR             reduce using rule 62 (assignment_compound -> IDENTIFIER OR_ASSIGN expression .)
    CONST           reduce using rule 62 (assignment_compound -> IDENTIFIER OR_ASSIGN expression .)
    LNOT            reduce using rule 62 (assignment_compound -> IDENTIFIER OR_ASSIGN expression .)
    LBRACKET        reduce using rule 62 (assignment_compound -> IDENTIFIER OR_ASSIGN expression .)
    LPAREN          reduce using rule 62 (assignment_compound -> IDENTIFIER OR_ASSIGN expression .)
    INT             reduce using rule 62 (assignment_compound -> IDENTIFIER OR_ASSIGN expression .)
    FLOAT64         reduce using rule 62 (assignment_compound -> IDENTIFIER OR_ASSIGN expression .)
    TRUE            reduce using rule 62 (assignment_compound -> IDENTIFIER OR_ASSIGN expression .)
    FALSE           reduce using rule 62 (assignment_compound -> IDENTIFIER OR_ASSIGN expression .)
    STRING          reduce using rule 62 (assignment_compound -> IDENTIFIER OR_ASSIGN expression .)
    RETURN          reduce using rule 62 (assignment_compound -> IDENTIFIER OR_ASSIGN expression .)
    FOR             reduce using rule 62 (assignment_compound -> IDENTIFIER OR_ASSIGN expression .)
    IF              reduce using rule 62 (assignment_compound -> IDENTIFIER OR_ASSIGN expression .)
    SWITCH          reduce using rule 62 (assignment_compound -> IDENTIFIER OR_ASSIGN expression .)
    BREAK           reduce using rule 62 (assignment_compound -> IDENTIFIER OR_ASSIGN expression .)
    CONTINUE        reduce using rule 62 (assignment_compound -> IDENTIFIER OR_ASSIGN expression .)
    FALLTHROUGH     reduce using rule 62 (assignment_compound -> IDENTIFIER OR_ASSIGN expression .)
    $end            reduce using rule 62 (assignment_compound -> IDENTIFIER OR_ASSIGN expression .)
    RBRACE          reduce using rule 62 (assignment_compound -> IDENTIFIER OR_ASSIGN expression .)
    CASE            reduce using rule 62 (assignment_compound -> IDENTIFIER OR_ASSIGN expression .)
    DEFAULT         reduce using rule 62 (assignment_compound -> IDENTIFIER OR_ASSIGN expression .)
    DOT             shift and go to state 58
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    TIMES           shift and go to state 61
    DIVIDE          shift and go to state 62
    MODULE          shift and go to state 63
    EQ              shift and go to state 64
    NEQ             shift and go to state 65
    LT              shift and go to state 66
    LE              shift and go to state 67
    GT              shift and go to state 68
    GE              shift and go to state 69
    LAND            shift and go to state 70
    LOR             shift and go to state 71
    AND             shift and go to state 72
    OR              shift and go to state 73
    XOR             shift and go to state 74
    AND_NOT         shift and go to state 75
    LSHIFT          shift and go to state 76
    RSHIFT          shift and go to state 77

  ! PLUS            [ reduce using rule 62 (assignment_compound -> IDENTIFIER OR_ASSIGN expression .) ]
  ! MINUS           [ reduce using rule 62 (assignment_compound -> IDENTIFIER OR_ASSIGN expression .) ]
>>>>>>> Stashed changes

    type_list                      shift and go to state 172
    type                           shift and go to state 173
    primitive_type                 shift and go to state 30
    slice_type                     shift and go to state 31
    array_type                     shift and go to state 32
    map_type                       shift and go to state 33

state 150

<<<<<<< Updated upstream
    (112) function_declaration -> FUNC IDENTIFIER LPAREN parameter_list RPAREN return_type . block
    (90) block -> . LBRACE local_statement_list RBRACE
    (91) block -> . LBRACE RBRACE

    LBRACE          shift and go to state 175
=======
    (63) assignment_compound -> IDENTIFIER XOR_ASSIGN expression .
    (100) expression -> expression . DOT IDENTIFIER
    (135) binary_expression -> expression . PLUS expression
    (136) binary_expression -> expression . MINUS expression
    (137) binary_expression -> expression . TIMES expression
    (138) binary_expression -> expression . DIVIDE expression
    (139) binary_expression -> expression . MODULE expression
    (144) relational_expression -> expression . EQ expression
    (145) relational_expression -> expression . NEQ expression
    (146) relational_expression -> expression . LT expression
    (147) relational_expression -> expression . LE expression
    (148) relational_expression -> expression . GT expression
    (149) relational_expression -> expression . GE expression
    (150) logical_expression -> expression . LAND expression
    (151) logical_expression -> expression . LOR expression
    (152) bitwise_expression -> expression . AND expression
    (153) bitwise_expression -> expression . OR expression
    (154) bitwise_expression -> expression . XOR expression
    (155) bitwise_expression -> expression . AND_NOT expression
    (156) bitwise_expression -> expression . LSHIFT expression
    (157) bitwise_expression -> expression . RSHIFT expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    SEMICOLON       reduce using rule 63 (assignment_compound -> IDENTIFIER XOR_ASSIGN expression .)
    FUNC            reduce using rule 63 (assignment_compound -> IDENTIFIER XOR_ASSIGN expression .)
    TYPE            reduce using rule 63 (assignment_compound -> IDENTIFIER XOR_ASSIGN expression .)
    IDENTIFIER      reduce using rule 63 (assignment_compound -> IDENTIFIER XOR_ASSIGN expression .)
    VAR             reduce using rule 63 (assignment_compound -> IDENTIFIER XOR_ASSIGN expression .)
    CONST           reduce using rule 63 (assignment_compound -> IDENTIFIER XOR_ASSIGN expression .)
    LNOT            reduce using rule 63 (assignment_compound -> IDENTIFIER XOR_ASSIGN expression .)
    LBRACKET        reduce using rule 63 (assignment_compound -> IDENTIFIER XOR_ASSIGN expression .)
    LPAREN          reduce using rule 63 (assignment_compound -> IDENTIFIER XOR_ASSIGN expression .)
    INT             reduce using rule 63 (assignment_compound -> IDENTIFIER XOR_ASSIGN expression .)
    FLOAT64         reduce using rule 63 (assignment_compound -> IDENTIFIER XOR_ASSIGN expression .)
    TRUE            reduce using rule 63 (assignment_compound -> IDENTIFIER XOR_ASSIGN expression .)
    FALSE           reduce using rule 63 (assignment_compound -> IDENTIFIER XOR_ASSIGN expression .)
    STRING          reduce using rule 63 (assignment_compound -> IDENTIFIER XOR_ASSIGN expression .)
    RETURN          reduce using rule 63 (assignment_compound -> IDENTIFIER XOR_ASSIGN expression .)
    FOR             reduce using rule 63 (assignment_compound -> IDENTIFIER XOR_ASSIGN expression .)
    IF              reduce using rule 63 (assignment_compound -> IDENTIFIER XOR_ASSIGN expression .)
    SWITCH          reduce using rule 63 (assignment_compound -> IDENTIFIER XOR_ASSIGN expression .)
    BREAK           reduce using rule 63 (assignment_compound -> IDENTIFIER XOR_ASSIGN expression .)
    CONTINUE        reduce using rule 63 (assignment_compound -> IDENTIFIER XOR_ASSIGN expression .)
    FALLTHROUGH     reduce using rule 63 (assignment_compound -> IDENTIFIER XOR_ASSIGN expression .)
    $end            reduce using rule 63 (assignment_compound -> IDENTIFIER XOR_ASSIGN expression .)
    RBRACE          reduce using rule 63 (assignment_compound -> IDENTIFIER XOR_ASSIGN expression .)
    CASE            reduce using rule 63 (assignment_compound -> IDENTIFIER XOR_ASSIGN expression .)
    DEFAULT         reduce using rule 63 (assignment_compound -> IDENTIFIER XOR_ASSIGN expression .)
    DOT             shift and go to state 58
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    TIMES           shift and go to state 61
    DIVIDE          shift and go to state 62
    MODULE          shift and go to state 63
    EQ              shift and go to state 64
    NEQ             shift and go to state 65
    LT              shift and go to state 66
    LE              shift and go to state 67
    GT              shift and go to state 68
    GE              shift and go to state 69
    LAND            shift and go to state 70
    LOR             shift and go to state 71
    AND             shift and go to state 72
    OR              shift and go to state 73
    XOR             shift and go to state 74
    AND_NOT         shift and go to state 75
    LSHIFT          shift and go to state 76
    RSHIFT          shift and go to state 77

  ! PLUS            [ reduce using rule 63 (assignment_compound -> IDENTIFIER XOR_ASSIGN expression .) ]
  ! MINUS           [ reduce using rule 63 (assignment_compound -> IDENTIFIER XOR_ASSIGN expression .) ]
>>>>>>> Stashed changes

    block                          shift and go to state 174

state 151

<<<<<<< Updated upstream
    (118) return_type -> type .

    LBRACE          reduce using rule 118 (return_type -> type .)
=======
    (64) assignment_compound -> IDENTIFIER LSHIFT_ASSIGN expression .
    (100) expression -> expression . DOT IDENTIFIER
    (135) binary_expression -> expression . PLUS expression
    (136) binary_expression -> expression . MINUS expression
    (137) binary_expression -> expression . TIMES expression
    (138) binary_expression -> expression . DIVIDE expression
    (139) binary_expression -> expression . MODULE expression
    (144) relational_expression -> expression . EQ expression
    (145) relational_expression -> expression . NEQ expression
    (146) relational_expression -> expression . LT expression
    (147) relational_expression -> expression . LE expression
    (148) relational_expression -> expression . GT expression
    (149) relational_expression -> expression . GE expression
    (150) logical_expression -> expression . LAND expression
    (151) logical_expression -> expression . LOR expression
    (152) bitwise_expression -> expression . AND expression
    (153) bitwise_expression -> expression . OR expression
    (154) bitwise_expression -> expression . XOR expression
    (155) bitwise_expression -> expression . AND_NOT expression
    (156) bitwise_expression -> expression . LSHIFT expression
    (157) bitwise_expression -> expression . RSHIFT expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    SEMICOLON       reduce using rule 64 (assignment_compound -> IDENTIFIER LSHIFT_ASSIGN expression .)
    FUNC            reduce using rule 64 (assignment_compound -> IDENTIFIER LSHIFT_ASSIGN expression .)
    TYPE            reduce using rule 64 (assignment_compound -> IDENTIFIER LSHIFT_ASSIGN expression .)
    IDENTIFIER      reduce using rule 64 (assignment_compound -> IDENTIFIER LSHIFT_ASSIGN expression .)
    VAR             reduce using rule 64 (assignment_compound -> IDENTIFIER LSHIFT_ASSIGN expression .)
    CONST           reduce using rule 64 (assignment_compound -> IDENTIFIER LSHIFT_ASSIGN expression .)
    LNOT            reduce using rule 64 (assignment_compound -> IDENTIFIER LSHIFT_ASSIGN expression .)
    LBRACKET        reduce using rule 64 (assignment_compound -> IDENTIFIER LSHIFT_ASSIGN expression .)
    LPAREN          reduce using rule 64 (assignment_compound -> IDENTIFIER LSHIFT_ASSIGN expression .)
    INT             reduce using rule 64 (assignment_compound -> IDENTIFIER LSHIFT_ASSIGN expression .)
    FLOAT64         reduce using rule 64 (assignment_compound -> IDENTIFIER LSHIFT_ASSIGN expression .)
    TRUE            reduce using rule 64 (assignment_compound -> IDENTIFIER LSHIFT_ASSIGN expression .)
    FALSE           reduce using rule 64 (assignment_compound -> IDENTIFIER LSHIFT_ASSIGN expression .)
    STRING          reduce using rule 64 (assignment_compound -> IDENTIFIER LSHIFT_ASSIGN expression .)
    RETURN          reduce using rule 64 (assignment_compound -> IDENTIFIER LSHIFT_ASSIGN expression .)
    FOR             reduce using rule 64 (assignment_compound -> IDENTIFIER LSHIFT_ASSIGN expression .)
    IF              reduce using rule 64 (assignment_compound -> IDENTIFIER LSHIFT_ASSIGN expression .)
    SWITCH          reduce using rule 64 (assignment_compound -> IDENTIFIER LSHIFT_ASSIGN expression .)
    BREAK           reduce using rule 64 (assignment_compound -> IDENTIFIER LSHIFT_ASSIGN expression .)
    CONTINUE        reduce using rule 64 (assignment_compound -> IDENTIFIER LSHIFT_ASSIGN expression .)
    FALLTHROUGH     reduce using rule 64 (assignment_compound -> IDENTIFIER LSHIFT_ASSIGN expression .)
    $end            reduce using rule 64 (assignment_compound -> IDENTIFIER LSHIFT_ASSIGN expression .)
    RBRACE          reduce using rule 64 (assignment_compound -> IDENTIFIER LSHIFT_ASSIGN expression .)
    CASE            reduce using rule 64 (assignment_compound -> IDENTIFIER LSHIFT_ASSIGN expression .)
    DEFAULT         reduce using rule 64 (assignment_compound -> IDENTIFIER LSHIFT_ASSIGN expression .)
    DOT             shift and go to state 58
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    TIMES           shift and go to state 61
    DIVIDE          shift and go to state 62
    MODULE          shift and go to state 63
    EQ              shift and go to state 64
    NEQ             shift and go to state 65
    LT              shift and go to state 66
    LE              shift and go to state 67
    GT              shift and go to state 68
    GE              shift and go to state 69
    LAND            shift and go to state 70
    LOR             shift and go to state 71
    AND             shift and go to state 72
    OR              shift and go to state 73
    XOR             shift and go to state 74
    AND_NOT         shift and go to state 75
    LSHIFT          shift and go to state 76
    RSHIFT          shift and go to state 77

  ! PLUS            [ reduce using rule 64 (assignment_compound -> IDENTIFIER LSHIFT_ASSIGN expression .) ]
  ! MINUS           [ reduce using rule 64 (assignment_compound -> IDENTIFIER LSHIFT_ASSIGN expression .) ]
>>>>>>> Stashed changes


state 152

<<<<<<< Updated upstream
    (120) return_type -> empty .

    LBRACE          reduce using rule 120 (return_type -> empty .)
=======
    (65) assignment_compound -> IDENTIFIER RSHIFT_ASSIGN expression .
    (100) expression -> expression . DOT IDENTIFIER
    (135) binary_expression -> expression . PLUS expression
    (136) binary_expression -> expression . MINUS expression
    (137) binary_expression -> expression . TIMES expression
    (138) binary_expression -> expression . DIVIDE expression
    (139) binary_expression -> expression . MODULE expression
    (144) relational_expression -> expression . EQ expression
    (145) relational_expression -> expression . NEQ expression
    (146) relational_expression -> expression . LT expression
    (147) relational_expression -> expression . LE expression
    (148) relational_expression -> expression . GT expression
    (149) relational_expression -> expression . GE expression
    (150) logical_expression -> expression . LAND expression
    (151) logical_expression -> expression . LOR expression
    (152) bitwise_expression -> expression . AND expression
    (153) bitwise_expression -> expression . OR expression
    (154) bitwise_expression -> expression . XOR expression
    (155) bitwise_expression -> expression . AND_NOT expression
    (156) bitwise_expression -> expression . LSHIFT expression
    (157) bitwise_expression -> expression . RSHIFT expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    SEMICOLON       reduce using rule 65 (assignment_compound -> IDENTIFIER RSHIFT_ASSIGN expression .)
    FUNC            reduce using rule 65 (assignment_compound -> IDENTIFIER RSHIFT_ASSIGN expression .)
    TYPE            reduce using rule 65 (assignment_compound -> IDENTIFIER RSHIFT_ASSIGN expression .)
    IDENTIFIER      reduce using rule 65 (assignment_compound -> IDENTIFIER RSHIFT_ASSIGN expression .)
    VAR             reduce using rule 65 (assignment_compound -> IDENTIFIER RSHIFT_ASSIGN expression .)
    CONST           reduce using rule 65 (assignment_compound -> IDENTIFIER RSHIFT_ASSIGN expression .)
    LNOT            reduce using rule 65 (assignment_compound -> IDENTIFIER RSHIFT_ASSIGN expression .)
    LBRACKET        reduce using rule 65 (assignment_compound -> IDENTIFIER RSHIFT_ASSIGN expression .)
    LPAREN          reduce using rule 65 (assignment_compound -> IDENTIFIER RSHIFT_ASSIGN expression .)
    INT             reduce using rule 65 (assignment_compound -> IDENTIFIER RSHIFT_ASSIGN expression .)
    FLOAT64         reduce using rule 65 (assignment_compound -> IDENTIFIER RSHIFT_ASSIGN expression .)
    TRUE            reduce using rule 65 (assignment_compound -> IDENTIFIER RSHIFT_ASSIGN expression .)
    FALSE           reduce using rule 65 (assignment_compound -> IDENTIFIER RSHIFT_ASSIGN expression .)
    STRING          reduce using rule 65 (assignment_compound -> IDENTIFIER RSHIFT_ASSIGN expression .)
    RETURN          reduce using rule 65 (assignment_compound -> IDENTIFIER RSHIFT_ASSIGN expression .)
    FOR             reduce using rule 65 (assignment_compound -> IDENTIFIER RSHIFT_ASSIGN expression .)
    IF              reduce using rule 65 (assignment_compound -> IDENTIFIER RSHIFT_ASSIGN expression .)
    SWITCH          reduce using rule 65 (assignment_compound -> IDENTIFIER RSHIFT_ASSIGN expression .)
    BREAK           reduce using rule 65 (assignment_compound -> IDENTIFIER RSHIFT_ASSIGN expression .)
    CONTINUE        reduce using rule 65 (assignment_compound -> IDENTIFIER RSHIFT_ASSIGN expression .)
    FALLTHROUGH     reduce using rule 65 (assignment_compound -> IDENTIFIER RSHIFT_ASSIGN expression .)
    $end            reduce using rule 65 (assignment_compound -> IDENTIFIER RSHIFT_ASSIGN expression .)
    RBRACE          reduce using rule 65 (assignment_compound -> IDENTIFIER RSHIFT_ASSIGN expression .)
    CASE            reduce using rule 65 (assignment_compound -> IDENTIFIER RSHIFT_ASSIGN expression .)
    DEFAULT         reduce using rule 65 (assignment_compound -> IDENTIFIER RSHIFT_ASSIGN expression .)
    DOT             shift and go to state 58
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    TIMES           shift and go to state 61
    DIVIDE          shift and go to state 62
    MODULE          shift and go to state 63
    EQ              shift and go to state 64
    NEQ             shift and go to state 65
    LT              shift and go to state 66
    LE              shift and go to state 67
    GT              shift and go to state 68
    GE              shift and go to state 69
    LAND            shift and go to state 70
    LOR             shift and go to state 71
    AND             shift and go to state 72
    OR              shift and go to state 73
    XOR             shift and go to state 74
    AND_NOT         shift and go to state 75
    LSHIFT          shift and go to state 76
    RSHIFT          shift and go to state 77

  ! PLUS            [ reduce using rule 65 (assignment_compound -> IDENTIFIER RSHIFT_ASSIGN expression .) ]
  ! MINUS           [ reduce using rule 65 (assignment_compound -> IDENTIFIER RSHIFT_ASSIGN expression .) ]
>>>>>>> Stashed changes


state 153

<<<<<<< Updated upstream
    (113) parameter_list -> parameter_list COMMA parameter .

    RPAREN          reduce using rule 113 (parameter_list -> parameter_list COMMA parameter .)
    COMMA           reduce using rule 113 (parameter_list -> parameter_list COMMA parameter .)
=======
    (103) expression -> IDENTIFIER LPAREN argument_list . RPAREN

    RPAREN          shift and go to state 215
>>>>>>> Stashed changes


state 154

<<<<<<< Updated upstream
    (146) method_declaration -> FUNC LPAREN receiver RPAREN IDENTIFIER LPAREN . parameter_list RPAREN return_type block
    (113) parameter_list -> . parameter_list COMMA parameter
    (114) parameter_list -> . parameter
    (115) parameter_list -> . empty
    (116) parameter -> . IDENTIFIER type
    (117) parameter -> . IDENTIFIER ELLIPSIS primitive_type
    (7) empty -> .

    IDENTIFIER      shift and go to state 69
    RPAREN          reduce using rule 7 (empty -> .)
    COMMA           reduce using rule 7 (empty -> .)
=======
    (104) argument_list -> expression_list .
    (101) expression_list -> expression_list . COMMA expression

    RPAREN          reduce using rule 104 (argument_list -> expression_list .)
    COMMA           shift and go to state 216
>>>>>>> Stashed changes

    parameter_list                 shift and go to state 176
    parameter                      shift and go to state 71
    empty                          shift and go to state 72

state 155

<<<<<<< Updated upstream
    (155) struct_type -> STRUCT LBRACE field_list RBRACE .

    VAR             reduce using rule 155 (struct_type -> STRUCT LBRACE field_list RBRACE .)
    CONST           reduce using rule 155 (struct_type -> STRUCT LBRACE field_list RBRACE .)
    FUNC            reduce using rule 155 (struct_type -> STRUCT LBRACE field_list RBRACE .)
    TYPE            reduce using rule 155 (struct_type -> STRUCT LBRACE field_list RBRACE .)
    $end            reduce using rule 155 (struct_type -> STRUCT LBRACE field_list RBRACE .)
=======
    (105) argument_list -> empty .

    RPAREN          reduce using rule 105 (argument_list -> empty .)
>>>>>>> Stashed changes


state 156

<<<<<<< Updated upstream
    (144) field_list -> field_list field_declaration .

    RBRACE          reduce using rule 144 (field_list -> field_list field_declaration .)
    IDENTIFIER      reduce using rule 144 (field_list -> field_list field_declaration .)
=======
    (102) expression_list -> expression .
    (100) expression -> expression . DOT IDENTIFIER
    (135) binary_expression -> expression . PLUS expression
    (136) binary_expression -> expression . MINUS expression
    (137) binary_expression -> expression . TIMES expression
    (138) binary_expression -> expression . DIVIDE expression
    (139) binary_expression -> expression . MODULE expression
    (144) relational_expression -> expression . EQ expression
    (145) relational_expression -> expression . NEQ expression
    (146) relational_expression -> expression . LT expression
    (147) relational_expression -> expression . LE expression
    (148) relational_expression -> expression . GT expression
    (149) relational_expression -> expression . GE expression
    (150) logical_expression -> expression . LAND expression
    (151) logical_expression -> expression . LOR expression
    (152) bitwise_expression -> expression . AND expression
    (153) bitwise_expression -> expression . OR expression
    (154) bitwise_expression -> expression . XOR expression
    (155) bitwise_expression -> expression . AND_NOT expression
    (156) bitwise_expression -> expression . LSHIFT expression
    (157) bitwise_expression -> expression . RSHIFT expression

    COMMA           reduce using rule 102 (expression_list -> expression .)
    RPAREN          reduce using rule 102 (expression_list -> expression .)
    RBRACE          reduce using rule 102 (expression_list -> expression .)
    DOT             shift and go to state 58
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    TIMES           shift and go to state 61
    DIVIDE          shift and go to state 62
    MODULE          shift and go to state 63
    EQ              shift and go to state 64
    NEQ             shift and go to state 65
    LT              shift and go to state 66
    LE              shift and go to state 67
    GT              shift and go to state 68
    GE              shift and go to state 69
    LAND            shift and go to state 70
    LOR             shift and go to state 71
    AND             shift and go to state 72
    OR              shift and go to state 73
    XOR             shift and go to state 74
    AND_NOT         shift and go to state 75
    LSHIFT          shift and go to state 76
    RSHIFT          shift and go to state 77
>>>>>>> Stashed changes


state 157

<<<<<<< Updated upstream
    (145) field_declaration -> IDENTIFIER type .

    RBRACE          reduce using rule 145 (field_declaration -> IDENTIFIER type .)
    IDENTIFIER      reduce using rule 145 (field_declaration -> IDENTIFIER type .)
=======
    (130) keyed_element -> IDENTIFIER . COLON expression
    (96) expression -> IDENTIFIER .
    (98) expression -> IDENTIFIER . PLUSPLUS
    (99) expression -> IDENTIFIER . MINUSMINUS
    (103) expression -> IDENTIFIER . LPAREN argument_list RPAREN
    (133) expression -> IDENTIFIER . LBRACE keyed_element_list RBRACE
    (134) expression -> IDENTIFIER . LBRACE RBRACE

    COLON           shift and go to state 217
    DOT             reduce using rule 96 (expression -> IDENTIFIER .)
    PLUS            reduce using rule 96 (expression -> IDENTIFIER .)
    MINUS           reduce using rule 96 (expression -> IDENTIFIER .)
    TIMES           reduce using rule 96 (expression -> IDENTIFIER .)
    DIVIDE          reduce using rule 96 (expression -> IDENTIFIER .)
    MODULE          reduce using rule 96 (expression -> IDENTIFIER .)
    EQ              reduce using rule 96 (expression -> IDENTIFIER .)
    NEQ             reduce using rule 96 (expression -> IDENTIFIER .)
    LT              reduce using rule 96 (expression -> IDENTIFIER .)
    LE              reduce using rule 96 (expression -> IDENTIFIER .)
    GT              reduce using rule 96 (expression -> IDENTIFIER .)
    GE              reduce using rule 96 (expression -> IDENTIFIER .)
    LAND            reduce using rule 96 (expression -> IDENTIFIER .)
    LOR             reduce using rule 96 (expression -> IDENTIFIER .)
    AND             reduce using rule 96 (expression -> IDENTIFIER .)
    OR              reduce using rule 96 (expression -> IDENTIFIER .)
    XOR             reduce using rule 96 (expression -> IDENTIFIER .)
    AND_NOT         reduce using rule 96 (expression -> IDENTIFIER .)
    LSHIFT          reduce using rule 96 (expression -> IDENTIFIER .)
    RSHIFT          reduce using rule 96 (expression -> IDENTIFIER .)
    RBRACE          reduce using rule 96 (expression -> IDENTIFIER .)
    COMMA           reduce using rule 96 (expression -> IDENTIFIER .)
    PLUSPLUS        shift and go to state 92
    MINUSMINUS      shift and go to state 93
    LPAREN          shift and go to state 94
    LBRACE          shift and go to state 95
>>>>>>> Stashed changes


state 158

<<<<<<< Updated upstream
    (203) expression -> IDENTIFIER LPAREN argument_list RPAREN .

    DOT             reduce using rule 203 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    LBRACKET        reduce using rule 203 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    PLUS            reduce using rule 203 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    MINUS           reduce using rule 203 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    TIMES           reduce using rule 203 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    DIVIDE          reduce using rule 203 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    MODULE          reduce using rule 203 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    EQ              reduce using rule 203 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    NEQ             reduce using rule 203 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    LT              reduce using rule 203 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    LE              reduce using rule 203 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    GT              reduce using rule 203 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    GE              reduce using rule 203 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    LAND            reduce using rule 203 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    LOR             reduce using rule 203 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    AND             reduce using rule 203 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    OR              reduce using rule 203 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    XOR             reduce using rule 203 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    AND_NOT         reduce using rule 203 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    LSHIFT          reduce using rule 203 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    RSHIFT          reduce using rule 203 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    VAR             reduce using rule 203 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    CONST           reduce using rule 203 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    FUNC            reduce using rule 203 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    TYPE            reduce using rule 203 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    $end            reduce using rule 203 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    RPAREN          reduce using rule 203 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    COMMA           reduce using rule 203 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    RBRACKET        reduce using rule 203 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    RBRACE          reduce using rule 203 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    COLON           reduce using rule 203 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    BREAK           reduce using rule 203 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    CONTINUE        reduce using rule 203 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    IDENTIFIER      reduce using rule 203 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    LPAREN          reduce using rule 203 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    INT             reduce using rule 203 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    FLOAT64         reduce using rule 203 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    STRING          reduce using rule 203 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    TRUE            reduce using rule 203 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    FALSE           reduce using rule 203 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    LNOT            reduce using rule 203 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    IF              reduce using rule 203 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    SWITCH          reduce using rule 203 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    RETURN          reduce using rule 203 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    MAP             reduce using rule 203 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    FOR             reduce using rule 203 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    LBRACE          reduce using rule 203 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    CASE            reduce using rule 203 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    DEFAULT         reduce using rule 203 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    SEMICOLON       reduce using rule 203 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
=======
    (133) expression -> IDENTIFIER LBRACE keyed_element_list . RBRACE
    (128) keyed_element_list -> keyed_element_list . COMMA keyed_element

    RBRACE          shift and go to state 218
    COMMA           shift and go to state 219
>>>>>>> Stashed changes


state 159

<<<<<<< Updated upstream
    (69) expression_list -> expression_list COMMA . expression
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (125) expression -> . LNOT expression
    (126) expression -> . IDENTIFIER PLUSPLUS
    (127) expression -> . IDENTIFIER MINUSMINUS
    (138) expression -> . map_type LBRACE expression_map_list RBRACE
    (139) expression -> . map_type LBRACE RBRACE
    (161) expression -> . type_name LBRACE keyed_element_list RBRACE
    (162) expression -> . type_name LBRACE RBRACE
    (198) expression -> . array_type LBRACE expression_list RBRACE
    (199) expression -> . array_type LBRACE RBRACE
    (200) expression -> . expression DOT IDENTIFIER
    (201) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> . expression LBRACKET expression RBRACKET
    (203) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (137) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (163) type_name -> . IDENTIFIER
    (164) type_name -> . slice_type
    (165) type_name -> . array_type
    (166) type_name -> . map_type
    (197) array_type -> . LBRACKET INT RBRACKET primitive_type

    LPAREN          shift and go to state 54
    INT             shift and go to state 55
    FLOAT64         shift and go to state 56
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 57
    TRUE            shift and go to state 58
    FALSE           shift and go to state 59
    LNOT            shift and go to state 60
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39
=======
    (134) expression -> IDENTIFIER LBRACE RBRACE .

    DOT             reduce using rule 134 (expression -> IDENTIFIER LBRACE RBRACE .)
    PLUS            reduce using rule 134 (expression -> IDENTIFIER LBRACE RBRACE .)
    MINUS           reduce using rule 134 (expression -> IDENTIFIER LBRACE RBRACE .)
    TIMES           reduce using rule 134 (expression -> IDENTIFIER LBRACE RBRACE .)
    DIVIDE          reduce using rule 134 (expression -> IDENTIFIER LBRACE RBRACE .)
    MODULE          reduce using rule 134 (expression -> IDENTIFIER LBRACE RBRACE .)
    EQ              reduce using rule 134 (expression -> IDENTIFIER LBRACE RBRACE .)
    NEQ             reduce using rule 134 (expression -> IDENTIFIER LBRACE RBRACE .)
    LT              reduce using rule 134 (expression -> IDENTIFIER LBRACE RBRACE .)
    LE              reduce using rule 134 (expression -> IDENTIFIER LBRACE RBRACE .)
    GT              reduce using rule 134 (expression -> IDENTIFIER LBRACE RBRACE .)
    GE              reduce using rule 134 (expression -> IDENTIFIER LBRACE RBRACE .)
    LAND            reduce using rule 134 (expression -> IDENTIFIER LBRACE RBRACE .)
    LOR             reduce using rule 134 (expression -> IDENTIFIER LBRACE RBRACE .)
    AND             reduce using rule 134 (expression -> IDENTIFIER LBRACE RBRACE .)
    OR              reduce using rule 134 (expression -> IDENTIFIER LBRACE RBRACE .)
    XOR             reduce using rule 134 (expression -> IDENTIFIER LBRACE RBRACE .)
    AND_NOT         reduce using rule 134 (expression -> IDENTIFIER LBRACE RBRACE .)
    LSHIFT          reduce using rule 134 (expression -> IDENTIFIER LBRACE RBRACE .)
    RSHIFT          reduce using rule 134 (expression -> IDENTIFIER LBRACE RBRACE .)
    SEMICOLON       reduce using rule 134 (expression -> IDENTIFIER LBRACE RBRACE .)
    FUNC            reduce using rule 134 (expression -> IDENTIFIER LBRACE RBRACE .)
    TYPE            reduce using rule 134 (expression -> IDENTIFIER LBRACE RBRACE .)
    IDENTIFIER      reduce using rule 134 (expression -> IDENTIFIER LBRACE RBRACE .)
    VAR             reduce using rule 134 (expression -> IDENTIFIER LBRACE RBRACE .)
    CONST           reduce using rule 134 (expression -> IDENTIFIER LBRACE RBRACE .)
    LNOT            reduce using rule 134 (expression -> IDENTIFIER LBRACE RBRACE .)
    LBRACKET        reduce using rule 134 (expression -> IDENTIFIER LBRACE RBRACE .)
    LPAREN          reduce using rule 134 (expression -> IDENTIFIER LBRACE RBRACE .)
    INT             reduce using rule 134 (expression -> IDENTIFIER LBRACE RBRACE .)
    FLOAT64         reduce using rule 134 (expression -> IDENTIFIER LBRACE RBRACE .)
    TRUE            reduce using rule 134 (expression -> IDENTIFIER LBRACE RBRACE .)
    FALSE           reduce using rule 134 (expression -> IDENTIFIER LBRACE RBRACE .)
    STRING          reduce using rule 134 (expression -> IDENTIFIER LBRACE RBRACE .)
    RETURN          reduce using rule 134 (expression -> IDENTIFIER LBRACE RBRACE .)
    FOR             reduce using rule 134 (expression -> IDENTIFIER LBRACE RBRACE .)
    IF              reduce using rule 134 (expression -> IDENTIFIER LBRACE RBRACE .)
    SWITCH          reduce using rule 134 (expression -> IDENTIFIER LBRACE RBRACE .)
    BREAK           reduce using rule 134 (expression -> IDENTIFIER LBRACE RBRACE .)
    CONTINUE        reduce using rule 134 (expression -> IDENTIFIER LBRACE RBRACE .)
    FALLTHROUGH     reduce using rule 134 (expression -> IDENTIFIER LBRACE RBRACE .)
    $end            reduce using rule 134 (expression -> IDENTIFIER LBRACE RBRACE .)
    RPAREN          reduce using rule 134 (expression -> IDENTIFIER LBRACE RBRACE .)
    COMMA           reduce using rule 134 (expression -> IDENTIFIER LBRACE RBRACE .)
    RBRACE          reduce using rule 134 (expression -> IDENTIFIER LBRACE RBRACE .)
    CASE            reduce using rule 134 (expression -> IDENTIFIER LBRACE RBRACE .)
    DEFAULT         reduce using rule 134 (expression -> IDENTIFIER LBRACE RBRACE .)
    LBRACE          reduce using rule 134 (expression -> IDENTIFIER LBRACE RBRACE .)
    COLON           reduce using rule 134 (expression -> IDENTIFIER LBRACE RBRACE .)
>>>>>>> Stashed changes

    expression                     shift and go to state 177
    slice_type                     shift and go to state 53
    map_type                       shift and go to state 61
    type_name                      shift and go to state 62
    array_type                     shift and go to state 63

state 160

<<<<<<< Updated upstream
    (201) expression -> expression DOT IDENTIFIER LPAREN . argument_list RPAREN
    (204) argument_list -> . expression_list
    (205) argument_list -> . empty
    (68) expression_list -> . expression
    (69) expression_list -> . expression_list COMMA expression
    (7) empty -> .
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (125) expression -> . LNOT expression
    (126) expression -> . IDENTIFIER PLUSPLUS
    (127) expression -> . IDENTIFIER MINUSMINUS
    (138) expression -> . map_type LBRACE expression_map_list RBRACE
    (139) expression -> . map_type LBRACE RBRACE
    (161) expression -> . type_name LBRACE keyed_element_list RBRACE
    (162) expression -> . type_name LBRACE RBRACE
    (198) expression -> . array_type LBRACE expression_list RBRACE
    (199) expression -> . array_type LBRACE RBRACE
    (200) expression -> . expression DOT IDENTIFIER
    (201) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> . expression LBRACKET expression RBRACKET
    (203) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (137) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (163) type_name -> . IDENTIFIER
    (164) type_name -> . slice_type
    (165) type_name -> . array_type
    (166) type_name -> . map_type
    (197) array_type -> . LBRACKET INT RBRACKET primitive_type

    RPAREN          reduce using rule 7 (empty -> .)
    LPAREN          shift and go to state 54
    INT             shift and go to state 55
    FLOAT64         shift and go to state 56
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 57
    TRUE            shift and go to state 58
    FALSE           shift and go to state 59
    LNOT            shift and go to state 60
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39
=======
    (129) keyed_element_list -> keyed_element .

    RBRACE          reduce using rule 129 (keyed_element_list -> keyed_element .)
    COMMA           reduce using rule 129 (keyed_element_list -> keyed_element .)
>>>>>>> Stashed changes

    expression                     shift and go to state 127
    argument_list                  shift and go to state 178
    expression_list                shift and go to state 125
    empty                          shift and go to state 126
    slice_type                     shift and go to state 53
    map_type                       shift and go to state 61
    type_name                      shift and go to state 62
    array_type                     shift and go to state 63

state 161

<<<<<<< Updated upstream
    (202) expression -> expression LBRACKET expression RBRACKET .

    DOT             reduce using rule 202 (expression -> expression LBRACKET expression RBRACKET .)
    LBRACKET        reduce using rule 202 (expression -> expression LBRACKET expression RBRACKET .)
    PLUS            reduce using rule 202 (expression -> expression LBRACKET expression RBRACKET .)
    MINUS           reduce using rule 202 (expression -> expression LBRACKET expression RBRACKET .)
    TIMES           reduce using rule 202 (expression -> expression LBRACKET expression RBRACKET .)
    DIVIDE          reduce using rule 202 (expression -> expression LBRACKET expression RBRACKET .)
    MODULE          reduce using rule 202 (expression -> expression LBRACKET expression RBRACKET .)
    EQ              reduce using rule 202 (expression -> expression LBRACKET expression RBRACKET .)
    NEQ             reduce using rule 202 (expression -> expression LBRACKET expression RBRACKET .)
    LT              reduce using rule 202 (expression -> expression LBRACKET expression RBRACKET .)
    LE              reduce using rule 202 (expression -> expression LBRACKET expression RBRACKET .)
    GT              reduce using rule 202 (expression -> expression LBRACKET expression RBRACKET .)
    GE              reduce using rule 202 (expression -> expression LBRACKET expression RBRACKET .)
    LAND            reduce using rule 202 (expression -> expression LBRACKET expression RBRACKET .)
    LOR             reduce using rule 202 (expression -> expression LBRACKET expression RBRACKET .)
    AND             reduce using rule 202 (expression -> expression LBRACKET expression RBRACKET .)
    OR              reduce using rule 202 (expression -> expression LBRACKET expression RBRACKET .)
    XOR             reduce using rule 202 (expression -> expression LBRACKET expression RBRACKET .)
    AND_NOT         reduce using rule 202 (expression -> expression LBRACKET expression RBRACKET .)
    LSHIFT          reduce using rule 202 (expression -> expression LBRACKET expression RBRACKET .)
    RSHIFT          reduce using rule 202 (expression -> expression LBRACKET expression RBRACKET .)
    VAR             reduce using rule 202 (expression -> expression LBRACKET expression RBRACKET .)
    CONST           reduce using rule 202 (expression -> expression LBRACKET expression RBRACKET .)
    FUNC            reduce using rule 202 (expression -> expression LBRACKET expression RBRACKET .)
    TYPE            reduce using rule 202 (expression -> expression LBRACKET expression RBRACKET .)
    $end            reduce using rule 202 (expression -> expression LBRACKET expression RBRACKET .)
    RPAREN          reduce using rule 202 (expression -> expression LBRACKET expression RBRACKET .)
    COMMA           reduce using rule 202 (expression -> expression LBRACKET expression RBRACKET .)
    RBRACKET        reduce using rule 202 (expression -> expression LBRACKET expression RBRACKET .)
    RBRACE          reduce using rule 202 (expression -> expression LBRACKET expression RBRACKET .)
    COLON           reduce using rule 202 (expression -> expression LBRACKET expression RBRACKET .)
    BREAK           reduce using rule 202 (expression -> expression LBRACKET expression RBRACKET .)
    CONTINUE        reduce using rule 202 (expression -> expression LBRACKET expression RBRACKET .)
    IDENTIFIER      reduce using rule 202 (expression -> expression LBRACKET expression RBRACKET .)
    LPAREN          reduce using rule 202 (expression -> expression LBRACKET expression RBRACKET .)
    INT             reduce using rule 202 (expression -> expression LBRACKET expression RBRACKET .)
    FLOAT64         reduce using rule 202 (expression -> expression LBRACKET expression RBRACKET .)
    STRING          reduce using rule 202 (expression -> expression LBRACKET expression RBRACKET .)
    TRUE            reduce using rule 202 (expression -> expression LBRACKET expression RBRACKET .)
    FALSE           reduce using rule 202 (expression -> expression LBRACKET expression RBRACKET .)
    LNOT            reduce using rule 202 (expression -> expression LBRACKET expression RBRACKET .)
    IF              reduce using rule 202 (expression -> expression LBRACKET expression RBRACKET .)
    SWITCH          reduce using rule 202 (expression -> expression LBRACKET expression RBRACKET .)
    RETURN          reduce using rule 202 (expression -> expression LBRACKET expression RBRACKET .)
    MAP             reduce using rule 202 (expression -> expression LBRACKET expression RBRACKET .)
    FOR             reduce using rule 202 (expression -> expression LBRACKET expression RBRACKET .)
    LBRACE          reduce using rule 202 (expression -> expression LBRACKET expression RBRACKET .)
    CASE            reduce using rule 202 (expression -> expression LBRACKET expression RBRACKET .)
    DEFAULT         reduce using rule 202 (expression -> expression LBRACKET expression RBRACKET .)
    SEMICOLON       reduce using rule 202 (expression -> expression LBRACKET expression RBRACKET .)
=======
    (132) keyed_element -> expression .
    (100) expression -> expression . DOT IDENTIFIER
    (135) binary_expression -> expression . PLUS expression
    (136) binary_expression -> expression . MINUS expression
    (137) binary_expression -> expression . TIMES expression
    (138) binary_expression -> expression . DIVIDE expression
    (139) binary_expression -> expression . MODULE expression
    (144) relational_expression -> expression . EQ expression
    (145) relational_expression -> expression . NEQ expression
    (146) relational_expression -> expression . LT expression
    (147) relational_expression -> expression . LE expression
    (148) relational_expression -> expression . GT expression
    (149) relational_expression -> expression . GE expression
    (150) logical_expression -> expression . LAND expression
    (151) logical_expression -> expression . LOR expression
    (152) bitwise_expression -> expression . AND expression
    (153) bitwise_expression -> expression . OR expression
    (154) bitwise_expression -> expression . XOR expression
    (155) bitwise_expression -> expression . AND_NOT expression
    (156) bitwise_expression -> expression . LSHIFT expression
    (157) bitwise_expression -> expression . RSHIFT expression

    RBRACE          reduce using rule 132 (keyed_element -> expression .)
    COMMA           reduce using rule 132 (keyed_element -> expression .)
    DOT             shift and go to state 58
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    TIMES           shift and go to state 61
    DIVIDE          shift and go to state 62
    MODULE          shift and go to state 63
    EQ              shift and go to state 64
    NEQ             shift and go to state 65
    LT              shift and go to state 66
    LE              shift and go to state 67
    GT              shift and go to state 68
    GE              shift and go to state 69
    LAND            shift and go to state 70
    LOR             shift and go to state 71
    AND             shift and go to state 72
    OR              shift and go to state 73
    XOR             shift and go to state 74
    AND_NOT         shift and go to state 75
    LSHIFT          shift and go to state 76
    RSHIFT          shift and go to state 77
>>>>>>> Stashed changes


state 162

<<<<<<< Updated upstream
    (66) expression -> slice_type LBRACE expression_list RBRACE .

    DOT             reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    LBRACKET        reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    PLUS            reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    MINUS           reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    TIMES           reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    DIVIDE          reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    MODULE          reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    EQ              reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    NEQ             reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    LT              reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    LE              reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    GT              reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    GE              reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    LAND            reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    LOR             reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    AND             reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    OR              reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    XOR             reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    AND_NOT         reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    LSHIFT          reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    RSHIFT          reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    VAR             reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    CONST           reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    FUNC            reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    TYPE            reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    $end            reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    RPAREN          reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    COMMA           reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    RBRACKET        reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    RBRACE          reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    COLON           reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    BREAK           reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    CONTINUE        reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    IDENTIFIER      reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    LPAREN          reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    INT             reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    FLOAT64         reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    STRING          reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    TRUE            reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    FALSE           reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    LNOT            reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    IF              reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    SWITCH          reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    RETURN          reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    MAP             reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    FOR             reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    LBRACE          reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    CASE            reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    DEFAULT         reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
    SEMICOLON       reduce using rule 66 (expression -> slice_type LBRACE expression_list RBRACE .)
=======
    (131) keyed_element -> INT . COLON expression
    (92) expression -> INT .

    COLON           shift and go to state 220
    DOT             reduce using rule 92 (expression -> INT .)
    PLUS            reduce using rule 92 (expression -> INT .)
    MINUS           reduce using rule 92 (expression -> INT .)
    TIMES           reduce using rule 92 (expression -> INT .)
    DIVIDE          reduce using rule 92 (expression -> INT .)
    MODULE          reduce using rule 92 (expression -> INT .)
    EQ              reduce using rule 92 (expression -> INT .)
    NEQ             reduce using rule 92 (expression -> INT .)
    LT              reduce using rule 92 (expression -> INT .)
    LE              reduce using rule 92 (expression -> INT .)
    GT              reduce using rule 92 (expression -> INT .)
    GE              reduce using rule 92 (expression -> INT .)
    LAND            reduce using rule 92 (expression -> INT .)
    LOR             reduce using rule 92 (expression -> INT .)
    AND             reduce using rule 92 (expression -> INT .)
    OR              reduce using rule 92 (expression -> INT .)
    XOR             reduce using rule 92 (expression -> INT .)
    AND_NOT         reduce using rule 92 (expression -> INT .)
    LSHIFT          reduce using rule 92 (expression -> INT .)
    RSHIFT          reduce using rule 92 (expression -> INT .)
    RBRACE          reduce using rule 92 (expression -> INT .)
    COMMA           reduce using rule 92 (expression -> INT .)
>>>>>>> Stashed changes


state 163

<<<<<<< Updated upstream
    (138) expression -> map_type LBRACE expression_map_list RBRACE .

    DOT             reduce using rule 138 (expression -> map_type LBRACE expression_map_list RBRACE .)
    LBRACKET        reduce using rule 138 (expression -> map_type LBRACE expression_map_list RBRACE .)
    PLUS            reduce using rule 138 (expression -> map_type LBRACE expression_map_list RBRACE .)
    MINUS           reduce using rule 138 (expression -> map_type LBRACE expression_map_list RBRACE .)
    TIMES           reduce using rule 138 (expression -> map_type LBRACE expression_map_list RBRACE .)
    DIVIDE          reduce using rule 138 (expression -> map_type LBRACE expression_map_list RBRACE .)
    MODULE          reduce using rule 138 (expression -> map_type LBRACE expression_map_list RBRACE .)
    EQ              reduce using rule 138 (expression -> map_type LBRACE expression_map_list RBRACE .)
    NEQ             reduce using rule 138 (expression -> map_type LBRACE expression_map_list RBRACE .)
    LT              reduce using rule 138 (expression -> map_type LBRACE expression_map_list RBRACE .)
    LE              reduce using rule 138 (expression -> map_type LBRACE expression_map_list RBRACE .)
    GT              reduce using rule 138 (expression -> map_type LBRACE expression_map_list RBRACE .)
    GE              reduce using rule 138 (expression -> map_type LBRACE expression_map_list RBRACE .)
    LAND            reduce using rule 138 (expression -> map_type LBRACE expression_map_list RBRACE .)
    LOR             reduce using rule 138 (expression -> map_type LBRACE expression_map_list RBRACE .)
    AND             reduce using rule 138 (expression -> map_type LBRACE expression_map_list RBRACE .)
    OR              reduce using rule 138 (expression -> map_type LBRACE expression_map_list RBRACE .)
    XOR             reduce using rule 138 (expression -> map_type LBRACE expression_map_list RBRACE .)
    AND_NOT         reduce using rule 138 (expression -> map_type LBRACE expression_map_list RBRACE .)
    LSHIFT          reduce using rule 138 (expression -> map_type LBRACE expression_map_list RBRACE .)
    RSHIFT          reduce using rule 138 (expression -> map_type LBRACE expression_map_list RBRACE .)
    VAR             reduce using rule 138 (expression -> map_type LBRACE expression_map_list RBRACE .)
    CONST           reduce using rule 138 (expression -> map_type LBRACE expression_map_list RBRACE .)
    FUNC            reduce using rule 138 (expression -> map_type LBRACE expression_map_list RBRACE .)
    TYPE            reduce using rule 138 (expression -> map_type LBRACE expression_map_list RBRACE .)
    $end            reduce using rule 138 (expression -> map_type LBRACE expression_map_list RBRACE .)
    RPAREN          reduce using rule 138 (expression -> map_type LBRACE expression_map_list RBRACE .)
    COMMA           reduce using rule 138 (expression -> map_type LBRACE expression_map_list RBRACE .)
    RBRACKET        reduce using rule 138 (expression -> map_type LBRACE expression_map_list RBRACE .)
    RBRACE          reduce using rule 138 (expression -> map_type LBRACE expression_map_list RBRACE .)
    COLON           reduce using rule 138 (expression -> map_type LBRACE expression_map_list RBRACE .)
    BREAK           reduce using rule 138 (expression -> map_type LBRACE expression_map_list RBRACE .)
    CONTINUE        reduce using rule 138 (expression -> map_type LBRACE expression_map_list RBRACE .)
    IDENTIFIER      reduce using rule 138 (expression -> map_type LBRACE expression_map_list RBRACE .)
    LPAREN          reduce using rule 138 (expression -> map_type LBRACE expression_map_list RBRACE .)
    INT             reduce using rule 138 (expression -> map_type LBRACE expression_map_list RBRACE .)
    FLOAT64         reduce using rule 138 (expression -> map_type LBRACE expression_map_list RBRACE .)
    STRING          reduce using rule 138 (expression -> map_type LBRACE expression_map_list RBRACE .)
    TRUE            reduce using rule 138 (expression -> map_type LBRACE expression_map_list RBRACE .)
    FALSE           reduce using rule 138 (expression -> map_type LBRACE expression_map_list RBRACE .)
    LNOT            reduce using rule 138 (expression -> map_type LBRACE expression_map_list RBRACE .)
    IF              reduce using rule 138 (expression -> map_type LBRACE expression_map_list RBRACE .)
    SWITCH          reduce using rule 138 (expression -> map_type LBRACE expression_map_list RBRACE .)
    RETURN          reduce using rule 138 (expression -> map_type LBRACE expression_map_list RBRACE .)
    MAP             reduce using rule 138 (expression -> map_type LBRACE expression_map_list RBRACE .)
    FOR             reduce using rule 138 (expression -> map_type LBRACE expression_map_list RBRACE .)
    LBRACE          reduce using rule 138 (expression -> map_type LBRACE expression_map_list RBRACE .)
    CASE            reduce using rule 138 (expression -> map_type LBRACE expression_map_list RBRACE .)
    DEFAULT         reduce using rule 138 (expression -> map_type LBRACE expression_map_list RBRACE .)
    SEMICOLON       reduce using rule 138 (expression -> map_type LBRACE expression_map_list RBRACE .)
=======
    (91) expression -> LPAREN expression RPAREN .

    DOT             reduce using rule 91 (expression -> LPAREN expression RPAREN .)
    PLUS            reduce using rule 91 (expression -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 91 (expression -> LPAREN expression RPAREN .)
    TIMES           reduce using rule 91 (expression -> LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 91 (expression -> LPAREN expression RPAREN .)
    MODULE          reduce using rule 91 (expression -> LPAREN expression RPAREN .)
    EQ              reduce using rule 91 (expression -> LPAREN expression RPAREN .)
    NEQ             reduce using rule 91 (expression -> LPAREN expression RPAREN .)
    LT              reduce using rule 91 (expression -> LPAREN expression RPAREN .)
    LE              reduce using rule 91 (expression -> LPAREN expression RPAREN .)
    GT              reduce using rule 91 (expression -> LPAREN expression RPAREN .)
    GE              reduce using rule 91 (expression -> LPAREN expression RPAREN .)
    LAND            reduce using rule 91 (expression -> LPAREN expression RPAREN .)
    LOR             reduce using rule 91 (expression -> LPAREN expression RPAREN .)
    AND             reduce using rule 91 (expression -> LPAREN expression RPAREN .)
    OR              reduce using rule 91 (expression -> LPAREN expression RPAREN .)
    XOR             reduce using rule 91 (expression -> LPAREN expression RPAREN .)
    AND_NOT         reduce using rule 91 (expression -> LPAREN expression RPAREN .)
    LSHIFT          reduce using rule 91 (expression -> LPAREN expression RPAREN .)
    RSHIFT          reduce using rule 91 (expression -> LPAREN expression RPAREN .)
    SEMICOLON       reduce using rule 91 (expression -> LPAREN expression RPAREN .)
    FUNC            reduce using rule 91 (expression -> LPAREN expression RPAREN .)
    TYPE            reduce using rule 91 (expression -> LPAREN expression RPAREN .)
    IDENTIFIER      reduce using rule 91 (expression -> LPAREN expression RPAREN .)
    VAR             reduce using rule 91 (expression -> LPAREN expression RPAREN .)
    CONST           reduce using rule 91 (expression -> LPAREN expression RPAREN .)
    LNOT            reduce using rule 91 (expression -> LPAREN expression RPAREN .)
    LBRACKET        reduce using rule 91 (expression -> LPAREN expression RPAREN .)
    LPAREN          reduce using rule 91 (expression -> LPAREN expression RPAREN .)
    INT             reduce using rule 91 (expression -> LPAREN expression RPAREN .)
    FLOAT64         reduce using rule 91 (expression -> LPAREN expression RPAREN .)
    TRUE            reduce using rule 91 (expression -> LPAREN expression RPAREN .)
    FALSE           reduce using rule 91 (expression -> LPAREN expression RPAREN .)
    STRING          reduce using rule 91 (expression -> LPAREN expression RPAREN .)
    RETURN          reduce using rule 91 (expression -> LPAREN expression RPAREN .)
    FOR             reduce using rule 91 (expression -> LPAREN expression RPAREN .)
    IF              reduce using rule 91 (expression -> LPAREN expression RPAREN .)
    SWITCH          reduce using rule 91 (expression -> LPAREN expression RPAREN .)
    BREAK           reduce using rule 91 (expression -> LPAREN expression RPAREN .)
    CONTINUE        reduce using rule 91 (expression -> LPAREN expression RPAREN .)
    FALLTHROUGH     reduce using rule 91 (expression -> LPAREN expression RPAREN .)
    $end            reduce using rule 91 (expression -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 91 (expression -> LPAREN expression RPAREN .)
    COMMA           reduce using rule 91 (expression -> LPAREN expression RPAREN .)
    RBRACE          reduce using rule 91 (expression -> LPAREN expression RPAREN .)
    CASE            reduce using rule 91 (expression -> LPAREN expression RPAREN .)
    DEFAULT         reduce using rule 91 (expression -> LPAREN expression RPAREN .)
    LBRACE          reduce using rule 91 (expression -> LPAREN expression RPAREN .)
    COLON           reduce using rule 91 (expression -> LPAREN expression RPAREN .)
>>>>>>> Stashed changes


state 164

<<<<<<< Updated upstream
    (141) expression_map_list -> expression_map_list COMMA . key_value
    (142) key_value -> . expression COLON expression
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (125) expression -> . LNOT expression
    (126) expression -> . IDENTIFIER PLUSPLUS
    (127) expression -> . IDENTIFIER MINUSMINUS
    (138) expression -> . map_type LBRACE expression_map_list RBRACE
    (139) expression -> . map_type LBRACE RBRACE
    (161) expression -> . type_name LBRACE keyed_element_list RBRACE
    (162) expression -> . type_name LBRACE RBRACE
    (198) expression -> . array_type LBRACE expression_list RBRACE
    (199) expression -> . array_type LBRACE RBRACE
    (200) expression -> . expression DOT IDENTIFIER
    (201) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> . expression LBRACKET expression RBRACKET
    (203) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (137) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (163) type_name -> . IDENTIFIER
    (164) type_name -> . slice_type
    (165) type_name -> . array_type
    (166) type_name -> . map_type
    (197) array_type -> . LBRACKET INT RBRACKET primitive_type

    LPAREN          shift and go to state 54
    INT             shift and go to state 55
    FLOAT64         shift and go to state 56
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 57
    TRUE            shift and go to state 58
    FALSE           shift and go to state 59
    LNOT            shift and go to state 60
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    key_value                      shift and go to state 179
    expression                     shift and go to state 137
    slice_type                     shift and go to state 53
    map_type                       shift and go to state 61
    type_name                      shift and go to state 62
    array_type                     shift and go to state 63

state 165

    (142) key_value -> expression COLON . expression
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (125) expression -> . LNOT expression
    (126) expression -> . IDENTIFIER PLUSPLUS
    (127) expression -> . IDENTIFIER MINUSMINUS
    (138) expression -> . map_type LBRACE expression_map_list RBRACE
    (139) expression -> . map_type LBRACE RBRACE
    (161) expression -> . type_name LBRACE keyed_element_list RBRACE
    (162) expression -> . type_name LBRACE RBRACE
    (198) expression -> . array_type LBRACE expression_list RBRACE
    (199) expression -> . array_type LBRACE RBRACE
    (200) expression -> . expression DOT IDENTIFIER
    (201) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> . expression LBRACKET expression RBRACKET
    (203) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (137) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (163) type_name -> . IDENTIFIER
    (164) type_name -> . slice_type
    (165) type_name -> . array_type
    (166) type_name -> . map_type
    (197) array_type -> . LBRACKET INT RBRACKET primitive_type

    LPAREN          shift and go to state 54
    INT             shift and go to state 55
    FLOAT64         shift and go to state 56
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 57
    TRUE            shift and go to state 58
    FALSE           shift and go to state 59
    LNOT            shift and go to state 60
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    expression                     shift and go to state 180
    slice_type                     shift and go to state 53
    map_type                       shift and go to state 61
    type_name                      shift and go to state 62
    array_type                     shift and go to state 63

state 166

    (161) expression -> type_name LBRACE keyed_element_list RBRACE .

    DOT             reduce using rule 161 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    LBRACKET        reduce using rule 161 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    PLUS            reduce using rule 161 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    MINUS           reduce using rule 161 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    TIMES           reduce using rule 161 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    DIVIDE          reduce using rule 161 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    MODULE          reduce using rule 161 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    EQ              reduce using rule 161 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    NEQ             reduce using rule 161 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    LT              reduce using rule 161 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    LE              reduce using rule 161 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    GT              reduce using rule 161 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    GE              reduce using rule 161 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    LAND            reduce using rule 161 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    LOR             reduce using rule 161 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    AND             reduce using rule 161 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    OR              reduce using rule 161 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    XOR             reduce using rule 161 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    AND_NOT         reduce using rule 161 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    LSHIFT          reduce using rule 161 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    RSHIFT          reduce using rule 161 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    VAR             reduce using rule 161 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    CONST           reduce using rule 161 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    FUNC            reduce using rule 161 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    TYPE            reduce using rule 161 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    $end            reduce using rule 161 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    RPAREN          reduce using rule 161 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    COMMA           reduce using rule 161 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    RBRACKET        reduce using rule 161 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    RBRACE          reduce using rule 161 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    COLON           reduce using rule 161 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    BREAK           reduce using rule 161 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    CONTINUE        reduce using rule 161 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    IDENTIFIER      reduce using rule 161 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    LPAREN          reduce using rule 161 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    INT             reduce using rule 161 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    FLOAT64         reduce using rule 161 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    STRING          reduce using rule 161 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    TRUE            reduce using rule 161 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    FALSE           reduce using rule 161 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    LNOT            reduce using rule 161 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    IF              reduce using rule 161 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    SWITCH          reduce using rule 161 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    RETURN          reduce using rule 161 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    MAP             reduce using rule 161 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    FOR             reduce using rule 161 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    LBRACE          reduce using rule 161 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    CASE            reduce using rule 161 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    DEFAULT         reduce using rule 161 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    SEMICOLON       reduce using rule 161 (expression -> type_name LBRACE keyed_element_list RBRACE .)


state 167

    (157) keyed_element_list -> keyed_element_list COMMA . keyed_element
    (158) keyed_element -> . IDENTIFIER COLON expression
    (159) keyed_element -> . INT COLON expression
    (160) keyed_element -> . expression
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (125) expression -> . LNOT expression
    (126) expression -> . IDENTIFIER PLUSPLUS
    (127) expression -> . IDENTIFIER MINUSMINUS
    (138) expression -> . map_type LBRACE expression_map_list RBRACE
    (139) expression -> . map_type LBRACE RBRACE
    (161) expression -> . type_name LBRACE keyed_element_list RBRACE
    (162) expression -> . type_name LBRACE RBRACE
    (198) expression -> . array_type LBRACE expression_list RBRACE
    (199) expression -> . array_type LBRACE RBRACE
    (200) expression -> . expression DOT IDENTIFIER
    (201) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> . expression LBRACKET expression RBRACKET
    (203) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (137) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (163) type_name -> . IDENTIFIER
    (164) type_name -> . slice_type
    (165) type_name -> . array_type
    (166) type_name -> . map_type
    (197) array_type -> . LBRACKET INT RBRACKET primitive_type

    IDENTIFIER      shift and go to state 141
    INT             shift and go to state 143
    LPAREN          shift and go to state 54
    FLOAT64         shift and go to state 56
    STRING          shift and go to state 57
    TRUE            shift and go to state 58
    FALSE           shift and go to state 59
    LNOT            shift and go to state 60
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    keyed_element                  shift and go to state 181
    expression                     shift and go to state 142
    slice_type                     shift and go to state 53
    map_type                       shift and go to state 61
    type_name                      shift and go to state 62
    array_type                     shift and go to state 63

state 168

    (158) keyed_element -> IDENTIFIER COLON . expression
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (125) expression -> . LNOT expression
    (126) expression -> . IDENTIFIER PLUSPLUS
    (127) expression -> . IDENTIFIER MINUSMINUS
    (138) expression -> . map_type LBRACE expression_map_list RBRACE
    (139) expression -> . map_type LBRACE RBRACE
    (161) expression -> . type_name LBRACE keyed_element_list RBRACE
    (162) expression -> . type_name LBRACE RBRACE
    (198) expression -> . array_type LBRACE expression_list RBRACE
    (199) expression -> . array_type LBRACE RBRACE
    (200) expression -> . expression DOT IDENTIFIER
    (201) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> . expression LBRACKET expression RBRACKET
    (203) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (137) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (163) type_name -> . IDENTIFIER
    (164) type_name -> . slice_type
    (165) type_name -> . array_type
    (166) type_name -> . map_type
    (197) array_type -> . LBRACKET INT RBRACKET primitive_type

    LPAREN          shift and go to state 54
    INT             shift and go to state 55
    FLOAT64         shift and go to state 56
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 57
    TRUE            shift and go to state 58
    FALSE           shift and go to state 59
    LNOT            shift and go to state 60
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    expression                     shift and go to state 182
    slice_type                     shift and go to state 53
    map_type                       shift and go to state 61
    type_name                      shift and go to state 62
    array_type                     shift and go to state 63

state 169

    (159) keyed_element -> INT COLON . expression
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (125) expression -> . LNOT expression
    (126) expression -> . IDENTIFIER PLUSPLUS
    (127) expression -> . IDENTIFIER MINUSMINUS
    (138) expression -> . map_type LBRACE expression_map_list RBRACE
    (139) expression -> . map_type LBRACE RBRACE
    (161) expression -> . type_name LBRACE keyed_element_list RBRACE
    (162) expression -> . type_name LBRACE RBRACE
    (198) expression -> . array_type LBRACE expression_list RBRACE
    (199) expression -> . array_type LBRACE RBRACE
    (200) expression -> . expression DOT IDENTIFIER
    (201) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> . expression LBRACKET expression RBRACKET
    (203) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (137) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (163) type_name -> . IDENTIFIER
    (164) type_name -> . slice_type
    (165) type_name -> . array_type
    (166) type_name -> . map_type
    (197) array_type -> . LBRACKET INT RBRACKET primitive_type

    LPAREN          shift and go to state 54
    INT             shift and go to state 55
    FLOAT64         shift and go to state 56
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 57
    TRUE            shift and go to state 58
    FALSE           shift and go to state 59
    LNOT            shift and go to state 60
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    expression                     shift and go to state 183
    slice_type                     shift and go to state 53
    map_type                       shift and go to state 61
    type_name                      shift and go to state 62
    array_type                     shift and go to state 63

state 170

    (198) expression -> array_type LBRACE expression_list RBRACE .

    DOT             reduce using rule 198 (expression -> array_type LBRACE expression_list RBRACE .)
    LBRACKET        reduce using rule 198 (expression -> array_type LBRACE expression_list RBRACE .)
    PLUS            reduce using rule 198 (expression -> array_type LBRACE expression_list RBRACE .)
    MINUS           reduce using rule 198 (expression -> array_type LBRACE expression_list RBRACE .)
    TIMES           reduce using rule 198 (expression -> array_type LBRACE expression_list RBRACE .)
    DIVIDE          reduce using rule 198 (expression -> array_type LBRACE expression_list RBRACE .)
    MODULE          reduce using rule 198 (expression -> array_type LBRACE expression_list RBRACE .)
    EQ              reduce using rule 198 (expression -> array_type LBRACE expression_list RBRACE .)
    NEQ             reduce using rule 198 (expression -> array_type LBRACE expression_list RBRACE .)
    LT              reduce using rule 198 (expression -> array_type LBRACE expression_list RBRACE .)
    LE              reduce using rule 198 (expression -> array_type LBRACE expression_list RBRACE .)
    GT              reduce using rule 198 (expression -> array_type LBRACE expression_list RBRACE .)
    GE              reduce using rule 198 (expression -> array_type LBRACE expression_list RBRACE .)
    LAND            reduce using rule 198 (expression -> array_type LBRACE expression_list RBRACE .)
    LOR             reduce using rule 198 (expression -> array_type LBRACE expression_list RBRACE .)
    AND             reduce using rule 198 (expression -> array_type LBRACE expression_list RBRACE .)
    OR              reduce using rule 198 (expression -> array_type LBRACE expression_list RBRACE .)
    XOR             reduce using rule 198 (expression -> array_type LBRACE expression_list RBRACE .)
    AND_NOT         reduce using rule 198 (expression -> array_type LBRACE expression_list RBRACE .)
    LSHIFT          reduce using rule 198 (expression -> array_type LBRACE expression_list RBRACE .)
    RSHIFT          reduce using rule 198 (expression -> array_type LBRACE expression_list RBRACE .)
    VAR             reduce using rule 198 (expression -> array_type LBRACE expression_list RBRACE .)
    CONST           reduce using rule 198 (expression -> array_type LBRACE expression_list RBRACE .)
    FUNC            reduce using rule 198 (expression -> array_type LBRACE expression_list RBRACE .)
    TYPE            reduce using rule 198 (expression -> array_type LBRACE expression_list RBRACE .)
    $end            reduce using rule 198 (expression -> array_type LBRACE expression_list RBRACE .)
    RPAREN          reduce using rule 198 (expression -> array_type LBRACE expression_list RBRACE .)
    COMMA           reduce using rule 198 (expression -> array_type LBRACE expression_list RBRACE .)
    RBRACKET        reduce using rule 198 (expression -> array_type LBRACE expression_list RBRACE .)
    RBRACE          reduce using rule 198 (expression -> array_type LBRACE expression_list RBRACE .)
    COLON           reduce using rule 198 (expression -> array_type LBRACE expression_list RBRACE .)
    BREAK           reduce using rule 198 (expression -> array_type LBRACE expression_list RBRACE .)
    CONTINUE        reduce using rule 198 (expression -> array_type LBRACE expression_list RBRACE .)
    IDENTIFIER      reduce using rule 198 (expression -> array_type LBRACE expression_list RBRACE .)
    LPAREN          reduce using rule 198 (expression -> array_type LBRACE expression_list RBRACE .)
    INT             reduce using rule 198 (expression -> array_type LBRACE expression_list RBRACE .)
    FLOAT64         reduce using rule 198 (expression -> array_type LBRACE expression_list RBRACE .)
    STRING          reduce using rule 198 (expression -> array_type LBRACE expression_list RBRACE .)
    TRUE            reduce using rule 198 (expression -> array_type LBRACE expression_list RBRACE .)
    FALSE           reduce using rule 198 (expression -> array_type LBRACE expression_list RBRACE .)
    LNOT            reduce using rule 198 (expression -> array_type LBRACE expression_list RBRACE .)
    IF              reduce using rule 198 (expression -> array_type LBRACE expression_list RBRACE .)
    SWITCH          reduce using rule 198 (expression -> array_type LBRACE expression_list RBRACE .)
    RETURN          reduce using rule 198 (expression -> array_type LBRACE expression_list RBRACE .)
    MAP             reduce using rule 198 (expression -> array_type LBRACE expression_list RBRACE .)
    FOR             reduce using rule 198 (expression -> array_type LBRACE expression_list RBRACE .)
    LBRACE          reduce using rule 198 (expression -> array_type LBRACE expression_list RBRACE .)
    CASE            reduce using rule 198 (expression -> array_type LBRACE expression_list RBRACE .)
    DEFAULT         reduce using rule 198 (expression -> array_type LBRACE expression_list RBRACE .)
    SEMICOLON       reduce using rule 198 (expression -> array_type LBRACE expression_list RBRACE .)
=======
    (117) type_declaration -> TYPE IDENTIFIER IDENTIFIER . optional_semicolon
    (8) optional_semicolon -> . SEMICOLON
    (9) optional_semicolon -> . empty
    (7) empty -> .

    SEMICOLON       shift and go to state 53
    FUNC            reduce using rule 7 (empty -> .)
    TYPE            reduce using rule 7 (empty -> .)
    IDENTIFIER      reduce using rule 7 (empty -> .)
    VAR             reduce using rule 7 (empty -> .)
    CONST           reduce using rule 7 (empty -> .)
    PLUS            reduce using rule 7 (empty -> .)
    MINUS           reduce using rule 7 (empty -> .)
    LNOT            reduce using rule 7 (empty -> .)
    LBRACKET        reduce using rule 7 (empty -> .)
    LPAREN          reduce using rule 7 (empty -> .)
    INT             reduce using rule 7 (empty -> .)
    FLOAT64         reduce using rule 7 (empty -> .)
    TRUE            reduce using rule 7 (empty -> .)
    FALSE           reduce using rule 7 (empty -> .)
    STRING          reduce using rule 7 (empty -> .)
    RETURN          reduce using rule 7 (empty -> .)
    FOR             reduce using rule 7 (empty -> .)
    IF              reduce using rule 7 (empty -> .)
    SWITCH          reduce using rule 7 (empty -> .)
    BREAK           reduce using rule 7 (empty -> .)
    CONTINUE        reduce using rule 7 (empty -> .)
    FALLTHROUGH     reduce using rule 7 (empty -> .)
    $end            reduce using rule 7 (empty -> .)

    optional_semicolon             shift and go to state 221
    empty                          shift and go to state 54

state 165

    (112) type_declaration -> TYPE IDENTIFIER struct_type . optional_semicolon
    (8) optional_semicolon -> . SEMICOLON
    (9) optional_semicolon -> . empty
    (7) empty -> .

    SEMICOLON       shift and go to state 53
    FUNC            reduce using rule 7 (empty -> .)
    TYPE            reduce using rule 7 (empty -> .)
    IDENTIFIER      reduce using rule 7 (empty -> .)
    VAR             reduce using rule 7 (empty -> .)
    CONST           reduce using rule 7 (empty -> .)
    PLUS            reduce using rule 7 (empty -> .)
    MINUS           reduce using rule 7 (empty -> .)
    LNOT            reduce using rule 7 (empty -> .)
    LBRACKET        reduce using rule 7 (empty -> .)
    LPAREN          reduce using rule 7 (empty -> .)
    INT             reduce using rule 7 (empty -> .)
    FLOAT64         reduce using rule 7 (empty -> .)
    TRUE            reduce using rule 7 (empty -> .)
    FALSE           reduce using rule 7 (empty -> .)
    STRING          reduce using rule 7 (empty -> .)
    RETURN          reduce using rule 7 (empty -> .)
    FOR             reduce using rule 7 (empty -> .)
    IF              reduce using rule 7 (empty -> .)
    SWITCH          reduce using rule 7 (empty -> .)
    BREAK           reduce using rule 7 (empty -> .)
    CONTINUE        reduce using rule 7 (empty -> .)
    FALLTHROUGH     reduce using rule 7 (empty -> .)
    $end            reduce using rule 7 (empty -> .)

    optional_semicolon             shift and go to state 222
    empty                          shift and go to state 54

state 166

    (113) type_declaration -> TYPE IDENTIFIER primitive_type . optional_semicolon
    (8) optional_semicolon -> . SEMICOLON
    (9) optional_semicolon -> . empty
    (7) empty -> .

    SEMICOLON       shift and go to state 53
    FUNC            reduce using rule 7 (empty -> .)
    TYPE            reduce using rule 7 (empty -> .)
    IDENTIFIER      reduce using rule 7 (empty -> .)
    VAR             reduce using rule 7 (empty -> .)
    CONST           reduce using rule 7 (empty -> .)
    PLUS            reduce using rule 7 (empty -> .)
    MINUS           reduce using rule 7 (empty -> .)
    LNOT            reduce using rule 7 (empty -> .)
    LBRACKET        reduce using rule 7 (empty -> .)
    LPAREN          reduce using rule 7 (empty -> .)
    INT             reduce using rule 7 (empty -> .)
    FLOAT64         reduce using rule 7 (empty -> .)
    TRUE            reduce using rule 7 (empty -> .)
    FALSE           reduce using rule 7 (empty -> .)
    STRING          reduce using rule 7 (empty -> .)
    RETURN          reduce using rule 7 (empty -> .)
    FOR             reduce using rule 7 (empty -> .)
    IF              reduce using rule 7 (empty -> .)
    SWITCH          reduce using rule 7 (empty -> .)
    BREAK           reduce using rule 7 (empty -> .)
    CONTINUE        reduce using rule 7 (empty -> .)
    FALLTHROUGH     reduce using rule 7 (empty -> .)
    $end            reduce using rule 7 (empty -> .)

    optional_semicolon             shift and go to state 223
    empty                          shift and go to state 54

state 167

    (114) type_declaration -> TYPE IDENTIFIER slice_type . optional_semicolon
    (8) optional_semicolon -> . SEMICOLON
    (9) optional_semicolon -> . empty
    (7) empty -> .

    SEMICOLON       shift and go to state 53
    FUNC            reduce using rule 7 (empty -> .)
    TYPE            reduce using rule 7 (empty -> .)
    IDENTIFIER      reduce using rule 7 (empty -> .)
    VAR             reduce using rule 7 (empty -> .)
    CONST           reduce using rule 7 (empty -> .)
    PLUS            reduce using rule 7 (empty -> .)
    MINUS           reduce using rule 7 (empty -> .)
    LNOT            reduce using rule 7 (empty -> .)
    LBRACKET        reduce using rule 7 (empty -> .)
    LPAREN          reduce using rule 7 (empty -> .)
    INT             reduce using rule 7 (empty -> .)
    FLOAT64         reduce using rule 7 (empty -> .)
    TRUE            reduce using rule 7 (empty -> .)
    FALSE           reduce using rule 7 (empty -> .)
    STRING          reduce using rule 7 (empty -> .)
    RETURN          reduce using rule 7 (empty -> .)
    FOR             reduce using rule 7 (empty -> .)
    IF              reduce using rule 7 (empty -> .)
    SWITCH          reduce using rule 7 (empty -> .)
    BREAK           reduce using rule 7 (empty -> .)
    CONTINUE        reduce using rule 7 (empty -> .)
    FALLTHROUGH     reduce using rule 7 (empty -> .)
    $end            reduce using rule 7 (empty -> .)

    optional_semicolon             shift and go to state 224
    empty                          shift and go to state 54

state 168

    (115) type_declaration -> TYPE IDENTIFIER array_type . optional_semicolon
    (8) optional_semicolon -> . SEMICOLON
    (9) optional_semicolon -> . empty
    (7) empty -> .

    SEMICOLON       shift and go to state 53
    FUNC            reduce using rule 7 (empty -> .)
    TYPE            reduce using rule 7 (empty -> .)
    IDENTIFIER      reduce using rule 7 (empty -> .)
    VAR             reduce using rule 7 (empty -> .)
    CONST           reduce using rule 7 (empty -> .)
    PLUS            reduce using rule 7 (empty -> .)
    MINUS           reduce using rule 7 (empty -> .)
    LNOT            reduce using rule 7 (empty -> .)
    LBRACKET        reduce using rule 7 (empty -> .)
    LPAREN          reduce using rule 7 (empty -> .)
    INT             reduce using rule 7 (empty -> .)
    FLOAT64         reduce using rule 7 (empty -> .)
    TRUE            reduce using rule 7 (empty -> .)
    FALSE           reduce using rule 7 (empty -> .)
    STRING          reduce using rule 7 (empty -> .)
    RETURN          reduce using rule 7 (empty -> .)
    FOR             reduce using rule 7 (empty -> .)
    IF              reduce using rule 7 (empty -> .)
    SWITCH          reduce using rule 7 (empty -> .)
    BREAK           reduce using rule 7 (empty -> .)
    CONTINUE        reduce using rule 7 (empty -> .)
    FALLTHROUGH     reduce using rule 7 (empty -> .)
    $end            reduce using rule 7 (empty -> .)

    optional_semicolon             shift and go to state 225
    empty                          shift and go to state 54

state 169

    (116) type_declaration -> TYPE IDENTIFIER map_type . optional_semicolon
    (8) optional_semicolon -> . SEMICOLON
    (9) optional_semicolon -> . empty
    (7) empty -> .

    SEMICOLON       shift and go to state 53
    FUNC            reduce using rule 7 (empty -> .)
    TYPE            reduce using rule 7 (empty -> .)
    IDENTIFIER      reduce using rule 7 (empty -> .)
    VAR             reduce using rule 7 (empty -> .)
    CONST           reduce using rule 7 (empty -> .)
    PLUS            reduce using rule 7 (empty -> .)
    MINUS           reduce using rule 7 (empty -> .)
    LNOT            reduce using rule 7 (empty -> .)
    LBRACKET        reduce using rule 7 (empty -> .)
    LPAREN          reduce using rule 7 (empty -> .)
    INT             reduce using rule 7 (empty -> .)
    FLOAT64         reduce using rule 7 (empty -> .)
    TRUE            reduce using rule 7 (empty -> .)
    FALSE           reduce using rule 7 (empty -> .)
    STRING          reduce using rule 7 (empty -> .)
    RETURN          reduce using rule 7 (empty -> .)
    FOR             reduce using rule 7 (empty -> .)
    IF              reduce using rule 7 (empty -> .)
    SWITCH          reduce using rule 7 (empty -> .)
    BREAK           reduce using rule 7 (empty -> .)
    CONTINUE        reduce using rule 7 (empty -> .)
    FALLTHROUGH     reduce using rule 7 (empty -> .)
    $end            reduce using rule 7 (empty -> .)

    optional_semicolon             shift and go to state 226
    empty                          shift and go to state 54

state 170

    (118) struct_type -> STRUCT . LBRACE RBRACE
    (119) struct_type -> STRUCT . LBRACE field_list RBRACE

    LBRACE          shift and go to state 227
>>>>>>> Stashed changes


state 171

<<<<<<< Updated upstream
    (137) map_type -> MAP LBRACKET primitive_type RBRACKET primitive_type .

    ASSIGN          reduce using rule 137 (map_type -> MAP LBRACKET primitive_type RBRACKET primitive_type .)
    VAR             reduce using rule 137 (map_type -> MAP LBRACKET primitive_type RBRACKET primitive_type .)
    CONST           reduce using rule 137 (map_type -> MAP LBRACKET primitive_type RBRACKET primitive_type .)
    FUNC            reduce using rule 137 (map_type -> MAP LBRACKET primitive_type RBRACKET primitive_type .)
    TYPE            reduce using rule 137 (map_type -> MAP LBRACKET primitive_type RBRACKET primitive_type .)
    $end            reduce using rule 137 (map_type -> MAP LBRACKET primitive_type RBRACKET primitive_type .)
    LBRACE          reduce using rule 137 (map_type -> MAP LBRACKET primitive_type RBRACKET primitive_type .)
    RPAREN          reduce using rule 137 (map_type -> MAP LBRACKET primitive_type RBRACKET primitive_type .)
    COMMA           reduce using rule 137 (map_type -> MAP LBRACKET primitive_type RBRACKET primitive_type .)
    RBRACE          reduce using rule 137 (map_type -> MAP LBRACKET primitive_type RBRACKET primitive_type .)
    IDENTIFIER      reduce using rule 137 (map_type -> MAP LBRACKET primitive_type RBRACKET primitive_type .)
    BREAK           reduce using rule 137 (map_type -> MAP LBRACKET primitive_type RBRACKET primitive_type .)
    CONTINUE        reduce using rule 137 (map_type -> MAP LBRACKET primitive_type RBRACKET primitive_type .)
    LPAREN          reduce using rule 137 (map_type -> MAP LBRACKET primitive_type RBRACKET primitive_type .)
    INT             reduce using rule 137 (map_type -> MAP LBRACKET primitive_type RBRACKET primitive_type .)
    FLOAT64         reduce using rule 137 (map_type -> MAP LBRACKET primitive_type RBRACKET primitive_type .)
    STRING          reduce using rule 137 (map_type -> MAP LBRACKET primitive_type RBRACKET primitive_type .)
    TRUE            reduce using rule 137 (map_type -> MAP LBRACKET primitive_type RBRACKET primitive_type .)
    FALSE           reduce using rule 137 (map_type -> MAP LBRACKET primitive_type RBRACKET primitive_type .)
    LNOT            reduce using rule 137 (map_type -> MAP LBRACKET primitive_type RBRACKET primitive_type .)
    IF              reduce using rule 137 (map_type -> MAP LBRACKET primitive_type RBRACKET primitive_type .)
    SWITCH          reduce using rule 137 (map_type -> MAP LBRACKET primitive_type RBRACKET primitive_type .)
    RETURN          reduce using rule 137 (map_type -> MAP LBRACKET primitive_type RBRACKET primitive_type .)
    LBRACKET        reduce using rule 137 (map_type -> MAP LBRACKET primitive_type RBRACKET primitive_type .)
    MAP             reduce using rule 137 (map_type -> MAP LBRACKET primitive_type RBRACKET primitive_type .)
    FOR             reduce using rule 137 (map_type -> MAP LBRACKET primitive_type RBRACKET primitive_type .)
    SEMICOLON       reduce using rule 137 (map_type -> MAP LBRACKET primitive_type RBRACKET primitive_type .)
    CASE            reduce using rule 137 (map_type -> MAP LBRACKET primitive_type RBRACKET primitive_type .)
    DEFAULT         reduce using rule 137 (map_type -> MAP LBRACKET primitive_type RBRACKET primitive_type .)
=======
    (76) primitive_type -> INT_TYPE .

    SEMICOLON       reduce using rule 76 (primitive_type -> INT_TYPE .)
    FUNC            reduce using rule 76 (primitive_type -> INT_TYPE .)
    TYPE            reduce using rule 76 (primitive_type -> INT_TYPE .)
    IDENTIFIER      reduce using rule 76 (primitive_type -> INT_TYPE .)
    VAR             reduce using rule 76 (primitive_type -> INT_TYPE .)
    CONST           reduce using rule 76 (primitive_type -> INT_TYPE .)
    PLUS            reduce using rule 76 (primitive_type -> INT_TYPE .)
    MINUS           reduce using rule 76 (primitive_type -> INT_TYPE .)
    LNOT            reduce using rule 76 (primitive_type -> INT_TYPE .)
    LBRACKET        reduce using rule 76 (primitive_type -> INT_TYPE .)
    LPAREN          reduce using rule 76 (primitive_type -> INT_TYPE .)
    INT             reduce using rule 76 (primitive_type -> INT_TYPE .)
    FLOAT64         reduce using rule 76 (primitive_type -> INT_TYPE .)
    TRUE            reduce using rule 76 (primitive_type -> INT_TYPE .)
    FALSE           reduce using rule 76 (primitive_type -> INT_TYPE .)
    STRING          reduce using rule 76 (primitive_type -> INT_TYPE .)
    RETURN          reduce using rule 76 (primitive_type -> INT_TYPE .)
    FOR             reduce using rule 76 (primitive_type -> INT_TYPE .)
    IF              reduce using rule 76 (primitive_type -> INT_TYPE .)
    SWITCH          reduce using rule 76 (primitive_type -> INT_TYPE .)
    BREAK           reduce using rule 76 (primitive_type -> INT_TYPE .)
    CONTINUE        reduce using rule 76 (primitive_type -> INT_TYPE .)
    FALLTHROUGH     reduce using rule 76 (primitive_type -> INT_TYPE .)
    $end            reduce using rule 76 (primitive_type -> INT_TYPE .)
    ASSIGN          reduce using rule 76 (primitive_type -> INT_TYPE .)
    LBRACE          reduce using rule 76 (primitive_type -> INT_TYPE .)
    RPAREN          reduce using rule 76 (primitive_type -> INT_TYPE .)
    COMMA           reduce using rule 76 (primitive_type -> INT_TYPE .)
    RBRACE          reduce using rule 76 (primitive_type -> INT_TYPE .)
    RBRACKET        reduce using rule 76 (primitive_type -> INT_TYPE .)
>>>>>>> Stashed changes


state 172

<<<<<<< Updated upstream
    (119) return_type -> LPAREN type_list . RPAREN
    (122) type_list -> type_list . COMMA type

    RPAREN          shift and go to state 184
    COMMA           shift and go to state 185
=======
    (77) primitive_type -> FLOAT64_TYPE .

    SEMICOLON       reduce using rule 77 (primitive_type -> FLOAT64_TYPE .)
    FUNC            reduce using rule 77 (primitive_type -> FLOAT64_TYPE .)
    TYPE            reduce using rule 77 (primitive_type -> FLOAT64_TYPE .)
    IDENTIFIER      reduce using rule 77 (primitive_type -> FLOAT64_TYPE .)
    VAR             reduce using rule 77 (primitive_type -> FLOAT64_TYPE .)
    CONST           reduce using rule 77 (primitive_type -> FLOAT64_TYPE .)
    PLUS            reduce using rule 77 (primitive_type -> FLOAT64_TYPE .)
    MINUS           reduce using rule 77 (primitive_type -> FLOAT64_TYPE .)
    LNOT            reduce using rule 77 (primitive_type -> FLOAT64_TYPE .)
    LBRACKET        reduce using rule 77 (primitive_type -> FLOAT64_TYPE .)
    LPAREN          reduce using rule 77 (primitive_type -> FLOAT64_TYPE .)
    INT             reduce using rule 77 (primitive_type -> FLOAT64_TYPE .)
    FLOAT64         reduce using rule 77 (primitive_type -> FLOAT64_TYPE .)
    TRUE            reduce using rule 77 (primitive_type -> FLOAT64_TYPE .)
    FALSE           reduce using rule 77 (primitive_type -> FLOAT64_TYPE .)
    STRING          reduce using rule 77 (primitive_type -> FLOAT64_TYPE .)
    RETURN          reduce using rule 77 (primitive_type -> FLOAT64_TYPE .)
    FOR             reduce using rule 77 (primitive_type -> FLOAT64_TYPE .)
    IF              reduce using rule 77 (primitive_type -> FLOAT64_TYPE .)
    SWITCH          reduce using rule 77 (primitive_type -> FLOAT64_TYPE .)
    BREAK           reduce using rule 77 (primitive_type -> FLOAT64_TYPE .)
    CONTINUE        reduce using rule 77 (primitive_type -> FLOAT64_TYPE .)
    FALLTHROUGH     reduce using rule 77 (primitive_type -> FLOAT64_TYPE .)
    $end            reduce using rule 77 (primitive_type -> FLOAT64_TYPE .)
    ASSIGN          reduce using rule 77 (primitive_type -> FLOAT64_TYPE .)
    LBRACE          reduce using rule 77 (primitive_type -> FLOAT64_TYPE .)
    RPAREN          reduce using rule 77 (primitive_type -> FLOAT64_TYPE .)
    COMMA           reduce using rule 77 (primitive_type -> FLOAT64_TYPE .)
    RBRACE          reduce using rule 77 (primitive_type -> FLOAT64_TYPE .)
    RBRACKET        reduce using rule 77 (primitive_type -> FLOAT64_TYPE .)
>>>>>>> Stashed changes


state 173

<<<<<<< Updated upstream
    (121) type_list -> type .

    RPAREN          reduce using rule 121 (type_list -> type .)
    COMMA           reduce using rule 121 (type_list -> type .)
=======
    (78) primitive_type -> STRING_TYPE .

    SEMICOLON       reduce using rule 78 (primitive_type -> STRING_TYPE .)
    FUNC            reduce using rule 78 (primitive_type -> STRING_TYPE .)
    TYPE            reduce using rule 78 (primitive_type -> STRING_TYPE .)
    IDENTIFIER      reduce using rule 78 (primitive_type -> STRING_TYPE .)
    VAR             reduce using rule 78 (primitive_type -> STRING_TYPE .)
    CONST           reduce using rule 78 (primitive_type -> STRING_TYPE .)
    PLUS            reduce using rule 78 (primitive_type -> STRING_TYPE .)
    MINUS           reduce using rule 78 (primitive_type -> STRING_TYPE .)
    LNOT            reduce using rule 78 (primitive_type -> STRING_TYPE .)
    LBRACKET        reduce using rule 78 (primitive_type -> STRING_TYPE .)
    LPAREN          reduce using rule 78 (primitive_type -> STRING_TYPE .)
    INT             reduce using rule 78 (primitive_type -> STRING_TYPE .)
    FLOAT64         reduce using rule 78 (primitive_type -> STRING_TYPE .)
    TRUE            reduce using rule 78 (primitive_type -> STRING_TYPE .)
    FALSE           reduce using rule 78 (primitive_type -> STRING_TYPE .)
    STRING          reduce using rule 78 (primitive_type -> STRING_TYPE .)
    RETURN          reduce using rule 78 (primitive_type -> STRING_TYPE .)
    FOR             reduce using rule 78 (primitive_type -> STRING_TYPE .)
    IF              reduce using rule 78 (primitive_type -> STRING_TYPE .)
    SWITCH          reduce using rule 78 (primitive_type -> STRING_TYPE .)
    BREAK           reduce using rule 78 (primitive_type -> STRING_TYPE .)
    CONTINUE        reduce using rule 78 (primitive_type -> STRING_TYPE .)
    FALLTHROUGH     reduce using rule 78 (primitive_type -> STRING_TYPE .)
    $end            reduce using rule 78 (primitive_type -> STRING_TYPE .)
    ASSIGN          reduce using rule 78 (primitive_type -> STRING_TYPE .)
    LBRACE          reduce using rule 78 (primitive_type -> STRING_TYPE .)
    RPAREN          reduce using rule 78 (primitive_type -> STRING_TYPE .)
    COMMA           reduce using rule 78 (primitive_type -> STRING_TYPE .)
    RBRACE          reduce using rule 78 (primitive_type -> STRING_TYPE .)
    RBRACKET        reduce using rule 78 (primitive_type -> STRING_TYPE .)
>>>>>>> Stashed changes


state 174

<<<<<<< Updated upstream
    (112) function_declaration -> FUNC IDENTIFIER LPAREN parameter_list RPAREN return_type block .

    VAR             reduce using rule 112 (function_declaration -> FUNC IDENTIFIER LPAREN parameter_list RPAREN return_type block .)
    CONST           reduce using rule 112 (function_declaration -> FUNC IDENTIFIER LPAREN parameter_list RPAREN return_type block .)
    FUNC            reduce using rule 112 (function_declaration -> FUNC IDENTIFIER LPAREN parameter_list RPAREN return_type block .)
    TYPE            reduce using rule 112 (function_declaration -> FUNC IDENTIFIER LPAREN parameter_list RPAREN return_type block .)
    $end            reduce using rule 112 (function_declaration -> FUNC IDENTIFIER LPAREN parameter_list RPAREN return_type block .)
=======
    (79) primitive_type -> BOOL_TYPE .

    SEMICOLON       reduce using rule 79 (primitive_type -> BOOL_TYPE .)
    FUNC            reduce using rule 79 (primitive_type -> BOOL_TYPE .)
    TYPE            reduce using rule 79 (primitive_type -> BOOL_TYPE .)
    IDENTIFIER      reduce using rule 79 (primitive_type -> BOOL_TYPE .)
    VAR             reduce using rule 79 (primitive_type -> BOOL_TYPE .)
    CONST           reduce using rule 79 (primitive_type -> BOOL_TYPE .)
    PLUS            reduce using rule 79 (primitive_type -> BOOL_TYPE .)
    MINUS           reduce using rule 79 (primitive_type -> BOOL_TYPE .)
    LNOT            reduce using rule 79 (primitive_type -> BOOL_TYPE .)
    LBRACKET        reduce using rule 79 (primitive_type -> BOOL_TYPE .)
    LPAREN          reduce using rule 79 (primitive_type -> BOOL_TYPE .)
    INT             reduce using rule 79 (primitive_type -> BOOL_TYPE .)
    FLOAT64         reduce using rule 79 (primitive_type -> BOOL_TYPE .)
    TRUE            reduce using rule 79 (primitive_type -> BOOL_TYPE .)
    FALSE           reduce using rule 79 (primitive_type -> BOOL_TYPE .)
    STRING          reduce using rule 79 (primitive_type -> BOOL_TYPE .)
    RETURN          reduce using rule 79 (primitive_type -> BOOL_TYPE .)
    FOR             reduce using rule 79 (primitive_type -> BOOL_TYPE .)
    IF              reduce using rule 79 (primitive_type -> BOOL_TYPE .)
    SWITCH          reduce using rule 79 (primitive_type -> BOOL_TYPE .)
    BREAK           reduce using rule 79 (primitive_type -> BOOL_TYPE .)
    CONTINUE        reduce using rule 79 (primitive_type -> BOOL_TYPE .)
    FALLTHROUGH     reduce using rule 79 (primitive_type -> BOOL_TYPE .)
    $end            reduce using rule 79 (primitive_type -> BOOL_TYPE .)
    ASSIGN          reduce using rule 79 (primitive_type -> BOOL_TYPE .)
    LBRACE          reduce using rule 79 (primitive_type -> BOOL_TYPE .)
    RPAREN          reduce using rule 79 (primitive_type -> BOOL_TYPE .)
    COMMA           reduce using rule 79 (primitive_type -> BOOL_TYPE .)
    RBRACE          reduce using rule 79 (primitive_type -> BOOL_TYPE .)
    RBRACKET        reduce using rule 79 (primitive_type -> BOOL_TYPE .)
>>>>>>> Stashed changes


state 175

<<<<<<< Updated upstream
    (90) block -> LBRACE . local_statement_list RBRACE
    (91) block -> LBRACE . RBRACE
    (92) local_statement_list -> . local_statement
    (93) local_statement_list -> . local_statement_list local_statement
    (78) local_statement -> . local_var_dec
    (79) local_statement -> . local_const_dec
    (80) local_statement -> . short_assignment
    (81) local_statement -> . simple_assignment
    (82) local_statement -> . assignment_compound
    (83) local_statement -> . expression
    (84) local_statement -> . for_statement
    (85) local_statement -> . if_statement
    (86) local_statement -> . switch_statement
    (87) local_statement -> . return_statement
    (88) local_statement -> . BREAK
    (89) local_statement -> . CONTINUE
    (20) local_var_dec -> . VAR IDENTIFIER type
    (21) local_var_dec -> . VAR IDENTIFIER type ASSIGN expression
    (22) local_var_dec -> . VAR IDENTIFIER ASSIGN expression
    (23) local_const_dec -> . CONST IDENTIFIER type ASSIGN expression
    (24) local_const_dec -> . CONST IDENTIFIER ASSIGN expression
    (77) short_assignment -> . IDENTIFIER SHORT_ASSIGN expression
    (56) simple_assignment -> . IDENTIFIER ASSIGN expression
    (25) assignment_compound -> . IDENTIFIER operator_assign expression
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (125) expression -> . LNOT expression
    (126) expression -> . IDENTIFIER PLUSPLUS
    (127) expression -> . IDENTIFIER MINUSMINUS
    (138) expression -> . map_type LBRACE expression_map_list RBRACE
    (139) expression -> . map_type LBRACE RBRACE
    (161) expression -> . type_name LBRACE keyed_element_list RBRACE
    (162) expression -> . type_name LBRACE RBRACE
    (198) expression -> . array_type LBRACE expression_list RBRACE
    (199) expression -> . array_type LBRACE RBRACE
    (200) expression -> . expression DOT IDENTIFIER
    (201) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> . expression LBRACKET expression RBRACKET
    (203) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (94) for_statement -> . for_classic
    (95) for_statement -> . for_condition
    (96) for_statement -> . for_infinite
    (128) if_statement -> . IF expression block
    (129) if_statement -> . IF expression block ELSE block
    (130) if_statement -> . IF expression block ELSE if_statement
    (131) if_statement -> . IF if_assignment SEMICOLON expression block
    (132) if_statement -> . IF if_assignment SEMICOLON expression block ELSE block
    (133) if_statement -> . IF if_assignment SEMICOLON expression block ELSE if_statement
    (167) switch_statement -> . SWITCH switch_expr LBRACE case_clause_list RBRACE
    (168) switch_statement -> . SWITCH switch_expr LBRACE RBRACE
    (169) switch_statement -> . SWITCH LBRACE case_clause_list RBRACE
    (170) switch_statement -> . SWITCH LBRACE RBRACE
    (171) switch_statement -> . SWITCH switch_assignment SEMICOLON switch_expr LBRACE case_clause_list RBRACE
    (172) switch_statement -> . SWITCH switch_assignment SEMICOLON switch_expr LBRACE RBRACE
    (173) switch_statement -> . SWITCH switch_assignment SEMICOLON LBRACE case_clause_list RBRACE
    (174) switch_statement -> . SWITCH switch_assignment SEMICOLON LBRACE RBRACE
    (123) return_statement -> . RETURN
    (124) return_statement -> . RETURN return_list
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (137) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (163) type_name -> . IDENTIFIER
    (164) type_name -> . slice_type
    (165) type_name -> . array_type
    (166) type_name -> . map_type
    (197) array_type -> . LBRACKET INT RBRACKET primitive_type
    (97) for_classic -> . FOR for_init SEMICOLON for_cond SEMICOLON for_post block
    (98) for_condition -> . FOR expression block
    (99) for_infinite -> . FOR block

    RBRACE          shift and go to state 187
    BREAK           shift and go to state 199
    CONTINUE        shift and go to state 200
    VAR             shift and go to state 201
    CONST           shift and go to state 203
    IDENTIFIER      shift and go to state 202
    LPAREN          shift and go to state 54
    INT             shift and go to state 55
    FLOAT64         shift and go to state 56
    STRING          shift and go to state 57
    TRUE            shift and go to state 58
    FALSE           shift and go to state 59
    LNOT            shift and go to state 60
    IF              shift and go to state 207
    SWITCH          shift and go to state 208
    RETURN          shift and go to state 209
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39
    FOR             shift and go to state 210
=======
    (80) slice_type -> LBRACKET . RBRACKET primitive_type
    (81) array_type -> LBRACKET . INT RBRACKET type

    RBRACKET        shift and go to state 228
    INT             shift and go to state 229
>>>>>>> Stashed changes

    local_statement_list           shift and go to state 186
    local_statement                shift and go to state 188
    local_var_dec                  shift and go to state 189
    local_const_dec                shift and go to state 190
    short_assignment               shift and go to state 191
    simple_assignment              shift and go to state 192
    assignment_compound            shift and go to state 193
    expression                     shift and go to state 194
    for_statement                  shift and go to state 195
    if_statement                   shift and go to state 196
    switch_statement               shift and go to state 197
    return_statement               shift and go to state 198
    slice_type                     shift and go to state 53
    map_type                       shift and go to state 61
    type_name                      shift and go to state 62
    array_type                     shift and go to state 63
    for_classic                    shift and go to state 204
    for_condition                  shift and go to state 205
    for_infinite                   shift and go to state 206

state 176

<<<<<<< Updated upstream
    (146) method_declaration -> FUNC LPAREN receiver RPAREN IDENTIFIER LPAREN parameter_list . RPAREN return_type block
    (113) parameter_list -> parameter_list . COMMA parameter

    RPAREN          shift and go to state 211
    COMMA           shift and go to state 116
=======
    (127) map_type -> MAP . LBRACKET primitive_type RBRACKET type

    LBRACKET        shift and go to state 230
>>>>>>> Stashed changes


state 177

<<<<<<< Updated upstream
    (69) expression_list -> expression_list COMMA expression .
    (36) expression -> expression . binary_operator expression
    (200) expression -> expression . DOT IDENTIFIER
    (201) expression -> expression . DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> expression . LBRACKET expression RBRACKET
    (37) binary_operator -> . PLUS
    (38) binary_operator -> . MINUS
    (39) binary_operator -> . TIMES
    (40) binary_operator -> . DIVIDE
    (41) binary_operator -> . MODULE
    (42) binary_operator -> . EQ
    (43) binary_operator -> . NEQ
    (44) binary_operator -> . LT
    (45) binary_operator -> . LE
    (46) binary_operator -> . GT
    (47) binary_operator -> . GE
    (48) binary_operator -> . LAND
    (49) binary_operator -> . LOR
    (50) binary_operator -> . AND
    (51) binary_operator -> . OR
    (52) binary_operator -> . XOR
    (53) binary_operator -> . AND_NOT
    (54) binary_operator -> . LSHIFT
    (55) binary_operator -> . RSHIFT

    COMMA           reduce using rule 69 (expression_list -> expression_list COMMA expression .)
    RPAREN          reduce using rule 69 (expression_list -> expression_list COMMA expression .)
    RBRACE          reduce using rule 69 (expression_list -> expression_list COMMA expression .)
    DOT             shift and go to state 82
    LBRACKET        shift and go to state 83
    PLUS            shift and go to state 84
    MINUS           shift and go to state 85
    TIMES           shift and go to state 86
    DIVIDE          shift and go to state 87
    MODULE          shift and go to state 88
    EQ              shift and go to state 89
    NEQ             shift and go to state 90
    LT              shift and go to state 91
    LE              shift and go to state 92
    GT              shift and go to state 93
    GE              shift and go to state 94
    LAND            shift and go to state 95
    LOR             shift and go to state 96
    AND             shift and go to state 97
    OR              shift and go to state 98
    XOR             shift and go to state 99
    AND_NOT         shift and go to state 100
    LSHIFT          shift and go to state 101
    RSHIFT          shift and go to state 102
=======
    (75) type -> IDENTIFIER .

    ASSIGN          reduce using rule 75 (type -> IDENTIFIER .)
    RPAREN          reduce using rule 75 (type -> IDENTIFIER .)
    COMMA           reduce using rule 75 (type -> IDENTIFIER .)
    LBRACE          reduce using rule 75 (type -> IDENTIFIER .)
    RBRACE          reduce using rule 75 (type -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 75 (type -> IDENTIFIER .)
    SEMICOLON       reduce using rule 75 (type -> IDENTIFIER .)
    FUNC            reduce using rule 75 (type -> IDENTIFIER .)
    TYPE            reduce using rule 75 (type -> IDENTIFIER .)
    VAR             reduce using rule 75 (type -> IDENTIFIER .)
    CONST           reduce using rule 75 (type -> IDENTIFIER .)
    PLUS            reduce using rule 75 (type -> IDENTIFIER .)
    MINUS           reduce using rule 75 (type -> IDENTIFIER .)
    LNOT            reduce using rule 75 (type -> IDENTIFIER .)
    LBRACKET        reduce using rule 75 (type -> IDENTIFIER .)
    LPAREN          reduce using rule 75 (type -> IDENTIFIER .)
    INT             reduce using rule 75 (type -> IDENTIFIER .)
    FLOAT64         reduce using rule 75 (type -> IDENTIFIER .)
    TRUE            reduce using rule 75 (type -> IDENTIFIER .)
    FALSE           reduce using rule 75 (type -> IDENTIFIER .)
    STRING          reduce using rule 75 (type -> IDENTIFIER .)
    RETURN          reduce using rule 75 (type -> IDENTIFIER .)
    FOR             reduce using rule 75 (type -> IDENTIFIER .)
    IF              reduce using rule 75 (type -> IDENTIFIER .)
    SWITCH          reduce using rule 75 (type -> IDENTIFIER .)
    BREAK           reduce using rule 75 (type -> IDENTIFIER .)
    CONTINUE        reduce using rule 75 (type -> IDENTIFIER .)
    FALLTHROUGH     reduce using rule 75 (type -> IDENTIFIER .)
    $end            reduce using rule 75 (type -> IDENTIFIER .)
>>>>>>> Stashed changes

    binary_operator                shift and go to state 81

state 178

<<<<<<< Updated upstream
    (201) expression -> expression DOT IDENTIFIER LPAREN argument_list . RPAREN

    RPAREN          shift and go to state 212
=======
    (66) variable_declaration -> VAR IDENTIFIER type . ASSIGN expression

    ASSIGN          shift and go to state 231
>>>>>>> Stashed changes


state 179

<<<<<<< Updated upstream
    (141) expression_map_list -> expression_map_list COMMA key_value .

    RBRACE          reduce using rule 141 (expression_map_list -> expression_map_list COMMA key_value .)
    COMMA           reduce using rule 141 (expression_map_list -> expression_map_list COMMA key_value .)
=======
    (68) variable_declaration -> VAR IDENTIFIER ASSIGN . expression
    (82) expression -> . binary_expression
    (83) expression -> . relational_expression
    (84) expression -> . logical_expression
    (85) expression -> . bitwise_expression
    (86) expression -> . PLUS expression
    (87) expression -> . MINUS expression
    (88) expression -> . LNOT expression
    (89) expression -> . LBRACKET RBRACKET primitive_type LBRACE expression_list RBRACE
    (90) expression -> . LBRACKET RBRACKET primitive_type LBRACE RBRACE
    (91) expression -> . LPAREN expression RPAREN
    (92) expression -> . INT
    (93) expression -> . FLOAT64
    (94) expression -> . TRUE
    (95) expression -> . FALSE
    (96) expression -> . IDENTIFIER
    (97) expression -> . STRING
    (98) expression -> . IDENTIFIER PLUSPLUS
    (99) expression -> . IDENTIFIER MINUSMINUS
    (100) expression -> . expression DOT IDENTIFIER
    (103) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (133) expression -> . IDENTIFIER LBRACE keyed_element_list RBRACE
    (134) expression -> . IDENTIFIER LBRACE RBRACE
    (135) binary_expression -> . expression PLUS expression
    (136) binary_expression -> . expression MINUS expression
    (137) binary_expression -> . expression TIMES expression
    (138) binary_expression -> . expression DIVIDE expression
    (139) binary_expression -> . expression MODULE expression
    (144) relational_expression -> . expression EQ expression
    (145) relational_expression -> . expression NEQ expression
    (146) relational_expression -> . expression LT expression
    (147) relational_expression -> . expression LE expression
    (148) relational_expression -> . expression GT expression
    (149) relational_expression -> . expression GE expression
    (150) logical_expression -> . expression LAND expression
    (151) logical_expression -> . expression LOR expression
    (152) bitwise_expression -> . expression AND expression
    (153) bitwise_expression -> . expression OR expression
    (154) bitwise_expression -> . expression XOR expression
    (155) bitwise_expression -> . expression AND_NOT expression
    (156) bitwise_expression -> . expression LSHIFT expression
    (157) bitwise_expression -> . expression RSHIFT expression

    PLUS            shift and go to state 37
    MINUS           shift and go to state 38
    LNOT            shift and go to state 39
    LBRACKET        shift and go to state 40
    LPAREN          shift and go to state 29
    INT             shift and go to state 41
    FLOAT64         shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44
    IDENTIFIER      shift and go to state 97
    STRING          shift and go to state 11
>>>>>>> Stashed changes

    expression                     shift and go to state 232
    binary_expression              shift and go to state 33
    relational_expression          shift and go to state 34
    logical_expression             shift and go to state 35
    bitwise_expression             shift and go to state 36

state 180

<<<<<<< Updated upstream
    (142) key_value -> expression COLON expression .
    (36) expression -> expression . binary_operator expression
    (200) expression -> expression . DOT IDENTIFIER
    (201) expression -> expression . DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> expression . LBRACKET expression RBRACKET
    (37) binary_operator -> . PLUS
    (38) binary_operator -> . MINUS
    (39) binary_operator -> . TIMES
    (40) binary_operator -> . DIVIDE
    (41) binary_operator -> . MODULE
    (42) binary_operator -> . EQ
    (43) binary_operator -> . NEQ
    (44) binary_operator -> . LT
    (45) binary_operator -> . LE
    (46) binary_operator -> . GT
    (47) binary_operator -> . GE
    (48) binary_operator -> . LAND
    (49) binary_operator -> . LOR
    (50) binary_operator -> . AND
    (51) binary_operator -> . OR
    (52) binary_operator -> . XOR
    (53) binary_operator -> . AND_NOT
    (54) binary_operator -> . LSHIFT
    (55) binary_operator -> . RSHIFT

    RBRACE          reduce using rule 142 (key_value -> expression COLON expression .)
    COMMA           reduce using rule 142 (key_value -> expression COLON expression .)
    DOT             shift and go to state 82
    LBRACKET        shift and go to state 83
    PLUS            shift and go to state 84
    MINUS           shift and go to state 85
    TIMES           shift and go to state 86
    DIVIDE          shift and go to state 87
    MODULE          shift and go to state 88
    EQ              shift and go to state 89
    NEQ             shift and go to state 90
    LT              shift and go to state 91
    LE              shift and go to state 92
    GT              shift and go to state 93
    GE              shift and go to state 94
    LAND            shift and go to state 95
    LOR             shift and go to state 96
    AND             shift and go to state 97
    OR              shift and go to state 98
    XOR             shift and go to state 99
    AND_NOT         shift and go to state 100
    LSHIFT          shift and go to state 101
    RSHIFT          shift and go to state 102
=======
    (70) type -> primitive_type .

    ASSIGN          reduce using rule 70 (type -> primitive_type .)
    RPAREN          reduce using rule 70 (type -> primitive_type .)
    COMMA           reduce using rule 70 (type -> primitive_type .)
    LBRACE          reduce using rule 70 (type -> primitive_type .)
    RBRACE          reduce using rule 70 (type -> primitive_type .)
    IDENTIFIER      reduce using rule 70 (type -> primitive_type .)
    SEMICOLON       reduce using rule 70 (type -> primitive_type .)
    FUNC            reduce using rule 70 (type -> primitive_type .)
    TYPE            reduce using rule 70 (type -> primitive_type .)
    VAR             reduce using rule 70 (type -> primitive_type .)
    CONST           reduce using rule 70 (type -> primitive_type .)
    PLUS            reduce using rule 70 (type -> primitive_type .)
    MINUS           reduce using rule 70 (type -> primitive_type .)
    LNOT            reduce using rule 70 (type -> primitive_type .)
    LBRACKET        reduce using rule 70 (type -> primitive_type .)
    LPAREN          reduce using rule 70 (type -> primitive_type .)
    INT             reduce using rule 70 (type -> primitive_type .)
    FLOAT64         reduce using rule 70 (type -> primitive_type .)
    TRUE            reduce using rule 70 (type -> primitive_type .)
    FALSE           reduce using rule 70 (type -> primitive_type .)
    STRING          reduce using rule 70 (type -> primitive_type .)
    RETURN          reduce using rule 70 (type -> primitive_type .)
    FOR             reduce using rule 70 (type -> primitive_type .)
    IF              reduce using rule 70 (type -> primitive_type .)
    SWITCH          reduce using rule 70 (type -> primitive_type .)
    BREAK           reduce using rule 70 (type -> primitive_type .)
    CONTINUE        reduce using rule 70 (type -> primitive_type .)
    FALLTHROUGH     reduce using rule 70 (type -> primitive_type .)
    $end            reduce using rule 70 (type -> primitive_type .)
>>>>>>> Stashed changes

    binary_operator                shift and go to state 81

state 181

<<<<<<< Updated upstream
    (157) keyed_element_list -> keyed_element_list COMMA keyed_element .

    RBRACE          reduce using rule 157 (keyed_element_list -> keyed_element_list COMMA keyed_element .)
    COMMA           reduce using rule 157 (keyed_element_list -> keyed_element_list COMMA keyed_element .)
=======
    (71) type -> slice_type .

    ASSIGN          reduce using rule 71 (type -> slice_type .)
    RPAREN          reduce using rule 71 (type -> slice_type .)
    COMMA           reduce using rule 71 (type -> slice_type .)
    LBRACE          reduce using rule 71 (type -> slice_type .)
    RBRACE          reduce using rule 71 (type -> slice_type .)
    IDENTIFIER      reduce using rule 71 (type -> slice_type .)
    SEMICOLON       reduce using rule 71 (type -> slice_type .)
    FUNC            reduce using rule 71 (type -> slice_type .)
    TYPE            reduce using rule 71 (type -> slice_type .)
    VAR             reduce using rule 71 (type -> slice_type .)
    CONST           reduce using rule 71 (type -> slice_type .)
    PLUS            reduce using rule 71 (type -> slice_type .)
    MINUS           reduce using rule 71 (type -> slice_type .)
    LNOT            reduce using rule 71 (type -> slice_type .)
    LBRACKET        reduce using rule 71 (type -> slice_type .)
    LPAREN          reduce using rule 71 (type -> slice_type .)
    INT             reduce using rule 71 (type -> slice_type .)
    FLOAT64         reduce using rule 71 (type -> slice_type .)
    TRUE            reduce using rule 71 (type -> slice_type .)
    FALSE           reduce using rule 71 (type -> slice_type .)
    STRING          reduce using rule 71 (type -> slice_type .)
    RETURN          reduce using rule 71 (type -> slice_type .)
    FOR             reduce using rule 71 (type -> slice_type .)
    IF              reduce using rule 71 (type -> slice_type .)
    SWITCH          reduce using rule 71 (type -> slice_type .)
    BREAK           reduce using rule 71 (type -> slice_type .)
    CONTINUE        reduce using rule 71 (type -> slice_type .)
    FALLTHROUGH     reduce using rule 71 (type -> slice_type .)
    $end            reduce using rule 71 (type -> slice_type .)
>>>>>>> Stashed changes


state 182

<<<<<<< Updated upstream
    (158) keyed_element -> IDENTIFIER COLON expression .
    (36) expression -> expression . binary_operator expression
    (200) expression -> expression . DOT IDENTIFIER
    (201) expression -> expression . DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> expression . LBRACKET expression RBRACKET
    (37) binary_operator -> . PLUS
    (38) binary_operator -> . MINUS
    (39) binary_operator -> . TIMES
    (40) binary_operator -> . DIVIDE
    (41) binary_operator -> . MODULE
    (42) binary_operator -> . EQ
    (43) binary_operator -> . NEQ
    (44) binary_operator -> . LT
    (45) binary_operator -> . LE
    (46) binary_operator -> . GT
    (47) binary_operator -> . GE
    (48) binary_operator -> . LAND
    (49) binary_operator -> . LOR
    (50) binary_operator -> . AND
    (51) binary_operator -> . OR
    (52) binary_operator -> . XOR
    (53) binary_operator -> . AND_NOT
    (54) binary_operator -> . LSHIFT
    (55) binary_operator -> . RSHIFT

    RBRACE          reduce using rule 158 (keyed_element -> IDENTIFIER COLON expression .)
    COMMA           reduce using rule 158 (keyed_element -> IDENTIFIER COLON expression .)
    DOT             shift and go to state 82
    LBRACKET        shift and go to state 83
    PLUS            shift and go to state 84
    MINUS           shift and go to state 85
    TIMES           shift and go to state 86
    DIVIDE          shift and go to state 87
    MODULE          shift and go to state 88
    EQ              shift and go to state 89
    NEQ             shift and go to state 90
    LT              shift and go to state 91
    LE              shift and go to state 92
    GT              shift and go to state 93
    GE              shift and go to state 94
    LAND            shift and go to state 95
    LOR             shift and go to state 96
    AND             shift and go to state 97
    OR              shift and go to state 98
    XOR             shift and go to state 99
    AND_NOT         shift and go to state 100
    LSHIFT          shift and go to state 101
    RSHIFT          shift and go to state 102
=======
    (72) type -> array_type .

    ASSIGN          reduce using rule 72 (type -> array_type .)
    RPAREN          reduce using rule 72 (type -> array_type .)
    COMMA           reduce using rule 72 (type -> array_type .)
    LBRACE          reduce using rule 72 (type -> array_type .)
    RBRACE          reduce using rule 72 (type -> array_type .)
    IDENTIFIER      reduce using rule 72 (type -> array_type .)
    SEMICOLON       reduce using rule 72 (type -> array_type .)
    FUNC            reduce using rule 72 (type -> array_type .)
    TYPE            reduce using rule 72 (type -> array_type .)
    VAR             reduce using rule 72 (type -> array_type .)
    CONST           reduce using rule 72 (type -> array_type .)
    PLUS            reduce using rule 72 (type -> array_type .)
    MINUS           reduce using rule 72 (type -> array_type .)
    LNOT            reduce using rule 72 (type -> array_type .)
    LBRACKET        reduce using rule 72 (type -> array_type .)
    LPAREN          reduce using rule 72 (type -> array_type .)
    INT             reduce using rule 72 (type -> array_type .)
    FLOAT64         reduce using rule 72 (type -> array_type .)
    TRUE            reduce using rule 72 (type -> array_type .)
    FALSE           reduce using rule 72 (type -> array_type .)
    STRING          reduce using rule 72 (type -> array_type .)
    RETURN          reduce using rule 72 (type -> array_type .)
    FOR             reduce using rule 72 (type -> array_type .)
    IF              reduce using rule 72 (type -> array_type .)
    SWITCH          reduce using rule 72 (type -> array_type .)
    BREAK           reduce using rule 72 (type -> array_type .)
    CONTINUE        reduce using rule 72 (type -> array_type .)
    FALLTHROUGH     reduce using rule 72 (type -> array_type .)
    $end            reduce using rule 72 (type -> array_type .)
>>>>>>> Stashed changes

    binary_operator                shift and go to state 81

state 183

<<<<<<< Updated upstream
    (159) keyed_element -> INT COLON expression .
    (36) expression -> expression . binary_operator expression
    (200) expression -> expression . DOT IDENTIFIER
    (201) expression -> expression . DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> expression . LBRACKET expression RBRACKET
    (37) binary_operator -> . PLUS
    (38) binary_operator -> . MINUS
    (39) binary_operator -> . TIMES
    (40) binary_operator -> . DIVIDE
    (41) binary_operator -> . MODULE
    (42) binary_operator -> . EQ
    (43) binary_operator -> . NEQ
    (44) binary_operator -> . LT
    (45) binary_operator -> . LE
    (46) binary_operator -> . GT
    (47) binary_operator -> . GE
    (48) binary_operator -> . LAND
    (49) binary_operator -> . LOR
    (50) binary_operator -> . AND
    (51) binary_operator -> . OR
    (52) binary_operator -> . XOR
    (53) binary_operator -> . AND_NOT
    (54) binary_operator -> . LSHIFT
    (55) binary_operator -> . RSHIFT

    RBRACE          reduce using rule 159 (keyed_element -> INT COLON expression .)
    COMMA           reduce using rule 159 (keyed_element -> INT COLON expression .)
    DOT             shift and go to state 82
    LBRACKET        shift and go to state 83
    PLUS            shift and go to state 84
    MINUS           shift and go to state 85
    TIMES           shift and go to state 86
    DIVIDE          shift and go to state 87
    MODULE          shift and go to state 88
    EQ              shift and go to state 89
    NEQ             shift and go to state 90
    LT              shift and go to state 91
    LE              shift and go to state 92
    GT              shift and go to state 93
    GE              shift and go to state 94
    LAND            shift and go to state 95
    LOR             shift and go to state 96
    AND             shift and go to state 97
    OR              shift and go to state 98
    XOR             shift and go to state 99
    AND_NOT         shift and go to state 100
    LSHIFT          shift and go to state 101
    RSHIFT          shift and go to state 102
=======
    (73) type -> map_type .

    ASSIGN          reduce using rule 73 (type -> map_type .)
    RPAREN          reduce using rule 73 (type -> map_type .)
    COMMA           reduce using rule 73 (type -> map_type .)
    LBRACE          reduce using rule 73 (type -> map_type .)
    RBRACE          reduce using rule 73 (type -> map_type .)
    IDENTIFIER      reduce using rule 73 (type -> map_type .)
    SEMICOLON       reduce using rule 73 (type -> map_type .)
    FUNC            reduce using rule 73 (type -> map_type .)
    TYPE            reduce using rule 73 (type -> map_type .)
    VAR             reduce using rule 73 (type -> map_type .)
    CONST           reduce using rule 73 (type -> map_type .)
    PLUS            reduce using rule 73 (type -> map_type .)
    MINUS           reduce using rule 73 (type -> map_type .)
    LNOT            reduce using rule 73 (type -> map_type .)
    LBRACKET        reduce using rule 73 (type -> map_type .)
    LPAREN          reduce using rule 73 (type -> map_type .)
    INT             reduce using rule 73 (type -> map_type .)
    FLOAT64         reduce using rule 73 (type -> map_type .)
    TRUE            reduce using rule 73 (type -> map_type .)
    FALSE           reduce using rule 73 (type -> map_type .)
    STRING          reduce using rule 73 (type -> map_type .)
    RETURN          reduce using rule 73 (type -> map_type .)
    FOR             reduce using rule 73 (type -> map_type .)
    IF              reduce using rule 73 (type -> map_type .)
    SWITCH          reduce using rule 73 (type -> map_type .)
    BREAK           reduce using rule 73 (type -> map_type .)
    CONTINUE        reduce using rule 73 (type -> map_type .)
    FALLTHROUGH     reduce using rule 73 (type -> map_type .)
    $end            reduce using rule 73 (type -> map_type .)
>>>>>>> Stashed changes

    binary_operator                shift and go to state 81

state 184

<<<<<<< Updated upstream
    (119) return_type -> LPAREN type_list RPAREN .

    LBRACE          reduce using rule 119 (return_type -> LPAREN type_list RPAREN .)
=======
    (74) type -> struct_type .

    ASSIGN          reduce using rule 74 (type -> struct_type .)
    RPAREN          reduce using rule 74 (type -> struct_type .)
    COMMA           reduce using rule 74 (type -> struct_type .)
    LBRACE          reduce using rule 74 (type -> struct_type .)
    RBRACE          reduce using rule 74 (type -> struct_type .)
    IDENTIFIER      reduce using rule 74 (type -> struct_type .)
    SEMICOLON       reduce using rule 74 (type -> struct_type .)
    FUNC            reduce using rule 74 (type -> struct_type .)
    TYPE            reduce using rule 74 (type -> struct_type .)
    VAR             reduce using rule 74 (type -> struct_type .)
    CONST           reduce using rule 74 (type -> struct_type .)
    PLUS            reduce using rule 74 (type -> struct_type .)
    MINUS           reduce using rule 74 (type -> struct_type .)
    LNOT            reduce using rule 74 (type -> struct_type .)
    LBRACKET        reduce using rule 74 (type -> struct_type .)
    LPAREN          reduce using rule 74 (type -> struct_type .)
    INT             reduce using rule 74 (type -> struct_type .)
    FLOAT64         reduce using rule 74 (type -> struct_type .)
    TRUE            reduce using rule 74 (type -> struct_type .)
    FALSE           reduce using rule 74 (type -> struct_type .)
    STRING          reduce using rule 74 (type -> struct_type .)
    RETURN          reduce using rule 74 (type -> struct_type .)
    FOR             reduce using rule 74 (type -> struct_type .)
    IF              reduce using rule 74 (type -> struct_type .)
    SWITCH          reduce using rule 74 (type -> struct_type .)
    BREAK           reduce using rule 74 (type -> struct_type .)
    CONTINUE        reduce using rule 74 (type -> struct_type .)
    FALLTHROUGH     reduce using rule 74 (type -> struct_type .)
    $end            reduce using rule 74 (type -> struct_type .)
>>>>>>> Stashed changes


state 185

<<<<<<< Updated upstream
    (122) type_list -> type_list COMMA . type
    (57) type -> . primitive_type
    (58) type -> . slice_type
    (59) type -> . array_type
    (60) type -> . map_type
    (61) primitive_type -> . INT_TYPE
    (62) primitive_type -> . FLOAT64_TYPE
    (63) primitive_type -> . STRING_TYPE
    (64) primitive_type -> . BOOL_TYPE
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (197) array_type -> . LBRACKET INT RBRACKET primitive_type
    (137) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type

    INT_TYPE        shift and go to state 34
    FLOAT64_TYPE    shift and go to state 35
    STRING_TYPE     shift and go to state 36
    BOOL_TYPE       shift and go to state 37
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    type                           shift and go to state 213
    primitive_type                 shift and go to state 30
    slice_type                     shift and go to state 31
    array_type                     shift and go to state 32
    map_type                       shift and go to state 33

state 186

    (90) block -> LBRACE local_statement_list . RBRACE
    (93) local_statement_list -> local_statement_list . local_statement
    (78) local_statement -> . local_var_dec
    (79) local_statement -> . local_const_dec
    (80) local_statement -> . short_assignment
    (81) local_statement -> . simple_assignment
    (82) local_statement -> . assignment_compound
    (83) local_statement -> . expression
    (84) local_statement -> . for_statement
    (85) local_statement -> . if_statement
    (86) local_statement -> . switch_statement
    (87) local_statement -> . return_statement
    (88) local_statement -> . BREAK
    (89) local_statement -> . CONTINUE
    (20) local_var_dec -> . VAR IDENTIFIER type
    (21) local_var_dec -> . VAR IDENTIFIER type ASSIGN expression
    (22) local_var_dec -> . VAR IDENTIFIER ASSIGN expression
    (23) local_const_dec -> . CONST IDENTIFIER type ASSIGN expression
    (24) local_const_dec -> . CONST IDENTIFIER ASSIGN expression
    (77) short_assignment -> . IDENTIFIER SHORT_ASSIGN expression
    (56) simple_assignment -> . IDENTIFIER ASSIGN expression
    (25) assignment_compound -> . IDENTIFIER operator_assign expression
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (125) expression -> . LNOT expression
    (126) expression -> . IDENTIFIER PLUSPLUS
    (127) expression -> . IDENTIFIER MINUSMINUS
    (138) expression -> . map_type LBRACE expression_map_list RBRACE
    (139) expression -> . map_type LBRACE RBRACE
    (161) expression -> . type_name LBRACE keyed_element_list RBRACE
    (162) expression -> . type_name LBRACE RBRACE
    (198) expression -> . array_type LBRACE expression_list RBRACE
    (199) expression -> . array_type LBRACE RBRACE
    (200) expression -> . expression DOT IDENTIFIER
    (201) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> . expression LBRACKET expression RBRACKET
    (203) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (94) for_statement -> . for_classic
    (95) for_statement -> . for_condition
    (96) for_statement -> . for_infinite
    (128) if_statement -> . IF expression block
    (129) if_statement -> . IF expression block ELSE block
    (130) if_statement -> . IF expression block ELSE if_statement
    (131) if_statement -> . IF if_assignment SEMICOLON expression block
    (132) if_statement -> . IF if_assignment SEMICOLON expression block ELSE block
    (133) if_statement -> . IF if_assignment SEMICOLON expression block ELSE if_statement
    (167) switch_statement -> . SWITCH switch_expr LBRACE case_clause_list RBRACE
    (168) switch_statement -> . SWITCH switch_expr LBRACE RBRACE
    (169) switch_statement -> . SWITCH LBRACE case_clause_list RBRACE
    (170) switch_statement -> . SWITCH LBRACE RBRACE
    (171) switch_statement -> . SWITCH switch_assignment SEMICOLON switch_expr LBRACE case_clause_list RBRACE
    (172) switch_statement -> . SWITCH switch_assignment SEMICOLON switch_expr LBRACE RBRACE
    (173) switch_statement -> . SWITCH switch_assignment SEMICOLON LBRACE case_clause_list RBRACE
    (174) switch_statement -> . SWITCH switch_assignment SEMICOLON LBRACE RBRACE
    (123) return_statement -> . RETURN
    (124) return_statement -> . RETURN return_list
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (137) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (163) type_name -> . IDENTIFIER
    (164) type_name -> . slice_type
    (165) type_name -> . array_type
    (166) type_name -> . map_type
    (197) array_type -> . LBRACKET INT RBRACKET primitive_type
    (97) for_classic -> . FOR for_init SEMICOLON for_cond SEMICOLON for_post block
    (98) for_condition -> . FOR expression block
    (99) for_infinite -> . FOR block

    RBRACE          shift and go to state 214
    BREAK           shift and go to state 199
    CONTINUE        shift and go to state 200
    VAR             shift and go to state 201
    CONST           shift and go to state 203
    IDENTIFIER      shift and go to state 202
    LPAREN          shift and go to state 54
    INT             shift and go to state 55
    FLOAT64         shift and go to state 56
    STRING          shift and go to state 57
    TRUE            shift and go to state 58
    FALSE           shift and go to state 59
    LNOT            shift and go to state 60
    IF              shift and go to state 207
    SWITCH          shift and go to state 208
    RETURN          shift and go to state 209
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39
    FOR             shift and go to state 210

    local_statement                shift and go to state 215
    local_var_dec                  shift and go to state 189
    local_const_dec                shift and go to state 190
    short_assignment               shift and go to state 191
    simple_assignment              shift and go to state 192
    assignment_compound            shift and go to state 193
    expression                     shift and go to state 194
    for_statement                  shift and go to state 195
    if_statement                   shift and go to state 196
    switch_statement               shift and go to state 197
    return_statement               shift and go to state 198
    slice_type                     shift and go to state 53
    map_type                       shift and go to state 61
    type_name                      shift and go to state 62
    array_type                     shift and go to state 63
    for_classic                    shift and go to state 204
    for_condition                  shift and go to state 205
    for_infinite                   shift and go to state 206

state 187

    (91) block -> LBRACE RBRACE .

    VAR             reduce using rule 91 (block -> LBRACE RBRACE .)
    CONST           reduce using rule 91 (block -> LBRACE RBRACE .)
    FUNC            reduce using rule 91 (block -> LBRACE RBRACE .)
    TYPE            reduce using rule 91 (block -> LBRACE RBRACE .)
    $end            reduce using rule 91 (block -> LBRACE RBRACE .)
    RBRACE          reduce using rule 91 (block -> LBRACE RBRACE .)
    BREAK           reduce using rule 91 (block -> LBRACE RBRACE .)
    CONTINUE        reduce using rule 91 (block -> LBRACE RBRACE .)
    IDENTIFIER      reduce using rule 91 (block -> LBRACE RBRACE .)
    LPAREN          reduce using rule 91 (block -> LBRACE RBRACE .)
    INT             reduce using rule 91 (block -> LBRACE RBRACE .)
    FLOAT64         reduce using rule 91 (block -> LBRACE RBRACE .)
    STRING          reduce using rule 91 (block -> LBRACE RBRACE .)
    TRUE            reduce using rule 91 (block -> LBRACE RBRACE .)
    FALSE           reduce using rule 91 (block -> LBRACE RBRACE .)
    LNOT            reduce using rule 91 (block -> LBRACE RBRACE .)
    IF              reduce using rule 91 (block -> LBRACE RBRACE .)
    SWITCH          reduce using rule 91 (block -> LBRACE RBRACE .)
    RETURN          reduce using rule 91 (block -> LBRACE RBRACE .)
    LBRACKET        reduce using rule 91 (block -> LBRACE RBRACE .)
    MAP             reduce using rule 91 (block -> LBRACE RBRACE .)
    FOR             reduce using rule 91 (block -> LBRACE RBRACE .)
    CASE            reduce using rule 91 (block -> LBRACE RBRACE .)
    DEFAULT         reduce using rule 91 (block -> LBRACE RBRACE .)
    ELSE            reduce using rule 91 (block -> LBRACE RBRACE .)
=======
    (67) variable_declaration -> CONST IDENTIFIER type . ASSIGN expression

    ASSIGN          shift and go to state 233


state 186

    (69) variable_declaration -> CONST IDENTIFIER ASSIGN . expression
    (82) expression -> . binary_expression
    (83) expression -> . relational_expression
    (84) expression -> . logical_expression
    (85) expression -> . bitwise_expression
    (86) expression -> . PLUS expression
    (87) expression -> . MINUS expression
    (88) expression -> . LNOT expression
    (89) expression -> . LBRACKET RBRACKET primitive_type LBRACE expression_list RBRACE
    (90) expression -> . LBRACKET RBRACKET primitive_type LBRACE RBRACE
    (91) expression -> . LPAREN expression RPAREN
    (92) expression -> . INT
    (93) expression -> . FLOAT64
    (94) expression -> . TRUE
    (95) expression -> . FALSE
    (96) expression -> . IDENTIFIER
    (97) expression -> . STRING
    (98) expression -> . IDENTIFIER PLUSPLUS
    (99) expression -> . IDENTIFIER MINUSMINUS
    (100) expression -> . expression DOT IDENTIFIER
    (103) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (133) expression -> . IDENTIFIER LBRACE keyed_element_list RBRACE
    (134) expression -> . IDENTIFIER LBRACE RBRACE
    (135) binary_expression -> . expression PLUS expression
    (136) binary_expression -> . expression MINUS expression
    (137) binary_expression -> . expression TIMES expression
    (138) binary_expression -> . expression DIVIDE expression
    (139) binary_expression -> . expression MODULE expression
    (144) relational_expression -> . expression EQ expression
    (145) relational_expression -> . expression NEQ expression
    (146) relational_expression -> . expression LT expression
    (147) relational_expression -> . expression LE expression
    (148) relational_expression -> . expression GT expression
    (149) relational_expression -> . expression GE expression
    (150) logical_expression -> . expression LAND expression
    (151) logical_expression -> . expression LOR expression
    (152) bitwise_expression -> . expression AND expression
    (153) bitwise_expression -> . expression OR expression
    (154) bitwise_expression -> . expression XOR expression
    (155) bitwise_expression -> . expression AND_NOT expression
    (156) bitwise_expression -> . expression LSHIFT expression
    (157) bitwise_expression -> . expression RSHIFT expression

    PLUS            shift and go to state 37
    MINUS           shift and go to state 38
    LNOT            shift and go to state 39
    LBRACKET        shift and go to state 40
    LPAREN          shift and go to state 29
    INT             shift and go to state 41
    FLOAT64         shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44
    IDENTIFIER      shift and go to state 97
    STRING          shift and go to state 11

    expression                     shift and go to state 234
    binary_expression              shift and go to state 33
    relational_expression          shift and go to state 34
    logical_expression             shift and go to state 35
    bitwise_expression             shift and go to state 36

state 187

    (89) expression -> LBRACKET RBRACKET primitive_type . LBRACE expression_list RBRACE
    (90) expression -> LBRACKET RBRACKET primitive_type . LBRACE RBRACE

    LBRACE          shift and go to state 235
>>>>>>> Stashed changes


state 188

<<<<<<< Updated upstream
    (92) local_statement_list -> local_statement .

    RBRACE          reduce using rule 92 (local_statement_list -> local_statement .)
    BREAK           reduce using rule 92 (local_statement_list -> local_statement .)
    CONTINUE        reduce using rule 92 (local_statement_list -> local_statement .)
    VAR             reduce using rule 92 (local_statement_list -> local_statement .)
    CONST           reduce using rule 92 (local_statement_list -> local_statement .)
    IDENTIFIER      reduce using rule 92 (local_statement_list -> local_statement .)
    LPAREN          reduce using rule 92 (local_statement_list -> local_statement .)
    INT             reduce using rule 92 (local_statement_list -> local_statement .)
    FLOAT64         reduce using rule 92 (local_statement_list -> local_statement .)
    STRING          reduce using rule 92 (local_statement_list -> local_statement .)
    TRUE            reduce using rule 92 (local_statement_list -> local_statement .)
    FALSE           reduce using rule 92 (local_statement_list -> local_statement .)
    LNOT            reduce using rule 92 (local_statement_list -> local_statement .)
    IF              reduce using rule 92 (local_statement_list -> local_statement .)
    SWITCH          reduce using rule 92 (local_statement_list -> local_statement .)
    RETURN          reduce using rule 92 (local_statement_list -> local_statement .)
    LBRACKET        reduce using rule 92 (local_statement_list -> local_statement .)
    MAP             reduce using rule 92 (local_statement_list -> local_statement .)
    FOR             reduce using rule 92 (local_statement_list -> local_statement .)
    CASE            reduce using rule 92 (local_statement_list -> local_statement .)
    DEFAULT         reduce using rule 92 (local_statement_list -> local_statement .)
=======
    (42) return_list -> return_list COMMA . expression
    (82) expression -> . binary_expression
    (83) expression -> . relational_expression
    (84) expression -> . logical_expression
    (85) expression -> . bitwise_expression
    (86) expression -> . PLUS expression
    (87) expression -> . MINUS expression
    (88) expression -> . LNOT expression
    (89) expression -> . LBRACKET RBRACKET primitive_type LBRACE expression_list RBRACE
    (90) expression -> . LBRACKET RBRACKET primitive_type LBRACE RBRACE
    (91) expression -> . LPAREN expression RPAREN
    (92) expression -> . INT
    (93) expression -> . FLOAT64
    (94) expression -> . TRUE
    (95) expression -> . FALSE
    (96) expression -> . IDENTIFIER
    (97) expression -> . STRING
    (98) expression -> . IDENTIFIER PLUSPLUS
    (99) expression -> . IDENTIFIER MINUSMINUS
    (100) expression -> . expression DOT IDENTIFIER
    (103) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (133) expression -> . IDENTIFIER LBRACE keyed_element_list RBRACE
    (134) expression -> . IDENTIFIER LBRACE RBRACE
    (135) binary_expression -> . expression PLUS expression
    (136) binary_expression -> . expression MINUS expression
    (137) binary_expression -> . expression TIMES expression
    (138) binary_expression -> . expression DIVIDE expression
    (139) binary_expression -> . expression MODULE expression
    (144) relational_expression -> . expression EQ expression
    (145) relational_expression -> . expression NEQ expression
    (146) relational_expression -> . expression LT expression
    (147) relational_expression -> . expression LE expression
    (148) relational_expression -> . expression GT expression
    (149) relational_expression -> . expression GE expression
    (150) logical_expression -> . expression LAND expression
    (151) logical_expression -> . expression LOR expression
    (152) bitwise_expression -> . expression AND expression
    (153) bitwise_expression -> . expression OR expression
    (154) bitwise_expression -> . expression XOR expression
    (155) bitwise_expression -> . expression AND_NOT expression
    (156) bitwise_expression -> . expression LSHIFT expression
    (157) bitwise_expression -> . expression RSHIFT expression

    PLUS            shift and go to state 37
    MINUS           shift and go to state 38
    LNOT            shift and go to state 39
    LBRACKET        shift and go to state 40
    LPAREN          shift and go to state 29
    INT             shift and go to state 41
    FLOAT64         shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44
    IDENTIFIER      shift and go to state 97
    STRING          shift and go to state 11
>>>>>>> Stashed changes

    expression                     shift and go to state 236
    binary_expression              shift and go to state 33
    relational_expression          shift and go to state 34
    logical_expression             shift and go to state 35
    bitwise_expression             shift and go to state 36

state 189

<<<<<<< Updated upstream
    (78) local_statement -> local_var_dec .

    RBRACE          reduce using rule 78 (local_statement -> local_var_dec .)
    BREAK           reduce using rule 78 (local_statement -> local_var_dec .)
    CONTINUE        reduce using rule 78 (local_statement -> local_var_dec .)
    VAR             reduce using rule 78 (local_statement -> local_var_dec .)
    CONST           reduce using rule 78 (local_statement -> local_var_dec .)
    IDENTIFIER      reduce using rule 78 (local_statement -> local_var_dec .)
    LPAREN          reduce using rule 78 (local_statement -> local_var_dec .)
    INT             reduce using rule 78 (local_statement -> local_var_dec .)
    FLOAT64         reduce using rule 78 (local_statement -> local_var_dec .)
    STRING          reduce using rule 78 (local_statement -> local_var_dec .)
    TRUE            reduce using rule 78 (local_statement -> local_var_dec .)
    FALSE           reduce using rule 78 (local_statement -> local_var_dec .)
    LNOT            reduce using rule 78 (local_statement -> local_var_dec .)
    IF              reduce using rule 78 (local_statement -> local_var_dec .)
    SWITCH          reduce using rule 78 (local_statement -> local_var_dec .)
    RETURN          reduce using rule 78 (local_statement -> local_var_dec .)
    LBRACKET        reduce using rule 78 (local_statement -> local_var_dec .)
    MAP             reduce using rule 78 (local_statement -> local_var_dec .)
    FOR             reduce using rule 78 (local_statement -> local_var_dec .)
    CASE            reduce using rule 78 (local_statement -> local_var_dec .)
    DEFAULT         reduce using rule 78 (local_statement -> local_var_dec .)
=======
    (33) for_statement -> FOR expression block .

    SEMICOLON       reduce using rule 33 (for_statement -> FOR expression block .)
    FUNC            reduce using rule 33 (for_statement -> FOR expression block .)
    TYPE            reduce using rule 33 (for_statement -> FOR expression block .)
    IDENTIFIER      reduce using rule 33 (for_statement -> FOR expression block .)
    VAR             reduce using rule 33 (for_statement -> FOR expression block .)
    CONST           reduce using rule 33 (for_statement -> FOR expression block .)
    PLUS            reduce using rule 33 (for_statement -> FOR expression block .)
    MINUS           reduce using rule 33 (for_statement -> FOR expression block .)
    LNOT            reduce using rule 33 (for_statement -> FOR expression block .)
    LBRACKET        reduce using rule 33 (for_statement -> FOR expression block .)
    LPAREN          reduce using rule 33 (for_statement -> FOR expression block .)
    INT             reduce using rule 33 (for_statement -> FOR expression block .)
    FLOAT64         reduce using rule 33 (for_statement -> FOR expression block .)
    TRUE            reduce using rule 33 (for_statement -> FOR expression block .)
    FALSE           reduce using rule 33 (for_statement -> FOR expression block .)
    STRING          reduce using rule 33 (for_statement -> FOR expression block .)
    RETURN          reduce using rule 33 (for_statement -> FOR expression block .)
    FOR             reduce using rule 33 (for_statement -> FOR expression block .)
    IF              reduce using rule 33 (for_statement -> FOR expression block .)
    SWITCH          reduce using rule 33 (for_statement -> FOR expression block .)
    BREAK           reduce using rule 33 (for_statement -> FOR expression block .)
    CONTINUE        reduce using rule 33 (for_statement -> FOR expression block .)
    FALLTHROUGH     reduce using rule 33 (for_statement -> FOR expression block .)
    $end            reduce using rule 33 (for_statement -> FOR expression block .)
    RBRACE          reduce using rule 33 (for_statement -> FOR expression block .)
    CASE            reduce using rule 33 (for_statement -> FOR expression block .)
    DEFAULT         reduce using rule 33 (for_statement -> FOR expression block .)
>>>>>>> Stashed changes


state 190

<<<<<<< Updated upstream
    (79) local_statement -> local_const_dec .

    RBRACE          reduce using rule 79 (local_statement -> local_const_dec .)
    BREAK           reduce using rule 79 (local_statement -> local_const_dec .)
    CONTINUE        reduce using rule 79 (local_statement -> local_const_dec .)
    VAR             reduce using rule 79 (local_statement -> local_const_dec .)
    CONST           reduce using rule 79 (local_statement -> local_const_dec .)
    IDENTIFIER      reduce using rule 79 (local_statement -> local_const_dec .)
    LPAREN          reduce using rule 79 (local_statement -> local_const_dec .)
    INT             reduce using rule 79 (local_statement -> local_const_dec .)
    FLOAT64         reduce using rule 79 (local_statement -> local_const_dec .)
    STRING          reduce using rule 79 (local_statement -> local_const_dec .)
    TRUE            reduce using rule 79 (local_statement -> local_const_dec .)
    FALSE           reduce using rule 79 (local_statement -> local_const_dec .)
    LNOT            reduce using rule 79 (local_statement -> local_const_dec .)
    IF              reduce using rule 79 (local_statement -> local_const_dec .)
    SWITCH          reduce using rule 79 (local_statement -> local_const_dec .)
    RETURN          reduce using rule 79 (local_statement -> local_const_dec .)
    LBRACKET        reduce using rule 79 (local_statement -> local_const_dec .)
    MAP             reduce using rule 79 (local_statement -> local_const_dec .)
    FOR             reduce using rule 79 (local_statement -> local_const_dec .)
    CASE            reduce using rule 79 (local_statement -> local_const_dec .)
    DEFAULT         reduce using rule 79 (local_statement -> local_const_dec .)
=======
    (35) for_statement -> FOR for_clause block .

    SEMICOLON       reduce using rule 35 (for_statement -> FOR for_clause block .)
    FUNC            reduce using rule 35 (for_statement -> FOR for_clause block .)
    TYPE            reduce using rule 35 (for_statement -> FOR for_clause block .)
    IDENTIFIER      reduce using rule 35 (for_statement -> FOR for_clause block .)
    VAR             reduce using rule 35 (for_statement -> FOR for_clause block .)
    CONST           reduce using rule 35 (for_statement -> FOR for_clause block .)
    PLUS            reduce using rule 35 (for_statement -> FOR for_clause block .)
    MINUS           reduce using rule 35 (for_statement -> FOR for_clause block .)
    LNOT            reduce using rule 35 (for_statement -> FOR for_clause block .)
    LBRACKET        reduce using rule 35 (for_statement -> FOR for_clause block .)
    LPAREN          reduce using rule 35 (for_statement -> FOR for_clause block .)
    INT             reduce using rule 35 (for_statement -> FOR for_clause block .)
    FLOAT64         reduce using rule 35 (for_statement -> FOR for_clause block .)
    TRUE            reduce using rule 35 (for_statement -> FOR for_clause block .)
    FALSE           reduce using rule 35 (for_statement -> FOR for_clause block .)
    STRING          reduce using rule 35 (for_statement -> FOR for_clause block .)
    RETURN          reduce using rule 35 (for_statement -> FOR for_clause block .)
    FOR             reduce using rule 35 (for_statement -> FOR for_clause block .)
    IF              reduce using rule 35 (for_statement -> FOR for_clause block .)
    SWITCH          reduce using rule 35 (for_statement -> FOR for_clause block .)
    BREAK           reduce using rule 35 (for_statement -> FOR for_clause block .)
    CONTINUE        reduce using rule 35 (for_statement -> FOR for_clause block .)
    FALLTHROUGH     reduce using rule 35 (for_statement -> FOR for_clause block .)
    $end            reduce using rule 35 (for_statement -> FOR for_clause block .)
    RBRACE          reduce using rule 35 (for_statement -> FOR for_clause block .)
    CASE            reduce using rule 35 (for_statement -> FOR for_clause block .)
    DEFAULT         reduce using rule 35 (for_statement -> FOR for_clause block .)
>>>>>>> Stashed changes


state 191

<<<<<<< Updated upstream
    (80) local_statement -> short_assignment .

    RBRACE          reduce using rule 80 (local_statement -> short_assignment .)
    BREAK           reduce using rule 80 (local_statement -> short_assignment .)
    CONTINUE        reduce using rule 80 (local_statement -> short_assignment .)
    VAR             reduce using rule 80 (local_statement -> short_assignment .)
    CONST           reduce using rule 80 (local_statement -> short_assignment .)
    IDENTIFIER      reduce using rule 80 (local_statement -> short_assignment .)
    LPAREN          reduce using rule 80 (local_statement -> short_assignment .)
    INT             reduce using rule 80 (local_statement -> short_assignment .)
    FLOAT64         reduce using rule 80 (local_statement -> short_assignment .)
    STRING          reduce using rule 80 (local_statement -> short_assignment .)
    TRUE            reduce using rule 80 (local_statement -> short_assignment .)
    FALSE           reduce using rule 80 (local_statement -> short_assignment .)
    LNOT            reduce using rule 80 (local_statement -> short_assignment .)
    IF              reduce using rule 80 (local_statement -> short_assignment .)
    SWITCH          reduce using rule 80 (local_statement -> short_assignment .)
    RETURN          reduce using rule 80 (local_statement -> short_assignment .)
    LBRACKET        reduce using rule 80 (local_statement -> short_assignment .)
    MAP             reduce using rule 80 (local_statement -> short_assignment .)
    FOR             reduce using rule 80 (local_statement -> short_assignment .)
    CASE            reduce using rule 80 (local_statement -> short_assignment .)
    DEFAULT         reduce using rule 80 (local_statement -> short_assignment .)
=======
    (16) block -> LBRACE enter_block . exit_block RBRACE
    (17) block -> LBRACE enter_block . statement_list exit_block RBRACE
    (168) exit_block -> .
    (18) statement_list -> . statement
    (19) statement_list -> . statement_list optional_semicolon statement
    (20) statement -> . assignment
    (21) statement -> . assignment_compound
    (22) statement -> . variable_declaration
    (23) statement -> . expression
    (24) statement -> . return_statement
    (25) statement -> . for_statement
    (26) statement -> . if_statement
    (27) statement -> . switch_statement
    (28) statement -> . break_statement
    (29) statement -> . continue_statement
    (30) statement -> . fallthrough_statement
    (54) assignment -> . IDENTIFIER ASSIGN expression
    (55) assignment -> . IDENTIFIER SHORT_ASSIGN expression
    (56) assignment_compound -> . IDENTIFIER PLUS_ASSIGN expression
    (57) assignment_compound -> . IDENTIFIER MINUS_ASSIGN expression
    (58) assignment_compound -> . IDENTIFIER MULT_ASSIGN expression
    (59) assignment_compound -> . IDENTIFIER DIV_ASSIGN expression
    (60) assignment_compound -> . IDENTIFIER MOD_ASSIGN expression
    (61) assignment_compound -> . IDENTIFIER AND_ASSIGN expression
    (62) assignment_compound -> . IDENTIFIER OR_ASSIGN expression
    (63) assignment_compound -> . IDENTIFIER XOR_ASSIGN expression
    (64) assignment_compound -> . IDENTIFIER LSHIFT_ASSIGN expression
    (65) assignment_compound -> . IDENTIFIER RSHIFT_ASSIGN expression
    (66) variable_declaration -> . VAR IDENTIFIER type ASSIGN expression
    (67) variable_declaration -> . CONST IDENTIFIER type ASSIGN expression
    (68) variable_declaration -> . VAR IDENTIFIER ASSIGN expression
    (69) variable_declaration -> . CONST IDENTIFIER ASSIGN expression
    (82) expression -> . binary_expression
    (83) expression -> . relational_expression
    (84) expression -> . logical_expression
    (85) expression -> . bitwise_expression
    (86) expression -> . PLUS expression
    (87) expression -> . MINUS expression
    (88) expression -> . LNOT expression
    (89) expression -> . LBRACKET RBRACKET primitive_type LBRACE expression_list RBRACE
    (90) expression -> . LBRACKET RBRACKET primitive_type LBRACE RBRACE
    (91) expression -> . LPAREN expression RPAREN
    (92) expression -> . INT
    (93) expression -> . FLOAT64
    (94) expression -> . TRUE
    (95) expression -> . FALSE
    (96) expression -> . IDENTIFIER
    (97) expression -> . STRING
    (98) expression -> . IDENTIFIER PLUSPLUS
    (99) expression -> . IDENTIFIER MINUSMINUS
    (100) expression -> . expression DOT IDENTIFIER
    (103) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (133) expression -> . IDENTIFIER LBRACE keyed_element_list RBRACE
    (134) expression -> . IDENTIFIER LBRACE RBRACE
    (39) return_statement -> . RETURN
    (40) return_statement -> . RETURN return_list
    (33) for_statement -> . FOR expression block
    (34) for_statement -> . FOR block
    (35) for_statement -> . FOR for_clause block
    (106) if_statement -> . IF expression block
    (107) if_statement -> . IF expression block ELSE block
    (108) if_statement -> . IF expression block ELSE if_statement
    (109) if_statement -> . IF assignment SEMICOLON expression block
    (110) if_statement -> . IF assignment SEMICOLON expression block ELSE block
    (111) if_statement -> . IF assignment SEMICOLON expression block ELSE if_statement
    (189) switch_statement -> . SWITCH enter_block switch_header LBRACE case_clauses RBRACE exit_block
    (31) break_statement -> . BREAK
    (32) continue_statement -> . CONTINUE
    (177) fallthrough_statement -> . FALLTHROUGH
    (135) binary_expression -> . expression PLUS expression
    (136) binary_expression -> . expression MINUS expression
    (137) binary_expression -> . expression TIMES expression
    (138) binary_expression -> . expression DIVIDE expression
    (139) binary_expression -> . expression MODULE expression
    (144) relational_expression -> . expression EQ expression
    (145) relational_expression -> . expression NEQ expression
    (146) relational_expression -> . expression LT expression
    (147) relational_expression -> . expression LE expression
    (148) relational_expression -> . expression GT expression
    (149) relational_expression -> . expression GE expression
    (150) logical_expression -> . expression LAND expression
    (151) logical_expression -> . expression LOR expression
    (152) bitwise_expression -> . expression AND expression
    (153) bitwise_expression -> . expression OR expression
    (154) bitwise_expression -> . expression XOR expression
    (155) bitwise_expression -> . expression AND_NOT expression
    (156) bitwise_expression -> . expression LSHIFT expression
    (157) bitwise_expression -> . expression RSHIFT expression

    RBRACE          reduce using rule 168 (exit_block -> .)
    IDENTIFIER      shift and go to state 28
    VAR             shift and go to state 31
    CONST           shift and go to state 32
    PLUS            shift and go to state 37
    MINUS           shift and go to state 38
    LNOT            shift and go to state 39
    LBRACKET        shift and go to state 40
    LPAREN          shift and go to state 29
    INT             shift and go to state 41
    FLOAT64         shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44
    STRING          shift and go to state 11
    RETURN          shift and go to state 45
    FOR             shift and go to state 46
    IF              shift and go to state 47
    SWITCH          shift and go to state 48
    BREAK           shift and go to state 49
    CONTINUE        shift and go to state 50
    FALLTHROUGH     shift and go to state 51
>>>>>>> Stashed changes

    exit_block                     shift and go to state 237
    statement_list                 shift and go to state 238
    statement                      shift and go to state 239
    assignment                     shift and go to state 16
    assignment_compound            shift and go to state 17
    variable_declaration           shift and go to state 18
    expression                     shift and go to state 19
    return_statement               shift and go to state 20
    for_statement                  shift and go to state 21
    if_statement                   shift and go to state 22
    switch_statement               shift and go to state 23
    break_statement                shift and go to state 24
    continue_statement             shift and go to state 25
    fallthrough_statement          shift and go to state 26
    binary_expression              shift and go to state 33
    relational_expression          shift and go to state 34
    logical_expression             shift and go to state 35
    bitwise_expression             shift and go to state 36

state 192

<<<<<<< Updated upstream
    (81) local_statement -> simple_assignment .

    RBRACE          reduce using rule 81 (local_statement -> simple_assignment .)
    BREAK           reduce using rule 81 (local_statement -> simple_assignment .)
    CONTINUE        reduce using rule 81 (local_statement -> simple_assignment .)
    VAR             reduce using rule 81 (local_statement -> simple_assignment .)
    CONST           reduce using rule 81 (local_statement -> simple_assignment .)
    IDENTIFIER      reduce using rule 81 (local_statement -> simple_assignment .)
    LPAREN          reduce using rule 81 (local_statement -> simple_assignment .)
    INT             reduce using rule 81 (local_statement -> simple_assignment .)
    FLOAT64         reduce using rule 81 (local_statement -> simple_assignment .)
    STRING          reduce using rule 81 (local_statement -> simple_assignment .)
    TRUE            reduce using rule 81 (local_statement -> simple_assignment .)
    FALSE           reduce using rule 81 (local_statement -> simple_assignment .)
    LNOT            reduce using rule 81 (local_statement -> simple_assignment .)
    IF              reduce using rule 81 (local_statement -> simple_assignment .)
    SWITCH          reduce using rule 81 (local_statement -> simple_assignment .)
    RETURN          reduce using rule 81 (local_statement -> simple_assignment .)
    LBRACKET        reduce using rule 81 (local_statement -> simple_assignment .)
    MAP             reduce using rule 81 (local_statement -> simple_assignment .)
    FOR             reduce using rule 81 (local_statement -> simple_assignment .)
    CASE            reduce using rule 81 (local_statement -> simple_assignment .)
    DEFAULT         reduce using rule 81 (local_statement -> simple_assignment .)
=======
    (36) for_clause -> assignment SEMICOLON . expression SEMICOLON assignment
    (82) expression -> . binary_expression
    (83) expression -> . relational_expression
    (84) expression -> . logical_expression
    (85) expression -> . bitwise_expression
    (86) expression -> . PLUS expression
    (87) expression -> . MINUS expression
    (88) expression -> . LNOT expression
    (89) expression -> . LBRACKET RBRACKET primitive_type LBRACE expression_list RBRACE
    (90) expression -> . LBRACKET RBRACKET primitive_type LBRACE RBRACE
    (91) expression -> . LPAREN expression RPAREN
    (92) expression -> . INT
    (93) expression -> . FLOAT64
    (94) expression -> . TRUE
    (95) expression -> . FALSE
    (96) expression -> . IDENTIFIER
    (97) expression -> . STRING
    (98) expression -> . IDENTIFIER PLUSPLUS
    (99) expression -> . IDENTIFIER MINUSMINUS
    (100) expression -> . expression DOT IDENTIFIER
    (103) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (133) expression -> . IDENTIFIER LBRACE keyed_element_list RBRACE
    (134) expression -> . IDENTIFIER LBRACE RBRACE
    (135) binary_expression -> . expression PLUS expression
    (136) binary_expression -> . expression MINUS expression
    (137) binary_expression -> . expression TIMES expression
    (138) binary_expression -> . expression DIVIDE expression
    (139) binary_expression -> . expression MODULE expression
    (144) relational_expression -> . expression EQ expression
    (145) relational_expression -> . expression NEQ expression
    (146) relational_expression -> . expression LT expression
    (147) relational_expression -> . expression LE expression
    (148) relational_expression -> . expression GT expression
    (149) relational_expression -> . expression GE expression
    (150) logical_expression -> . expression LAND expression
    (151) logical_expression -> . expression LOR expression
    (152) bitwise_expression -> . expression AND expression
    (153) bitwise_expression -> . expression OR expression
    (154) bitwise_expression -> . expression XOR expression
    (155) bitwise_expression -> . expression AND_NOT expression
    (156) bitwise_expression -> . expression LSHIFT expression
    (157) bitwise_expression -> . expression RSHIFT expression

    PLUS            shift and go to state 37
    MINUS           shift and go to state 38
    LNOT            shift and go to state 39
    LBRACKET        shift and go to state 40
    LPAREN          shift and go to state 29
    INT             shift and go to state 41
    FLOAT64         shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44
    IDENTIFIER      shift and go to state 97
    STRING          shift and go to state 11
>>>>>>> Stashed changes

    expression                     shift and go to state 240
    binary_expression              shift and go to state 33
    relational_expression          shift and go to state 34
    logical_expression             shift and go to state 35
    bitwise_expression             shift and go to state 36

state 193

<<<<<<< Updated upstream
    (82) local_statement -> assignment_compound .

    RBRACE          reduce using rule 82 (local_statement -> assignment_compound .)
    BREAK           reduce using rule 82 (local_statement -> assignment_compound .)
    CONTINUE        reduce using rule 82 (local_statement -> assignment_compound .)
    VAR             reduce using rule 82 (local_statement -> assignment_compound .)
    CONST           reduce using rule 82 (local_statement -> assignment_compound .)
    IDENTIFIER      reduce using rule 82 (local_statement -> assignment_compound .)
    LPAREN          reduce using rule 82 (local_statement -> assignment_compound .)
    INT             reduce using rule 82 (local_statement -> assignment_compound .)
    FLOAT64         reduce using rule 82 (local_statement -> assignment_compound .)
    STRING          reduce using rule 82 (local_statement -> assignment_compound .)
    TRUE            reduce using rule 82 (local_statement -> assignment_compound .)
    FALSE           reduce using rule 82 (local_statement -> assignment_compound .)
    LNOT            reduce using rule 82 (local_statement -> assignment_compound .)
    IF              reduce using rule 82 (local_statement -> assignment_compound .)
    SWITCH          reduce using rule 82 (local_statement -> assignment_compound .)
    RETURN          reduce using rule 82 (local_statement -> assignment_compound .)
    LBRACKET        reduce using rule 82 (local_statement -> assignment_compound .)
    MAP             reduce using rule 82 (local_statement -> assignment_compound .)
    FOR             reduce using rule 82 (local_statement -> assignment_compound .)
    CASE            reduce using rule 82 (local_statement -> assignment_compound .)
    DEFAULT         reduce using rule 82 (local_statement -> assignment_compound .)
=======
    (37) for_clause -> SEMICOLON expression . SEMICOLON assignment
    (38) for_clause -> SEMICOLON expression . SEMICOLON
    (100) expression -> expression . DOT IDENTIFIER
    (135) binary_expression -> expression . PLUS expression
    (136) binary_expression -> expression . MINUS expression
    (137) binary_expression -> expression . TIMES expression
    (138) binary_expression -> expression . DIVIDE expression
    (139) binary_expression -> expression . MODULE expression
    (144) relational_expression -> expression . EQ expression
    (145) relational_expression -> expression . NEQ expression
    (146) relational_expression -> expression . LT expression
    (147) relational_expression -> expression . LE expression
    (148) relational_expression -> expression . GT expression
    (149) relational_expression -> expression . GE expression
    (150) logical_expression -> expression . LAND expression
    (151) logical_expression -> expression . LOR expression
    (152) bitwise_expression -> expression . AND expression
    (153) bitwise_expression -> expression . OR expression
    (154) bitwise_expression -> expression . XOR expression
    (155) bitwise_expression -> expression . AND_NOT expression
    (156) bitwise_expression -> expression . LSHIFT expression
    (157) bitwise_expression -> expression . RSHIFT expression

    SEMICOLON       shift and go to state 241
    DOT             shift and go to state 58
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    TIMES           shift and go to state 61
    DIVIDE          shift and go to state 62
    MODULE          shift and go to state 63
    EQ              shift and go to state 64
    NEQ             shift and go to state 65
    LT              shift and go to state 66
    LE              shift and go to state 67
    GT              shift and go to state 68
    GE              shift and go to state 69
    LAND            shift and go to state 70
    LOR             shift and go to state 71
    AND             shift and go to state 72
    OR              shift and go to state 73
    XOR             shift and go to state 74
    AND_NOT         shift and go to state 75
    LSHIFT          shift and go to state 76
    RSHIFT          shift and go to state 77
>>>>>>> Stashed changes


state 194

<<<<<<< Updated upstream
    (83) local_statement -> expression .
    (36) expression -> expression . binary_operator expression
    (200) expression -> expression . DOT IDENTIFIER
    (201) expression -> expression . DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> expression . LBRACKET expression RBRACKET
    (37) binary_operator -> . PLUS
    (38) binary_operator -> . MINUS
    (39) binary_operator -> . TIMES
    (40) binary_operator -> . DIVIDE
    (41) binary_operator -> . MODULE
    (42) binary_operator -> . EQ
    (43) binary_operator -> . NEQ
    (44) binary_operator -> . LT
    (45) binary_operator -> . LE
    (46) binary_operator -> . GT
    (47) binary_operator -> . GE
    (48) binary_operator -> . LAND
    (49) binary_operator -> . LOR
    (50) binary_operator -> . AND
    (51) binary_operator -> . OR
    (52) binary_operator -> . XOR
    (53) binary_operator -> . AND_NOT
    (54) binary_operator -> . LSHIFT
    (55) binary_operator -> . RSHIFT

  ! shift/reduce conflict for LBRACKET resolved as shift
    RBRACE          reduce using rule 83 (local_statement -> expression .)
    BREAK           reduce using rule 83 (local_statement -> expression .)
    CONTINUE        reduce using rule 83 (local_statement -> expression .)
    VAR             reduce using rule 83 (local_statement -> expression .)
    CONST           reduce using rule 83 (local_statement -> expression .)
    IDENTIFIER      reduce using rule 83 (local_statement -> expression .)
    LPAREN          reduce using rule 83 (local_statement -> expression .)
    INT             reduce using rule 83 (local_statement -> expression .)
    FLOAT64         reduce using rule 83 (local_statement -> expression .)
    STRING          reduce using rule 83 (local_statement -> expression .)
    TRUE            reduce using rule 83 (local_statement -> expression .)
    FALSE           reduce using rule 83 (local_statement -> expression .)
    LNOT            reduce using rule 83 (local_statement -> expression .)
    IF              reduce using rule 83 (local_statement -> expression .)
    SWITCH          reduce using rule 83 (local_statement -> expression .)
    RETURN          reduce using rule 83 (local_statement -> expression .)
    MAP             reduce using rule 83 (local_statement -> expression .)
    FOR             reduce using rule 83 (local_statement -> expression .)
    CASE            reduce using rule 83 (local_statement -> expression .)
    DEFAULT         reduce using rule 83 (local_statement -> expression .)
    DOT             shift and go to state 82
    LBRACKET        shift and go to state 83
    PLUS            shift and go to state 84
    MINUS           shift and go to state 85
    TIMES           shift and go to state 86
    DIVIDE          shift and go to state 87
    MODULE          shift and go to state 88
    EQ              shift and go to state 89
    NEQ             shift and go to state 90
    LT              shift and go to state 91
    LE              shift and go to state 92
    GT              shift and go to state 93
    GE              shift and go to state 94
    LAND            shift and go to state 95
    LOR             shift and go to state 96
    AND             shift and go to state 97
    OR              shift and go to state 98
    XOR             shift and go to state 99
    AND_NOT         shift and go to state 100
    LSHIFT          shift and go to state 101
    RSHIFT          shift and go to state 102
=======
    (106) if_statement -> IF expression block .
    (107) if_statement -> IF expression block . ELSE block
    (108) if_statement -> IF expression block . ELSE if_statement

    SEMICOLON       reduce using rule 106 (if_statement -> IF expression block .)
    FUNC            reduce using rule 106 (if_statement -> IF expression block .)
    TYPE            reduce using rule 106 (if_statement -> IF expression block .)
    IDENTIFIER      reduce using rule 106 (if_statement -> IF expression block .)
    VAR             reduce using rule 106 (if_statement -> IF expression block .)
    CONST           reduce using rule 106 (if_statement -> IF expression block .)
    PLUS            reduce using rule 106 (if_statement -> IF expression block .)
    MINUS           reduce using rule 106 (if_statement -> IF expression block .)
    LNOT            reduce using rule 106 (if_statement -> IF expression block .)
    LBRACKET        reduce using rule 106 (if_statement -> IF expression block .)
    LPAREN          reduce using rule 106 (if_statement -> IF expression block .)
    INT             reduce using rule 106 (if_statement -> IF expression block .)
    FLOAT64         reduce using rule 106 (if_statement -> IF expression block .)
    TRUE            reduce using rule 106 (if_statement -> IF expression block .)
    FALSE           reduce using rule 106 (if_statement -> IF expression block .)
    STRING          reduce using rule 106 (if_statement -> IF expression block .)
    RETURN          reduce using rule 106 (if_statement -> IF expression block .)
    FOR             reduce using rule 106 (if_statement -> IF expression block .)
    IF              reduce using rule 106 (if_statement -> IF expression block .)
    SWITCH          reduce using rule 106 (if_statement -> IF expression block .)
    BREAK           reduce using rule 106 (if_statement -> IF expression block .)
    CONTINUE        reduce using rule 106 (if_statement -> IF expression block .)
    FALLTHROUGH     reduce using rule 106 (if_statement -> IF expression block .)
    $end            reduce using rule 106 (if_statement -> IF expression block .)
    RBRACE          reduce using rule 106 (if_statement -> IF expression block .)
    CASE            reduce using rule 106 (if_statement -> IF expression block .)
    DEFAULT         reduce using rule 106 (if_statement -> IF expression block .)
    ELSE            shift and go to state 242
>>>>>>> Stashed changes

  ! LBRACKET        [ reduce using rule 83 (local_statement -> expression .) ]

    binary_operator                shift and go to state 81

state 195

<<<<<<< Updated upstream
    (84) local_statement -> for_statement .

    RBRACE          reduce using rule 84 (local_statement -> for_statement .)
    BREAK           reduce using rule 84 (local_statement -> for_statement .)
    CONTINUE        reduce using rule 84 (local_statement -> for_statement .)
    VAR             reduce using rule 84 (local_statement -> for_statement .)
    CONST           reduce using rule 84 (local_statement -> for_statement .)
    IDENTIFIER      reduce using rule 84 (local_statement -> for_statement .)
    LPAREN          reduce using rule 84 (local_statement -> for_statement .)
    INT             reduce using rule 84 (local_statement -> for_statement .)
    FLOAT64         reduce using rule 84 (local_statement -> for_statement .)
    STRING          reduce using rule 84 (local_statement -> for_statement .)
    TRUE            reduce using rule 84 (local_statement -> for_statement .)
    FALSE           reduce using rule 84 (local_statement -> for_statement .)
    LNOT            reduce using rule 84 (local_statement -> for_statement .)
    IF              reduce using rule 84 (local_statement -> for_statement .)
    SWITCH          reduce using rule 84 (local_statement -> for_statement .)
    RETURN          reduce using rule 84 (local_statement -> for_statement .)
    LBRACKET        reduce using rule 84 (local_statement -> for_statement .)
    MAP             reduce using rule 84 (local_statement -> for_statement .)
    FOR             reduce using rule 84 (local_statement -> for_statement .)
    CASE            reduce using rule 84 (local_statement -> for_statement .)
    DEFAULT         reduce using rule 84 (local_statement -> for_statement .)
=======
    (109) if_statement -> IF assignment SEMICOLON . expression block
    (110) if_statement -> IF assignment SEMICOLON . expression block ELSE block
    (111) if_statement -> IF assignment SEMICOLON . expression block ELSE if_statement
    (82) expression -> . binary_expression
    (83) expression -> . relational_expression
    (84) expression -> . logical_expression
    (85) expression -> . bitwise_expression
    (86) expression -> . PLUS expression
    (87) expression -> . MINUS expression
    (88) expression -> . LNOT expression
    (89) expression -> . LBRACKET RBRACKET primitive_type LBRACE expression_list RBRACE
    (90) expression -> . LBRACKET RBRACKET primitive_type LBRACE RBRACE
    (91) expression -> . LPAREN expression RPAREN
    (92) expression -> . INT
    (93) expression -> . FLOAT64
    (94) expression -> . TRUE
    (95) expression -> . FALSE
    (96) expression -> . IDENTIFIER
    (97) expression -> . STRING
    (98) expression -> . IDENTIFIER PLUSPLUS
    (99) expression -> . IDENTIFIER MINUSMINUS
    (100) expression -> . expression DOT IDENTIFIER
    (103) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (133) expression -> . IDENTIFIER LBRACE keyed_element_list RBRACE
    (134) expression -> . IDENTIFIER LBRACE RBRACE
    (135) binary_expression -> . expression PLUS expression
    (136) binary_expression -> . expression MINUS expression
    (137) binary_expression -> . expression TIMES expression
    (138) binary_expression -> . expression DIVIDE expression
    (139) binary_expression -> . expression MODULE expression
    (144) relational_expression -> . expression EQ expression
    (145) relational_expression -> . expression NEQ expression
    (146) relational_expression -> . expression LT expression
    (147) relational_expression -> . expression LE expression
    (148) relational_expression -> . expression GT expression
    (149) relational_expression -> . expression GE expression
    (150) logical_expression -> . expression LAND expression
    (151) logical_expression -> . expression LOR expression
    (152) bitwise_expression -> . expression AND expression
    (153) bitwise_expression -> . expression OR expression
    (154) bitwise_expression -> . expression XOR expression
    (155) bitwise_expression -> . expression AND_NOT expression
    (156) bitwise_expression -> . expression LSHIFT expression
    (157) bitwise_expression -> . expression RSHIFT expression

    PLUS            shift and go to state 37
    MINUS           shift and go to state 38
    LNOT            shift and go to state 39
    LBRACKET        shift and go to state 40
    LPAREN          shift and go to state 29
    INT             shift and go to state 41
    FLOAT64         shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44
    IDENTIFIER      shift and go to state 97
    STRING          shift and go to state 11
>>>>>>> Stashed changes

    expression                     shift and go to state 243
    binary_expression              shift and go to state 33
    relational_expression          shift and go to state 34
    logical_expression             shift and go to state 35
    bitwise_expression             shift and go to state 36

state 196

<<<<<<< Updated upstream
    (85) local_statement -> if_statement .

    RBRACE          reduce using rule 85 (local_statement -> if_statement .)
    BREAK           reduce using rule 85 (local_statement -> if_statement .)
    CONTINUE        reduce using rule 85 (local_statement -> if_statement .)
    VAR             reduce using rule 85 (local_statement -> if_statement .)
    CONST           reduce using rule 85 (local_statement -> if_statement .)
    IDENTIFIER      reduce using rule 85 (local_statement -> if_statement .)
    LPAREN          reduce using rule 85 (local_statement -> if_statement .)
    INT             reduce using rule 85 (local_statement -> if_statement .)
    FLOAT64         reduce using rule 85 (local_statement -> if_statement .)
    STRING          reduce using rule 85 (local_statement -> if_statement .)
    TRUE            reduce using rule 85 (local_statement -> if_statement .)
    FALSE           reduce using rule 85 (local_statement -> if_statement .)
    LNOT            reduce using rule 85 (local_statement -> if_statement .)
    IF              reduce using rule 85 (local_statement -> if_statement .)
    SWITCH          reduce using rule 85 (local_statement -> if_statement .)
    RETURN          reduce using rule 85 (local_statement -> if_statement .)
    LBRACKET        reduce using rule 85 (local_statement -> if_statement .)
    MAP             reduce using rule 85 (local_statement -> if_statement .)
    FOR             reduce using rule 85 (local_statement -> if_statement .)
    CASE            reduce using rule 85 (local_statement -> if_statement .)
    DEFAULT         reduce using rule 85 (local_statement -> if_statement .)
=======
    (189) switch_statement -> SWITCH enter_block switch_header . LBRACE case_clauses RBRACE exit_block

    LBRACE          shift and go to state 244
>>>>>>> Stashed changes


state 197

<<<<<<< Updated upstream
    (86) local_statement -> switch_statement .

    RBRACE          reduce using rule 86 (local_statement -> switch_statement .)
    BREAK           reduce using rule 86 (local_statement -> switch_statement .)
    CONTINUE        reduce using rule 86 (local_statement -> switch_statement .)
    VAR             reduce using rule 86 (local_statement -> switch_statement .)
    CONST           reduce using rule 86 (local_statement -> switch_statement .)
    IDENTIFIER      reduce using rule 86 (local_statement -> switch_statement .)
    LPAREN          reduce using rule 86 (local_statement -> switch_statement .)
    INT             reduce using rule 86 (local_statement -> switch_statement .)
    FLOAT64         reduce using rule 86 (local_statement -> switch_statement .)
    STRING          reduce using rule 86 (local_statement -> switch_statement .)
    TRUE            reduce using rule 86 (local_statement -> switch_statement .)
    FALSE           reduce using rule 86 (local_statement -> switch_statement .)
    LNOT            reduce using rule 86 (local_statement -> switch_statement .)
    IF              reduce using rule 86 (local_statement -> switch_statement .)
    SWITCH          reduce using rule 86 (local_statement -> switch_statement .)
    RETURN          reduce using rule 86 (local_statement -> switch_statement .)
    LBRACKET        reduce using rule 86 (local_statement -> switch_statement .)
    MAP             reduce using rule 86 (local_statement -> switch_statement .)
    FOR             reduce using rule 86 (local_statement -> switch_statement .)
    CASE            reduce using rule 86 (local_statement -> switch_statement .)
    DEFAULT         reduce using rule 86 (local_statement -> switch_statement .)
=======
    (187) switch_header -> switch_expression .

    LBRACE          reduce using rule 187 (switch_header -> switch_expression .)
>>>>>>> Stashed changes


state 198

<<<<<<< Updated upstream
    (87) local_statement -> return_statement .

    RBRACE          reduce using rule 87 (local_statement -> return_statement .)
    BREAK           reduce using rule 87 (local_statement -> return_statement .)
    CONTINUE        reduce using rule 87 (local_statement -> return_statement .)
    VAR             reduce using rule 87 (local_statement -> return_statement .)
    CONST           reduce using rule 87 (local_statement -> return_statement .)
    IDENTIFIER      reduce using rule 87 (local_statement -> return_statement .)
    LPAREN          reduce using rule 87 (local_statement -> return_statement .)
    INT             reduce using rule 87 (local_statement -> return_statement .)
    FLOAT64         reduce using rule 87 (local_statement -> return_statement .)
    STRING          reduce using rule 87 (local_statement -> return_statement .)
    TRUE            reduce using rule 87 (local_statement -> return_statement .)
    FALSE           reduce using rule 87 (local_statement -> return_statement .)
    LNOT            reduce using rule 87 (local_statement -> return_statement .)
    IF              reduce using rule 87 (local_statement -> return_statement .)
    SWITCH          reduce using rule 87 (local_statement -> return_statement .)
    RETURN          reduce using rule 87 (local_statement -> return_statement .)
    LBRACKET        reduce using rule 87 (local_statement -> return_statement .)
    MAP             reduce using rule 87 (local_statement -> return_statement .)
    FOR             reduce using rule 87 (local_statement -> return_statement .)
    CASE            reduce using rule 87 (local_statement -> return_statement .)
    DEFAULT         reduce using rule 87 (local_statement -> return_statement .)
=======
    (188) switch_header -> switch_init .

    LBRACE          reduce using rule 188 (switch_header -> switch_init .)
>>>>>>> Stashed changes


state 199

<<<<<<< Updated upstream
    (88) local_statement -> BREAK .

    RBRACE          reduce using rule 88 (local_statement -> BREAK .)
    BREAK           reduce using rule 88 (local_statement -> BREAK .)
    CONTINUE        reduce using rule 88 (local_statement -> BREAK .)
    VAR             reduce using rule 88 (local_statement -> BREAK .)
    CONST           reduce using rule 88 (local_statement -> BREAK .)
    IDENTIFIER      reduce using rule 88 (local_statement -> BREAK .)
    LPAREN          reduce using rule 88 (local_statement -> BREAK .)
    INT             reduce using rule 88 (local_statement -> BREAK .)
    FLOAT64         reduce using rule 88 (local_statement -> BREAK .)
    STRING          reduce using rule 88 (local_statement -> BREAK .)
    TRUE            reduce using rule 88 (local_statement -> BREAK .)
    FALSE           reduce using rule 88 (local_statement -> BREAK .)
    LNOT            reduce using rule 88 (local_statement -> BREAK .)
    IF              reduce using rule 88 (local_statement -> BREAK .)
    SWITCH          reduce using rule 88 (local_statement -> BREAK .)
    RETURN          reduce using rule 88 (local_statement -> BREAK .)
    LBRACKET        reduce using rule 88 (local_statement -> BREAK .)
    MAP             reduce using rule 88 (local_statement -> BREAK .)
    FOR             reduce using rule 88 (local_statement -> BREAK .)
    CASE            reduce using rule 88 (local_statement -> BREAK .)
    DEFAULT         reduce using rule 88 (local_statement -> BREAK .)
=======
    (185) switch_expression -> switch_primary .

    LBRACE          reduce using rule 185 (switch_expression -> switch_primary .)
>>>>>>> Stashed changes


state 200

<<<<<<< Updated upstream
    (89) local_statement -> CONTINUE .

    RBRACE          reduce using rule 89 (local_statement -> CONTINUE .)
    BREAK           reduce using rule 89 (local_statement -> CONTINUE .)
    CONTINUE        reduce using rule 89 (local_statement -> CONTINUE .)
    VAR             reduce using rule 89 (local_statement -> CONTINUE .)
    CONST           reduce using rule 89 (local_statement -> CONTINUE .)
    IDENTIFIER      reduce using rule 89 (local_statement -> CONTINUE .)
    LPAREN          reduce using rule 89 (local_statement -> CONTINUE .)
    INT             reduce using rule 89 (local_statement -> CONTINUE .)
    FLOAT64         reduce using rule 89 (local_statement -> CONTINUE .)
    STRING          reduce using rule 89 (local_statement -> CONTINUE .)
    TRUE            reduce using rule 89 (local_statement -> CONTINUE .)
    FALSE           reduce using rule 89 (local_statement -> CONTINUE .)
    LNOT            reduce using rule 89 (local_statement -> CONTINUE .)
    IF              reduce using rule 89 (local_statement -> CONTINUE .)
    SWITCH          reduce using rule 89 (local_statement -> CONTINUE .)
    RETURN          reduce using rule 89 (local_statement -> CONTINUE .)
    LBRACKET        reduce using rule 89 (local_statement -> CONTINUE .)
    MAP             reduce using rule 89 (local_statement -> CONTINUE .)
    FOR             reduce using rule 89 (local_statement -> CONTINUE .)
    CASE            reduce using rule 89 (local_statement -> CONTINUE .)
    DEFAULT         reduce using rule 89 (local_statement -> CONTINUE .)
=======
    (186) switch_expression -> empty .

    LBRACE          reduce using rule 186 (switch_expression -> empty .)
>>>>>>> Stashed changes


state 201

<<<<<<< Updated upstream
    (20) local_var_dec -> VAR . IDENTIFIER type
    (21) local_var_dec -> VAR . IDENTIFIER type ASSIGN expression
    (22) local_var_dec -> VAR . IDENTIFIER ASSIGN expression

    IDENTIFIER      shift and go to state 216
=======
    (184) switch_init -> assignment . SEMICOLON switch_expression

    SEMICOLON       shift and go to state 245
>>>>>>> Stashed changes


state 202

<<<<<<< Updated upstream
    (77) short_assignment -> IDENTIFIER . SHORT_ASSIGN expression
    (56) simple_assignment -> IDENTIFIER . ASSIGN expression
    (25) assignment_compound -> IDENTIFIER . operator_assign expression
    (73) expression -> IDENTIFIER .
    (126) expression -> IDENTIFIER . PLUSPLUS
    (127) expression -> IDENTIFIER . MINUSMINUS
    (203) expression -> IDENTIFIER . LPAREN argument_list RPAREN
    (163) type_name -> IDENTIFIER .
    (26) operator_assign -> . PLUS_ASSIGN
    (27) operator_assign -> . MINUS_ASSIGN
    (28) operator_assign -> . MULT_ASSIGN
    (29) operator_assign -> . DIV_ASSIGN
    (30) operator_assign -> . MOD_ASSIGN
    (31) operator_assign -> . AND_ASSIGN
    (32) operator_assign -> . OR_ASSIGN
    (33) operator_assign -> . XOR_ASSIGN
    (34) operator_assign -> . LSHIFT_ASSIGN
    (35) operator_assign -> . RSHIFT_ASSIGN

  ! shift/reduce conflict for LPAREN resolved as shift
    SHORT_ASSIGN    shift and go to state 217
    ASSIGN          shift and go to state 218
    DOT             reduce using rule 73 (expression -> IDENTIFIER .)
    LBRACKET        reduce using rule 73 (expression -> IDENTIFIER .)
    PLUS            reduce using rule 73 (expression -> IDENTIFIER .)
    MINUS           reduce using rule 73 (expression -> IDENTIFIER .)
    TIMES           reduce using rule 73 (expression -> IDENTIFIER .)
    DIVIDE          reduce using rule 73 (expression -> IDENTIFIER .)
    MODULE          reduce using rule 73 (expression -> IDENTIFIER .)
    EQ              reduce using rule 73 (expression -> IDENTIFIER .)
    NEQ             reduce using rule 73 (expression -> IDENTIFIER .)
    LT              reduce using rule 73 (expression -> IDENTIFIER .)
    LE              reduce using rule 73 (expression -> IDENTIFIER .)
    GT              reduce using rule 73 (expression -> IDENTIFIER .)
    GE              reduce using rule 73 (expression -> IDENTIFIER .)
    LAND            reduce using rule 73 (expression -> IDENTIFIER .)
    LOR             reduce using rule 73 (expression -> IDENTIFIER .)
    AND             reduce using rule 73 (expression -> IDENTIFIER .)
    OR              reduce using rule 73 (expression -> IDENTIFIER .)
    XOR             reduce using rule 73 (expression -> IDENTIFIER .)
    AND_NOT         reduce using rule 73 (expression -> IDENTIFIER .)
    LSHIFT          reduce using rule 73 (expression -> IDENTIFIER .)
    RSHIFT          reduce using rule 73 (expression -> IDENTIFIER .)
    RBRACE          reduce using rule 73 (expression -> IDENTIFIER .)
    BREAK           reduce using rule 73 (expression -> IDENTIFIER .)
    CONTINUE        reduce using rule 73 (expression -> IDENTIFIER .)
    VAR             reduce using rule 73 (expression -> IDENTIFIER .)
    CONST           reduce using rule 73 (expression -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 73 (expression -> IDENTIFIER .)
    INT             reduce using rule 73 (expression -> IDENTIFIER .)
    FLOAT64         reduce using rule 73 (expression -> IDENTIFIER .)
    STRING          reduce using rule 73 (expression -> IDENTIFIER .)
    TRUE            reduce using rule 73 (expression -> IDENTIFIER .)
    FALSE           reduce using rule 73 (expression -> IDENTIFIER .)
    LNOT            reduce using rule 73 (expression -> IDENTIFIER .)
    IF              reduce using rule 73 (expression -> IDENTIFIER .)
    SWITCH          reduce using rule 73 (expression -> IDENTIFIER .)
    RETURN          reduce using rule 73 (expression -> IDENTIFIER .)
    MAP             reduce using rule 73 (expression -> IDENTIFIER .)
    FOR             reduce using rule 73 (expression -> IDENTIFIER .)
    CASE            reduce using rule 73 (expression -> IDENTIFIER .)
    DEFAULT         reduce using rule 73 (expression -> IDENTIFIER .)
    PLUSPLUS        shift and go to state 78
    MINUSMINUS      shift and go to state 79
    LPAREN          shift and go to state 80
    LBRACE          reduce using rule 163 (type_name -> IDENTIFIER .)
    PLUS_ASSIGN     shift and go to state 220
    MINUS_ASSIGN    shift and go to state 221
    MULT_ASSIGN     shift and go to state 222
    DIV_ASSIGN      shift and go to state 223
    MOD_ASSIGN      shift and go to state 224
    AND_ASSIGN      shift and go to state 225
    OR_ASSIGN       shift and go to state 226
    XOR_ASSIGN      shift and go to state 227
    LSHIFT_ASSIGN   shift and go to state 228
    RSHIFT_ASSIGN   shift and go to state 229
=======
    (178) switch_primary -> IDENTIFIER .
    (54) assignment -> IDENTIFIER . ASSIGN expression
    (55) assignment -> IDENTIFIER . SHORT_ASSIGN expression

    LBRACE          reduce using rule 178 (switch_primary -> IDENTIFIER .)
    ASSIGN          shift and go to state 80
    SHORT_ASSIGN    shift and go to state 81
>>>>>>> Stashed changes

  ! LPAREN          [ reduce using rule 73 (expression -> IDENTIFIER .) ]

    operator_assign                shift and go to state 219

state 203

<<<<<<< Updated upstream
    (23) local_const_dec -> CONST . IDENTIFIER type ASSIGN expression
    (24) local_const_dec -> CONST . IDENTIFIER ASSIGN expression

    IDENTIFIER      shift and go to state 230
=======
    (179) switch_primary -> INT .

    LBRACE          reduce using rule 179 (switch_primary -> INT .)
>>>>>>> Stashed changes


state 204

<<<<<<< Updated upstream
    (94) for_statement -> for_classic .

    RBRACE          reduce using rule 94 (for_statement -> for_classic .)
    BREAK           reduce using rule 94 (for_statement -> for_classic .)
    CONTINUE        reduce using rule 94 (for_statement -> for_classic .)
    VAR             reduce using rule 94 (for_statement -> for_classic .)
    CONST           reduce using rule 94 (for_statement -> for_classic .)
    IDENTIFIER      reduce using rule 94 (for_statement -> for_classic .)
    LPAREN          reduce using rule 94 (for_statement -> for_classic .)
    INT             reduce using rule 94 (for_statement -> for_classic .)
    FLOAT64         reduce using rule 94 (for_statement -> for_classic .)
    STRING          reduce using rule 94 (for_statement -> for_classic .)
    TRUE            reduce using rule 94 (for_statement -> for_classic .)
    FALSE           reduce using rule 94 (for_statement -> for_classic .)
    LNOT            reduce using rule 94 (for_statement -> for_classic .)
    IF              reduce using rule 94 (for_statement -> for_classic .)
    SWITCH          reduce using rule 94 (for_statement -> for_classic .)
    RETURN          reduce using rule 94 (for_statement -> for_classic .)
    LBRACKET        reduce using rule 94 (for_statement -> for_classic .)
    MAP             reduce using rule 94 (for_statement -> for_classic .)
    FOR             reduce using rule 94 (for_statement -> for_classic .)
    CASE            reduce using rule 94 (for_statement -> for_classic .)
    DEFAULT         reduce using rule 94 (for_statement -> for_classic .)
=======
    (180) switch_primary -> FLOAT64 .

    LBRACE          reduce using rule 180 (switch_primary -> FLOAT64 .)
>>>>>>> Stashed changes


state 205

<<<<<<< Updated upstream
    (95) for_statement -> for_condition .

    RBRACE          reduce using rule 95 (for_statement -> for_condition .)
    BREAK           reduce using rule 95 (for_statement -> for_condition .)
    CONTINUE        reduce using rule 95 (for_statement -> for_condition .)
    VAR             reduce using rule 95 (for_statement -> for_condition .)
    CONST           reduce using rule 95 (for_statement -> for_condition .)
    IDENTIFIER      reduce using rule 95 (for_statement -> for_condition .)
    LPAREN          reduce using rule 95 (for_statement -> for_condition .)
    INT             reduce using rule 95 (for_statement -> for_condition .)
    FLOAT64         reduce using rule 95 (for_statement -> for_condition .)
    STRING          reduce using rule 95 (for_statement -> for_condition .)
    TRUE            reduce using rule 95 (for_statement -> for_condition .)
    FALSE           reduce using rule 95 (for_statement -> for_condition .)
    LNOT            reduce using rule 95 (for_statement -> for_condition .)
    IF              reduce using rule 95 (for_statement -> for_condition .)
    SWITCH          reduce using rule 95 (for_statement -> for_condition .)
    RETURN          reduce using rule 95 (for_statement -> for_condition .)
    LBRACKET        reduce using rule 95 (for_statement -> for_condition .)
    MAP             reduce using rule 95 (for_statement -> for_condition .)
    FOR             reduce using rule 95 (for_statement -> for_condition .)
    CASE            reduce using rule 95 (for_statement -> for_condition .)
    DEFAULT         reduce using rule 95 (for_statement -> for_condition .)
=======
    (181) switch_primary -> STRING .

    LBRACE          reduce using rule 181 (switch_primary -> STRING .)
>>>>>>> Stashed changes


state 206

<<<<<<< Updated upstream
    (96) for_statement -> for_infinite .

    RBRACE          reduce using rule 96 (for_statement -> for_infinite .)
    BREAK           reduce using rule 96 (for_statement -> for_infinite .)
    CONTINUE        reduce using rule 96 (for_statement -> for_infinite .)
    VAR             reduce using rule 96 (for_statement -> for_infinite .)
    CONST           reduce using rule 96 (for_statement -> for_infinite .)
    IDENTIFIER      reduce using rule 96 (for_statement -> for_infinite .)
    LPAREN          reduce using rule 96 (for_statement -> for_infinite .)
    INT             reduce using rule 96 (for_statement -> for_infinite .)
    FLOAT64         reduce using rule 96 (for_statement -> for_infinite .)
    STRING          reduce using rule 96 (for_statement -> for_infinite .)
    TRUE            reduce using rule 96 (for_statement -> for_infinite .)
    FALSE           reduce using rule 96 (for_statement -> for_infinite .)
    LNOT            reduce using rule 96 (for_statement -> for_infinite .)
    IF              reduce using rule 96 (for_statement -> for_infinite .)
    SWITCH          reduce using rule 96 (for_statement -> for_infinite .)
    RETURN          reduce using rule 96 (for_statement -> for_infinite .)
    LBRACKET        reduce using rule 96 (for_statement -> for_infinite .)
    MAP             reduce using rule 96 (for_statement -> for_infinite .)
    FOR             reduce using rule 96 (for_statement -> for_infinite .)
    CASE            reduce using rule 96 (for_statement -> for_infinite .)
    DEFAULT         reduce using rule 96 (for_statement -> for_infinite .)
=======
    (182) switch_primary -> TRUE .

    LBRACE          reduce using rule 182 (switch_primary -> TRUE .)
>>>>>>> Stashed changes


state 207

<<<<<<< Updated upstream
    (128) if_statement -> IF . expression block
    (129) if_statement -> IF . expression block ELSE block
    (130) if_statement -> IF . expression block ELSE if_statement
    (131) if_statement -> IF . if_assignment SEMICOLON expression block
    (132) if_statement -> IF . if_assignment SEMICOLON expression block ELSE block
    (133) if_statement -> IF . if_assignment SEMICOLON expression block ELSE if_statement
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (125) expression -> . LNOT expression
    (126) expression -> . IDENTIFIER PLUSPLUS
    (127) expression -> . IDENTIFIER MINUSMINUS
    (138) expression -> . map_type LBRACE expression_map_list RBRACE
    (139) expression -> . map_type LBRACE RBRACE
    (161) expression -> . type_name LBRACE keyed_element_list RBRACE
    (162) expression -> . type_name LBRACE RBRACE
    (198) expression -> . array_type LBRACE expression_list RBRACE
    (199) expression -> . array_type LBRACE RBRACE
    (200) expression -> . expression DOT IDENTIFIER
    (201) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> . expression LBRACKET expression RBRACKET
    (203) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (134) if_assignment -> . simple_assignment
    (135) if_assignment -> . short_assignment
    (136) if_assignment -> . local_var_dec
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (137) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (163) type_name -> . IDENTIFIER
    (164) type_name -> . slice_type
    (165) type_name -> . array_type
    (166) type_name -> . map_type
    (197) array_type -> . LBRACKET INT RBRACKET primitive_type
    (56) simple_assignment -> . IDENTIFIER ASSIGN expression
    (77) short_assignment -> . IDENTIFIER SHORT_ASSIGN expression
    (20) local_var_dec -> . VAR IDENTIFIER type
    (21) local_var_dec -> . VAR IDENTIFIER type ASSIGN expression
    (22) local_var_dec -> . VAR IDENTIFIER ASSIGN expression

    LPAREN          shift and go to state 54
    INT             shift and go to state 55
    FLOAT64         shift and go to state 56
    IDENTIFIER      shift and go to state 233
    STRING          shift and go to state 57
    TRUE            shift and go to state 58
    FALSE           shift and go to state 59
    LNOT            shift and go to state 60
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39
    VAR             shift and go to state 201
=======
    (183) switch_primary -> FALSE .

    LBRACE          reduce using rule 183 (switch_primary -> FALSE .)
>>>>>>> Stashed changes

    expression                     shift and go to state 231
    if_assignment                  shift and go to state 232
    slice_type                     shift and go to state 53
    map_type                       shift and go to state 61
    type_name                      shift and go to state 62
    array_type                     shift and go to state 63
    simple_assignment              shift and go to state 234
    short_assignment               shift and go to state 235
    local_var_dec                  shift and go to state 236

state 208

<<<<<<< Updated upstream
    (167) switch_statement -> SWITCH . switch_expr LBRACE case_clause_list RBRACE
    (168) switch_statement -> SWITCH . switch_expr LBRACE RBRACE
    (169) switch_statement -> SWITCH . LBRACE case_clause_list RBRACE
    (170) switch_statement -> SWITCH . LBRACE RBRACE
    (171) switch_statement -> SWITCH . switch_assignment SEMICOLON switch_expr LBRACE case_clause_list RBRACE
    (172) switch_statement -> SWITCH . switch_assignment SEMICOLON switch_expr LBRACE RBRACE
    (173) switch_statement -> SWITCH . switch_assignment SEMICOLON LBRACE case_clause_list RBRACE
    (174) switch_statement -> SWITCH . switch_assignment SEMICOLON LBRACE RBRACE
    (175) switch_expr -> . primary_expression
    (188) switch_assignment -> . simple_assignment
    (189) switch_assignment -> . short_assignment
    (190) switch_assignment -> . local_var_dec
    (176) primary_expression -> . IDENTIFIER
    (177) primary_expression -> . INT
    (178) primary_expression -> . FLOAT64
    (179) primary_expression -> . STRING
    (180) primary_expression -> . TRUE
    (181) primary_expression -> . FALSE
    (182) primary_expression -> . LPAREN expression RPAREN
    (183) primary_expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (184) primary_expression -> . primary_expression DOT IDENTIFIER
    (185) primary_expression -> . primary_expression LBRACKET expression RBRACKET
    (56) simple_assignment -> . IDENTIFIER ASSIGN expression
    (77) short_assignment -> . IDENTIFIER SHORT_ASSIGN expression
    (20) local_var_dec -> . VAR IDENTIFIER type
    (21) local_var_dec -> . VAR IDENTIFIER type ASSIGN expression
    (22) local_var_dec -> . VAR IDENTIFIER ASSIGN expression

    LBRACE          shift and go to state 238
    IDENTIFIER      shift and go to state 244
    INT             shift and go to state 245
    FLOAT64         shift and go to state 246
    STRING          shift and go to state 247
    TRUE            shift and go to state 248
    FALSE           shift and go to state 249
    LPAREN          shift and go to state 250
    VAR             shift and go to state 201

    switch_expr                    shift and go to state 237
    switch_assignment              shift and go to state 239
    primary_expression             shift and go to state 240
    simple_assignment              shift and go to state 241
    short_assignment               shift and go to state 242
    local_var_dec                  shift and go to state 243

state 209

    (123) return_statement -> RETURN .
    (124) return_statement -> RETURN . return_list
    (110) return_list -> . expression
    (111) return_list -> . return_list COMMA expression
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (125) expression -> . LNOT expression
    (126) expression -> . IDENTIFIER PLUSPLUS
    (127) expression -> . IDENTIFIER MINUSMINUS
    (138) expression -> . map_type LBRACE expression_map_list RBRACE
    (139) expression -> . map_type LBRACE RBRACE
    (161) expression -> . type_name LBRACE keyed_element_list RBRACE
    (162) expression -> . type_name LBRACE RBRACE
    (198) expression -> . array_type LBRACE expression_list RBRACE
    (199) expression -> . array_type LBRACE RBRACE
    (200) expression -> . expression DOT IDENTIFIER
    (201) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> . expression LBRACKET expression RBRACKET
    (203) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (137) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (163) type_name -> . IDENTIFIER
    (164) type_name -> . slice_type
    (165) type_name -> . array_type
    (166) type_name -> . map_type
    (197) array_type -> . LBRACKET INT RBRACKET primitive_type

  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT64 resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for LNOT resolved as shift
  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for MAP resolved as shift
    RBRACE          reduce using rule 123 (return_statement -> RETURN .)
    BREAK           reduce using rule 123 (return_statement -> RETURN .)
    CONTINUE        reduce using rule 123 (return_statement -> RETURN .)
    VAR             reduce using rule 123 (return_statement -> RETURN .)
    CONST           reduce using rule 123 (return_statement -> RETURN .)
    IF              reduce using rule 123 (return_statement -> RETURN .)
    SWITCH          reduce using rule 123 (return_statement -> RETURN .)
    RETURN          reduce using rule 123 (return_statement -> RETURN .)
    FOR             reduce using rule 123 (return_statement -> RETURN .)
    CASE            reduce using rule 123 (return_statement -> RETURN .)
    DEFAULT         reduce using rule 123 (return_statement -> RETURN .)
    LPAREN          shift and go to state 54
    INT             shift and go to state 55
    FLOAT64         shift and go to state 56
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 57
    TRUE            shift and go to state 58
    FALSE           shift and go to state 59
    LNOT            shift and go to state 60
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

  ! IDENTIFIER      [ reduce using rule 123 (return_statement -> RETURN .) ]
  ! LPAREN          [ reduce using rule 123 (return_statement -> RETURN .) ]
  ! INT             [ reduce using rule 123 (return_statement -> RETURN .) ]
  ! FLOAT64         [ reduce using rule 123 (return_statement -> RETURN .) ]
  ! STRING          [ reduce using rule 123 (return_statement -> RETURN .) ]
  ! TRUE            [ reduce using rule 123 (return_statement -> RETURN .) ]
  ! FALSE           [ reduce using rule 123 (return_statement -> RETURN .) ]
  ! LNOT            [ reduce using rule 123 (return_statement -> RETURN .) ]
  ! LBRACKET        [ reduce using rule 123 (return_statement -> RETURN .) ]
  ! MAP             [ reduce using rule 123 (return_statement -> RETURN .) ]

    return_list                    shift and go to state 251
    expression                     shift and go to state 252
    slice_type                     shift and go to state 53
    map_type                       shift and go to state 61
    type_name                      shift and go to state 62
    array_type                     shift and go to state 63

state 210

    (97) for_classic -> FOR . for_init SEMICOLON for_cond SEMICOLON for_post block
    (98) for_condition -> FOR . expression block
    (99) for_infinite -> FOR . block
    (100) for_init -> . simple_assignment
    (101) for_init -> . short_assignment
    (102) for_init -> . local_var_dec
    (103) for_init -> . empty
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (125) expression -> . LNOT expression
    (126) expression -> . IDENTIFIER PLUSPLUS
    (127) expression -> . IDENTIFIER MINUSMINUS
    (138) expression -> . map_type LBRACE expression_map_list RBRACE
    (139) expression -> . map_type LBRACE RBRACE
    (161) expression -> . type_name LBRACE keyed_element_list RBRACE
    (162) expression -> . type_name LBRACE RBRACE
    (198) expression -> . array_type LBRACE expression_list RBRACE
    (199) expression -> . array_type LBRACE RBRACE
    (200) expression -> . expression DOT IDENTIFIER
    (201) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> . expression LBRACKET expression RBRACKET
    (203) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (90) block -> . LBRACE local_statement_list RBRACE
    (91) block -> . LBRACE RBRACE
    (56) simple_assignment -> . IDENTIFIER ASSIGN expression
    (77) short_assignment -> . IDENTIFIER SHORT_ASSIGN expression
    (20) local_var_dec -> . VAR IDENTIFIER type
    (21) local_var_dec -> . VAR IDENTIFIER type ASSIGN expression
    (22) local_var_dec -> . VAR IDENTIFIER ASSIGN expression
    (7) empty -> .
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (137) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (163) type_name -> . IDENTIFIER
    (164) type_name -> . slice_type
    (165) type_name -> . array_type
    (166) type_name -> . map_type
    (197) array_type -> . LBRACKET INT RBRACKET primitive_type

    LPAREN          shift and go to state 54
    INT             shift and go to state 55
    FLOAT64         shift and go to state 56
    IDENTIFIER      shift and go to state 260
    STRING          shift and go to state 57
    TRUE            shift and go to state 58
    FALSE           shift and go to state 59
    LNOT            shift and go to state 60
    LBRACE          shift and go to state 175
    VAR             shift and go to state 201
    SEMICOLON       reduce using rule 7 (empty -> .)
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    for_init                       shift and go to state 253
    block                          shift and go to state 254
    expression                     shift and go to state 255
    simple_assignment              shift and go to state 256
    short_assignment               shift and go to state 257
    local_var_dec                  shift and go to state 258
    empty                          shift and go to state 259
    slice_type                     shift and go to state 53
    map_type                       shift and go to state 61
    type_name                      shift and go to state 62
    array_type                     shift and go to state 63

state 211

    (146) method_declaration -> FUNC LPAREN receiver RPAREN IDENTIFIER LPAREN parameter_list RPAREN . return_type block
    (118) return_type -> . type
    (119) return_type -> . LPAREN type_list RPAREN
    (120) return_type -> . empty
    (57) type -> . primitive_type
    (58) type -> . slice_type
    (59) type -> . array_type
    (60) type -> . map_type
    (7) empty -> .
    (61) primitive_type -> . INT_TYPE
    (62) primitive_type -> . FLOAT64_TYPE
    (63) primitive_type -> . STRING_TYPE
    (64) primitive_type -> . BOOL_TYPE
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (197) array_type -> . LBRACKET INT RBRACKET primitive_type
    (137) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type

    LPAREN          shift and go to state 149
    LBRACE          reduce using rule 7 (empty -> .)
    INT_TYPE        shift and go to state 34
    FLOAT64_TYPE    shift and go to state 35
    STRING_TYPE     shift and go to state 36
    BOOL_TYPE       shift and go to state 37
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39
=======
    (47) parameter -> IDENTIFIER . type
    (48) parameter -> IDENTIFIER . ELLIPSIS primitive_type
    (70) type -> . primitive_type
    (71) type -> . slice_type
    (72) type -> . array_type
    (73) type -> . map_type
    (74) type -> . struct_type
    (75) type -> . IDENTIFIER
    (76) primitive_type -> . INT_TYPE
    (77) primitive_type -> . FLOAT64_TYPE
    (78) primitive_type -> . STRING_TYPE
    (79) primitive_type -> . BOOL_TYPE
    (80) slice_type -> . LBRACKET RBRACKET primitive_type
    (81) array_type -> . LBRACKET INT RBRACKET type
    (127) map_type -> . MAP LBRACKET primitive_type RBRACKET type
    (118) struct_type -> . STRUCT LBRACE RBRACE
    (119) struct_type -> . STRUCT LBRACE field_list RBRACE

    ELLIPSIS        shift and go to state 247
    IDENTIFIER      shift and go to state 177
    INT_TYPE        shift and go to state 171
    FLOAT64_TYPE    shift and go to state 172
    STRING_TYPE     shift and go to state 173
    BOOL_TYPE       shift and go to state 174
    LBRACKET        shift and go to state 175
    MAP             shift and go to state 176
    STRUCT          shift and go to state 170

    type                           shift and go to state 246
    primitive_type                 shift and go to state 180
    slice_type                     shift and go to state 181
    array_type                     shift and go to state 182
    map_type                       shift and go to state 183
    struct_type                    shift and go to state 184

state 209

    (43) function_declaration -> FUNC IDENTIFIER LPAREN parameter_list . RPAREN return_type block
    (44) parameter_list -> parameter_list . COMMA parameter

    RPAREN          shift and go to state 248
    COMMA           shift and go to state 249


state 210

    (45) parameter_list -> parameter .

    RPAREN          reduce using rule 45 (parameter_list -> parameter .)
    COMMA           reduce using rule 45 (parameter_list -> parameter .)


state 211

    (46) parameter_list -> empty .

    RPAREN          reduce using rule 46 (parameter_list -> empty .)
    COMMA           reduce using rule 46 (parameter_list -> empty .)
>>>>>>> Stashed changes

    return_type                    shift and go to state 261
    type                           shift and go to state 151
    empty                          shift and go to state 152
    primitive_type                 shift and go to state 30
    slice_type                     shift and go to state 31
    array_type                     shift and go to state 32
    map_type                       shift and go to state 33

state 212

<<<<<<< Updated upstream
    (201) expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .

    DOT             reduce using rule 201 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    LBRACKET        reduce using rule 201 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    PLUS            reduce using rule 201 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    MINUS           reduce using rule 201 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    TIMES           reduce using rule 201 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    DIVIDE          reduce using rule 201 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    MODULE          reduce using rule 201 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    EQ              reduce using rule 201 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    NEQ             reduce using rule 201 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    LT              reduce using rule 201 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    LE              reduce using rule 201 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    GT              reduce using rule 201 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    GE              reduce using rule 201 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    LAND            reduce using rule 201 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    LOR             reduce using rule 201 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    AND             reduce using rule 201 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    OR              reduce using rule 201 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    XOR             reduce using rule 201 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    AND_NOT         reduce using rule 201 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    LSHIFT          reduce using rule 201 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    RSHIFT          reduce using rule 201 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    VAR             reduce using rule 201 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    CONST           reduce using rule 201 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    FUNC            reduce using rule 201 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    TYPE            reduce using rule 201 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    $end            reduce using rule 201 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    RPAREN          reduce using rule 201 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    COMMA           reduce using rule 201 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    RBRACKET        reduce using rule 201 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    RBRACE          reduce using rule 201 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    COLON           reduce using rule 201 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    BREAK           reduce using rule 201 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    CONTINUE        reduce using rule 201 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    IDENTIFIER      reduce using rule 201 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    LPAREN          reduce using rule 201 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    INT             reduce using rule 201 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    FLOAT64         reduce using rule 201 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    STRING          reduce using rule 201 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    TRUE            reduce using rule 201 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    FALSE           reduce using rule 201 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    LNOT            reduce using rule 201 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    IF              reduce using rule 201 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    SWITCH          reduce using rule 201 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    RETURN          reduce using rule 201 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    MAP             reduce using rule 201 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    FOR             reduce using rule 201 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    LBRACE          reduce using rule 201 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    CASE            reduce using rule 201 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    DEFAULT         reduce using rule 201 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
    SEMICOLON       reduce using rule 201 (expression -> expression DOT IDENTIFIER LPAREN argument_list RPAREN .)
=======
    (124) method_declaration -> FUNC LPAREN receiver RPAREN . IDENTIFIER LPAREN parameter_list RPAREN return_type block

    IDENTIFIER      shift and go to state 250
>>>>>>> Stashed changes


state 213

<<<<<<< Updated upstream
    (122) type_list -> type_list COMMA type .

    RPAREN          reduce using rule 122 (type_list -> type_list COMMA type .)
    COMMA           reduce using rule 122 (type_list -> type_list COMMA type .)
=======
    (125) receiver -> IDENTIFIER type .

    RPAREN          reduce using rule 125 (receiver -> IDENTIFIER type .)
>>>>>>> Stashed changes


state 214

<<<<<<< Updated upstream
    (90) block -> LBRACE local_statement_list RBRACE .

    VAR             reduce using rule 90 (block -> LBRACE local_statement_list RBRACE .)
    CONST           reduce using rule 90 (block -> LBRACE local_statement_list RBRACE .)
    FUNC            reduce using rule 90 (block -> LBRACE local_statement_list RBRACE .)
    TYPE            reduce using rule 90 (block -> LBRACE local_statement_list RBRACE .)
    $end            reduce using rule 90 (block -> LBRACE local_statement_list RBRACE .)
    RBRACE          reduce using rule 90 (block -> LBRACE local_statement_list RBRACE .)
    BREAK           reduce using rule 90 (block -> LBRACE local_statement_list RBRACE .)
    CONTINUE        reduce using rule 90 (block -> LBRACE local_statement_list RBRACE .)
    IDENTIFIER      reduce using rule 90 (block -> LBRACE local_statement_list RBRACE .)
    LPAREN          reduce using rule 90 (block -> LBRACE local_statement_list RBRACE .)
    INT             reduce using rule 90 (block -> LBRACE local_statement_list RBRACE .)
    FLOAT64         reduce using rule 90 (block -> LBRACE local_statement_list RBRACE .)
    STRING          reduce using rule 90 (block -> LBRACE local_statement_list RBRACE .)
    TRUE            reduce using rule 90 (block -> LBRACE local_statement_list RBRACE .)
    FALSE           reduce using rule 90 (block -> LBRACE local_statement_list RBRACE .)
    LNOT            reduce using rule 90 (block -> LBRACE local_statement_list RBRACE .)
    IF              reduce using rule 90 (block -> LBRACE local_statement_list RBRACE .)
    SWITCH          reduce using rule 90 (block -> LBRACE local_statement_list RBRACE .)
    RETURN          reduce using rule 90 (block -> LBRACE local_statement_list RBRACE .)
    LBRACKET        reduce using rule 90 (block -> LBRACE local_statement_list RBRACE .)
    MAP             reduce using rule 90 (block -> LBRACE local_statement_list RBRACE .)
    FOR             reduce using rule 90 (block -> LBRACE local_statement_list RBRACE .)
    CASE            reduce using rule 90 (block -> LBRACE local_statement_list RBRACE .)
    DEFAULT         reduce using rule 90 (block -> LBRACE local_statement_list RBRACE .)
    ELSE            reduce using rule 90 (block -> LBRACE local_statement_list RBRACE .)
=======
    (126) receiver -> IDENTIFIER TIMES . IDENTIFIER

    IDENTIFIER      shift and go to state 251
>>>>>>> Stashed changes


state 215

<<<<<<< Updated upstream
    (93) local_statement_list -> local_statement_list local_statement .

    RBRACE          reduce using rule 93 (local_statement_list -> local_statement_list local_statement .)
    BREAK           reduce using rule 93 (local_statement_list -> local_statement_list local_statement .)
    CONTINUE        reduce using rule 93 (local_statement_list -> local_statement_list local_statement .)
    VAR             reduce using rule 93 (local_statement_list -> local_statement_list local_statement .)
    CONST           reduce using rule 93 (local_statement_list -> local_statement_list local_statement .)
    IDENTIFIER      reduce using rule 93 (local_statement_list -> local_statement_list local_statement .)
    LPAREN          reduce using rule 93 (local_statement_list -> local_statement_list local_statement .)
    INT             reduce using rule 93 (local_statement_list -> local_statement_list local_statement .)
    FLOAT64         reduce using rule 93 (local_statement_list -> local_statement_list local_statement .)
    STRING          reduce using rule 93 (local_statement_list -> local_statement_list local_statement .)
    TRUE            reduce using rule 93 (local_statement_list -> local_statement_list local_statement .)
    FALSE           reduce using rule 93 (local_statement_list -> local_statement_list local_statement .)
    LNOT            reduce using rule 93 (local_statement_list -> local_statement_list local_statement .)
    IF              reduce using rule 93 (local_statement_list -> local_statement_list local_statement .)
    SWITCH          reduce using rule 93 (local_statement_list -> local_statement_list local_statement .)
    RETURN          reduce using rule 93 (local_statement_list -> local_statement_list local_statement .)
    LBRACKET        reduce using rule 93 (local_statement_list -> local_statement_list local_statement .)
    MAP             reduce using rule 93 (local_statement_list -> local_statement_list local_statement .)
    FOR             reduce using rule 93 (local_statement_list -> local_statement_list local_statement .)
    CASE            reduce using rule 93 (local_statement_list -> local_statement_list local_statement .)
    DEFAULT         reduce using rule 93 (local_statement_list -> local_statement_list local_statement .)
=======
    (103) expression -> IDENTIFIER LPAREN argument_list RPAREN .

    DOT             reduce using rule 103 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    PLUS            reduce using rule 103 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    MINUS           reduce using rule 103 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    TIMES           reduce using rule 103 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    DIVIDE          reduce using rule 103 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    MODULE          reduce using rule 103 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    EQ              reduce using rule 103 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    NEQ             reduce using rule 103 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    LT              reduce using rule 103 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    LE              reduce using rule 103 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    GT              reduce using rule 103 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    GE              reduce using rule 103 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    LAND            reduce using rule 103 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    LOR             reduce using rule 103 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    AND             reduce using rule 103 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    OR              reduce using rule 103 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    XOR             reduce using rule 103 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    AND_NOT         reduce using rule 103 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    LSHIFT          reduce using rule 103 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    RSHIFT          reduce using rule 103 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    SEMICOLON       reduce using rule 103 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    FUNC            reduce using rule 103 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    TYPE            reduce using rule 103 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    IDENTIFIER      reduce using rule 103 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    VAR             reduce using rule 103 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    CONST           reduce using rule 103 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    LNOT            reduce using rule 103 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    LBRACKET        reduce using rule 103 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    LPAREN          reduce using rule 103 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    INT             reduce using rule 103 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    FLOAT64         reduce using rule 103 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    TRUE            reduce using rule 103 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    FALSE           reduce using rule 103 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    STRING          reduce using rule 103 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    RETURN          reduce using rule 103 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    FOR             reduce using rule 103 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    IF              reduce using rule 103 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    SWITCH          reduce using rule 103 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    BREAK           reduce using rule 103 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    CONTINUE        reduce using rule 103 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    FALLTHROUGH     reduce using rule 103 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    $end            reduce using rule 103 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    RPAREN          reduce using rule 103 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    COMMA           reduce using rule 103 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    RBRACE          reduce using rule 103 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    CASE            reduce using rule 103 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    DEFAULT         reduce using rule 103 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    LBRACE          reduce using rule 103 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    COLON           reduce using rule 103 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
>>>>>>> Stashed changes


state 216

<<<<<<< Updated upstream
    (20) local_var_dec -> VAR IDENTIFIER . type
    (21) local_var_dec -> VAR IDENTIFIER . type ASSIGN expression
    (22) local_var_dec -> VAR IDENTIFIER . ASSIGN expression
    (57) type -> . primitive_type
    (58) type -> . slice_type
    (59) type -> . array_type
    (60) type -> . map_type
    (61) primitive_type -> . INT_TYPE
    (62) primitive_type -> . FLOAT64_TYPE
    (63) primitive_type -> . STRING_TYPE
    (64) primitive_type -> . BOOL_TYPE
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (197) array_type -> . LBRACKET INT RBRACKET primitive_type
    (137) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type

    ASSIGN          shift and go to state 263
    INT_TYPE        shift and go to state 34
    FLOAT64_TYPE    shift and go to state 35
    STRING_TYPE     shift and go to state 36
    BOOL_TYPE       shift and go to state 37
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    type                           shift and go to state 262
    primitive_type                 shift and go to state 30
    slice_type                     shift and go to state 31
    array_type                     shift and go to state 32
    map_type                       shift and go to state 33

state 217

    (77) short_assignment -> IDENTIFIER SHORT_ASSIGN . expression
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (125) expression -> . LNOT expression
    (126) expression -> . IDENTIFIER PLUSPLUS
    (127) expression -> . IDENTIFIER MINUSMINUS
    (138) expression -> . map_type LBRACE expression_map_list RBRACE
    (139) expression -> . map_type LBRACE RBRACE
    (161) expression -> . type_name LBRACE keyed_element_list RBRACE
    (162) expression -> . type_name LBRACE RBRACE
    (198) expression -> . array_type LBRACE expression_list RBRACE
    (199) expression -> . array_type LBRACE RBRACE
    (200) expression -> . expression DOT IDENTIFIER
    (201) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> . expression LBRACKET expression RBRACKET
    (203) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (137) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (163) type_name -> . IDENTIFIER
    (164) type_name -> . slice_type
    (165) type_name -> . array_type
    (166) type_name -> . map_type
    (197) array_type -> . LBRACKET INT RBRACKET primitive_type

    LPAREN          shift and go to state 54
    INT             shift and go to state 55
    FLOAT64         shift and go to state 56
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 57
    TRUE            shift and go to state 58
    FALSE           shift and go to state 59
    LNOT            shift and go to state 60
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    expression                     shift and go to state 264
    slice_type                     shift and go to state 53
    map_type                       shift and go to state 61
    type_name                      shift and go to state 62
    array_type                     shift and go to state 63

state 218

    (56) simple_assignment -> IDENTIFIER ASSIGN . expression
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (125) expression -> . LNOT expression
    (126) expression -> . IDENTIFIER PLUSPLUS
    (127) expression -> . IDENTIFIER MINUSMINUS
    (138) expression -> . map_type LBRACE expression_map_list RBRACE
    (139) expression -> . map_type LBRACE RBRACE
    (161) expression -> . type_name LBRACE keyed_element_list RBRACE
    (162) expression -> . type_name LBRACE RBRACE
    (198) expression -> . array_type LBRACE expression_list RBRACE
    (199) expression -> . array_type LBRACE RBRACE
    (200) expression -> . expression DOT IDENTIFIER
    (201) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> . expression LBRACKET expression RBRACKET
    (203) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (137) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (163) type_name -> . IDENTIFIER
    (164) type_name -> . slice_type
    (165) type_name -> . array_type
    (166) type_name -> . map_type
    (197) array_type -> . LBRACKET INT RBRACKET primitive_type

    LPAREN          shift and go to state 54
    INT             shift and go to state 55
    FLOAT64         shift and go to state 56
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 57
    TRUE            shift and go to state 58
    FALSE           shift and go to state 59
    LNOT            shift and go to state 60
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39
=======
    (101) expression_list -> expression_list COMMA . expression
    (82) expression -> . binary_expression
    (83) expression -> . relational_expression
    (84) expression -> . logical_expression
    (85) expression -> . bitwise_expression
    (86) expression -> . PLUS expression
    (87) expression -> . MINUS expression
    (88) expression -> . LNOT expression
    (89) expression -> . LBRACKET RBRACKET primitive_type LBRACE expression_list RBRACE
    (90) expression -> . LBRACKET RBRACKET primitive_type LBRACE RBRACE
    (91) expression -> . LPAREN expression RPAREN
    (92) expression -> . INT
    (93) expression -> . FLOAT64
    (94) expression -> . TRUE
    (95) expression -> . FALSE
    (96) expression -> . IDENTIFIER
    (97) expression -> . STRING
    (98) expression -> . IDENTIFIER PLUSPLUS
    (99) expression -> . IDENTIFIER MINUSMINUS
    (100) expression -> . expression DOT IDENTIFIER
    (103) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (133) expression -> . IDENTIFIER LBRACE keyed_element_list RBRACE
    (134) expression -> . IDENTIFIER LBRACE RBRACE
    (135) binary_expression -> . expression PLUS expression
    (136) binary_expression -> . expression MINUS expression
    (137) binary_expression -> . expression TIMES expression
    (138) binary_expression -> . expression DIVIDE expression
    (139) binary_expression -> . expression MODULE expression
    (144) relational_expression -> . expression EQ expression
    (145) relational_expression -> . expression NEQ expression
    (146) relational_expression -> . expression LT expression
    (147) relational_expression -> . expression LE expression
    (148) relational_expression -> . expression GT expression
    (149) relational_expression -> . expression GE expression
    (150) logical_expression -> . expression LAND expression
    (151) logical_expression -> . expression LOR expression
    (152) bitwise_expression -> . expression AND expression
    (153) bitwise_expression -> . expression OR expression
    (154) bitwise_expression -> . expression XOR expression
    (155) bitwise_expression -> . expression AND_NOT expression
    (156) bitwise_expression -> . expression LSHIFT expression
    (157) bitwise_expression -> . expression RSHIFT expression

    PLUS            shift and go to state 37
    MINUS           shift and go to state 38
    LNOT            shift and go to state 39
    LBRACKET        shift and go to state 40
    LPAREN          shift and go to state 29
    INT             shift and go to state 41
    FLOAT64         shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44
    IDENTIFIER      shift and go to state 97
    STRING          shift and go to state 11

    expression                     shift and go to state 252
    binary_expression              shift and go to state 33
    relational_expression          shift and go to state 34
    logical_expression             shift and go to state 35
    bitwise_expression             shift and go to state 36

state 217

    (130) keyed_element -> IDENTIFIER COLON . expression
    (82) expression -> . binary_expression
    (83) expression -> . relational_expression
    (84) expression -> . logical_expression
    (85) expression -> . bitwise_expression
    (86) expression -> . PLUS expression
    (87) expression -> . MINUS expression
    (88) expression -> . LNOT expression
    (89) expression -> . LBRACKET RBRACKET primitive_type LBRACE expression_list RBRACE
    (90) expression -> . LBRACKET RBRACKET primitive_type LBRACE RBRACE
    (91) expression -> . LPAREN expression RPAREN
    (92) expression -> . INT
    (93) expression -> . FLOAT64
    (94) expression -> . TRUE
    (95) expression -> . FALSE
    (96) expression -> . IDENTIFIER
    (97) expression -> . STRING
    (98) expression -> . IDENTIFIER PLUSPLUS
    (99) expression -> . IDENTIFIER MINUSMINUS
    (100) expression -> . expression DOT IDENTIFIER
    (103) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (133) expression -> . IDENTIFIER LBRACE keyed_element_list RBRACE
    (134) expression -> . IDENTIFIER LBRACE RBRACE
    (135) binary_expression -> . expression PLUS expression
    (136) binary_expression -> . expression MINUS expression
    (137) binary_expression -> . expression TIMES expression
    (138) binary_expression -> . expression DIVIDE expression
    (139) binary_expression -> . expression MODULE expression
    (144) relational_expression -> . expression EQ expression
    (145) relational_expression -> . expression NEQ expression
    (146) relational_expression -> . expression LT expression
    (147) relational_expression -> . expression LE expression
    (148) relational_expression -> . expression GT expression
    (149) relational_expression -> . expression GE expression
    (150) logical_expression -> . expression LAND expression
    (151) logical_expression -> . expression LOR expression
    (152) bitwise_expression -> . expression AND expression
    (153) bitwise_expression -> . expression OR expression
    (154) bitwise_expression -> . expression XOR expression
    (155) bitwise_expression -> . expression AND_NOT expression
    (156) bitwise_expression -> . expression LSHIFT expression
    (157) bitwise_expression -> . expression RSHIFT expression

    PLUS            shift and go to state 37
    MINUS           shift and go to state 38
    LNOT            shift and go to state 39
    LBRACKET        shift and go to state 40
    LPAREN          shift and go to state 29
    INT             shift and go to state 41
    FLOAT64         shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44
    IDENTIFIER      shift and go to state 97
    STRING          shift and go to state 11

    expression                     shift and go to state 253
    binary_expression              shift and go to state 33
    relational_expression          shift and go to state 34
    logical_expression             shift and go to state 35
    bitwise_expression             shift and go to state 36

state 218

    (133) expression -> IDENTIFIER LBRACE keyed_element_list RBRACE .

    DOT             reduce using rule 133 (expression -> IDENTIFIER LBRACE keyed_element_list RBRACE .)
    PLUS            reduce using rule 133 (expression -> IDENTIFIER LBRACE keyed_element_list RBRACE .)
    MINUS           reduce using rule 133 (expression -> IDENTIFIER LBRACE keyed_element_list RBRACE .)
    TIMES           reduce using rule 133 (expression -> IDENTIFIER LBRACE keyed_element_list RBRACE .)
    DIVIDE          reduce using rule 133 (expression -> IDENTIFIER LBRACE keyed_element_list RBRACE .)
    MODULE          reduce using rule 133 (expression -> IDENTIFIER LBRACE keyed_element_list RBRACE .)
    EQ              reduce using rule 133 (expression -> IDENTIFIER LBRACE keyed_element_list RBRACE .)
    NEQ             reduce using rule 133 (expression -> IDENTIFIER LBRACE keyed_element_list RBRACE .)
    LT              reduce using rule 133 (expression -> IDENTIFIER LBRACE keyed_element_list RBRACE .)
    LE              reduce using rule 133 (expression -> IDENTIFIER LBRACE keyed_element_list RBRACE .)
    GT              reduce using rule 133 (expression -> IDENTIFIER LBRACE keyed_element_list RBRACE .)
    GE              reduce using rule 133 (expression -> IDENTIFIER LBRACE keyed_element_list RBRACE .)
    LAND            reduce using rule 133 (expression -> IDENTIFIER LBRACE keyed_element_list RBRACE .)
    LOR             reduce using rule 133 (expression -> IDENTIFIER LBRACE keyed_element_list RBRACE .)
    AND             reduce using rule 133 (expression -> IDENTIFIER LBRACE keyed_element_list RBRACE .)
    OR              reduce using rule 133 (expression -> IDENTIFIER LBRACE keyed_element_list RBRACE .)
    XOR             reduce using rule 133 (expression -> IDENTIFIER LBRACE keyed_element_list RBRACE .)
    AND_NOT         reduce using rule 133 (expression -> IDENTIFIER LBRACE keyed_element_list RBRACE .)
    LSHIFT          reduce using rule 133 (expression -> IDENTIFIER LBRACE keyed_element_list RBRACE .)
    RSHIFT          reduce using rule 133 (expression -> IDENTIFIER LBRACE keyed_element_list RBRACE .)
    SEMICOLON       reduce using rule 133 (expression -> IDENTIFIER LBRACE keyed_element_list RBRACE .)
    FUNC            reduce using rule 133 (expression -> IDENTIFIER LBRACE keyed_element_list RBRACE .)
    TYPE            reduce using rule 133 (expression -> IDENTIFIER LBRACE keyed_element_list RBRACE .)
    IDENTIFIER      reduce using rule 133 (expression -> IDENTIFIER LBRACE keyed_element_list RBRACE .)
    VAR             reduce using rule 133 (expression -> IDENTIFIER LBRACE keyed_element_list RBRACE .)
    CONST           reduce using rule 133 (expression -> IDENTIFIER LBRACE keyed_element_list RBRACE .)
    LNOT            reduce using rule 133 (expression -> IDENTIFIER LBRACE keyed_element_list RBRACE .)
    LBRACKET        reduce using rule 133 (expression -> IDENTIFIER LBRACE keyed_element_list RBRACE .)
    LPAREN          reduce using rule 133 (expression -> IDENTIFIER LBRACE keyed_element_list RBRACE .)
    INT             reduce using rule 133 (expression -> IDENTIFIER LBRACE keyed_element_list RBRACE .)
    FLOAT64         reduce using rule 133 (expression -> IDENTIFIER LBRACE keyed_element_list RBRACE .)
    TRUE            reduce using rule 133 (expression -> IDENTIFIER LBRACE keyed_element_list RBRACE .)
    FALSE           reduce using rule 133 (expression -> IDENTIFIER LBRACE keyed_element_list RBRACE .)
    STRING          reduce using rule 133 (expression -> IDENTIFIER LBRACE keyed_element_list RBRACE .)
    RETURN          reduce using rule 133 (expression -> IDENTIFIER LBRACE keyed_element_list RBRACE .)
    FOR             reduce using rule 133 (expression -> IDENTIFIER LBRACE keyed_element_list RBRACE .)
    IF              reduce using rule 133 (expression -> IDENTIFIER LBRACE keyed_element_list RBRACE .)
    SWITCH          reduce using rule 133 (expression -> IDENTIFIER LBRACE keyed_element_list RBRACE .)
    BREAK           reduce using rule 133 (expression -> IDENTIFIER LBRACE keyed_element_list RBRACE .)
    CONTINUE        reduce using rule 133 (expression -> IDENTIFIER LBRACE keyed_element_list RBRACE .)
    FALLTHROUGH     reduce using rule 133 (expression -> IDENTIFIER LBRACE keyed_element_list RBRACE .)
    $end            reduce using rule 133 (expression -> IDENTIFIER LBRACE keyed_element_list RBRACE .)
    RPAREN          reduce using rule 133 (expression -> IDENTIFIER LBRACE keyed_element_list RBRACE .)
    COMMA           reduce using rule 133 (expression -> IDENTIFIER LBRACE keyed_element_list RBRACE .)
    RBRACE          reduce using rule 133 (expression -> IDENTIFIER LBRACE keyed_element_list RBRACE .)
    CASE            reduce using rule 133 (expression -> IDENTIFIER LBRACE keyed_element_list RBRACE .)
    DEFAULT         reduce using rule 133 (expression -> IDENTIFIER LBRACE keyed_element_list RBRACE .)
    LBRACE          reduce using rule 133 (expression -> IDENTIFIER LBRACE keyed_element_list RBRACE .)
    COLON           reduce using rule 133 (expression -> IDENTIFIER LBRACE keyed_element_list RBRACE .)
>>>>>>> Stashed changes

    expression                     shift and go to state 265
    slice_type                     shift and go to state 53
    map_type                       shift and go to state 61
    type_name                      shift and go to state 62
    array_type                     shift and go to state 63

state 219

<<<<<<< Updated upstream
    (25) assignment_compound -> IDENTIFIER operator_assign . expression
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (125) expression -> . LNOT expression
    (126) expression -> . IDENTIFIER PLUSPLUS
    (127) expression -> . IDENTIFIER MINUSMINUS
    (138) expression -> . map_type LBRACE expression_map_list RBRACE
    (139) expression -> . map_type LBRACE RBRACE
    (161) expression -> . type_name LBRACE keyed_element_list RBRACE
    (162) expression -> . type_name LBRACE RBRACE
    (198) expression -> . array_type LBRACE expression_list RBRACE
    (199) expression -> . array_type LBRACE RBRACE
    (200) expression -> . expression DOT IDENTIFIER
    (201) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> . expression LBRACKET expression RBRACKET
    (203) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (137) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (163) type_name -> . IDENTIFIER
    (164) type_name -> . slice_type
    (165) type_name -> . array_type
    (166) type_name -> . map_type
    (197) array_type -> . LBRACKET INT RBRACKET primitive_type

    LPAREN          shift and go to state 54
    INT             shift and go to state 55
    FLOAT64         shift and go to state 56
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 57
    TRUE            shift and go to state 58
    FALSE           shift and go to state 59
    LNOT            shift and go to state 60
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    expression                     shift and go to state 266
    slice_type                     shift and go to state 53
    map_type                       shift and go to state 61
    type_name                      shift and go to state 62
    array_type                     shift and go to state 63

state 220

    (26) operator_assign -> PLUS_ASSIGN .

    LPAREN          reduce using rule 26 (operator_assign -> PLUS_ASSIGN .)
    INT             reduce using rule 26 (operator_assign -> PLUS_ASSIGN .)
    FLOAT64         reduce using rule 26 (operator_assign -> PLUS_ASSIGN .)
    IDENTIFIER      reduce using rule 26 (operator_assign -> PLUS_ASSIGN .)
    STRING          reduce using rule 26 (operator_assign -> PLUS_ASSIGN .)
    TRUE            reduce using rule 26 (operator_assign -> PLUS_ASSIGN .)
    FALSE           reduce using rule 26 (operator_assign -> PLUS_ASSIGN .)
    LNOT            reduce using rule 26 (operator_assign -> PLUS_ASSIGN .)
    LBRACKET        reduce using rule 26 (operator_assign -> PLUS_ASSIGN .)
    MAP             reduce using rule 26 (operator_assign -> PLUS_ASSIGN .)
=======
    (128) keyed_element_list -> keyed_element_list COMMA . keyed_element
    (130) keyed_element -> . IDENTIFIER COLON expression
    (131) keyed_element -> . INT COLON expression
    (132) keyed_element -> . expression
    (82) expression -> . binary_expression
    (83) expression -> . relational_expression
    (84) expression -> . logical_expression
    (85) expression -> . bitwise_expression
    (86) expression -> . PLUS expression
    (87) expression -> . MINUS expression
    (88) expression -> . LNOT expression
    (89) expression -> . LBRACKET RBRACKET primitive_type LBRACE expression_list RBRACE
    (90) expression -> . LBRACKET RBRACKET primitive_type LBRACE RBRACE
    (91) expression -> . LPAREN expression RPAREN
    (92) expression -> . INT
    (93) expression -> . FLOAT64
    (94) expression -> . TRUE
    (95) expression -> . FALSE
    (96) expression -> . IDENTIFIER
    (97) expression -> . STRING
    (98) expression -> . IDENTIFIER PLUSPLUS
    (99) expression -> . IDENTIFIER MINUSMINUS
    (100) expression -> . expression DOT IDENTIFIER
    (103) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (133) expression -> . IDENTIFIER LBRACE keyed_element_list RBRACE
    (134) expression -> . IDENTIFIER LBRACE RBRACE
    (135) binary_expression -> . expression PLUS expression
    (136) binary_expression -> . expression MINUS expression
    (137) binary_expression -> . expression TIMES expression
    (138) binary_expression -> . expression DIVIDE expression
    (139) binary_expression -> . expression MODULE expression
    (144) relational_expression -> . expression EQ expression
    (145) relational_expression -> . expression NEQ expression
    (146) relational_expression -> . expression LT expression
    (147) relational_expression -> . expression LE expression
    (148) relational_expression -> . expression GT expression
    (149) relational_expression -> . expression GE expression
    (150) logical_expression -> . expression LAND expression
    (151) logical_expression -> . expression LOR expression
    (152) bitwise_expression -> . expression AND expression
    (153) bitwise_expression -> . expression OR expression
    (154) bitwise_expression -> . expression XOR expression
    (155) bitwise_expression -> . expression AND_NOT expression
    (156) bitwise_expression -> . expression LSHIFT expression
    (157) bitwise_expression -> . expression RSHIFT expression

    IDENTIFIER      shift and go to state 157
    INT             shift and go to state 162
    PLUS            shift and go to state 37
    MINUS           shift and go to state 38
    LNOT            shift and go to state 39
    LBRACKET        shift and go to state 40
    LPAREN          shift and go to state 29
    FLOAT64         shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44
    STRING          shift and go to state 11

    keyed_element                  shift and go to state 254
    expression                     shift and go to state 161
    binary_expression              shift and go to state 33
    relational_expression          shift and go to state 34
    logical_expression             shift and go to state 35
    bitwise_expression             shift and go to state 36

state 220

    (131) keyed_element -> INT COLON . expression
    (82) expression -> . binary_expression
    (83) expression -> . relational_expression
    (84) expression -> . logical_expression
    (85) expression -> . bitwise_expression
    (86) expression -> . PLUS expression
    (87) expression -> . MINUS expression
    (88) expression -> . LNOT expression
    (89) expression -> . LBRACKET RBRACKET primitive_type LBRACE expression_list RBRACE
    (90) expression -> . LBRACKET RBRACKET primitive_type LBRACE RBRACE
    (91) expression -> . LPAREN expression RPAREN
    (92) expression -> . INT
    (93) expression -> . FLOAT64
    (94) expression -> . TRUE
    (95) expression -> . FALSE
    (96) expression -> . IDENTIFIER
    (97) expression -> . STRING
    (98) expression -> . IDENTIFIER PLUSPLUS
    (99) expression -> . IDENTIFIER MINUSMINUS
    (100) expression -> . expression DOT IDENTIFIER
    (103) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (133) expression -> . IDENTIFIER LBRACE keyed_element_list RBRACE
    (134) expression -> . IDENTIFIER LBRACE RBRACE
    (135) binary_expression -> . expression PLUS expression
    (136) binary_expression -> . expression MINUS expression
    (137) binary_expression -> . expression TIMES expression
    (138) binary_expression -> . expression DIVIDE expression
    (139) binary_expression -> . expression MODULE expression
    (144) relational_expression -> . expression EQ expression
    (145) relational_expression -> . expression NEQ expression
    (146) relational_expression -> . expression LT expression
    (147) relational_expression -> . expression LE expression
    (148) relational_expression -> . expression GT expression
    (149) relational_expression -> . expression GE expression
    (150) logical_expression -> . expression LAND expression
    (151) logical_expression -> . expression LOR expression
    (152) bitwise_expression -> . expression AND expression
    (153) bitwise_expression -> . expression OR expression
    (154) bitwise_expression -> . expression XOR expression
    (155) bitwise_expression -> . expression AND_NOT expression
    (156) bitwise_expression -> . expression LSHIFT expression
    (157) bitwise_expression -> . expression RSHIFT expression

    PLUS            shift and go to state 37
    MINUS           shift and go to state 38
    LNOT            shift and go to state 39
    LBRACKET        shift and go to state 40
    LPAREN          shift and go to state 29
    INT             shift and go to state 41
    FLOAT64         shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44
    IDENTIFIER      shift and go to state 97
    STRING          shift and go to state 11
>>>>>>> Stashed changes

    expression                     shift and go to state 255
    binary_expression              shift and go to state 33
    relational_expression          shift and go to state 34
    logical_expression             shift and go to state 35
    bitwise_expression             shift and go to state 36

state 221

<<<<<<< Updated upstream
    (27) operator_assign -> MINUS_ASSIGN .

    LPAREN          reduce using rule 27 (operator_assign -> MINUS_ASSIGN .)
    INT             reduce using rule 27 (operator_assign -> MINUS_ASSIGN .)
    FLOAT64         reduce using rule 27 (operator_assign -> MINUS_ASSIGN .)
    IDENTIFIER      reduce using rule 27 (operator_assign -> MINUS_ASSIGN .)
    STRING          reduce using rule 27 (operator_assign -> MINUS_ASSIGN .)
    TRUE            reduce using rule 27 (operator_assign -> MINUS_ASSIGN .)
    FALSE           reduce using rule 27 (operator_assign -> MINUS_ASSIGN .)
    LNOT            reduce using rule 27 (operator_assign -> MINUS_ASSIGN .)
    LBRACKET        reduce using rule 27 (operator_assign -> MINUS_ASSIGN .)
    MAP             reduce using rule 27 (operator_assign -> MINUS_ASSIGN .)
=======
    (117) type_declaration -> TYPE IDENTIFIER IDENTIFIER optional_semicolon .

    FUNC            reduce using rule 117 (type_declaration -> TYPE IDENTIFIER IDENTIFIER optional_semicolon .)
    TYPE            reduce using rule 117 (type_declaration -> TYPE IDENTIFIER IDENTIFIER optional_semicolon .)
    IDENTIFIER      reduce using rule 117 (type_declaration -> TYPE IDENTIFIER IDENTIFIER optional_semicolon .)
    VAR             reduce using rule 117 (type_declaration -> TYPE IDENTIFIER IDENTIFIER optional_semicolon .)
    CONST           reduce using rule 117 (type_declaration -> TYPE IDENTIFIER IDENTIFIER optional_semicolon .)
    PLUS            reduce using rule 117 (type_declaration -> TYPE IDENTIFIER IDENTIFIER optional_semicolon .)
    MINUS           reduce using rule 117 (type_declaration -> TYPE IDENTIFIER IDENTIFIER optional_semicolon .)
    LNOT            reduce using rule 117 (type_declaration -> TYPE IDENTIFIER IDENTIFIER optional_semicolon .)
    LBRACKET        reduce using rule 117 (type_declaration -> TYPE IDENTIFIER IDENTIFIER optional_semicolon .)
    LPAREN          reduce using rule 117 (type_declaration -> TYPE IDENTIFIER IDENTIFIER optional_semicolon .)
    INT             reduce using rule 117 (type_declaration -> TYPE IDENTIFIER IDENTIFIER optional_semicolon .)
    FLOAT64         reduce using rule 117 (type_declaration -> TYPE IDENTIFIER IDENTIFIER optional_semicolon .)
    TRUE            reduce using rule 117 (type_declaration -> TYPE IDENTIFIER IDENTIFIER optional_semicolon .)
    FALSE           reduce using rule 117 (type_declaration -> TYPE IDENTIFIER IDENTIFIER optional_semicolon .)
    STRING          reduce using rule 117 (type_declaration -> TYPE IDENTIFIER IDENTIFIER optional_semicolon .)
    RETURN          reduce using rule 117 (type_declaration -> TYPE IDENTIFIER IDENTIFIER optional_semicolon .)
    FOR             reduce using rule 117 (type_declaration -> TYPE IDENTIFIER IDENTIFIER optional_semicolon .)
    IF              reduce using rule 117 (type_declaration -> TYPE IDENTIFIER IDENTIFIER optional_semicolon .)
    SWITCH          reduce using rule 117 (type_declaration -> TYPE IDENTIFIER IDENTIFIER optional_semicolon .)
    BREAK           reduce using rule 117 (type_declaration -> TYPE IDENTIFIER IDENTIFIER optional_semicolon .)
    CONTINUE        reduce using rule 117 (type_declaration -> TYPE IDENTIFIER IDENTIFIER optional_semicolon .)
    FALLTHROUGH     reduce using rule 117 (type_declaration -> TYPE IDENTIFIER IDENTIFIER optional_semicolon .)
    $end            reduce using rule 117 (type_declaration -> TYPE IDENTIFIER IDENTIFIER optional_semicolon .)
>>>>>>> Stashed changes


state 222

<<<<<<< Updated upstream
    (28) operator_assign -> MULT_ASSIGN .

    LPAREN          reduce using rule 28 (operator_assign -> MULT_ASSIGN .)
    INT             reduce using rule 28 (operator_assign -> MULT_ASSIGN .)
    FLOAT64         reduce using rule 28 (operator_assign -> MULT_ASSIGN .)
    IDENTIFIER      reduce using rule 28 (operator_assign -> MULT_ASSIGN .)
    STRING          reduce using rule 28 (operator_assign -> MULT_ASSIGN .)
    TRUE            reduce using rule 28 (operator_assign -> MULT_ASSIGN .)
    FALSE           reduce using rule 28 (operator_assign -> MULT_ASSIGN .)
    LNOT            reduce using rule 28 (operator_assign -> MULT_ASSIGN .)
    LBRACKET        reduce using rule 28 (operator_assign -> MULT_ASSIGN .)
    MAP             reduce using rule 28 (operator_assign -> MULT_ASSIGN .)
=======
    (112) type_declaration -> TYPE IDENTIFIER struct_type optional_semicolon .

    FUNC            reduce using rule 112 (type_declaration -> TYPE IDENTIFIER struct_type optional_semicolon .)
    TYPE            reduce using rule 112 (type_declaration -> TYPE IDENTIFIER struct_type optional_semicolon .)
    IDENTIFIER      reduce using rule 112 (type_declaration -> TYPE IDENTIFIER struct_type optional_semicolon .)
    VAR             reduce using rule 112 (type_declaration -> TYPE IDENTIFIER struct_type optional_semicolon .)
    CONST           reduce using rule 112 (type_declaration -> TYPE IDENTIFIER struct_type optional_semicolon .)
    PLUS            reduce using rule 112 (type_declaration -> TYPE IDENTIFIER struct_type optional_semicolon .)
    MINUS           reduce using rule 112 (type_declaration -> TYPE IDENTIFIER struct_type optional_semicolon .)
    LNOT            reduce using rule 112 (type_declaration -> TYPE IDENTIFIER struct_type optional_semicolon .)
    LBRACKET        reduce using rule 112 (type_declaration -> TYPE IDENTIFIER struct_type optional_semicolon .)
    LPAREN          reduce using rule 112 (type_declaration -> TYPE IDENTIFIER struct_type optional_semicolon .)
    INT             reduce using rule 112 (type_declaration -> TYPE IDENTIFIER struct_type optional_semicolon .)
    FLOAT64         reduce using rule 112 (type_declaration -> TYPE IDENTIFIER struct_type optional_semicolon .)
    TRUE            reduce using rule 112 (type_declaration -> TYPE IDENTIFIER struct_type optional_semicolon .)
    FALSE           reduce using rule 112 (type_declaration -> TYPE IDENTIFIER struct_type optional_semicolon .)
    STRING          reduce using rule 112 (type_declaration -> TYPE IDENTIFIER struct_type optional_semicolon .)
    RETURN          reduce using rule 112 (type_declaration -> TYPE IDENTIFIER struct_type optional_semicolon .)
    FOR             reduce using rule 112 (type_declaration -> TYPE IDENTIFIER struct_type optional_semicolon .)
    IF              reduce using rule 112 (type_declaration -> TYPE IDENTIFIER struct_type optional_semicolon .)
    SWITCH          reduce using rule 112 (type_declaration -> TYPE IDENTIFIER struct_type optional_semicolon .)
    BREAK           reduce using rule 112 (type_declaration -> TYPE IDENTIFIER struct_type optional_semicolon .)
    CONTINUE        reduce using rule 112 (type_declaration -> TYPE IDENTIFIER struct_type optional_semicolon .)
    FALLTHROUGH     reduce using rule 112 (type_declaration -> TYPE IDENTIFIER struct_type optional_semicolon .)
    $end            reduce using rule 112 (type_declaration -> TYPE IDENTIFIER struct_type optional_semicolon .)
>>>>>>> Stashed changes


state 223

<<<<<<< Updated upstream
    (29) operator_assign -> DIV_ASSIGN .

    LPAREN          reduce using rule 29 (operator_assign -> DIV_ASSIGN .)
    INT             reduce using rule 29 (operator_assign -> DIV_ASSIGN .)
    FLOAT64         reduce using rule 29 (operator_assign -> DIV_ASSIGN .)
    IDENTIFIER      reduce using rule 29 (operator_assign -> DIV_ASSIGN .)
    STRING          reduce using rule 29 (operator_assign -> DIV_ASSIGN .)
    TRUE            reduce using rule 29 (operator_assign -> DIV_ASSIGN .)
    FALSE           reduce using rule 29 (operator_assign -> DIV_ASSIGN .)
    LNOT            reduce using rule 29 (operator_assign -> DIV_ASSIGN .)
    LBRACKET        reduce using rule 29 (operator_assign -> DIV_ASSIGN .)
    MAP             reduce using rule 29 (operator_assign -> DIV_ASSIGN .)
=======
    (113) type_declaration -> TYPE IDENTIFIER primitive_type optional_semicolon .

    FUNC            reduce using rule 113 (type_declaration -> TYPE IDENTIFIER primitive_type optional_semicolon .)
    TYPE            reduce using rule 113 (type_declaration -> TYPE IDENTIFIER primitive_type optional_semicolon .)
    IDENTIFIER      reduce using rule 113 (type_declaration -> TYPE IDENTIFIER primitive_type optional_semicolon .)
    VAR             reduce using rule 113 (type_declaration -> TYPE IDENTIFIER primitive_type optional_semicolon .)
    CONST           reduce using rule 113 (type_declaration -> TYPE IDENTIFIER primitive_type optional_semicolon .)
    PLUS            reduce using rule 113 (type_declaration -> TYPE IDENTIFIER primitive_type optional_semicolon .)
    MINUS           reduce using rule 113 (type_declaration -> TYPE IDENTIFIER primitive_type optional_semicolon .)
    LNOT            reduce using rule 113 (type_declaration -> TYPE IDENTIFIER primitive_type optional_semicolon .)
    LBRACKET        reduce using rule 113 (type_declaration -> TYPE IDENTIFIER primitive_type optional_semicolon .)
    LPAREN          reduce using rule 113 (type_declaration -> TYPE IDENTIFIER primitive_type optional_semicolon .)
    INT             reduce using rule 113 (type_declaration -> TYPE IDENTIFIER primitive_type optional_semicolon .)
    FLOAT64         reduce using rule 113 (type_declaration -> TYPE IDENTIFIER primitive_type optional_semicolon .)
    TRUE            reduce using rule 113 (type_declaration -> TYPE IDENTIFIER primitive_type optional_semicolon .)
    FALSE           reduce using rule 113 (type_declaration -> TYPE IDENTIFIER primitive_type optional_semicolon .)
    STRING          reduce using rule 113 (type_declaration -> TYPE IDENTIFIER primitive_type optional_semicolon .)
    RETURN          reduce using rule 113 (type_declaration -> TYPE IDENTIFIER primitive_type optional_semicolon .)
    FOR             reduce using rule 113 (type_declaration -> TYPE IDENTIFIER primitive_type optional_semicolon .)
    IF              reduce using rule 113 (type_declaration -> TYPE IDENTIFIER primitive_type optional_semicolon .)
    SWITCH          reduce using rule 113 (type_declaration -> TYPE IDENTIFIER primitive_type optional_semicolon .)
    BREAK           reduce using rule 113 (type_declaration -> TYPE IDENTIFIER primitive_type optional_semicolon .)
    CONTINUE        reduce using rule 113 (type_declaration -> TYPE IDENTIFIER primitive_type optional_semicolon .)
    FALLTHROUGH     reduce using rule 113 (type_declaration -> TYPE IDENTIFIER primitive_type optional_semicolon .)
    $end            reduce using rule 113 (type_declaration -> TYPE IDENTIFIER primitive_type optional_semicolon .)
>>>>>>> Stashed changes


state 224

<<<<<<< Updated upstream
    (30) operator_assign -> MOD_ASSIGN .

    LPAREN          reduce using rule 30 (operator_assign -> MOD_ASSIGN .)
    INT             reduce using rule 30 (operator_assign -> MOD_ASSIGN .)
    FLOAT64         reduce using rule 30 (operator_assign -> MOD_ASSIGN .)
    IDENTIFIER      reduce using rule 30 (operator_assign -> MOD_ASSIGN .)
    STRING          reduce using rule 30 (operator_assign -> MOD_ASSIGN .)
    TRUE            reduce using rule 30 (operator_assign -> MOD_ASSIGN .)
    FALSE           reduce using rule 30 (operator_assign -> MOD_ASSIGN .)
    LNOT            reduce using rule 30 (operator_assign -> MOD_ASSIGN .)
    LBRACKET        reduce using rule 30 (operator_assign -> MOD_ASSIGN .)
    MAP             reduce using rule 30 (operator_assign -> MOD_ASSIGN .)
=======
    (114) type_declaration -> TYPE IDENTIFIER slice_type optional_semicolon .

    FUNC            reduce using rule 114 (type_declaration -> TYPE IDENTIFIER slice_type optional_semicolon .)
    TYPE            reduce using rule 114 (type_declaration -> TYPE IDENTIFIER slice_type optional_semicolon .)
    IDENTIFIER      reduce using rule 114 (type_declaration -> TYPE IDENTIFIER slice_type optional_semicolon .)
    VAR             reduce using rule 114 (type_declaration -> TYPE IDENTIFIER slice_type optional_semicolon .)
    CONST           reduce using rule 114 (type_declaration -> TYPE IDENTIFIER slice_type optional_semicolon .)
    PLUS            reduce using rule 114 (type_declaration -> TYPE IDENTIFIER slice_type optional_semicolon .)
    MINUS           reduce using rule 114 (type_declaration -> TYPE IDENTIFIER slice_type optional_semicolon .)
    LNOT            reduce using rule 114 (type_declaration -> TYPE IDENTIFIER slice_type optional_semicolon .)
    LBRACKET        reduce using rule 114 (type_declaration -> TYPE IDENTIFIER slice_type optional_semicolon .)
    LPAREN          reduce using rule 114 (type_declaration -> TYPE IDENTIFIER slice_type optional_semicolon .)
    INT             reduce using rule 114 (type_declaration -> TYPE IDENTIFIER slice_type optional_semicolon .)
    FLOAT64         reduce using rule 114 (type_declaration -> TYPE IDENTIFIER slice_type optional_semicolon .)
    TRUE            reduce using rule 114 (type_declaration -> TYPE IDENTIFIER slice_type optional_semicolon .)
    FALSE           reduce using rule 114 (type_declaration -> TYPE IDENTIFIER slice_type optional_semicolon .)
    STRING          reduce using rule 114 (type_declaration -> TYPE IDENTIFIER slice_type optional_semicolon .)
    RETURN          reduce using rule 114 (type_declaration -> TYPE IDENTIFIER slice_type optional_semicolon .)
    FOR             reduce using rule 114 (type_declaration -> TYPE IDENTIFIER slice_type optional_semicolon .)
    IF              reduce using rule 114 (type_declaration -> TYPE IDENTIFIER slice_type optional_semicolon .)
    SWITCH          reduce using rule 114 (type_declaration -> TYPE IDENTIFIER slice_type optional_semicolon .)
    BREAK           reduce using rule 114 (type_declaration -> TYPE IDENTIFIER slice_type optional_semicolon .)
    CONTINUE        reduce using rule 114 (type_declaration -> TYPE IDENTIFIER slice_type optional_semicolon .)
    FALLTHROUGH     reduce using rule 114 (type_declaration -> TYPE IDENTIFIER slice_type optional_semicolon .)
    $end            reduce using rule 114 (type_declaration -> TYPE IDENTIFIER slice_type optional_semicolon .)
>>>>>>> Stashed changes


state 225

<<<<<<< Updated upstream
    (31) operator_assign -> AND_ASSIGN .

    LPAREN          reduce using rule 31 (operator_assign -> AND_ASSIGN .)
    INT             reduce using rule 31 (operator_assign -> AND_ASSIGN .)
    FLOAT64         reduce using rule 31 (operator_assign -> AND_ASSIGN .)
    IDENTIFIER      reduce using rule 31 (operator_assign -> AND_ASSIGN .)
    STRING          reduce using rule 31 (operator_assign -> AND_ASSIGN .)
    TRUE            reduce using rule 31 (operator_assign -> AND_ASSIGN .)
    FALSE           reduce using rule 31 (operator_assign -> AND_ASSIGN .)
    LNOT            reduce using rule 31 (operator_assign -> AND_ASSIGN .)
    LBRACKET        reduce using rule 31 (operator_assign -> AND_ASSIGN .)
    MAP             reduce using rule 31 (operator_assign -> AND_ASSIGN .)
=======
    (115) type_declaration -> TYPE IDENTIFIER array_type optional_semicolon .

    FUNC            reduce using rule 115 (type_declaration -> TYPE IDENTIFIER array_type optional_semicolon .)
    TYPE            reduce using rule 115 (type_declaration -> TYPE IDENTIFIER array_type optional_semicolon .)
    IDENTIFIER      reduce using rule 115 (type_declaration -> TYPE IDENTIFIER array_type optional_semicolon .)
    VAR             reduce using rule 115 (type_declaration -> TYPE IDENTIFIER array_type optional_semicolon .)
    CONST           reduce using rule 115 (type_declaration -> TYPE IDENTIFIER array_type optional_semicolon .)
    PLUS            reduce using rule 115 (type_declaration -> TYPE IDENTIFIER array_type optional_semicolon .)
    MINUS           reduce using rule 115 (type_declaration -> TYPE IDENTIFIER array_type optional_semicolon .)
    LNOT            reduce using rule 115 (type_declaration -> TYPE IDENTIFIER array_type optional_semicolon .)
    LBRACKET        reduce using rule 115 (type_declaration -> TYPE IDENTIFIER array_type optional_semicolon .)
    LPAREN          reduce using rule 115 (type_declaration -> TYPE IDENTIFIER array_type optional_semicolon .)
    INT             reduce using rule 115 (type_declaration -> TYPE IDENTIFIER array_type optional_semicolon .)
    FLOAT64         reduce using rule 115 (type_declaration -> TYPE IDENTIFIER array_type optional_semicolon .)
    TRUE            reduce using rule 115 (type_declaration -> TYPE IDENTIFIER array_type optional_semicolon .)
    FALSE           reduce using rule 115 (type_declaration -> TYPE IDENTIFIER array_type optional_semicolon .)
    STRING          reduce using rule 115 (type_declaration -> TYPE IDENTIFIER array_type optional_semicolon .)
    RETURN          reduce using rule 115 (type_declaration -> TYPE IDENTIFIER array_type optional_semicolon .)
    FOR             reduce using rule 115 (type_declaration -> TYPE IDENTIFIER array_type optional_semicolon .)
    IF              reduce using rule 115 (type_declaration -> TYPE IDENTIFIER array_type optional_semicolon .)
    SWITCH          reduce using rule 115 (type_declaration -> TYPE IDENTIFIER array_type optional_semicolon .)
    BREAK           reduce using rule 115 (type_declaration -> TYPE IDENTIFIER array_type optional_semicolon .)
    CONTINUE        reduce using rule 115 (type_declaration -> TYPE IDENTIFIER array_type optional_semicolon .)
    FALLTHROUGH     reduce using rule 115 (type_declaration -> TYPE IDENTIFIER array_type optional_semicolon .)
    $end            reduce using rule 115 (type_declaration -> TYPE IDENTIFIER array_type optional_semicolon .)
>>>>>>> Stashed changes


state 226

<<<<<<< Updated upstream
    (32) operator_assign -> OR_ASSIGN .

    LPAREN          reduce using rule 32 (operator_assign -> OR_ASSIGN .)
    INT             reduce using rule 32 (operator_assign -> OR_ASSIGN .)
    FLOAT64         reduce using rule 32 (operator_assign -> OR_ASSIGN .)
    IDENTIFIER      reduce using rule 32 (operator_assign -> OR_ASSIGN .)
    STRING          reduce using rule 32 (operator_assign -> OR_ASSIGN .)
    TRUE            reduce using rule 32 (operator_assign -> OR_ASSIGN .)
    FALSE           reduce using rule 32 (operator_assign -> OR_ASSIGN .)
    LNOT            reduce using rule 32 (operator_assign -> OR_ASSIGN .)
    LBRACKET        reduce using rule 32 (operator_assign -> OR_ASSIGN .)
    MAP             reduce using rule 32 (operator_assign -> OR_ASSIGN .)
=======
    (116) type_declaration -> TYPE IDENTIFIER map_type optional_semicolon .

    FUNC            reduce using rule 116 (type_declaration -> TYPE IDENTIFIER map_type optional_semicolon .)
    TYPE            reduce using rule 116 (type_declaration -> TYPE IDENTIFIER map_type optional_semicolon .)
    IDENTIFIER      reduce using rule 116 (type_declaration -> TYPE IDENTIFIER map_type optional_semicolon .)
    VAR             reduce using rule 116 (type_declaration -> TYPE IDENTIFIER map_type optional_semicolon .)
    CONST           reduce using rule 116 (type_declaration -> TYPE IDENTIFIER map_type optional_semicolon .)
    PLUS            reduce using rule 116 (type_declaration -> TYPE IDENTIFIER map_type optional_semicolon .)
    MINUS           reduce using rule 116 (type_declaration -> TYPE IDENTIFIER map_type optional_semicolon .)
    LNOT            reduce using rule 116 (type_declaration -> TYPE IDENTIFIER map_type optional_semicolon .)
    LBRACKET        reduce using rule 116 (type_declaration -> TYPE IDENTIFIER map_type optional_semicolon .)
    LPAREN          reduce using rule 116 (type_declaration -> TYPE IDENTIFIER map_type optional_semicolon .)
    INT             reduce using rule 116 (type_declaration -> TYPE IDENTIFIER map_type optional_semicolon .)
    FLOAT64         reduce using rule 116 (type_declaration -> TYPE IDENTIFIER map_type optional_semicolon .)
    TRUE            reduce using rule 116 (type_declaration -> TYPE IDENTIFIER map_type optional_semicolon .)
    FALSE           reduce using rule 116 (type_declaration -> TYPE IDENTIFIER map_type optional_semicolon .)
    STRING          reduce using rule 116 (type_declaration -> TYPE IDENTIFIER map_type optional_semicolon .)
    RETURN          reduce using rule 116 (type_declaration -> TYPE IDENTIFIER map_type optional_semicolon .)
    FOR             reduce using rule 116 (type_declaration -> TYPE IDENTIFIER map_type optional_semicolon .)
    IF              reduce using rule 116 (type_declaration -> TYPE IDENTIFIER map_type optional_semicolon .)
    SWITCH          reduce using rule 116 (type_declaration -> TYPE IDENTIFIER map_type optional_semicolon .)
    BREAK           reduce using rule 116 (type_declaration -> TYPE IDENTIFIER map_type optional_semicolon .)
    CONTINUE        reduce using rule 116 (type_declaration -> TYPE IDENTIFIER map_type optional_semicolon .)
    FALLTHROUGH     reduce using rule 116 (type_declaration -> TYPE IDENTIFIER map_type optional_semicolon .)
    $end            reduce using rule 116 (type_declaration -> TYPE IDENTIFIER map_type optional_semicolon .)
>>>>>>> Stashed changes


state 227

<<<<<<< Updated upstream
    (33) operator_assign -> XOR_ASSIGN .

    LPAREN          reduce using rule 33 (operator_assign -> XOR_ASSIGN .)
    INT             reduce using rule 33 (operator_assign -> XOR_ASSIGN .)
    FLOAT64         reduce using rule 33 (operator_assign -> XOR_ASSIGN .)
    IDENTIFIER      reduce using rule 33 (operator_assign -> XOR_ASSIGN .)
    STRING          reduce using rule 33 (operator_assign -> XOR_ASSIGN .)
    TRUE            reduce using rule 33 (operator_assign -> XOR_ASSIGN .)
    FALSE           reduce using rule 33 (operator_assign -> XOR_ASSIGN .)
    LNOT            reduce using rule 33 (operator_assign -> XOR_ASSIGN .)
    LBRACKET        reduce using rule 33 (operator_assign -> XOR_ASSIGN .)
    MAP             reduce using rule 33 (operator_assign -> XOR_ASSIGN .)


state 228

    (34) operator_assign -> LSHIFT_ASSIGN .

    LPAREN          reduce using rule 34 (operator_assign -> LSHIFT_ASSIGN .)
    INT             reduce using rule 34 (operator_assign -> LSHIFT_ASSIGN .)
    FLOAT64         reduce using rule 34 (operator_assign -> LSHIFT_ASSIGN .)
    IDENTIFIER      reduce using rule 34 (operator_assign -> LSHIFT_ASSIGN .)
    STRING          reduce using rule 34 (operator_assign -> LSHIFT_ASSIGN .)
    TRUE            reduce using rule 34 (operator_assign -> LSHIFT_ASSIGN .)
    FALSE           reduce using rule 34 (operator_assign -> LSHIFT_ASSIGN .)
    LNOT            reduce using rule 34 (operator_assign -> LSHIFT_ASSIGN .)
    LBRACKET        reduce using rule 34 (operator_assign -> LSHIFT_ASSIGN .)
    MAP             reduce using rule 34 (operator_assign -> LSHIFT_ASSIGN .)
=======
    (118) struct_type -> STRUCT LBRACE . RBRACE
    (119) struct_type -> STRUCT LBRACE . field_list RBRACE
    (120) field_list -> . field_declaration
    (121) field_list -> . field_list field_declaration
    (122) field_declaration -> . IDENTIFIER type
    (123) field_declaration -> . IDENTIFIER

    RBRACE          shift and go to state 256
    IDENTIFIER      shift and go to state 259

    field_list                     shift and go to state 257
    field_declaration              shift and go to state 258

state 228

    (80) slice_type -> LBRACKET RBRACKET . primitive_type
    (76) primitive_type -> . INT_TYPE
    (77) primitive_type -> . FLOAT64_TYPE
    (78) primitive_type -> . STRING_TYPE
    (79) primitive_type -> . BOOL_TYPE

    INT_TYPE        shift and go to state 171
    FLOAT64_TYPE    shift and go to state 172
    STRING_TYPE     shift and go to state 173
    BOOL_TYPE       shift and go to state 174
>>>>>>> Stashed changes

    primitive_type                 shift and go to state 260

state 229

<<<<<<< Updated upstream
    (35) operator_assign -> RSHIFT_ASSIGN .

    LPAREN          reduce using rule 35 (operator_assign -> RSHIFT_ASSIGN .)
    INT             reduce using rule 35 (operator_assign -> RSHIFT_ASSIGN .)
    FLOAT64         reduce using rule 35 (operator_assign -> RSHIFT_ASSIGN .)
    IDENTIFIER      reduce using rule 35 (operator_assign -> RSHIFT_ASSIGN .)
    STRING          reduce using rule 35 (operator_assign -> RSHIFT_ASSIGN .)
    TRUE            reduce using rule 35 (operator_assign -> RSHIFT_ASSIGN .)
    FALSE           reduce using rule 35 (operator_assign -> RSHIFT_ASSIGN .)
    LNOT            reduce using rule 35 (operator_assign -> RSHIFT_ASSIGN .)
    LBRACKET        reduce using rule 35 (operator_assign -> RSHIFT_ASSIGN .)
    MAP             reduce using rule 35 (operator_assign -> RSHIFT_ASSIGN .)
=======
    (81) array_type -> LBRACKET INT . RBRACKET type

    RBRACKET        shift and go to state 261
>>>>>>> Stashed changes


state 230

<<<<<<< Updated upstream
    (23) local_const_dec -> CONST IDENTIFIER . type ASSIGN expression
    (24) local_const_dec -> CONST IDENTIFIER . ASSIGN expression
    (57) type -> . primitive_type
    (58) type -> . slice_type
    (59) type -> . array_type
    (60) type -> . map_type
    (61) primitive_type -> . INT_TYPE
    (62) primitive_type -> . FLOAT64_TYPE
    (63) primitive_type -> . STRING_TYPE
    (64) primitive_type -> . BOOL_TYPE
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (197) array_type -> . LBRACKET INT RBRACKET primitive_type
    (137) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type

    ASSIGN          shift and go to state 268
    INT_TYPE        shift and go to state 34
    FLOAT64_TYPE    shift and go to state 35
    STRING_TYPE     shift and go to state 36
    BOOL_TYPE       shift and go to state 37
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    type                           shift and go to state 267
    primitive_type                 shift and go to state 30
    slice_type                     shift and go to state 31
    array_type                     shift and go to state 32
    map_type                       shift and go to state 33

state 231

    (128) if_statement -> IF expression . block
    (129) if_statement -> IF expression . block ELSE block
    (130) if_statement -> IF expression . block ELSE if_statement
    (36) expression -> expression . binary_operator expression
    (200) expression -> expression . DOT IDENTIFIER
    (201) expression -> expression . DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> expression . LBRACKET expression RBRACKET
    (90) block -> . LBRACE local_statement_list RBRACE
    (91) block -> . LBRACE RBRACE
    (37) binary_operator -> . PLUS
    (38) binary_operator -> . MINUS
    (39) binary_operator -> . TIMES
    (40) binary_operator -> . DIVIDE
    (41) binary_operator -> . MODULE
    (42) binary_operator -> . EQ
    (43) binary_operator -> . NEQ
    (44) binary_operator -> . LT
    (45) binary_operator -> . LE
    (46) binary_operator -> . GT
    (47) binary_operator -> . GE
    (48) binary_operator -> . LAND
    (49) binary_operator -> . LOR
    (50) binary_operator -> . AND
    (51) binary_operator -> . OR
    (52) binary_operator -> . XOR
    (53) binary_operator -> . AND_NOT
    (54) binary_operator -> . LSHIFT
    (55) binary_operator -> . RSHIFT

    DOT             shift and go to state 82
    LBRACKET        shift and go to state 83
    LBRACE          shift and go to state 175
    PLUS            shift and go to state 84
    MINUS           shift and go to state 85
    TIMES           shift and go to state 86
    DIVIDE          shift and go to state 87
    MODULE          shift and go to state 88
    EQ              shift and go to state 89
    NEQ             shift and go to state 90
    LT              shift and go to state 91
    LE              shift and go to state 92
    GT              shift and go to state 93
    GE              shift and go to state 94
    LAND            shift and go to state 95
    LOR             shift and go to state 96
    AND             shift and go to state 97
    OR              shift and go to state 98
    XOR             shift and go to state 99
    AND_NOT         shift and go to state 100
    LSHIFT          shift and go to state 101
    RSHIFT          shift and go to state 102

    block                          shift and go to state 269
    binary_operator                shift and go to state 81

state 232

    (131) if_statement -> IF if_assignment . SEMICOLON expression block
    (132) if_statement -> IF if_assignment . SEMICOLON expression block ELSE block
    (133) if_statement -> IF if_assignment . SEMICOLON expression block ELSE if_statement

    SEMICOLON       shift and go to state 270
=======
    (127) map_type -> MAP LBRACKET . primitive_type RBRACKET type
    (76) primitive_type -> . INT_TYPE
    (77) primitive_type -> . FLOAT64_TYPE
    (78) primitive_type -> . STRING_TYPE
    (79) primitive_type -> . BOOL_TYPE

    INT_TYPE        shift and go to state 171
    FLOAT64_TYPE    shift and go to state 172
    STRING_TYPE     shift and go to state 173
    BOOL_TYPE       shift and go to state 174

    primitive_type                 shift and go to state 262

state 231

    (66) variable_declaration -> VAR IDENTIFIER type ASSIGN . expression
    (82) expression -> . binary_expression
    (83) expression -> . relational_expression
    (84) expression -> . logical_expression
    (85) expression -> . bitwise_expression
    (86) expression -> . PLUS expression
    (87) expression -> . MINUS expression
    (88) expression -> . LNOT expression
    (89) expression -> . LBRACKET RBRACKET primitive_type LBRACE expression_list RBRACE
    (90) expression -> . LBRACKET RBRACKET primitive_type LBRACE RBRACE
    (91) expression -> . LPAREN expression RPAREN
    (92) expression -> . INT
    (93) expression -> . FLOAT64
    (94) expression -> . TRUE
    (95) expression -> . FALSE
    (96) expression -> . IDENTIFIER
    (97) expression -> . STRING
    (98) expression -> . IDENTIFIER PLUSPLUS
    (99) expression -> . IDENTIFIER MINUSMINUS
    (100) expression -> . expression DOT IDENTIFIER
    (103) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (133) expression -> . IDENTIFIER LBRACE keyed_element_list RBRACE
    (134) expression -> . IDENTIFIER LBRACE RBRACE
    (135) binary_expression -> . expression PLUS expression
    (136) binary_expression -> . expression MINUS expression
    (137) binary_expression -> . expression TIMES expression
    (138) binary_expression -> . expression DIVIDE expression
    (139) binary_expression -> . expression MODULE expression
    (144) relational_expression -> . expression EQ expression
    (145) relational_expression -> . expression NEQ expression
    (146) relational_expression -> . expression LT expression
    (147) relational_expression -> . expression LE expression
    (148) relational_expression -> . expression GT expression
    (149) relational_expression -> . expression GE expression
    (150) logical_expression -> . expression LAND expression
    (151) logical_expression -> . expression LOR expression
    (152) bitwise_expression -> . expression AND expression
    (153) bitwise_expression -> . expression OR expression
    (154) bitwise_expression -> . expression XOR expression
    (155) bitwise_expression -> . expression AND_NOT expression
    (156) bitwise_expression -> . expression LSHIFT expression
    (157) bitwise_expression -> . expression RSHIFT expression

    PLUS            shift and go to state 37
    MINUS           shift and go to state 38
    LNOT            shift and go to state 39
    LBRACKET        shift and go to state 40
    LPAREN          shift and go to state 29
    INT             shift and go to state 41
    FLOAT64         shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44
    IDENTIFIER      shift and go to state 97
    STRING          shift and go to state 11

    expression                     shift and go to state 263
    binary_expression              shift and go to state 33
    relational_expression          shift and go to state 34
    logical_expression             shift and go to state 35
    bitwise_expression             shift and go to state 36

state 232

    (68) variable_declaration -> VAR IDENTIFIER ASSIGN expression .
    (100) expression -> expression . DOT IDENTIFIER
    (135) binary_expression -> expression . PLUS expression
    (136) binary_expression -> expression . MINUS expression
    (137) binary_expression -> expression . TIMES expression
    (138) binary_expression -> expression . DIVIDE expression
    (139) binary_expression -> expression . MODULE expression
    (144) relational_expression -> expression . EQ expression
    (145) relational_expression -> expression . NEQ expression
    (146) relational_expression -> expression . LT expression
    (147) relational_expression -> expression . LE expression
    (148) relational_expression -> expression . GT expression
    (149) relational_expression -> expression . GE expression
    (150) logical_expression -> expression . LAND expression
    (151) logical_expression -> expression . LOR expression
    (152) bitwise_expression -> expression . AND expression
    (153) bitwise_expression -> expression . OR expression
    (154) bitwise_expression -> expression . XOR expression
    (155) bitwise_expression -> expression . AND_NOT expression
    (156) bitwise_expression -> expression . LSHIFT expression
    (157) bitwise_expression -> expression . RSHIFT expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    SEMICOLON       reduce using rule 68 (variable_declaration -> VAR IDENTIFIER ASSIGN expression .)
    FUNC            reduce using rule 68 (variable_declaration -> VAR IDENTIFIER ASSIGN expression .)
    TYPE            reduce using rule 68 (variable_declaration -> VAR IDENTIFIER ASSIGN expression .)
    IDENTIFIER      reduce using rule 68 (variable_declaration -> VAR IDENTIFIER ASSIGN expression .)
    VAR             reduce using rule 68 (variable_declaration -> VAR IDENTIFIER ASSIGN expression .)
    CONST           reduce using rule 68 (variable_declaration -> VAR IDENTIFIER ASSIGN expression .)
    LNOT            reduce using rule 68 (variable_declaration -> VAR IDENTIFIER ASSIGN expression .)
    LBRACKET        reduce using rule 68 (variable_declaration -> VAR IDENTIFIER ASSIGN expression .)
    LPAREN          reduce using rule 68 (variable_declaration -> VAR IDENTIFIER ASSIGN expression .)
    INT             reduce using rule 68 (variable_declaration -> VAR IDENTIFIER ASSIGN expression .)
    FLOAT64         reduce using rule 68 (variable_declaration -> VAR IDENTIFIER ASSIGN expression .)
    TRUE            reduce using rule 68 (variable_declaration -> VAR IDENTIFIER ASSIGN expression .)
    FALSE           reduce using rule 68 (variable_declaration -> VAR IDENTIFIER ASSIGN expression .)
    STRING          reduce using rule 68 (variable_declaration -> VAR IDENTIFIER ASSIGN expression .)
    RETURN          reduce using rule 68 (variable_declaration -> VAR IDENTIFIER ASSIGN expression .)
    FOR             reduce using rule 68 (variable_declaration -> VAR IDENTIFIER ASSIGN expression .)
    IF              reduce using rule 68 (variable_declaration -> VAR IDENTIFIER ASSIGN expression .)
    SWITCH          reduce using rule 68 (variable_declaration -> VAR IDENTIFIER ASSIGN expression .)
    BREAK           reduce using rule 68 (variable_declaration -> VAR IDENTIFIER ASSIGN expression .)
    CONTINUE        reduce using rule 68 (variable_declaration -> VAR IDENTIFIER ASSIGN expression .)
    FALLTHROUGH     reduce using rule 68 (variable_declaration -> VAR IDENTIFIER ASSIGN expression .)
    $end            reduce using rule 68 (variable_declaration -> VAR IDENTIFIER ASSIGN expression .)
    RBRACE          reduce using rule 68 (variable_declaration -> VAR IDENTIFIER ASSIGN expression .)
    CASE            reduce using rule 68 (variable_declaration -> VAR IDENTIFIER ASSIGN expression .)
    DEFAULT         reduce using rule 68 (variable_declaration -> VAR IDENTIFIER ASSIGN expression .)
    DOT             shift and go to state 58
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    TIMES           shift and go to state 61
    DIVIDE          shift and go to state 62
    MODULE          shift and go to state 63
    EQ              shift and go to state 64
    NEQ             shift and go to state 65
    LT              shift and go to state 66
    LE              shift and go to state 67
    GT              shift and go to state 68
    GE              shift and go to state 69
    LAND            shift and go to state 70
    LOR             shift and go to state 71
    AND             shift and go to state 72
    OR              shift and go to state 73
    XOR             shift and go to state 74
    AND_NOT         shift and go to state 75
    LSHIFT          shift and go to state 76
    RSHIFT          shift and go to state 77

  ! PLUS            [ reduce using rule 68 (variable_declaration -> VAR IDENTIFIER ASSIGN expression .) ]
  ! MINUS           [ reduce using rule 68 (variable_declaration -> VAR IDENTIFIER ASSIGN expression .) ]
>>>>>>> Stashed changes


state 233

<<<<<<< Updated upstream
    (73) expression -> IDENTIFIER .
    (126) expression -> IDENTIFIER . PLUSPLUS
    (127) expression -> IDENTIFIER . MINUSMINUS
    (203) expression -> IDENTIFIER . LPAREN argument_list RPAREN
    (163) type_name -> IDENTIFIER .
    (56) simple_assignment -> IDENTIFIER . ASSIGN expression
    (77) short_assignment -> IDENTIFIER . SHORT_ASSIGN expression

  ! reduce/reduce conflict for LBRACE resolved using rule 73 (expression -> IDENTIFIER .)
    DOT             reduce using rule 73 (expression -> IDENTIFIER .)
    LBRACKET        reduce using rule 73 (expression -> IDENTIFIER .)
    LBRACE          reduce using rule 73 (expression -> IDENTIFIER .)
    PLUS            reduce using rule 73 (expression -> IDENTIFIER .)
    MINUS           reduce using rule 73 (expression -> IDENTIFIER .)
    TIMES           reduce using rule 73 (expression -> IDENTIFIER .)
    DIVIDE          reduce using rule 73 (expression -> IDENTIFIER .)
    MODULE          reduce using rule 73 (expression -> IDENTIFIER .)
    EQ              reduce using rule 73 (expression -> IDENTIFIER .)
    NEQ             reduce using rule 73 (expression -> IDENTIFIER .)
    LT              reduce using rule 73 (expression -> IDENTIFIER .)
    LE              reduce using rule 73 (expression -> IDENTIFIER .)
    GT              reduce using rule 73 (expression -> IDENTIFIER .)
    GE              reduce using rule 73 (expression -> IDENTIFIER .)
    LAND            reduce using rule 73 (expression -> IDENTIFIER .)
    LOR             reduce using rule 73 (expression -> IDENTIFIER .)
    AND             reduce using rule 73 (expression -> IDENTIFIER .)
    OR              reduce using rule 73 (expression -> IDENTIFIER .)
    XOR             reduce using rule 73 (expression -> IDENTIFIER .)
    AND_NOT         reduce using rule 73 (expression -> IDENTIFIER .)
    LSHIFT          reduce using rule 73 (expression -> IDENTIFIER .)
    RSHIFT          reduce using rule 73 (expression -> IDENTIFIER .)
    PLUSPLUS        shift and go to state 78
    MINUSMINUS      shift and go to state 79
    LPAREN          shift and go to state 80
    ASSIGN          shift and go to state 218
    SHORT_ASSIGN    shift and go to state 217

  ! LBRACE          [ reduce using rule 163 (type_name -> IDENTIFIER .) ]
=======
    (67) variable_declaration -> CONST IDENTIFIER type ASSIGN . expression
    (82) expression -> . binary_expression
    (83) expression -> . relational_expression
    (84) expression -> . logical_expression
    (85) expression -> . bitwise_expression
    (86) expression -> . PLUS expression
    (87) expression -> . MINUS expression
    (88) expression -> . LNOT expression
    (89) expression -> . LBRACKET RBRACKET primitive_type LBRACE expression_list RBRACE
    (90) expression -> . LBRACKET RBRACKET primitive_type LBRACE RBRACE
    (91) expression -> . LPAREN expression RPAREN
    (92) expression -> . INT
    (93) expression -> . FLOAT64
    (94) expression -> . TRUE
    (95) expression -> . FALSE
    (96) expression -> . IDENTIFIER
    (97) expression -> . STRING
    (98) expression -> . IDENTIFIER PLUSPLUS
    (99) expression -> . IDENTIFIER MINUSMINUS
    (100) expression -> . expression DOT IDENTIFIER
    (103) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (133) expression -> . IDENTIFIER LBRACE keyed_element_list RBRACE
    (134) expression -> . IDENTIFIER LBRACE RBRACE
    (135) binary_expression -> . expression PLUS expression
    (136) binary_expression -> . expression MINUS expression
    (137) binary_expression -> . expression TIMES expression
    (138) binary_expression -> . expression DIVIDE expression
    (139) binary_expression -> . expression MODULE expression
    (144) relational_expression -> . expression EQ expression
    (145) relational_expression -> . expression NEQ expression
    (146) relational_expression -> . expression LT expression
    (147) relational_expression -> . expression LE expression
    (148) relational_expression -> . expression GT expression
    (149) relational_expression -> . expression GE expression
    (150) logical_expression -> . expression LAND expression
    (151) logical_expression -> . expression LOR expression
    (152) bitwise_expression -> . expression AND expression
    (153) bitwise_expression -> . expression OR expression
    (154) bitwise_expression -> . expression XOR expression
    (155) bitwise_expression -> . expression AND_NOT expression
    (156) bitwise_expression -> . expression LSHIFT expression
    (157) bitwise_expression -> . expression RSHIFT expression

    PLUS            shift and go to state 37
    MINUS           shift and go to state 38
    LNOT            shift and go to state 39
    LBRACKET        shift and go to state 40
    LPAREN          shift and go to state 29
    INT             shift and go to state 41
    FLOAT64         shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44
    IDENTIFIER      shift and go to state 97
    STRING          shift and go to state 11
>>>>>>> Stashed changes

    expression                     shift and go to state 264
    binary_expression              shift and go to state 33
    relational_expression          shift and go to state 34
    logical_expression             shift and go to state 35
    bitwise_expression             shift and go to state 36

state 234

<<<<<<< Updated upstream
    (134) if_assignment -> simple_assignment .

    SEMICOLON       reduce using rule 134 (if_assignment -> simple_assignment .)
=======
    (69) variable_declaration -> CONST IDENTIFIER ASSIGN expression .
    (100) expression -> expression . DOT IDENTIFIER
    (135) binary_expression -> expression . PLUS expression
    (136) binary_expression -> expression . MINUS expression
    (137) binary_expression -> expression . TIMES expression
    (138) binary_expression -> expression . DIVIDE expression
    (139) binary_expression -> expression . MODULE expression
    (144) relational_expression -> expression . EQ expression
    (145) relational_expression -> expression . NEQ expression
    (146) relational_expression -> expression . LT expression
    (147) relational_expression -> expression . LE expression
    (148) relational_expression -> expression . GT expression
    (149) relational_expression -> expression . GE expression
    (150) logical_expression -> expression . LAND expression
    (151) logical_expression -> expression . LOR expression
    (152) bitwise_expression -> expression . AND expression
    (153) bitwise_expression -> expression . OR expression
    (154) bitwise_expression -> expression . XOR expression
    (155) bitwise_expression -> expression . AND_NOT expression
    (156) bitwise_expression -> expression . LSHIFT expression
    (157) bitwise_expression -> expression . RSHIFT expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    SEMICOLON       reduce using rule 69 (variable_declaration -> CONST IDENTIFIER ASSIGN expression .)
    FUNC            reduce using rule 69 (variable_declaration -> CONST IDENTIFIER ASSIGN expression .)
    TYPE            reduce using rule 69 (variable_declaration -> CONST IDENTIFIER ASSIGN expression .)
    IDENTIFIER      reduce using rule 69 (variable_declaration -> CONST IDENTIFIER ASSIGN expression .)
    VAR             reduce using rule 69 (variable_declaration -> CONST IDENTIFIER ASSIGN expression .)
    CONST           reduce using rule 69 (variable_declaration -> CONST IDENTIFIER ASSIGN expression .)
    LNOT            reduce using rule 69 (variable_declaration -> CONST IDENTIFIER ASSIGN expression .)
    LBRACKET        reduce using rule 69 (variable_declaration -> CONST IDENTIFIER ASSIGN expression .)
    LPAREN          reduce using rule 69 (variable_declaration -> CONST IDENTIFIER ASSIGN expression .)
    INT             reduce using rule 69 (variable_declaration -> CONST IDENTIFIER ASSIGN expression .)
    FLOAT64         reduce using rule 69 (variable_declaration -> CONST IDENTIFIER ASSIGN expression .)
    TRUE            reduce using rule 69 (variable_declaration -> CONST IDENTIFIER ASSIGN expression .)
    FALSE           reduce using rule 69 (variable_declaration -> CONST IDENTIFIER ASSIGN expression .)
    STRING          reduce using rule 69 (variable_declaration -> CONST IDENTIFIER ASSIGN expression .)
    RETURN          reduce using rule 69 (variable_declaration -> CONST IDENTIFIER ASSIGN expression .)
    FOR             reduce using rule 69 (variable_declaration -> CONST IDENTIFIER ASSIGN expression .)
    IF              reduce using rule 69 (variable_declaration -> CONST IDENTIFIER ASSIGN expression .)
    SWITCH          reduce using rule 69 (variable_declaration -> CONST IDENTIFIER ASSIGN expression .)
    BREAK           reduce using rule 69 (variable_declaration -> CONST IDENTIFIER ASSIGN expression .)
    CONTINUE        reduce using rule 69 (variable_declaration -> CONST IDENTIFIER ASSIGN expression .)
    FALLTHROUGH     reduce using rule 69 (variable_declaration -> CONST IDENTIFIER ASSIGN expression .)
    $end            reduce using rule 69 (variable_declaration -> CONST IDENTIFIER ASSIGN expression .)
    RBRACE          reduce using rule 69 (variable_declaration -> CONST IDENTIFIER ASSIGN expression .)
    CASE            reduce using rule 69 (variable_declaration -> CONST IDENTIFIER ASSIGN expression .)
    DEFAULT         reduce using rule 69 (variable_declaration -> CONST IDENTIFIER ASSIGN expression .)
    DOT             shift and go to state 58
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    TIMES           shift and go to state 61
    DIVIDE          shift and go to state 62
    MODULE          shift and go to state 63
    EQ              shift and go to state 64
    NEQ             shift and go to state 65
    LT              shift and go to state 66
    LE              shift and go to state 67
    GT              shift and go to state 68
    GE              shift and go to state 69
    LAND            shift and go to state 70
    LOR             shift and go to state 71
    AND             shift and go to state 72
    OR              shift and go to state 73
    XOR             shift and go to state 74
    AND_NOT         shift and go to state 75
    LSHIFT          shift and go to state 76
    RSHIFT          shift and go to state 77

  ! PLUS            [ reduce using rule 69 (variable_declaration -> CONST IDENTIFIER ASSIGN expression .) ]
  ! MINUS           [ reduce using rule 69 (variable_declaration -> CONST IDENTIFIER ASSIGN expression .) ]
>>>>>>> Stashed changes


state 235

<<<<<<< Updated upstream
    (135) if_assignment -> short_assignment .

    SEMICOLON       reduce using rule 135 (if_assignment -> short_assignment .)


state 236

    (136) if_assignment -> local_var_dec .

    SEMICOLON       reduce using rule 136 (if_assignment -> local_var_dec .)
=======
    (89) expression -> LBRACKET RBRACKET primitive_type LBRACE . expression_list RBRACE
    (90) expression -> LBRACKET RBRACKET primitive_type LBRACE . RBRACE
    (101) expression_list -> . expression_list COMMA expression
    (102) expression_list -> . expression
    (82) expression -> . binary_expression
    (83) expression -> . relational_expression
    (84) expression -> . logical_expression
    (85) expression -> . bitwise_expression
    (86) expression -> . PLUS expression
    (87) expression -> . MINUS expression
    (88) expression -> . LNOT expression
    (89) expression -> . LBRACKET RBRACKET primitive_type LBRACE expression_list RBRACE
    (90) expression -> . LBRACKET RBRACKET primitive_type LBRACE RBRACE
    (91) expression -> . LPAREN expression RPAREN
    (92) expression -> . INT
    (93) expression -> . FLOAT64
    (94) expression -> . TRUE
    (95) expression -> . FALSE
    (96) expression -> . IDENTIFIER
    (97) expression -> . STRING
    (98) expression -> . IDENTIFIER PLUSPLUS
    (99) expression -> . IDENTIFIER MINUSMINUS
    (100) expression -> . expression DOT IDENTIFIER
    (103) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (133) expression -> . IDENTIFIER LBRACE keyed_element_list RBRACE
    (134) expression -> . IDENTIFIER LBRACE RBRACE
    (135) binary_expression -> . expression PLUS expression
    (136) binary_expression -> . expression MINUS expression
    (137) binary_expression -> . expression TIMES expression
    (138) binary_expression -> . expression DIVIDE expression
    (139) binary_expression -> . expression MODULE expression
    (144) relational_expression -> . expression EQ expression
    (145) relational_expression -> . expression NEQ expression
    (146) relational_expression -> . expression LT expression
    (147) relational_expression -> . expression LE expression
    (148) relational_expression -> . expression GT expression
    (149) relational_expression -> . expression GE expression
    (150) logical_expression -> . expression LAND expression
    (151) logical_expression -> . expression LOR expression
    (152) bitwise_expression -> . expression AND expression
    (153) bitwise_expression -> . expression OR expression
    (154) bitwise_expression -> . expression XOR expression
    (155) bitwise_expression -> . expression AND_NOT expression
    (156) bitwise_expression -> . expression LSHIFT expression
    (157) bitwise_expression -> . expression RSHIFT expression

    RBRACE          shift and go to state 266
    PLUS            shift and go to state 37
    MINUS           shift and go to state 38
    LNOT            shift and go to state 39
    LBRACKET        shift and go to state 40
    LPAREN          shift and go to state 29
    INT             shift and go to state 41
    FLOAT64         shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44
    IDENTIFIER      shift and go to state 97
    STRING          shift and go to state 11

    expression_list                shift and go to state 265
    expression                     shift and go to state 156
    binary_expression              shift and go to state 33
    relational_expression          shift and go to state 34
    logical_expression             shift and go to state 35
    bitwise_expression             shift and go to state 36

state 236

    (42) return_list -> return_list COMMA expression .
    (100) expression -> expression . DOT IDENTIFIER
    (135) binary_expression -> expression . PLUS expression
    (136) binary_expression -> expression . MINUS expression
    (137) binary_expression -> expression . TIMES expression
    (138) binary_expression -> expression . DIVIDE expression
    (139) binary_expression -> expression . MODULE expression
    (144) relational_expression -> expression . EQ expression
    (145) relational_expression -> expression . NEQ expression
    (146) relational_expression -> expression . LT expression
    (147) relational_expression -> expression . LE expression
    (148) relational_expression -> expression . GT expression
    (149) relational_expression -> expression . GE expression
    (150) logical_expression -> expression . LAND expression
    (151) logical_expression -> expression . LOR expression
    (152) bitwise_expression -> expression . AND expression
    (153) bitwise_expression -> expression . OR expression
    (154) bitwise_expression -> expression . XOR expression
    (155) bitwise_expression -> expression . AND_NOT expression
    (156) bitwise_expression -> expression . LSHIFT expression
    (157) bitwise_expression -> expression . RSHIFT expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    COMMA           reduce using rule 42 (return_list -> return_list COMMA expression .)
    SEMICOLON       reduce using rule 42 (return_list -> return_list COMMA expression .)
    FUNC            reduce using rule 42 (return_list -> return_list COMMA expression .)
    TYPE            reduce using rule 42 (return_list -> return_list COMMA expression .)
    IDENTIFIER      reduce using rule 42 (return_list -> return_list COMMA expression .)
    VAR             reduce using rule 42 (return_list -> return_list COMMA expression .)
    CONST           reduce using rule 42 (return_list -> return_list COMMA expression .)
    LNOT            reduce using rule 42 (return_list -> return_list COMMA expression .)
    LBRACKET        reduce using rule 42 (return_list -> return_list COMMA expression .)
    LPAREN          reduce using rule 42 (return_list -> return_list COMMA expression .)
    INT             reduce using rule 42 (return_list -> return_list COMMA expression .)
    FLOAT64         reduce using rule 42 (return_list -> return_list COMMA expression .)
    TRUE            reduce using rule 42 (return_list -> return_list COMMA expression .)
    FALSE           reduce using rule 42 (return_list -> return_list COMMA expression .)
    STRING          reduce using rule 42 (return_list -> return_list COMMA expression .)
    RETURN          reduce using rule 42 (return_list -> return_list COMMA expression .)
    FOR             reduce using rule 42 (return_list -> return_list COMMA expression .)
    IF              reduce using rule 42 (return_list -> return_list COMMA expression .)
    SWITCH          reduce using rule 42 (return_list -> return_list COMMA expression .)
    BREAK           reduce using rule 42 (return_list -> return_list COMMA expression .)
    CONTINUE        reduce using rule 42 (return_list -> return_list COMMA expression .)
    FALLTHROUGH     reduce using rule 42 (return_list -> return_list COMMA expression .)
    $end            reduce using rule 42 (return_list -> return_list COMMA expression .)
    RBRACE          reduce using rule 42 (return_list -> return_list COMMA expression .)
    CASE            reduce using rule 42 (return_list -> return_list COMMA expression .)
    DEFAULT         reduce using rule 42 (return_list -> return_list COMMA expression .)
    DOT             shift and go to state 58
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    TIMES           shift and go to state 61
    DIVIDE          shift and go to state 62
    MODULE          shift and go to state 63
    EQ              shift and go to state 64
    NEQ             shift and go to state 65
    LT              shift and go to state 66
    LE              shift and go to state 67
    GT              shift and go to state 68
    GE              shift and go to state 69
    LAND            shift and go to state 70
    LOR             shift and go to state 71
    AND             shift and go to state 72
    OR              shift and go to state 73
    XOR             shift and go to state 74
    AND_NOT         shift and go to state 75
    LSHIFT          shift and go to state 76
    RSHIFT          shift and go to state 77

  ! PLUS            [ reduce using rule 42 (return_list -> return_list COMMA expression .) ]
  ! MINUS           [ reduce using rule 42 (return_list -> return_list COMMA expression .) ]
>>>>>>> Stashed changes


state 237

<<<<<<< Updated upstream
    (167) switch_statement -> SWITCH switch_expr . LBRACE case_clause_list RBRACE
    (168) switch_statement -> SWITCH switch_expr . LBRACE RBRACE

    LBRACE          shift and go to state 271
=======
    (16) block -> LBRACE enter_block exit_block . RBRACE

    RBRACE          shift and go to state 267
>>>>>>> Stashed changes


state 238

<<<<<<< Updated upstream
    (169) switch_statement -> SWITCH LBRACE . case_clause_list RBRACE
    (170) switch_statement -> SWITCH LBRACE . RBRACE
    (186) case_clause_list -> . case_clause
    (187) case_clause_list -> . case_clause_list case_clause
    (191) case_clause -> . CASE case_expression_list COLON case_body
    (192) case_clause -> . DEFAULT COLON case_body

    RBRACE          shift and go to state 273
    CASE            shift and go to state 275
    DEFAULT         shift and go to state 276

    case_clause_list               shift and go to state 272
    case_clause                    shift and go to state 274

state 239

    (171) switch_statement -> SWITCH switch_assignment . SEMICOLON switch_expr LBRACE case_clause_list RBRACE
    (172) switch_statement -> SWITCH switch_assignment . SEMICOLON switch_expr LBRACE RBRACE
    (173) switch_statement -> SWITCH switch_assignment . SEMICOLON LBRACE case_clause_list RBRACE
    (174) switch_statement -> SWITCH switch_assignment . SEMICOLON LBRACE RBRACE

    SEMICOLON       shift and go to state 277
=======
    (17) block -> LBRACE enter_block statement_list . exit_block RBRACE
    (19) statement_list -> statement_list . optional_semicolon statement
    (168) exit_block -> .
    (8) optional_semicolon -> . SEMICOLON
    (9) optional_semicolon -> . empty
    (7) empty -> .

    RBRACE          reduce using rule 168 (exit_block -> .)
    SEMICOLON       shift and go to state 53
    IDENTIFIER      reduce using rule 7 (empty -> .)
    VAR             reduce using rule 7 (empty -> .)
    CONST           reduce using rule 7 (empty -> .)
    PLUS            reduce using rule 7 (empty -> .)
    MINUS           reduce using rule 7 (empty -> .)
    LNOT            reduce using rule 7 (empty -> .)
    LBRACKET        reduce using rule 7 (empty -> .)
    LPAREN          reduce using rule 7 (empty -> .)
    INT             reduce using rule 7 (empty -> .)
    FLOAT64         reduce using rule 7 (empty -> .)
    TRUE            reduce using rule 7 (empty -> .)
    FALSE           reduce using rule 7 (empty -> .)
    STRING          reduce using rule 7 (empty -> .)
    RETURN          reduce using rule 7 (empty -> .)
    FOR             reduce using rule 7 (empty -> .)
    IF              reduce using rule 7 (empty -> .)
    SWITCH          reduce using rule 7 (empty -> .)
    BREAK           reduce using rule 7 (empty -> .)
    CONTINUE        reduce using rule 7 (empty -> .)
    FALLTHROUGH     reduce using rule 7 (empty -> .)

    exit_block                     shift and go to state 268
    optional_semicolon             shift and go to state 269
    empty                          shift and go to state 54

state 239

    (18) statement_list -> statement .

    SEMICOLON       reduce using rule 18 (statement_list -> statement .)
    RBRACE          reduce using rule 18 (statement_list -> statement .)
    IDENTIFIER      reduce using rule 18 (statement_list -> statement .)
    VAR             reduce using rule 18 (statement_list -> statement .)
    CONST           reduce using rule 18 (statement_list -> statement .)
    PLUS            reduce using rule 18 (statement_list -> statement .)
    MINUS           reduce using rule 18 (statement_list -> statement .)
    LNOT            reduce using rule 18 (statement_list -> statement .)
    LBRACKET        reduce using rule 18 (statement_list -> statement .)
    LPAREN          reduce using rule 18 (statement_list -> statement .)
    INT             reduce using rule 18 (statement_list -> statement .)
    FLOAT64         reduce using rule 18 (statement_list -> statement .)
    TRUE            reduce using rule 18 (statement_list -> statement .)
    FALSE           reduce using rule 18 (statement_list -> statement .)
    STRING          reduce using rule 18 (statement_list -> statement .)
    RETURN          reduce using rule 18 (statement_list -> statement .)
    FOR             reduce using rule 18 (statement_list -> statement .)
    IF              reduce using rule 18 (statement_list -> statement .)
    SWITCH          reduce using rule 18 (statement_list -> statement .)
    BREAK           reduce using rule 18 (statement_list -> statement .)
    CONTINUE        reduce using rule 18 (statement_list -> statement .)
    FALLTHROUGH     reduce using rule 18 (statement_list -> statement .)
    CASE            reduce using rule 18 (statement_list -> statement .)
    DEFAULT         reduce using rule 18 (statement_list -> statement .)
>>>>>>> Stashed changes


state 240

<<<<<<< Updated upstream
    (175) switch_expr -> primary_expression .
    (184) primary_expression -> primary_expression . DOT IDENTIFIER
    (185) primary_expression -> primary_expression . LBRACKET expression RBRACKET

    LBRACE          reduce using rule 175 (switch_expr -> primary_expression .)
    DOT             shift and go to state 278
    LBRACKET        shift and go to state 279
=======
    (36) for_clause -> assignment SEMICOLON expression . SEMICOLON assignment
    (100) expression -> expression . DOT IDENTIFIER
    (135) binary_expression -> expression . PLUS expression
    (136) binary_expression -> expression . MINUS expression
    (137) binary_expression -> expression . TIMES expression
    (138) binary_expression -> expression . DIVIDE expression
    (139) binary_expression -> expression . MODULE expression
    (144) relational_expression -> expression . EQ expression
    (145) relational_expression -> expression . NEQ expression
    (146) relational_expression -> expression . LT expression
    (147) relational_expression -> expression . LE expression
    (148) relational_expression -> expression . GT expression
    (149) relational_expression -> expression . GE expression
    (150) logical_expression -> expression . LAND expression
    (151) logical_expression -> expression . LOR expression
    (152) bitwise_expression -> expression . AND expression
    (153) bitwise_expression -> expression . OR expression
    (154) bitwise_expression -> expression . XOR expression
    (155) bitwise_expression -> expression . AND_NOT expression
    (156) bitwise_expression -> expression . LSHIFT expression
    (157) bitwise_expression -> expression . RSHIFT expression

    SEMICOLON       shift and go to state 270
    DOT             shift and go to state 58
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    TIMES           shift and go to state 61
    DIVIDE          shift and go to state 62
    MODULE          shift and go to state 63
    EQ              shift and go to state 64
    NEQ             shift and go to state 65
    LT              shift and go to state 66
    LE              shift and go to state 67
    GT              shift and go to state 68
    GE              shift and go to state 69
    LAND            shift and go to state 70
    LOR             shift and go to state 71
    AND             shift and go to state 72
    OR              shift and go to state 73
    XOR             shift and go to state 74
    AND_NOT         shift and go to state 75
    LSHIFT          shift and go to state 76
    RSHIFT          shift and go to state 77
>>>>>>> Stashed changes


state 241

<<<<<<< Updated upstream
    (188) switch_assignment -> simple_assignment .

    SEMICOLON       reduce using rule 188 (switch_assignment -> simple_assignment .)


state 242

    (189) switch_assignment -> short_assignment .

    SEMICOLON       reduce using rule 189 (switch_assignment -> short_assignment .)
=======
    (37) for_clause -> SEMICOLON expression SEMICOLON . assignment
    (38) for_clause -> SEMICOLON expression SEMICOLON .
    (54) assignment -> . IDENTIFIER ASSIGN expression
    (55) assignment -> . IDENTIFIER SHORT_ASSIGN expression

    LBRACE          reduce using rule 38 (for_clause -> SEMICOLON expression SEMICOLON .)
    IDENTIFIER      shift and go to state 272

    assignment                     shift and go to state 271

state 242

    (107) if_statement -> IF expression block ELSE . block
    (108) if_statement -> IF expression block ELSE . if_statement
    (16) block -> . LBRACE enter_block exit_block RBRACE
    (17) block -> . LBRACE enter_block statement_list exit_block RBRACE
    (106) if_statement -> . IF expression block
    (107) if_statement -> . IF expression block ELSE block
    (108) if_statement -> . IF expression block ELSE if_statement
    (109) if_statement -> . IF assignment SEMICOLON expression block
    (110) if_statement -> . IF assignment SEMICOLON expression block ELSE block
    (111) if_statement -> . IF assignment SEMICOLON expression block ELSE if_statement

    LBRACE          shift and go to state 110
    IF              shift and go to state 47
>>>>>>> Stashed changes

    block                          shift and go to state 273
    if_statement                   shift and go to state 274

state 243

<<<<<<< Updated upstream
    (190) switch_assignment -> local_var_dec .

    SEMICOLON       reduce using rule 190 (switch_assignment -> local_var_dec .)
=======
    (109) if_statement -> IF assignment SEMICOLON expression . block
    (110) if_statement -> IF assignment SEMICOLON expression . block ELSE block
    (111) if_statement -> IF assignment SEMICOLON expression . block ELSE if_statement
    (100) expression -> expression . DOT IDENTIFIER
    (135) binary_expression -> expression . PLUS expression
    (136) binary_expression -> expression . MINUS expression
    (137) binary_expression -> expression . TIMES expression
    (138) binary_expression -> expression . DIVIDE expression
    (139) binary_expression -> expression . MODULE expression
    (144) relational_expression -> expression . EQ expression
    (145) relational_expression -> expression . NEQ expression
    (146) relational_expression -> expression . LT expression
    (147) relational_expression -> expression . LE expression
    (148) relational_expression -> expression . GT expression
    (149) relational_expression -> expression . GE expression
    (150) logical_expression -> expression . LAND expression
    (151) logical_expression -> expression . LOR expression
    (152) bitwise_expression -> expression . AND expression
    (153) bitwise_expression -> expression . OR expression
    (154) bitwise_expression -> expression . XOR expression
    (155) bitwise_expression -> expression . AND_NOT expression
    (156) bitwise_expression -> expression . LSHIFT expression
    (157) bitwise_expression -> expression . RSHIFT expression
    (16) block -> . LBRACE enter_block exit_block RBRACE
    (17) block -> . LBRACE enter_block statement_list exit_block RBRACE

    DOT             shift and go to state 58
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    TIMES           shift and go to state 61
    DIVIDE          shift and go to state 62
    MODULE          shift and go to state 63
    EQ              shift and go to state 64
    NEQ             shift and go to state 65
    LT              shift and go to state 66
    LE              shift and go to state 67
    GT              shift and go to state 68
    GE              shift and go to state 69
    LAND            shift and go to state 70
    LOR             shift and go to state 71
    AND             shift and go to state 72
    OR              shift and go to state 73
    XOR             shift and go to state 74
    AND_NOT         shift and go to state 75
    LSHIFT          shift and go to state 76
    RSHIFT          shift and go to state 77
    LBRACE          shift and go to state 110
>>>>>>> Stashed changes

    block                          shift and go to state 275

state 244

<<<<<<< Updated upstream
    (176) primary_expression -> IDENTIFIER .
    (183) primary_expression -> IDENTIFIER . LPAREN argument_list RPAREN
    (56) simple_assignment -> IDENTIFIER . ASSIGN expression
    (77) short_assignment -> IDENTIFIER . SHORT_ASSIGN expression

    DOT             reduce using rule 176 (primary_expression -> IDENTIFIER .)
    LBRACKET        reduce using rule 176 (primary_expression -> IDENTIFIER .)
    LBRACE          reduce using rule 176 (primary_expression -> IDENTIFIER .)
    LPAREN          shift and go to state 280
    ASSIGN          shift and go to state 218
    SHORT_ASSIGN    shift and go to state 217
=======
    (189) switch_statement -> SWITCH enter_block switch_header LBRACE . case_clauses RBRACE exit_block
    (171) case_clauses -> . case_clause
    (172) case_clauses -> . case_clauses case_clause
    (173) case_clause -> . CASE case_expression_list COLON enter_block case_body exit_block
    (174) case_clause -> . DEFAULT COLON enter_block case_body exit_block

    CASE            shift and go to state 278
    DEFAULT         shift and go to state 279
>>>>>>> Stashed changes

    case_clauses                   shift and go to state 276
    case_clause                    shift and go to state 277

state 245

<<<<<<< Updated upstream
    (177) primary_expression -> INT .

    DOT             reduce using rule 177 (primary_expression -> INT .)
    LBRACKET        reduce using rule 177 (primary_expression -> INT .)
    LBRACE          reduce using rule 177 (primary_expression -> INT .)
=======
    (184) switch_init -> assignment SEMICOLON . switch_expression
    (185) switch_expression -> . switch_primary
    (186) switch_expression -> . empty
    (178) switch_primary -> . IDENTIFIER
    (179) switch_primary -> . INT
    (180) switch_primary -> . FLOAT64
    (181) switch_primary -> . STRING
    (182) switch_primary -> . TRUE
    (183) switch_primary -> . FALSE
    (7) empty -> .

    IDENTIFIER      shift and go to state 281
    INT             shift and go to state 203
    FLOAT64         shift and go to state 204
    STRING          shift and go to state 205
    TRUE            shift and go to state 206
    FALSE           shift and go to state 207
    LBRACE          reduce using rule 7 (empty -> .)
>>>>>>> Stashed changes

    switch_expression              shift and go to state 280
    switch_primary                 shift and go to state 199
    empty                          shift and go to state 200

state 246

<<<<<<< Updated upstream
    (178) primary_expression -> FLOAT64 .

    DOT             reduce using rule 178 (primary_expression -> FLOAT64 .)
    LBRACKET        reduce using rule 178 (primary_expression -> FLOAT64 .)
    LBRACE          reduce using rule 178 (primary_expression -> FLOAT64 .)
=======
    (47) parameter -> IDENTIFIER type .

    RPAREN          reduce using rule 47 (parameter -> IDENTIFIER type .)
    COMMA           reduce using rule 47 (parameter -> IDENTIFIER type .)
>>>>>>> Stashed changes


state 247

<<<<<<< Updated upstream
    (179) primary_expression -> STRING .

    DOT             reduce using rule 179 (primary_expression -> STRING .)
    LBRACKET        reduce using rule 179 (primary_expression -> STRING .)
    LBRACE          reduce using rule 179 (primary_expression -> STRING .)
=======
    (48) parameter -> IDENTIFIER ELLIPSIS . primitive_type
    (76) primitive_type -> . INT_TYPE
    (77) primitive_type -> . FLOAT64_TYPE
    (78) primitive_type -> . STRING_TYPE
    (79) primitive_type -> . BOOL_TYPE

    INT_TYPE        shift and go to state 171
    FLOAT64_TYPE    shift and go to state 172
    STRING_TYPE     shift and go to state 173
    BOOL_TYPE       shift and go to state 174
>>>>>>> Stashed changes

    primitive_type                 shift and go to state 282

state 248

<<<<<<< Updated upstream
    (180) primary_expression -> TRUE .

    DOT             reduce using rule 180 (primary_expression -> TRUE .)
    LBRACKET        reduce using rule 180 (primary_expression -> TRUE .)
    LBRACE          reduce using rule 180 (primary_expression -> TRUE .)
=======
    (43) function_declaration -> FUNC IDENTIFIER LPAREN parameter_list RPAREN . return_type block
    (49) return_type -> . type
    (50) return_type -> . LPAREN type_list RPAREN
    (51) return_type -> . empty
    (70) type -> . primitive_type
    (71) type -> . slice_type
    (72) type -> . array_type
    (73) type -> . map_type
    (74) type -> . struct_type
    (75) type -> . IDENTIFIER
    (7) empty -> .
    (76) primitive_type -> . INT_TYPE
    (77) primitive_type -> . FLOAT64_TYPE
    (78) primitive_type -> . STRING_TYPE
    (79) primitive_type -> . BOOL_TYPE
    (80) slice_type -> . LBRACKET RBRACKET primitive_type
    (81) array_type -> . LBRACKET INT RBRACKET type
    (127) map_type -> . MAP LBRACKET primitive_type RBRACKET type
    (118) struct_type -> . STRUCT LBRACE RBRACE
    (119) struct_type -> . STRUCT LBRACE field_list RBRACE

    LPAREN          shift and go to state 283
    IDENTIFIER      shift and go to state 177
    LBRACE          reduce using rule 7 (empty -> .)
    INT_TYPE        shift and go to state 171
    FLOAT64_TYPE    shift and go to state 172
    STRING_TYPE     shift and go to state 173
    BOOL_TYPE       shift and go to state 174
    LBRACKET        shift and go to state 175
    MAP             shift and go to state 176
    STRUCT          shift and go to state 170
>>>>>>> Stashed changes

    return_type                    shift and go to state 284
    type                           shift and go to state 285
    empty                          shift and go to state 286
    primitive_type                 shift and go to state 180
    slice_type                     shift and go to state 181
    array_type                     shift and go to state 182
    map_type                       shift and go to state 183
    struct_type                    shift and go to state 184

state 249

<<<<<<< Updated upstream
    (181) primary_expression -> FALSE .

    DOT             reduce using rule 181 (primary_expression -> FALSE .)
    LBRACKET        reduce using rule 181 (primary_expression -> FALSE .)
    LBRACE          reduce using rule 181 (primary_expression -> FALSE .)
=======
    (44) parameter_list -> parameter_list COMMA . parameter
    (47) parameter -> . IDENTIFIER type
    (48) parameter -> . IDENTIFIER ELLIPSIS primitive_type

    IDENTIFIER      shift and go to state 208
>>>>>>> Stashed changes

    parameter                      shift and go to state 287

state 250

<<<<<<< Updated upstream
    (182) primary_expression -> LPAREN . expression RPAREN
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (125) expression -> . LNOT expression
    (126) expression -> . IDENTIFIER PLUSPLUS
    (127) expression -> . IDENTIFIER MINUSMINUS
    (138) expression -> . map_type LBRACE expression_map_list RBRACE
    (139) expression -> . map_type LBRACE RBRACE
    (161) expression -> . type_name LBRACE keyed_element_list RBRACE
    (162) expression -> . type_name LBRACE RBRACE
    (198) expression -> . array_type LBRACE expression_list RBRACE
    (199) expression -> . array_type LBRACE RBRACE
    (200) expression -> . expression DOT IDENTIFIER
    (201) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> . expression LBRACKET expression RBRACKET
    (203) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (137) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (163) type_name -> . IDENTIFIER
    (164) type_name -> . slice_type
    (165) type_name -> . array_type
    (166) type_name -> . map_type
    (197) array_type -> . LBRACKET INT RBRACKET primitive_type

    LPAREN          shift and go to state 54
    INT             shift and go to state 55
    FLOAT64         shift and go to state 56
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 57
    TRUE            shift and go to state 58
    FALSE           shift and go to state 59
    LNOT            shift and go to state 60
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39
=======
    (124) method_declaration -> FUNC LPAREN receiver RPAREN IDENTIFIER . LPAREN parameter_list RPAREN return_type block

    LPAREN          shift and go to state 288
>>>>>>> Stashed changes

    expression                     shift and go to state 281
    slice_type                     shift and go to state 53
    map_type                       shift and go to state 61
    type_name                      shift and go to state 62
    array_type                     shift and go to state 63

state 251

<<<<<<< Updated upstream
    (124) return_statement -> RETURN return_list .
    (111) return_list -> return_list . COMMA expression

    RBRACE          reduce using rule 124 (return_statement -> RETURN return_list .)
    BREAK           reduce using rule 124 (return_statement -> RETURN return_list .)
    CONTINUE        reduce using rule 124 (return_statement -> RETURN return_list .)
    VAR             reduce using rule 124 (return_statement -> RETURN return_list .)
    CONST           reduce using rule 124 (return_statement -> RETURN return_list .)
    IDENTIFIER      reduce using rule 124 (return_statement -> RETURN return_list .)
    LPAREN          reduce using rule 124 (return_statement -> RETURN return_list .)
    INT             reduce using rule 124 (return_statement -> RETURN return_list .)
    FLOAT64         reduce using rule 124 (return_statement -> RETURN return_list .)
    STRING          reduce using rule 124 (return_statement -> RETURN return_list .)
    TRUE            reduce using rule 124 (return_statement -> RETURN return_list .)
    FALSE           reduce using rule 124 (return_statement -> RETURN return_list .)
    LNOT            reduce using rule 124 (return_statement -> RETURN return_list .)
    IF              reduce using rule 124 (return_statement -> RETURN return_list .)
    SWITCH          reduce using rule 124 (return_statement -> RETURN return_list .)
    RETURN          reduce using rule 124 (return_statement -> RETURN return_list .)
    LBRACKET        reduce using rule 124 (return_statement -> RETURN return_list .)
    MAP             reduce using rule 124 (return_statement -> RETURN return_list .)
    FOR             reduce using rule 124 (return_statement -> RETURN return_list .)
    CASE            reduce using rule 124 (return_statement -> RETURN return_list .)
    DEFAULT         reduce using rule 124 (return_statement -> RETURN return_list .)
    COMMA           shift and go to state 282
=======
    (126) receiver -> IDENTIFIER TIMES IDENTIFIER .

    RPAREN          reduce using rule 126 (receiver -> IDENTIFIER TIMES IDENTIFIER .)
>>>>>>> Stashed changes


state 252

<<<<<<< Updated upstream
    (110) return_list -> expression .
    (36) expression -> expression . binary_operator expression
    (200) expression -> expression . DOT IDENTIFIER
    (201) expression -> expression . DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> expression . LBRACKET expression RBRACKET
    (37) binary_operator -> . PLUS
    (38) binary_operator -> . MINUS
    (39) binary_operator -> . TIMES
    (40) binary_operator -> . DIVIDE
    (41) binary_operator -> . MODULE
    (42) binary_operator -> . EQ
    (43) binary_operator -> . NEQ
    (44) binary_operator -> . LT
    (45) binary_operator -> . LE
    (46) binary_operator -> . GT
    (47) binary_operator -> . GE
    (48) binary_operator -> . LAND
    (49) binary_operator -> . LOR
    (50) binary_operator -> . AND
    (51) binary_operator -> . OR
    (52) binary_operator -> . XOR
    (53) binary_operator -> . AND_NOT
    (54) binary_operator -> . LSHIFT
    (55) binary_operator -> . RSHIFT

  ! shift/reduce conflict for LBRACKET resolved as shift
    COMMA           reduce using rule 110 (return_list -> expression .)
    RBRACE          reduce using rule 110 (return_list -> expression .)
    BREAK           reduce using rule 110 (return_list -> expression .)
    CONTINUE        reduce using rule 110 (return_list -> expression .)
    VAR             reduce using rule 110 (return_list -> expression .)
    CONST           reduce using rule 110 (return_list -> expression .)
    IDENTIFIER      reduce using rule 110 (return_list -> expression .)
    LPAREN          reduce using rule 110 (return_list -> expression .)
    INT             reduce using rule 110 (return_list -> expression .)
    FLOAT64         reduce using rule 110 (return_list -> expression .)
    STRING          reduce using rule 110 (return_list -> expression .)
    TRUE            reduce using rule 110 (return_list -> expression .)
    FALSE           reduce using rule 110 (return_list -> expression .)
    LNOT            reduce using rule 110 (return_list -> expression .)
    IF              reduce using rule 110 (return_list -> expression .)
    SWITCH          reduce using rule 110 (return_list -> expression .)
    RETURN          reduce using rule 110 (return_list -> expression .)
    MAP             reduce using rule 110 (return_list -> expression .)
    FOR             reduce using rule 110 (return_list -> expression .)
    CASE            reduce using rule 110 (return_list -> expression .)
    DEFAULT         reduce using rule 110 (return_list -> expression .)
    DOT             shift and go to state 82
    LBRACKET        shift and go to state 83
    PLUS            shift and go to state 84
    MINUS           shift and go to state 85
    TIMES           shift and go to state 86
    DIVIDE          shift and go to state 87
    MODULE          shift and go to state 88
    EQ              shift and go to state 89
    NEQ             shift and go to state 90
    LT              shift and go to state 91
    LE              shift and go to state 92
    GT              shift and go to state 93
    GE              shift and go to state 94
    LAND            shift and go to state 95
    LOR             shift and go to state 96
    AND             shift and go to state 97
    OR              shift and go to state 98
    XOR             shift and go to state 99
    AND_NOT         shift and go to state 100
    LSHIFT          shift and go to state 101
    RSHIFT          shift and go to state 102
=======
    (101) expression_list -> expression_list COMMA expression .
    (100) expression -> expression . DOT IDENTIFIER
    (135) binary_expression -> expression . PLUS expression
    (136) binary_expression -> expression . MINUS expression
    (137) binary_expression -> expression . TIMES expression
    (138) binary_expression -> expression . DIVIDE expression
    (139) binary_expression -> expression . MODULE expression
    (144) relational_expression -> expression . EQ expression
    (145) relational_expression -> expression . NEQ expression
    (146) relational_expression -> expression . LT expression
    (147) relational_expression -> expression . LE expression
    (148) relational_expression -> expression . GT expression
    (149) relational_expression -> expression . GE expression
    (150) logical_expression -> expression . LAND expression
    (151) logical_expression -> expression . LOR expression
    (152) bitwise_expression -> expression . AND expression
    (153) bitwise_expression -> expression . OR expression
    (154) bitwise_expression -> expression . XOR expression
    (155) bitwise_expression -> expression . AND_NOT expression
    (156) bitwise_expression -> expression . LSHIFT expression
    (157) bitwise_expression -> expression . RSHIFT expression

    COMMA           reduce using rule 101 (expression_list -> expression_list COMMA expression .)
    RPAREN          reduce using rule 101 (expression_list -> expression_list COMMA expression .)
    RBRACE          reduce using rule 101 (expression_list -> expression_list COMMA expression .)
    DOT             shift and go to state 58
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    TIMES           shift and go to state 61
    DIVIDE          shift and go to state 62
    MODULE          shift and go to state 63
    EQ              shift and go to state 64
    NEQ             shift and go to state 65
    LT              shift and go to state 66
    LE              shift and go to state 67
    GT              shift and go to state 68
    GE              shift and go to state 69
    LAND            shift and go to state 70
    LOR             shift and go to state 71
    AND             shift and go to state 72
    OR              shift and go to state 73
    XOR             shift and go to state 74
    AND_NOT         shift and go to state 75
    LSHIFT          shift and go to state 76
    RSHIFT          shift and go to state 77
>>>>>>> Stashed changes

  ! LBRACKET        [ reduce using rule 110 (return_list -> expression .) ]

    binary_operator                shift and go to state 81

state 253

<<<<<<< Updated upstream
    (97) for_classic -> FOR for_init . SEMICOLON for_cond SEMICOLON for_post block

    SEMICOLON       shift and go to state 283
=======
    (130) keyed_element -> IDENTIFIER COLON expression .
    (100) expression -> expression . DOT IDENTIFIER
    (135) binary_expression -> expression . PLUS expression
    (136) binary_expression -> expression . MINUS expression
    (137) binary_expression -> expression . TIMES expression
    (138) binary_expression -> expression . DIVIDE expression
    (139) binary_expression -> expression . MODULE expression
    (144) relational_expression -> expression . EQ expression
    (145) relational_expression -> expression . NEQ expression
    (146) relational_expression -> expression . LT expression
    (147) relational_expression -> expression . LE expression
    (148) relational_expression -> expression . GT expression
    (149) relational_expression -> expression . GE expression
    (150) logical_expression -> expression . LAND expression
    (151) logical_expression -> expression . LOR expression
    (152) bitwise_expression -> expression . AND expression
    (153) bitwise_expression -> expression . OR expression
    (154) bitwise_expression -> expression . XOR expression
    (155) bitwise_expression -> expression . AND_NOT expression
    (156) bitwise_expression -> expression . LSHIFT expression
    (157) bitwise_expression -> expression . RSHIFT expression

    RBRACE          reduce using rule 130 (keyed_element -> IDENTIFIER COLON expression .)
    COMMA           reduce using rule 130 (keyed_element -> IDENTIFIER COLON expression .)
    DOT             shift and go to state 58
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    TIMES           shift and go to state 61
    DIVIDE          shift and go to state 62
    MODULE          shift and go to state 63
    EQ              shift and go to state 64
    NEQ             shift and go to state 65
    LT              shift and go to state 66
    LE              shift and go to state 67
    GT              shift and go to state 68
    GE              shift and go to state 69
    LAND            shift and go to state 70
    LOR             shift and go to state 71
    AND             shift and go to state 72
    OR              shift and go to state 73
    XOR             shift and go to state 74
    AND_NOT         shift and go to state 75
    LSHIFT          shift and go to state 76
    RSHIFT          shift and go to state 77
>>>>>>> Stashed changes


state 254

<<<<<<< Updated upstream
    (99) for_infinite -> FOR block .

    RBRACE          reduce using rule 99 (for_infinite -> FOR block .)
    BREAK           reduce using rule 99 (for_infinite -> FOR block .)
    CONTINUE        reduce using rule 99 (for_infinite -> FOR block .)
    VAR             reduce using rule 99 (for_infinite -> FOR block .)
    CONST           reduce using rule 99 (for_infinite -> FOR block .)
    IDENTIFIER      reduce using rule 99 (for_infinite -> FOR block .)
    LPAREN          reduce using rule 99 (for_infinite -> FOR block .)
    INT             reduce using rule 99 (for_infinite -> FOR block .)
    FLOAT64         reduce using rule 99 (for_infinite -> FOR block .)
    STRING          reduce using rule 99 (for_infinite -> FOR block .)
    TRUE            reduce using rule 99 (for_infinite -> FOR block .)
    FALSE           reduce using rule 99 (for_infinite -> FOR block .)
    LNOT            reduce using rule 99 (for_infinite -> FOR block .)
    IF              reduce using rule 99 (for_infinite -> FOR block .)
    SWITCH          reduce using rule 99 (for_infinite -> FOR block .)
    RETURN          reduce using rule 99 (for_infinite -> FOR block .)
    LBRACKET        reduce using rule 99 (for_infinite -> FOR block .)
    MAP             reduce using rule 99 (for_infinite -> FOR block .)
    FOR             reduce using rule 99 (for_infinite -> FOR block .)
    CASE            reduce using rule 99 (for_infinite -> FOR block .)
    DEFAULT         reduce using rule 99 (for_infinite -> FOR block .)
=======
    (128) keyed_element_list -> keyed_element_list COMMA keyed_element .

    RBRACE          reduce using rule 128 (keyed_element_list -> keyed_element_list COMMA keyed_element .)
    COMMA           reduce using rule 128 (keyed_element_list -> keyed_element_list COMMA keyed_element .)
>>>>>>> Stashed changes


state 255

<<<<<<< Updated upstream
    (98) for_condition -> FOR expression . block
    (36) expression -> expression . binary_operator expression
    (200) expression -> expression . DOT IDENTIFIER
    (201) expression -> expression . DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> expression . LBRACKET expression RBRACKET
    (90) block -> . LBRACE local_statement_list RBRACE
    (91) block -> . LBRACE RBRACE
    (37) binary_operator -> . PLUS
    (38) binary_operator -> . MINUS
    (39) binary_operator -> . TIMES
    (40) binary_operator -> . DIVIDE
    (41) binary_operator -> . MODULE
    (42) binary_operator -> . EQ
    (43) binary_operator -> . NEQ
    (44) binary_operator -> . LT
    (45) binary_operator -> . LE
    (46) binary_operator -> . GT
    (47) binary_operator -> . GE
    (48) binary_operator -> . LAND
    (49) binary_operator -> . LOR
    (50) binary_operator -> . AND
    (51) binary_operator -> . OR
    (52) binary_operator -> . XOR
    (53) binary_operator -> . AND_NOT
    (54) binary_operator -> . LSHIFT
    (55) binary_operator -> . RSHIFT

    DOT             shift and go to state 82
    LBRACKET        shift and go to state 83
    LBRACE          shift and go to state 175
    PLUS            shift and go to state 84
    MINUS           shift and go to state 85
    TIMES           shift and go to state 86
    DIVIDE          shift and go to state 87
    MODULE          shift and go to state 88
    EQ              shift and go to state 89
    NEQ             shift and go to state 90
    LT              shift and go to state 91
    LE              shift and go to state 92
    GT              shift and go to state 93
    GE              shift and go to state 94
    LAND            shift and go to state 95
    LOR             shift and go to state 96
    AND             shift and go to state 97
    OR              shift and go to state 98
    XOR             shift and go to state 99
    AND_NOT         shift and go to state 100
    LSHIFT          shift and go to state 101
    RSHIFT          shift and go to state 102

    block                          shift and go to state 284
    binary_operator                shift and go to state 81

state 256

    (100) for_init -> simple_assignment .

    SEMICOLON       reduce using rule 100 (for_init -> simple_assignment .)
=======
    (131) keyed_element -> INT COLON expression .
    (100) expression -> expression . DOT IDENTIFIER
    (135) binary_expression -> expression . PLUS expression
    (136) binary_expression -> expression . MINUS expression
    (137) binary_expression -> expression . TIMES expression
    (138) binary_expression -> expression . DIVIDE expression
    (139) binary_expression -> expression . MODULE expression
    (144) relational_expression -> expression . EQ expression
    (145) relational_expression -> expression . NEQ expression
    (146) relational_expression -> expression . LT expression
    (147) relational_expression -> expression . LE expression
    (148) relational_expression -> expression . GT expression
    (149) relational_expression -> expression . GE expression
    (150) logical_expression -> expression . LAND expression
    (151) logical_expression -> expression . LOR expression
    (152) bitwise_expression -> expression . AND expression
    (153) bitwise_expression -> expression . OR expression
    (154) bitwise_expression -> expression . XOR expression
    (155) bitwise_expression -> expression . AND_NOT expression
    (156) bitwise_expression -> expression . LSHIFT expression
    (157) bitwise_expression -> expression . RSHIFT expression

    RBRACE          reduce using rule 131 (keyed_element -> INT COLON expression .)
    COMMA           reduce using rule 131 (keyed_element -> INT COLON expression .)
    DOT             shift and go to state 58
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    TIMES           shift and go to state 61
    DIVIDE          shift and go to state 62
    MODULE          shift and go to state 63
    EQ              shift and go to state 64
    NEQ             shift and go to state 65
    LT              shift and go to state 66
    LE              shift and go to state 67
    GT              shift and go to state 68
    GE              shift and go to state 69
    LAND            shift and go to state 70
    LOR             shift and go to state 71
    AND             shift and go to state 72
    OR              shift and go to state 73
    XOR             shift and go to state 74
    AND_NOT         shift and go to state 75
    LSHIFT          shift and go to state 76
    RSHIFT          shift and go to state 77


state 256

    (118) struct_type -> STRUCT LBRACE RBRACE .

    SEMICOLON       reduce using rule 118 (struct_type -> STRUCT LBRACE RBRACE .)
    FUNC            reduce using rule 118 (struct_type -> STRUCT LBRACE RBRACE .)
    TYPE            reduce using rule 118 (struct_type -> STRUCT LBRACE RBRACE .)
    IDENTIFIER      reduce using rule 118 (struct_type -> STRUCT LBRACE RBRACE .)
    VAR             reduce using rule 118 (struct_type -> STRUCT LBRACE RBRACE .)
    CONST           reduce using rule 118 (struct_type -> STRUCT LBRACE RBRACE .)
    PLUS            reduce using rule 118 (struct_type -> STRUCT LBRACE RBRACE .)
    MINUS           reduce using rule 118 (struct_type -> STRUCT LBRACE RBRACE .)
    LNOT            reduce using rule 118 (struct_type -> STRUCT LBRACE RBRACE .)
    LBRACKET        reduce using rule 118 (struct_type -> STRUCT LBRACE RBRACE .)
    LPAREN          reduce using rule 118 (struct_type -> STRUCT LBRACE RBRACE .)
    INT             reduce using rule 118 (struct_type -> STRUCT LBRACE RBRACE .)
    FLOAT64         reduce using rule 118 (struct_type -> STRUCT LBRACE RBRACE .)
    TRUE            reduce using rule 118 (struct_type -> STRUCT LBRACE RBRACE .)
    FALSE           reduce using rule 118 (struct_type -> STRUCT LBRACE RBRACE .)
    STRING          reduce using rule 118 (struct_type -> STRUCT LBRACE RBRACE .)
    RETURN          reduce using rule 118 (struct_type -> STRUCT LBRACE RBRACE .)
    FOR             reduce using rule 118 (struct_type -> STRUCT LBRACE RBRACE .)
    IF              reduce using rule 118 (struct_type -> STRUCT LBRACE RBRACE .)
    SWITCH          reduce using rule 118 (struct_type -> STRUCT LBRACE RBRACE .)
    BREAK           reduce using rule 118 (struct_type -> STRUCT LBRACE RBRACE .)
    CONTINUE        reduce using rule 118 (struct_type -> STRUCT LBRACE RBRACE .)
    FALLTHROUGH     reduce using rule 118 (struct_type -> STRUCT LBRACE RBRACE .)
    $end            reduce using rule 118 (struct_type -> STRUCT LBRACE RBRACE .)
    ASSIGN          reduce using rule 118 (struct_type -> STRUCT LBRACE RBRACE .)
    RPAREN          reduce using rule 118 (struct_type -> STRUCT LBRACE RBRACE .)
    COMMA           reduce using rule 118 (struct_type -> STRUCT LBRACE RBRACE .)
    LBRACE          reduce using rule 118 (struct_type -> STRUCT LBRACE RBRACE .)
    RBRACE          reduce using rule 118 (struct_type -> STRUCT LBRACE RBRACE .)
>>>>>>> Stashed changes


state 257

<<<<<<< Updated upstream
    (101) for_init -> short_assignment .

    SEMICOLON       reduce using rule 101 (for_init -> short_assignment .)
=======
    (119) struct_type -> STRUCT LBRACE field_list . RBRACE
    (121) field_list -> field_list . field_declaration
    (122) field_declaration -> . IDENTIFIER type
    (123) field_declaration -> . IDENTIFIER

    RBRACE          shift and go to state 289
    IDENTIFIER      shift and go to state 259
>>>>>>> Stashed changes

    field_declaration              shift and go to state 290

state 258

<<<<<<< Updated upstream
    (102) for_init -> local_var_dec .

    SEMICOLON       reduce using rule 102 (for_init -> local_var_dec .)
=======
    (120) field_list -> field_declaration .

    RBRACE          reduce using rule 120 (field_list -> field_declaration .)
    IDENTIFIER      reduce using rule 120 (field_list -> field_declaration .)
>>>>>>> Stashed changes


state 259

<<<<<<< Updated upstream
    (103) for_init -> empty .

    SEMICOLON       reduce using rule 103 (for_init -> empty .)
=======
    (122) field_declaration -> IDENTIFIER . type
    (123) field_declaration -> IDENTIFIER .
    (70) type -> . primitive_type
    (71) type -> . slice_type
    (72) type -> . array_type
    (73) type -> . map_type
    (74) type -> . struct_type
    (75) type -> . IDENTIFIER
    (76) primitive_type -> . INT_TYPE
    (77) primitive_type -> . FLOAT64_TYPE
    (78) primitive_type -> . STRING_TYPE
    (79) primitive_type -> . BOOL_TYPE
    (80) slice_type -> . LBRACKET RBRACKET primitive_type
    (81) array_type -> . LBRACKET INT RBRACKET type
    (127) map_type -> . MAP LBRACKET primitive_type RBRACKET type
    (118) struct_type -> . STRUCT LBRACE RBRACE
    (119) struct_type -> . STRUCT LBRACE field_list RBRACE

  ! shift/reduce conflict for IDENTIFIER resolved as shift
    RBRACE          reduce using rule 123 (field_declaration -> IDENTIFIER .)
    IDENTIFIER      shift and go to state 177
    INT_TYPE        shift and go to state 171
    FLOAT64_TYPE    shift and go to state 172
    STRING_TYPE     shift and go to state 173
    BOOL_TYPE       shift and go to state 174
    LBRACKET        shift and go to state 175
    MAP             shift and go to state 176
    STRUCT          shift and go to state 170
>>>>>>> Stashed changes

  ! IDENTIFIER      [ reduce using rule 123 (field_declaration -> IDENTIFIER .) ]

    type                           shift and go to state 291
    primitive_type                 shift and go to state 180
    slice_type                     shift and go to state 181
    array_type                     shift and go to state 182
    map_type                       shift and go to state 183
    struct_type                    shift and go to state 184

state 260

<<<<<<< Updated upstream
    (73) expression -> IDENTIFIER .
    (126) expression -> IDENTIFIER . PLUSPLUS
    (127) expression -> IDENTIFIER . MINUSMINUS
    (203) expression -> IDENTIFIER . LPAREN argument_list RPAREN
    (56) simple_assignment -> IDENTIFIER . ASSIGN expression
    (77) short_assignment -> IDENTIFIER . SHORT_ASSIGN expression
    (163) type_name -> IDENTIFIER .

  ! reduce/reduce conflict for LBRACE resolved using rule 73 (expression -> IDENTIFIER .)
    DOT             reduce using rule 73 (expression -> IDENTIFIER .)
    LBRACKET        reduce using rule 73 (expression -> IDENTIFIER .)
    LBRACE          reduce using rule 73 (expression -> IDENTIFIER .)
    PLUS            reduce using rule 73 (expression -> IDENTIFIER .)
    MINUS           reduce using rule 73 (expression -> IDENTIFIER .)
    TIMES           reduce using rule 73 (expression -> IDENTIFIER .)
    DIVIDE          reduce using rule 73 (expression -> IDENTIFIER .)
    MODULE          reduce using rule 73 (expression -> IDENTIFIER .)
    EQ              reduce using rule 73 (expression -> IDENTIFIER .)
    NEQ             reduce using rule 73 (expression -> IDENTIFIER .)
    LT              reduce using rule 73 (expression -> IDENTIFIER .)
    LE              reduce using rule 73 (expression -> IDENTIFIER .)
    GT              reduce using rule 73 (expression -> IDENTIFIER .)
    GE              reduce using rule 73 (expression -> IDENTIFIER .)
    LAND            reduce using rule 73 (expression -> IDENTIFIER .)
    LOR             reduce using rule 73 (expression -> IDENTIFIER .)
    AND             reduce using rule 73 (expression -> IDENTIFIER .)
    OR              reduce using rule 73 (expression -> IDENTIFIER .)
    XOR             reduce using rule 73 (expression -> IDENTIFIER .)
    AND_NOT         reduce using rule 73 (expression -> IDENTIFIER .)
    LSHIFT          reduce using rule 73 (expression -> IDENTIFIER .)
    RSHIFT          reduce using rule 73 (expression -> IDENTIFIER .)
    PLUSPLUS        shift and go to state 78
    MINUSMINUS      shift and go to state 79
    LPAREN          shift and go to state 80
    ASSIGN          shift and go to state 218
    SHORT_ASSIGN    shift and go to state 217

  ! LBRACE          [ reduce using rule 163 (type_name -> IDENTIFIER .) ]
=======
    (80) slice_type -> LBRACKET RBRACKET primitive_type .

    SEMICOLON       reduce using rule 80 (slice_type -> LBRACKET RBRACKET primitive_type .)
    FUNC            reduce using rule 80 (slice_type -> LBRACKET RBRACKET primitive_type .)
    TYPE            reduce using rule 80 (slice_type -> LBRACKET RBRACKET primitive_type .)
    IDENTIFIER      reduce using rule 80 (slice_type -> LBRACKET RBRACKET primitive_type .)
    VAR             reduce using rule 80 (slice_type -> LBRACKET RBRACKET primitive_type .)
    CONST           reduce using rule 80 (slice_type -> LBRACKET RBRACKET primitive_type .)
    PLUS            reduce using rule 80 (slice_type -> LBRACKET RBRACKET primitive_type .)
    MINUS           reduce using rule 80 (slice_type -> LBRACKET RBRACKET primitive_type .)
    LNOT            reduce using rule 80 (slice_type -> LBRACKET RBRACKET primitive_type .)
    LBRACKET        reduce using rule 80 (slice_type -> LBRACKET RBRACKET primitive_type .)
    LPAREN          reduce using rule 80 (slice_type -> LBRACKET RBRACKET primitive_type .)
    INT             reduce using rule 80 (slice_type -> LBRACKET RBRACKET primitive_type .)
    FLOAT64         reduce using rule 80 (slice_type -> LBRACKET RBRACKET primitive_type .)
    TRUE            reduce using rule 80 (slice_type -> LBRACKET RBRACKET primitive_type .)
    FALSE           reduce using rule 80 (slice_type -> LBRACKET RBRACKET primitive_type .)
    STRING          reduce using rule 80 (slice_type -> LBRACKET RBRACKET primitive_type .)
    RETURN          reduce using rule 80 (slice_type -> LBRACKET RBRACKET primitive_type .)
    FOR             reduce using rule 80 (slice_type -> LBRACKET RBRACKET primitive_type .)
    IF              reduce using rule 80 (slice_type -> LBRACKET RBRACKET primitive_type .)
    SWITCH          reduce using rule 80 (slice_type -> LBRACKET RBRACKET primitive_type .)
    BREAK           reduce using rule 80 (slice_type -> LBRACKET RBRACKET primitive_type .)
    CONTINUE        reduce using rule 80 (slice_type -> LBRACKET RBRACKET primitive_type .)
    FALLTHROUGH     reduce using rule 80 (slice_type -> LBRACKET RBRACKET primitive_type .)
    $end            reduce using rule 80 (slice_type -> LBRACKET RBRACKET primitive_type .)
    ASSIGN          reduce using rule 80 (slice_type -> LBRACKET RBRACKET primitive_type .)
    RPAREN          reduce using rule 80 (slice_type -> LBRACKET RBRACKET primitive_type .)
    COMMA           reduce using rule 80 (slice_type -> LBRACKET RBRACKET primitive_type .)
    LBRACE          reduce using rule 80 (slice_type -> LBRACKET RBRACKET primitive_type .)
    RBRACE          reduce using rule 80 (slice_type -> LBRACKET RBRACKET primitive_type .)
>>>>>>> Stashed changes


state 261

<<<<<<< Updated upstream
    (146) method_declaration -> FUNC LPAREN receiver RPAREN IDENTIFIER LPAREN parameter_list RPAREN return_type . block
    (90) block -> . LBRACE local_statement_list RBRACE
    (91) block -> . LBRACE RBRACE

    LBRACE          shift and go to state 175

    block                          shift and go to state 285

state 262

    (20) local_var_dec -> VAR IDENTIFIER type .
    (21) local_var_dec -> VAR IDENTIFIER type . ASSIGN expression

    RBRACE          reduce using rule 20 (local_var_dec -> VAR IDENTIFIER type .)
    BREAK           reduce using rule 20 (local_var_dec -> VAR IDENTIFIER type .)
    CONTINUE        reduce using rule 20 (local_var_dec -> VAR IDENTIFIER type .)
    VAR             reduce using rule 20 (local_var_dec -> VAR IDENTIFIER type .)
    CONST           reduce using rule 20 (local_var_dec -> VAR IDENTIFIER type .)
    IDENTIFIER      reduce using rule 20 (local_var_dec -> VAR IDENTIFIER type .)
    LPAREN          reduce using rule 20 (local_var_dec -> VAR IDENTIFIER type .)
    INT             reduce using rule 20 (local_var_dec -> VAR IDENTIFIER type .)
    FLOAT64         reduce using rule 20 (local_var_dec -> VAR IDENTIFIER type .)
    STRING          reduce using rule 20 (local_var_dec -> VAR IDENTIFIER type .)
    TRUE            reduce using rule 20 (local_var_dec -> VAR IDENTIFIER type .)
    FALSE           reduce using rule 20 (local_var_dec -> VAR IDENTIFIER type .)
    LNOT            reduce using rule 20 (local_var_dec -> VAR IDENTIFIER type .)
    IF              reduce using rule 20 (local_var_dec -> VAR IDENTIFIER type .)
    SWITCH          reduce using rule 20 (local_var_dec -> VAR IDENTIFIER type .)
    RETURN          reduce using rule 20 (local_var_dec -> VAR IDENTIFIER type .)
    LBRACKET        reduce using rule 20 (local_var_dec -> VAR IDENTIFIER type .)
    MAP             reduce using rule 20 (local_var_dec -> VAR IDENTIFIER type .)
    FOR             reduce using rule 20 (local_var_dec -> VAR IDENTIFIER type .)
    SEMICOLON       reduce using rule 20 (local_var_dec -> VAR IDENTIFIER type .)
    CASE            reduce using rule 20 (local_var_dec -> VAR IDENTIFIER type .)
    DEFAULT         reduce using rule 20 (local_var_dec -> VAR IDENTIFIER type .)
    ASSIGN          shift and go to state 286
=======
    (81) array_type -> LBRACKET INT RBRACKET . type
    (70) type -> . primitive_type
    (71) type -> . slice_type
    (72) type -> . array_type
    (73) type -> . map_type
    (74) type -> . struct_type
    (75) type -> . IDENTIFIER
    (76) primitive_type -> . INT_TYPE
    (77) primitive_type -> . FLOAT64_TYPE
    (78) primitive_type -> . STRING_TYPE
    (79) primitive_type -> . BOOL_TYPE
    (80) slice_type -> . LBRACKET RBRACKET primitive_type
    (81) array_type -> . LBRACKET INT RBRACKET type
    (127) map_type -> . MAP LBRACKET primitive_type RBRACKET type
    (118) struct_type -> . STRUCT LBRACE RBRACE
    (119) struct_type -> . STRUCT LBRACE field_list RBRACE

    IDENTIFIER      shift and go to state 177
    INT_TYPE        shift and go to state 171
    FLOAT64_TYPE    shift and go to state 172
    STRING_TYPE     shift and go to state 173
    BOOL_TYPE       shift and go to state 174
    LBRACKET        shift and go to state 175
    MAP             shift and go to state 176
    STRUCT          shift and go to state 170

    type                           shift and go to state 292
    primitive_type                 shift and go to state 180
    slice_type                     shift and go to state 181
    array_type                     shift and go to state 182
    map_type                       shift and go to state 183
    struct_type                    shift and go to state 184

state 262

    (127) map_type -> MAP LBRACKET primitive_type . RBRACKET type

    RBRACKET        shift and go to state 293
>>>>>>> Stashed changes


state 263

<<<<<<< Updated upstream
    (22) local_var_dec -> VAR IDENTIFIER ASSIGN . expression
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (125) expression -> . LNOT expression
    (126) expression -> . IDENTIFIER PLUSPLUS
    (127) expression -> . IDENTIFIER MINUSMINUS
    (138) expression -> . map_type LBRACE expression_map_list RBRACE
    (139) expression -> . map_type LBRACE RBRACE
    (161) expression -> . type_name LBRACE keyed_element_list RBRACE
    (162) expression -> . type_name LBRACE RBRACE
    (198) expression -> . array_type LBRACE expression_list RBRACE
    (199) expression -> . array_type LBRACE RBRACE
    (200) expression -> . expression DOT IDENTIFIER
    (201) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> . expression LBRACKET expression RBRACKET
    (203) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (137) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (163) type_name -> . IDENTIFIER
    (164) type_name -> . slice_type
    (165) type_name -> . array_type
    (166) type_name -> . map_type
    (197) array_type -> . LBRACKET INT RBRACKET primitive_type

    LPAREN          shift and go to state 54
    INT             shift and go to state 55
    FLOAT64         shift and go to state 56
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 57
    TRUE            shift and go to state 58
    FALSE           shift and go to state 59
    LNOT            shift and go to state 60
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39
=======
    (66) variable_declaration -> VAR IDENTIFIER type ASSIGN expression .
    (100) expression -> expression . DOT IDENTIFIER
    (135) binary_expression -> expression . PLUS expression
    (136) binary_expression -> expression . MINUS expression
    (137) binary_expression -> expression . TIMES expression
    (138) binary_expression -> expression . DIVIDE expression
    (139) binary_expression -> expression . MODULE expression
    (144) relational_expression -> expression . EQ expression
    (145) relational_expression -> expression . NEQ expression
    (146) relational_expression -> expression . LT expression
    (147) relational_expression -> expression . LE expression
    (148) relational_expression -> expression . GT expression
    (149) relational_expression -> expression . GE expression
    (150) logical_expression -> expression . LAND expression
    (151) logical_expression -> expression . LOR expression
    (152) bitwise_expression -> expression . AND expression
    (153) bitwise_expression -> expression . OR expression
    (154) bitwise_expression -> expression . XOR expression
    (155) bitwise_expression -> expression . AND_NOT expression
    (156) bitwise_expression -> expression . LSHIFT expression
    (157) bitwise_expression -> expression . RSHIFT expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    SEMICOLON       reduce using rule 66 (variable_declaration -> VAR IDENTIFIER type ASSIGN expression .)
    FUNC            reduce using rule 66 (variable_declaration -> VAR IDENTIFIER type ASSIGN expression .)
    TYPE            reduce using rule 66 (variable_declaration -> VAR IDENTIFIER type ASSIGN expression .)
    IDENTIFIER      reduce using rule 66 (variable_declaration -> VAR IDENTIFIER type ASSIGN expression .)
    VAR             reduce using rule 66 (variable_declaration -> VAR IDENTIFIER type ASSIGN expression .)
    CONST           reduce using rule 66 (variable_declaration -> VAR IDENTIFIER type ASSIGN expression .)
    LNOT            reduce using rule 66 (variable_declaration -> VAR IDENTIFIER type ASSIGN expression .)
    LBRACKET        reduce using rule 66 (variable_declaration -> VAR IDENTIFIER type ASSIGN expression .)
    LPAREN          reduce using rule 66 (variable_declaration -> VAR IDENTIFIER type ASSIGN expression .)
    INT             reduce using rule 66 (variable_declaration -> VAR IDENTIFIER type ASSIGN expression .)
    FLOAT64         reduce using rule 66 (variable_declaration -> VAR IDENTIFIER type ASSIGN expression .)
    TRUE            reduce using rule 66 (variable_declaration -> VAR IDENTIFIER type ASSIGN expression .)
    FALSE           reduce using rule 66 (variable_declaration -> VAR IDENTIFIER type ASSIGN expression .)
    STRING          reduce using rule 66 (variable_declaration -> VAR IDENTIFIER type ASSIGN expression .)
    RETURN          reduce using rule 66 (variable_declaration -> VAR IDENTIFIER type ASSIGN expression .)
    FOR             reduce using rule 66 (variable_declaration -> VAR IDENTIFIER type ASSIGN expression .)
    IF              reduce using rule 66 (variable_declaration -> VAR IDENTIFIER type ASSIGN expression .)
    SWITCH          reduce using rule 66 (variable_declaration -> VAR IDENTIFIER type ASSIGN expression .)
    BREAK           reduce using rule 66 (variable_declaration -> VAR IDENTIFIER type ASSIGN expression .)
    CONTINUE        reduce using rule 66 (variable_declaration -> VAR IDENTIFIER type ASSIGN expression .)
    FALLTHROUGH     reduce using rule 66 (variable_declaration -> VAR IDENTIFIER type ASSIGN expression .)
    $end            reduce using rule 66 (variable_declaration -> VAR IDENTIFIER type ASSIGN expression .)
    RBRACE          reduce using rule 66 (variable_declaration -> VAR IDENTIFIER type ASSIGN expression .)
    CASE            reduce using rule 66 (variable_declaration -> VAR IDENTIFIER type ASSIGN expression .)
    DEFAULT         reduce using rule 66 (variable_declaration -> VAR IDENTIFIER type ASSIGN expression .)
    DOT             shift and go to state 58
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    TIMES           shift and go to state 61
    DIVIDE          shift and go to state 62
    MODULE          shift and go to state 63
    EQ              shift and go to state 64
    NEQ             shift and go to state 65
    LT              shift and go to state 66
    LE              shift and go to state 67
    GT              shift and go to state 68
    GE              shift and go to state 69
    LAND            shift and go to state 70
    LOR             shift and go to state 71
    AND             shift and go to state 72
    OR              shift and go to state 73
    XOR             shift and go to state 74
    AND_NOT         shift and go to state 75
    LSHIFT          shift and go to state 76
    RSHIFT          shift and go to state 77

  ! PLUS            [ reduce using rule 66 (variable_declaration -> VAR IDENTIFIER type ASSIGN expression .) ]
  ! MINUS           [ reduce using rule 66 (variable_declaration -> VAR IDENTIFIER type ASSIGN expression .) ]
>>>>>>> Stashed changes

    expression                     shift and go to state 287
    slice_type                     shift and go to state 53
    map_type                       shift and go to state 61
    type_name                      shift and go to state 62
    array_type                     shift and go to state 63

state 264

<<<<<<< Updated upstream
    (77) short_assignment -> IDENTIFIER SHORT_ASSIGN expression .
    (36) expression -> expression . binary_operator expression
    (200) expression -> expression . DOT IDENTIFIER
    (201) expression -> expression . DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> expression . LBRACKET expression RBRACKET
    (37) binary_operator -> . PLUS
    (38) binary_operator -> . MINUS
    (39) binary_operator -> . TIMES
    (40) binary_operator -> . DIVIDE
    (41) binary_operator -> . MODULE
    (42) binary_operator -> . EQ
    (43) binary_operator -> . NEQ
    (44) binary_operator -> . LT
    (45) binary_operator -> . LE
    (46) binary_operator -> . GT
    (47) binary_operator -> . GE
    (48) binary_operator -> . LAND
    (49) binary_operator -> . LOR
    (50) binary_operator -> . AND
    (51) binary_operator -> . OR
    (52) binary_operator -> . XOR
    (53) binary_operator -> . AND_NOT
    (54) binary_operator -> . LSHIFT
    (55) binary_operator -> . RSHIFT

  ! shift/reduce conflict for LBRACKET resolved as shift
    RBRACE          reduce using rule 77 (short_assignment -> IDENTIFIER SHORT_ASSIGN expression .)
    BREAK           reduce using rule 77 (short_assignment -> IDENTIFIER SHORT_ASSIGN expression .)
    CONTINUE        reduce using rule 77 (short_assignment -> IDENTIFIER SHORT_ASSIGN expression .)
    VAR             reduce using rule 77 (short_assignment -> IDENTIFIER SHORT_ASSIGN expression .)
    CONST           reduce using rule 77 (short_assignment -> IDENTIFIER SHORT_ASSIGN expression .)
    IDENTIFIER      reduce using rule 77 (short_assignment -> IDENTIFIER SHORT_ASSIGN expression .)
    LPAREN          reduce using rule 77 (short_assignment -> IDENTIFIER SHORT_ASSIGN expression .)
    INT             reduce using rule 77 (short_assignment -> IDENTIFIER SHORT_ASSIGN expression .)
    FLOAT64         reduce using rule 77 (short_assignment -> IDENTIFIER SHORT_ASSIGN expression .)
    STRING          reduce using rule 77 (short_assignment -> IDENTIFIER SHORT_ASSIGN expression .)
    TRUE            reduce using rule 77 (short_assignment -> IDENTIFIER SHORT_ASSIGN expression .)
    FALSE           reduce using rule 77 (short_assignment -> IDENTIFIER SHORT_ASSIGN expression .)
    LNOT            reduce using rule 77 (short_assignment -> IDENTIFIER SHORT_ASSIGN expression .)
    IF              reduce using rule 77 (short_assignment -> IDENTIFIER SHORT_ASSIGN expression .)
    SWITCH          reduce using rule 77 (short_assignment -> IDENTIFIER SHORT_ASSIGN expression .)
    RETURN          reduce using rule 77 (short_assignment -> IDENTIFIER SHORT_ASSIGN expression .)
    MAP             reduce using rule 77 (short_assignment -> IDENTIFIER SHORT_ASSIGN expression .)
    FOR             reduce using rule 77 (short_assignment -> IDENTIFIER SHORT_ASSIGN expression .)
    SEMICOLON       reduce using rule 77 (short_assignment -> IDENTIFIER SHORT_ASSIGN expression .)
    CASE            reduce using rule 77 (short_assignment -> IDENTIFIER SHORT_ASSIGN expression .)
    DEFAULT         reduce using rule 77 (short_assignment -> IDENTIFIER SHORT_ASSIGN expression .)
    DOT             shift and go to state 82
    LBRACKET        shift and go to state 83
    PLUS            shift and go to state 84
    MINUS           shift and go to state 85
    TIMES           shift and go to state 86
    DIVIDE          shift and go to state 87
    MODULE          shift and go to state 88
    EQ              shift and go to state 89
    NEQ             shift and go to state 90
    LT              shift and go to state 91
    LE              shift and go to state 92
    GT              shift and go to state 93
    GE              shift and go to state 94
    LAND            shift and go to state 95
    LOR             shift and go to state 96
    AND             shift and go to state 97
    OR              shift and go to state 98
    XOR             shift and go to state 99
    AND_NOT         shift and go to state 100
    LSHIFT          shift and go to state 101
    RSHIFT          shift and go to state 102
=======
    (67) variable_declaration -> CONST IDENTIFIER type ASSIGN expression .
    (100) expression -> expression . DOT IDENTIFIER
    (135) binary_expression -> expression . PLUS expression
    (136) binary_expression -> expression . MINUS expression
    (137) binary_expression -> expression . TIMES expression
    (138) binary_expression -> expression . DIVIDE expression
    (139) binary_expression -> expression . MODULE expression
    (144) relational_expression -> expression . EQ expression
    (145) relational_expression -> expression . NEQ expression
    (146) relational_expression -> expression . LT expression
    (147) relational_expression -> expression . LE expression
    (148) relational_expression -> expression . GT expression
    (149) relational_expression -> expression . GE expression
    (150) logical_expression -> expression . LAND expression
    (151) logical_expression -> expression . LOR expression
    (152) bitwise_expression -> expression . AND expression
    (153) bitwise_expression -> expression . OR expression
    (154) bitwise_expression -> expression . XOR expression
    (155) bitwise_expression -> expression . AND_NOT expression
    (156) bitwise_expression -> expression . LSHIFT expression
    (157) bitwise_expression -> expression . RSHIFT expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    SEMICOLON       reduce using rule 67 (variable_declaration -> CONST IDENTIFIER type ASSIGN expression .)
    FUNC            reduce using rule 67 (variable_declaration -> CONST IDENTIFIER type ASSIGN expression .)
    TYPE            reduce using rule 67 (variable_declaration -> CONST IDENTIFIER type ASSIGN expression .)
    IDENTIFIER      reduce using rule 67 (variable_declaration -> CONST IDENTIFIER type ASSIGN expression .)
    VAR             reduce using rule 67 (variable_declaration -> CONST IDENTIFIER type ASSIGN expression .)
    CONST           reduce using rule 67 (variable_declaration -> CONST IDENTIFIER type ASSIGN expression .)
    LNOT            reduce using rule 67 (variable_declaration -> CONST IDENTIFIER type ASSIGN expression .)
    LBRACKET        reduce using rule 67 (variable_declaration -> CONST IDENTIFIER type ASSIGN expression .)
    LPAREN          reduce using rule 67 (variable_declaration -> CONST IDENTIFIER type ASSIGN expression .)
    INT             reduce using rule 67 (variable_declaration -> CONST IDENTIFIER type ASSIGN expression .)
    FLOAT64         reduce using rule 67 (variable_declaration -> CONST IDENTIFIER type ASSIGN expression .)
    TRUE            reduce using rule 67 (variable_declaration -> CONST IDENTIFIER type ASSIGN expression .)
    FALSE           reduce using rule 67 (variable_declaration -> CONST IDENTIFIER type ASSIGN expression .)
    STRING          reduce using rule 67 (variable_declaration -> CONST IDENTIFIER type ASSIGN expression .)
    RETURN          reduce using rule 67 (variable_declaration -> CONST IDENTIFIER type ASSIGN expression .)
    FOR             reduce using rule 67 (variable_declaration -> CONST IDENTIFIER type ASSIGN expression .)
    IF              reduce using rule 67 (variable_declaration -> CONST IDENTIFIER type ASSIGN expression .)
    SWITCH          reduce using rule 67 (variable_declaration -> CONST IDENTIFIER type ASSIGN expression .)
    BREAK           reduce using rule 67 (variable_declaration -> CONST IDENTIFIER type ASSIGN expression .)
    CONTINUE        reduce using rule 67 (variable_declaration -> CONST IDENTIFIER type ASSIGN expression .)
    FALLTHROUGH     reduce using rule 67 (variable_declaration -> CONST IDENTIFIER type ASSIGN expression .)
    $end            reduce using rule 67 (variable_declaration -> CONST IDENTIFIER type ASSIGN expression .)
    RBRACE          reduce using rule 67 (variable_declaration -> CONST IDENTIFIER type ASSIGN expression .)
    CASE            reduce using rule 67 (variable_declaration -> CONST IDENTIFIER type ASSIGN expression .)
    DEFAULT         reduce using rule 67 (variable_declaration -> CONST IDENTIFIER type ASSIGN expression .)
    DOT             shift and go to state 58
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    TIMES           shift and go to state 61
    DIVIDE          shift and go to state 62
    MODULE          shift and go to state 63
    EQ              shift and go to state 64
    NEQ             shift and go to state 65
    LT              shift and go to state 66
    LE              shift and go to state 67
    GT              shift and go to state 68
    GE              shift and go to state 69
    LAND            shift and go to state 70
    LOR             shift and go to state 71
    AND             shift and go to state 72
    OR              shift and go to state 73
    XOR             shift and go to state 74
    AND_NOT         shift and go to state 75
    LSHIFT          shift and go to state 76
    RSHIFT          shift and go to state 77

  ! PLUS            [ reduce using rule 67 (variable_declaration -> CONST IDENTIFIER type ASSIGN expression .) ]
  ! MINUS           [ reduce using rule 67 (variable_declaration -> CONST IDENTIFIER type ASSIGN expression .) ]
>>>>>>> Stashed changes

  ! LBRACKET        [ reduce using rule 77 (short_assignment -> IDENTIFIER SHORT_ASSIGN expression .) ]

    binary_operator                shift and go to state 81

state 265

<<<<<<< Updated upstream
    (56) simple_assignment -> IDENTIFIER ASSIGN expression .
    (36) expression -> expression . binary_operator expression
    (200) expression -> expression . DOT IDENTIFIER
    (201) expression -> expression . DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> expression . LBRACKET expression RBRACKET
    (37) binary_operator -> . PLUS
    (38) binary_operator -> . MINUS
    (39) binary_operator -> . TIMES
    (40) binary_operator -> . DIVIDE
    (41) binary_operator -> . MODULE
    (42) binary_operator -> . EQ
    (43) binary_operator -> . NEQ
    (44) binary_operator -> . LT
    (45) binary_operator -> . LE
    (46) binary_operator -> . GT
    (47) binary_operator -> . GE
    (48) binary_operator -> . LAND
    (49) binary_operator -> . LOR
    (50) binary_operator -> . AND
    (51) binary_operator -> . OR
    (52) binary_operator -> . XOR
    (53) binary_operator -> . AND_NOT
    (54) binary_operator -> . LSHIFT
    (55) binary_operator -> . RSHIFT

  ! shift/reduce conflict for LBRACKET resolved as shift
    RBRACE          reduce using rule 56 (simple_assignment -> IDENTIFIER ASSIGN expression .)
    BREAK           reduce using rule 56 (simple_assignment -> IDENTIFIER ASSIGN expression .)
    CONTINUE        reduce using rule 56 (simple_assignment -> IDENTIFIER ASSIGN expression .)
    VAR             reduce using rule 56 (simple_assignment -> IDENTIFIER ASSIGN expression .)
    CONST           reduce using rule 56 (simple_assignment -> IDENTIFIER ASSIGN expression .)
    IDENTIFIER      reduce using rule 56 (simple_assignment -> IDENTIFIER ASSIGN expression .)
    LPAREN          reduce using rule 56 (simple_assignment -> IDENTIFIER ASSIGN expression .)
    INT             reduce using rule 56 (simple_assignment -> IDENTIFIER ASSIGN expression .)
    FLOAT64         reduce using rule 56 (simple_assignment -> IDENTIFIER ASSIGN expression .)
    STRING          reduce using rule 56 (simple_assignment -> IDENTIFIER ASSIGN expression .)
    TRUE            reduce using rule 56 (simple_assignment -> IDENTIFIER ASSIGN expression .)
    FALSE           reduce using rule 56 (simple_assignment -> IDENTIFIER ASSIGN expression .)
    LNOT            reduce using rule 56 (simple_assignment -> IDENTIFIER ASSIGN expression .)
    IF              reduce using rule 56 (simple_assignment -> IDENTIFIER ASSIGN expression .)
    SWITCH          reduce using rule 56 (simple_assignment -> IDENTIFIER ASSIGN expression .)
    RETURN          reduce using rule 56 (simple_assignment -> IDENTIFIER ASSIGN expression .)
    MAP             reduce using rule 56 (simple_assignment -> IDENTIFIER ASSIGN expression .)
    FOR             reduce using rule 56 (simple_assignment -> IDENTIFIER ASSIGN expression .)
    SEMICOLON       reduce using rule 56 (simple_assignment -> IDENTIFIER ASSIGN expression .)
    CASE            reduce using rule 56 (simple_assignment -> IDENTIFIER ASSIGN expression .)
    DEFAULT         reduce using rule 56 (simple_assignment -> IDENTIFIER ASSIGN expression .)
    LBRACE          reduce using rule 56 (simple_assignment -> IDENTIFIER ASSIGN expression .)
    DOT             shift and go to state 82
    LBRACKET        shift and go to state 83
    PLUS            shift and go to state 84
    MINUS           shift and go to state 85
    TIMES           shift and go to state 86
    DIVIDE          shift and go to state 87
    MODULE          shift and go to state 88
    EQ              shift and go to state 89
    NEQ             shift and go to state 90
    LT              shift and go to state 91
    LE              shift and go to state 92
    GT              shift and go to state 93
    GE              shift and go to state 94
    LAND            shift and go to state 95
    LOR             shift and go to state 96
    AND             shift and go to state 97
    OR              shift and go to state 98
    XOR             shift and go to state 99
    AND_NOT         shift and go to state 100
    LSHIFT          shift and go to state 101
    RSHIFT          shift and go to state 102
=======
    (89) expression -> LBRACKET RBRACKET primitive_type LBRACE expression_list . RBRACE
    (101) expression_list -> expression_list . COMMA expression

    RBRACE          shift and go to state 294
    COMMA           shift and go to state 216
>>>>>>> Stashed changes

  ! LBRACKET        [ reduce using rule 56 (simple_assignment -> IDENTIFIER ASSIGN expression .) ]

    binary_operator                shift and go to state 81

state 266

<<<<<<< Updated upstream
    (25) assignment_compound -> IDENTIFIER operator_assign expression .
    (36) expression -> expression . binary_operator expression
    (200) expression -> expression . DOT IDENTIFIER
    (201) expression -> expression . DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> expression . LBRACKET expression RBRACKET
    (37) binary_operator -> . PLUS
    (38) binary_operator -> . MINUS
    (39) binary_operator -> . TIMES
    (40) binary_operator -> . DIVIDE
    (41) binary_operator -> . MODULE
    (42) binary_operator -> . EQ
    (43) binary_operator -> . NEQ
    (44) binary_operator -> . LT
    (45) binary_operator -> . LE
    (46) binary_operator -> . GT
    (47) binary_operator -> . GE
    (48) binary_operator -> . LAND
    (49) binary_operator -> . LOR
    (50) binary_operator -> . AND
    (51) binary_operator -> . OR
    (52) binary_operator -> . XOR
    (53) binary_operator -> . AND_NOT
    (54) binary_operator -> . LSHIFT
    (55) binary_operator -> . RSHIFT

  ! shift/reduce conflict for LBRACKET resolved as shift
    RBRACE          reduce using rule 25 (assignment_compound -> IDENTIFIER operator_assign expression .)
    BREAK           reduce using rule 25 (assignment_compound -> IDENTIFIER operator_assign expression .)
    CONTINUE        reduce using rule 25 (assignment_compound -> IDENTIFIER operator_assign expression .)
    VAR             reduce using rule 25 (assignment_compound -> IDENTIFIER operator_assign expression .)
    CONST           reduce using rule 25 (assignment_compound -> IDENTIFIER operator_assign expression .)
    IDENTIFIER      reduce using rule 25 (assignment_compound -> IDENTIFIER operator_assign expression .)
    LPAREN          reduce using rule 25 (assignment_compound -> IDENTIFIER operator_assign expression .)
    INT             reduce using rule 25 (assignment_compound -> IDENTIFIER operator_assign expression .)
    FLOAT64         reduce using rule 25 (assignment_compound -> IDENTIFIER operator_assign expression .)
    STRING          reduce using rule 25 (assignment_compound -> IDENTIFIER operator_assign expression .)
    TRUE            reduce using rule 25 (assignment_compound -> IDENTIFIER operator_assign expression .)
    FALSE           reduce using rule 25 (assignment_compound -> IDENTIFIER operator_assign expression .)
    LNOT            reduce using rule 25 (assignment_compound -> IDENTIFIER operator_assign expression .)
    IF              reduce using rule 25 (assignment_compound -> IDENTIFIER operator_assign expression .)
    SWITCH          reduce using rule 25 (assignment_compound -> IDENTIFIER operator_assign expression .)
    RETURN          reduce using rule 25 (assignment_compound -> IDENTIFIER operator_assign expression .)
    MAP             reduce using rule 25 (assignment_compound -> IDENTIFIER operator_assign expression .)
    FOR             reduce using rule 25 (assignment_compound -> IDENTIFIER operator_assign expression .)
    CASE            reduce using rule 25 (assignment_compound -> IDENTIFIER operator_assign expression .)
    DEFAULT         reduce using rule 25 (assignment_compound -> IDENTIFIER operator_assign expression .)
    LBRACE          reduce using rule 25 (assignment_compound -> IDENTIFIER operator_assign expression .)
    DOT             shift and go to state 82
    LBRACKET        shift and go to state 83
    PLUS            shift and go to state 84
    MINUS           shift and go to state 85
    TIMES           shift and go to state 86
    DIVIDE          shift and go to state 87
    MODULE          shift and go to state 88
    EQ              shift and go to state 89
    NEQ             shift and go to state 90
    LT              shift and go to state 91
    LE              shift and go to state 92
    GT              shift and go to state 93
    GE              shift and go to state 94
    LAND            shift and go to state 95
    LOR             shift and go to state 96
    AND             shift and go to state 97
    OR              shift and go to state 98
    XOR             shift and go to state 99
    AND_NOT         shift and go to state 100
    LSHIFT          shift and go to state 101
    RSHIFT          shift and go to state 102
=======
    (90) expression -> LBRACKET RBRACKET primitive_type LBRACE RBRACE .

    DOT             reduce using rule 90 (expression -> LBRACKET RBRACKET primitive_type LBRACE RBRACE .)
    PLUS            reduce using rule 90 (expression -> LBRACKET RBRACKET primitive_type LBRACE RBRACE .)
    MINUS           reduce using rule 90 (expression -> LBRACKET RBRACKET primitive_type LBRACE RBRACE .)
    TIMES           reduce using rule 90 (expression -> LBRACKET RBRACKET primitive_type LBRACE RBRACE .)
    DIVIDE          reduce using rule 90 (expression -> LBRACKET RBRACKET primitive_type LBRACE RBRACE .)
    MODULE          reduce using rule 90 (expression -> LBRACKET RBRACKET primitive_type LBRACE RBRACE .)
    EQ              reduce using rule 90 (expression -> LBRACKET RBRACKET primitive_type LBRACE RBRACE .)
    NEQ             reduce using rule 90 (expression -> LBRACKET RBRACKET primitive_type LBRACE RBRACE .)
    LT              reduce using rule 90 (expression -> LBRACKET RBRACKET primitive_type LBRACE RBRACE .)
    LE              reduce using rule 90 (expression -> LBRACKET RBRACKET primitive_type LBRACE RBRACE .)
    GT              reduce using rule 90 (expression -> LBRACKET RBRACKET primitive_type LBRACE RBRACE .)
    GE              reduce using rule 90 (expression -> LBRACKET RBRACKET primitive_type LBRACE RBRACE .)
    LAND            reduce using rule 90 (expression -> LBRACKET RBRACKET primitive_type LBRACE RBRACE .)
    LOR             reduce using rule 90 (expression -> LBRACKET RBRACKET primitive_type LBRACE RBRACE .)
    AND             reduce using rule 90 (expression -> LBRACKET RBRACKET primitive_type LBRACE RBRACE .)
    OR              reduce using rule 90 (expression -> LBRACKET RBRACKET primitive_type LBRACE RBRACE .)
    XOR             reduce using rule 90 (expression -> LBRACKET RBRACKET primitive_type LBRACE RBRACE .)
    AND_NOT         reduce using rule 90 (expression -> LBRACKET RBRACKET primitive_type LBRACE RBRACE .)
    LSHIFT          reduce using rule 90 (expression -> LBRACKET RBRACKET primitive_type LBRACE RBRACE .)
    RSHIFT          reduce using rule 90 (expression -> LBRACKET RBRACKET primitive_type LBRACE RBRACE .)
    SEMICOLON       reduce using rule 90 (expression -> LBRACKET RBRACKET primitive_type LBRACE RBRACE .)
    FUNC            reduce using rule 90 (expression -> LBRACKET RBRACKET primitive_type LBRACE RBRACE .)
    TYPE            reduce using rule 90 (expression -> LBRACKET RBRACKET primitive_type LBRACE RBRACE .)
    IDENTIFIER      reduce using rule 90 (expression -> LBRACKET RBRACKET primitive_type LBRACE RBRACE .)
    VAR             reduce using rule 90 (expression -> LBRACKET RBRACKET primitive_type LBRACE RBRACE .)
    CONST           reduce using rule 90 (expression -> LBRACKET RBRACKET primitive_type LBRACE RBRACE .)
    LNOT            reduce using rule 90 (expression -> LBRACKET RBRACKET primitive_type LBRACE RBRACE .)
    LBRACKET        reduce using rule 90 (expression -> LBRACKET RBRACKET primitive_type LBRACE RBRACE .)
    LPAREN          reduce using rule 90 (expression -> LBRACKET RBRACKET primitive_type LBRACE RBRACE .)
    INT             reduce using rule 90 (expression -> LBRACKET RBRACKET primitive_type LBRACE RBRACE .)
    FLOAT64         reduce using rule 90 (expression -> LBRACKET RBRACKET primitive_type LBRACE RBRACE .)
    TRUE            reduce using rule 90 (expression -> LBRACKET RBRACKET primitive_type LBRACE RBRACE .)
    FALSE           reduce using rule 90 (expression -> LBRACKET RBRACKET primitive_type LBRACE RBRACE .)
    STRING          reduce using rule 90 (expression -> LBRACKET RBRACKET primitive_type LBRACE RBRACE .)
    RETURN          reduce using rule 90 (expression -> LBRACKET RBRACKET primitive_type LBRACE RBRACE .)
    FOR             reduce using rule 90 (expression -> LBRACKET RBRACKET primitive_type LBRACE RBRACE .)
    IF              reduce using rule 90 (expression -> LBRACKET RBRACKET primitive_type LBRACE RBRACE .)
    SWITCH          reduce using rule 90 (expression -> LBRACKET RBRACKET primitive_type LBRACE RBRACE .)
    BREAK           reduce using rule 90 (expression -> LBRACKET RBRACKET primitive_type LBRACE RBRACE .)
    CONTINUE        reduce using rule 90 (expression -> LBRACKET RBRACKET primitive_type LBRACE RBRACE .)
    FALLTHROUGH     reduce using rule 90 (expression -> LBRACKET RBRACKET primitive_type LBRACE RBRACE .)
    $end            reduce using rule 90 (expression -> LBRACKET RBRACKET primitive_type LBRACE RBRACE .)
    RPAREN          reduce using rule 90 (expression -> LBRACKET RBRACKET primitive_type LBRACE RBRACE .)
    COMMA           reduce using rule 90 (expression -> LBRACKET RBRACKET primitive_type LBRACE RBRACE .)
    RBRACE          reduce using rule 90 (expression -> LBRACKET RBRACKET primitive_type LBRACE RBRACE .)
    CASE            reduce using rule 90 (expression -> LBRACKET RBRACKET primitive_type LBRACE RBRACE .)
    DEFAULT         reduce using rule 90 (expression -> LBRACKET RBRACKET primitive_type LBRACE RBRACE .)
    LBRACE          reduce using rule 90 (expression -> LBRACKET RBRACKET primitive_type LBRACE RBRACE .)
    COLON           reduce using rule 90 (expression -> LBRACKET RBRACKET primitive_type LBRACE RBRACE .)
>>>>>>> Stashed changes

  ! LBRACKET        [ reduce using rule 25 (assignment_compound -> IDENTIFIER operator_assign expression .) ]

    binary_operator                shift and go to state 81

state 267

<<<<<<< Updated upstream
    (23) local_const_dec -> CONST IDENTIFIER type . ASSIGN expression

    ASSIGN          shift and go to state 288
=======
    (16) block -> LBRACE enter_block exit_block RBRACE .

    SEMICOLON       reduce using rule 16 (block -> LBRACE enter_block exit_block RBRACE .)
    FUNC            reduce using rule 16 (block -> LBRACE enter_block exit_block RBRACE .)
    TYPE            reduce using rule 16 (block -> LBRACE enter_block exit_block RBRACE .)
    IDENTIFIER      reduce using rule 16 (block -> LBRACE enter_block exit_block RBRACE .)
    VAR             reduce using rule 16 (block -> LBRACE enter_block exit_block RBRACE .)
    CONST           reduce using rule 16 (block -> LBRACE enter_block exit_block RBRACE .)
    PLUS            reduce using rule 16 (block -> LBRACE enter_block exit_block RBRACE .)
    MINUS           reduce using rule 16 (block -> LBRACE enter_block exit_block RBRACE .)
    LNOT            reduce using rule 16 (block -> LBRACE enter_block exit_block RBRACE .)
    LBRACKET        reduce using rule 16 (block -> LBRACE enter_block exit_block RBRACE .)
    LPAREN          reduce using rule 16 (block -> LBRACE enter_block exit_block RBRACE .)
    INT             reduce using rule 16 (block -> LBRACE enter_block exit_block RBRACE .)
    FLOAT64         reduce using rule 16 (block -> LBRACE enter_block exit_block RBRACE .)
    TRUE            reduce using rule 16 (block -> LBRACE enter_block exit_block RBRACE .)
    FALSE           reduce using rule 16 (block -> LBRACE enter_block exit_block RBRACE .)
    STRING          reduce using rule 16 (block -> LBRACE enter_block exit_block RBRACE .)
    RETURN          reduce using rule 16 (block -> LBRACE enter_block exit_block RBRACE .)
    FOR             reduce using rule 16 (block -> LBRACE enter_block exit_block RBRACE .)
    IF              reduce using rule 16 (block -> LBRACE enter_block exit_block RBRACE .)
    SWITCH          reduce using rule 16 (block -> LBRACE enter_block exit_block RBRACE .)
    BREAK           reduce using rule 16 (block -> LBRACE enter_block exit_block RBRACE .)
    CONTINUE        reduce using rule 16 (block -> LBRACE enter_block exit_block RBRACE .)
    FALLTHROUGH     reduce using rule 16 (block -> LBRACE enter_block exit_block RBRACE .)
    $end            reduce using rule 16 (block -> LBRACE enter_block exit_block RBRACE .)
    RBRACE          reduce using rule 16 (block -> LBRACE enter_block exit_block RBRACE .)
    CASE            reduce using rule 16 (block -> LBRACE enter_block exit_block RBRACE .)
    DEFAULT         reduce using rule 16 (block -> LBRACE enter_block exit_block RBRACE .)
    ELSE            reduce using rule 16 (block -> LBRACE enter_block exit_block RBRACE .)
>>>>>>> Stashed changes


state 268

<<<<<<< Updated upstream
    (24) local_const_dec -> CONST IDENTIFIER ASSIGN . expression
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (125) expression -> . LNOT expression
    (126) expression -> . IDENTIFIER PLUSPLUS
    (127) expression -> . IDENTIFIER MINUSMINUS
    (138) expression -> . map_type LBRACE expression_map_list RBRACE
    (139) expression -> . map_type LBRACE RBRACE
    (161) expression -> . type_name LBRACE keyed_element_list RBRACE
    (162) expression -> . type_name LBRACE RBRACE
    (198) expression -> . array_type LBRACE expression_list RBRACE
    (199) expression -> . array_type LBRACE RBRACE
    (200) expression -> . expression DOT IDENTIFIER
    (201) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> . expression LBRACKET expression RBRACKET
    (203) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (137) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (163) type_name -> . IDENTIFIER
    (164) type_name -> . slice_type
    (165) type_name -> . array_type
    (166) type_name -> . map_type
    (197) array_type -> . LBRACKET INT RBRACKET primitive_type

    LPAREN          shift and go to state 54
    INT             shift and go to state 55
    FLOAT64         shift and go to state 56
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 57
    TRUE            shift and go to state 58
    FALSE           shift and go to state 59
    LNOT            shift and go to state 60
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39
=======
    (17) block -> LBRACE enter_block statement_list exit_block . RBRACE

    RBRACE          shift and go to state 295
>>>>>>> Stashed changes

    expression                     shift and go to state 289
    slice_type                     shift and go to state 53
    map_type                       shift and go to state 61
    type_name                      shift and go to state 62
    array_type                     shift and go to state 63

state 269

<<<<<<< Updated upstream
    (128) if_statement -> IF expression block .
    (129) if_statement -> IF expression block . ELSE block
    (130) if_statement -> IF expression block . ELSE if_statement

    RBRACE          reduce using rule 128 (if_statement -> IF expression block .)
    BREAK           reduce using rule 128 (if_statement -> IF expression block .)
    CONTINUE        reduce using rule 128 (if_statement -> IF expression block .)
    VAR             reduce using rule 128 (if_statement -> IF expression block .)
    CONST           reduce using rule 128 (if_statement -> IF expression block .)
    IDENTIFIER      reduce using rule 128 (if_statement -> IF expression block .)
    LPAREN          reduce using rule 128 (if_statement -> IF expression block .)
    INT             reduce using rule 128 (if_statement -> IF expression block .)
    FLOAT64         reduce using rule 128 (if_statement -> IF expression block .)
    STRING          reduce using rule 128 (if_statement -> IF expression block .)
    TRUE            reduce using rule 128 (if_statement -> IF expression block .)
    FALSE           reduce using rule 128 (if_statement -> IF expression block .)
    LNOT            reduce using rule 128 (if_statement -> IF expression block .)
    IF              reduce using rule 128 (if_statement -> IF expression block .)
    SWITCH          reduce using rule 128 (if_statement -> IF expression block .)
    RETURN          reduce using rule 128 (if_statement -> IF expression block .)
    LBRACKET        reduce using rule 128 (if_statement -> IF expression block .)
    MAP             reduce using rule 128 (if_statement -> IF expression block .)
    FOR             reduce using rule 128 (if_statement -> IF expression block .)
    CASE            reduce using rule 128 (if_statement -> IF expression block .)
    DEFAULT         reduce using rule 128 (if_statement -> IF expression block .)
    ELSE            shift and go to state 290


state 270

    (131) if_statement -> IF if_assignment SEMICOLON . expression block
    (132) if_statement -> IF if_assignment SEMICOLON . expression block ELSE block
    (133) if_statement -> IF if_assignment SEMICOLON . expression block ELSE if_statement
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (125) expression -> . LNOT expression
    (126) expression -> . IDENTIFIER PLUSPLUS
    (127) expression -> . IDENTIFIER MINUSMINUS
    (138) expression -> . map_type LBRACE expression_map_list RBRACE
    (139) expression -> . map_type LBRACE RBRACE
    (161) expression -> . type_name LBRACE keyed_element_list RBRACE
    (162) expression -> . type_name LBRACE RBRACE
    (198) expression -> . array_type LBRACE expression_list RBRACE
    (199) expression -> . array_type LBRACE RBRACE
    (200) expression -> . expression DOT IDENTIFIER
    (201) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> . expression LBRACKET expression RBRACKET
    (203) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (137) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (163) type_name -> . IDENTIFIER
    (164) type_name -> . slice_type
    (165) type_name -> . array_type
    (166) type_name -> . map_type
    (197) array_type -> . LBRACKET INT RBRACKET primitive_type

    LPAREN          shift and go to state 54
    INT             shift and go to state 55
    FLOAT64         shift and go to state 56
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 57
    TRUE            shift and go to state 58
    FALSE           shift and go to state 59
    LNOT            shift and go to state 60
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    expression                     shift and go to state 291
    slice_type                     shift and go to state 53
    map_type                       shift and go to state 61
    type_name                      shift and go to state 62
    array_type                     shift and go to state 63

state 271

    (167) switch_statement -> SWITCH switch_expr LBRACE . case_clause_list RBRACE
    (168) switch_statement -> SWITCH switch_expr LBRACE . RBRACE
    (186) case_clause_list -> . case_clause
    (187) case_clause_list -> . case_clause_list case_clause
    (191) case_clause -> . CASE case_expression_list COLON case_body
    (192) case_clause -> . DEFAULT COLON case_body

    RBRACE          shift and go to state 293
    CASE            shift and go to state 275
    DEFAULT         shift and go to state 276
=======
    (19) statement_list -> statement_list optional_semicolon . statement
    (20) statement -> . assignment
    (21) statement -> . assignment_compound
    (22) statement -> . variable_declaration
    (23) statement -> . expression
    (24) statement -> . return_statement
    (25) statement -> . for_statement
    (26) statement -> . if_statement
    (27) statement -> . switch_statement
    (28) statement -> . break_statement
    (29) statement -> . continue_statement
    (30) statement -> . fallthrough_statement
    (54) assignment -> . IDENTIFIER ASSIGN expression
    (55) assignment -> . IDENTIFIER SHORT_ASSIGN expression
    (56) assignment_compound -> . IDENTIFIER PLUS_ASSIGN expression
    (57) assignment_compound -> . IDENTIFIER MINUS_ASSIGN expression
    (58) assignment_compound -> . IDENTIFIER MULT_ASSIGN expression
    (59) assignment_compound -> . IDENTIFIER DIV_ASSIGN expression
    (60) assignment_compound -> . IDENTIFIER MOD_ASSIGN expression
    (61) assignment_compound -> . IDENTIFIER AND_ASSIGN expression
    (62) assignment_compound -> . IDENTIFIER OR_ASSIGN expression
    (63) assignment_compound -> . IDENTIFIER XOR_ASSIGN expression
    (64) assignment_compound -> . IDENTIFIER LSHIFT_ASSIGN expression
    (65) assignment_compound -> . IDENTIFIER RSHIFT_ASSIGN expression
    (66) variable_declaration -> . VAR IDENTIFIER type ASSIGN expression
    (67) variable_declaration -> . CONST IDENTIFIER type ASSIGN expression
    (68) variable_declaration -> . VAR IDENTIFIER ASSIGN expression
    (69) variable_declaration -> . CONST IDENTIFIER ASSIGN expression
    (82) expression -> . binary_expression
    (83) expression -> . relational_expression
    (84) expression -> . logical_expression
    (85) expression -> . bitwise_expression
    (86) expression -> . PLUS expression
    (87) expression -> . MINUS expression
    (88) expression -> . LNOT expression
    (89) expression -> . LBRACKET RBRACKET primitive_type LBRACE expression_list RBRACE
    (90) expression -> . LBRACKET RBRACKET primitive_type LBRACE RBRACE
    (91) expression -> . LPAREN expression RPAREN
    (92) expression -> . INT
    (93) expression -> . FLOAT64
    (94) expression -> . TRUE
    (95) expression -> . FALSE
    (96) expression -> . IDENTIFIER
    (97) expression -> . STRING
    (98) expression -> . IDENTIFIER PLUSPLUS
    (99) expression -> . IDENTIFIER MINUSMINUS
    (100) expression -> . expression DOT IDENTIFIER
    (103) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (133) expression -> . IDENTIFIER LBRACE keyed_element_list RBRACE
    (134) expression -> . IDENTIFIER LBRACE RBRACE
    (39) return_statement -> . RETURN
    (40) return_statement -> . RETURN return_list
    (33) for_statement -> . FOR expression block
    (34) for_statement -> . FOR block
    (35) for_statement -> . FOR for_clause block
    (106) if_statement -> . IF expression block
    (107) if_statement -> . IF expression block ELSE block
    (108) if_statement -> . IF expression block ELSE if_statement
    (109) if_statement -> . IF assignment SEMICOLON expression block
    (110) if_statement -> . IF assignment SEMICOLON expression block ELSE block
    (111) if_statement -> . IF assignment SEMICOLON expression block ELSE if_statement
    (189) switch_statement -> . SWITCH enter_block switch_header LBRACE case_clauses RBRACE exit_block
    (31) break_statement -> . BREAK
    (32) continue_statement -> . CONTINUE
    (177) fallthrough_statement -> . FALLTHROUGH
    (135) binary_expression -> . expression PLUS expression
    (136) binary_expression -> . expression MINUS expression
    (137) binary_expression -> . expression TIMES expression
    (138) binary_expression -> . expression DIVIDE expression
    (139) binary_expression -> . expression MODULE expression
    (144) relational_expression -> . expression EQ expression
    (145) relational_expression -> . expression NEQ expression
    (146) relational_expression -> . expression LT expression
    (147) relational_expression -> . expression LE expression
    (148) relational_expression -> . expression GT expression
    (149) relational_expression -> . expression GE expression
    (150) logical_expression -> . expression LAND expression
    (151) logical_expression -> . expression LOR expression
    (152) bitwise_expression -> . expression AND expression
    (153) bitwise_expression -> . expression OR expression
    (154) bitwise_expression -> . expression XOR expression
    (155) bitwise_expression -> . expression AND_NOT expression
    (156) bitwise_expression -> . expression LSHIFT expression
    (157) bitwise_expression -> . expression RSHIFT expression

    IDENTIFIER      shift and go to state 28
    VAR             shift and go to state 31
    CONST           shift and go to state 32
    PLUS            shift and go to state 37
    MINUS           shift and go to state 38
    LNOT            shift and go to state 39
    LBRACKET        shift and go to state 40
    LPAREN          shift and go to state 29
    INT             shift and go to state 41
    FLOAT64         shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44
    STRING          shift and go to state 11
    RETURN          shift and go to state 45
    FOR             shift and go to state 46
    IF              shift and go to state 47
    SWITCH          shift and go to state 48
    BREAK           shift and go to state 49
    CONTINUE        shift and go to state 50
    FALLTHROUGH     shift and go to state 51

    statement                      shift and go to state 296
    assignment                     shift and go to state 16
    assignment_compound            shift and go to state 17
    variable_declaration           shift and go to state 18
    expression                     shift and go to state 19
    return_statement               shift and go to state 20
    for_statement                  shift and go to state 21
    if_statement                   shift and go to state 22
    switch_statement               shift and go to state 23
    break_statement                shift and go to state 24
    continue_statement             shift and go to state 25
    fallthrough_statement          shift and go to state 26
    binary_expression              shift and go to state 33
    relational_expression          shift and go to state 34
    logical_expression             shift and go to state 35
    bitwise_expression             shift and go to state 36

state 270

    (36) for_clause -> assignment SEMICOLON expression SEMICOLON . assignment
    (54) assignment -> . IDENTIFIER ASSIGN expression
    (55) assignment -> . IDENTIFIER SHORT_ASSIGN expression

    IDENTIFIER      shift and go to state 272

    assignment                     shift and go to state 297

state 271

    (37) for_clause -> SEMICOLON expression SEMICOLON assignment .

    LBRACE          reduce using rule 37 (for_clause -> SEMICOLON expression SEMICOLON assignment .)
>>>>>>> Stashed changes

    case_clause_list               shift and go to state 292
    case_clause                    shift and go to state 274

state 272

<<<<<<< Updated upstream
    (169) switch_statement -> SWITCH LBRACE case_clause_list . RBRACE
    (187) case_clause_list -> case_clause_list . case_clause
    (191) case_clause -> . CASE case_expression_list COLON case_body
    (192) case_clause -> . DEFAULT COLON case_body

    RBRACE          shift and go to state 294
    CASE            shift and go to state 275
    DEFAULT         shift and go to state 276

    case_clause                    shift and go to state 295

state 273

    (170) switch_statement -> SWITCH LBRACE RBRACE .

    RBRACE          reduce using rule 170 (switch_statement -> SWITCH LBRACE RBRACE .)
    BREAK           reduce using rule 170 (switch_statement -> SWITCH LBRACE RBRACE .)
    CONTINUE        reduce using rule 170 (switch_statement -> SWITCH LBRACE RBRACE .)
    VAR             reduce using rule 170 (switch_statement -> SWITCH LBRACE RBRACE .)
    CONST           reduce using rule 170 (switch_statement -> SWITCH LBRACE RBRACE .)
    IDENTIFIER      reduce using rule 170 (switch_statement -> SWITCH LBRACE RBRACE .)
    LPAREN          reduce using rule 170 (switch_statement -> SWITCH LBRACE RBRACE .)
    INT             reduce using rule 170 (switch_statement -> SWITCH LBRACE RBRACE .)
    FLOAT64         reduce using rule 170 (switch_statement -> SWITCH LBRACE RBRACE .)
    STRING          reduce using rule 170 (switch_statement -> SWITCH LBRACE RBRACE .)
    TRUE            reduce using rule 170 (switch_statement -> SWITCH LBRACE RBRACE .)
    FALSE           reduce using rule 170 (switch_statement -> SWITCH LBRACE RBRACE .)
    LNOT            reduce using rule 170 (switch_statement -> SWITCH LBRACE RBRACE .)
    IF              reduce using rule 170 (switch_statement -> SWITCH LBRACE RBRACE .)
    SWITCH          reduce using rule 170 (switch_statement -> SWITCH LBRACE RBRACE .)
    RETURN          reduce using rule 170 (switch_statement -> SWITCH LBRACE RBRACE .)
    LBRACKET        reduce using rule 170 (switch_statement -> SWITCH LBRACE RBRACE .)
    MAP             reduce using rule 170 (switch_statement -> SWITCH LBRACE RBRACE .)
    FOR             reduce using rule 170 (switch_statement -> SWITCH LBRACE RBRACE .)
    CASE            reduce using rule 170 (switch_statement -> SWITCH LBRACE RBRACE .)
    DEFAULT         reduce using rule 170 (switch_statement -> SWITCH LBRACE RBRACE .)
=======
    (54) assignment -> IDENTIFIER . ASSIGN expression
    (55) assignment -> IDENTIFIER . SHORT_ASSIGN expression

    ASSIGN          shift and go to state 80
    SHORT_ASSIGN    shift and go to state 81


state 273

    (107) if_statement -> IF expression block ELSE block .

    SEMICOLON       reduce using rule 107 (if_statement -> IF expression block ELSE block .)
    FUNC            reduce using rule 107 (if_statement -> IF expression block ELSE block .)
    TYPE            reduce using rule 107 (if_statement -> IF expression block ELSE block .)
    IDENTIFIER      reduce using rule 107 (if_statement -> IF expression block ELSE block .)
    VAR             reduce using rule 107 (if_statement -> IF expression block ELSE block .)
    CONST           reduce using rule 107 (if_statement -> IF expression block ELSE block .)
    PLUS            reduce using rule 107 (if_statement -> IF expression block ELSE block .)
    MINUS           reduce using rule 107 (if_statement -> IF expression block ELSE block .)
    LNOT            reduce using rule 107 (if_statement -> IF expression block ELSE block .)
    LBRACKET        reduce using rule 107 (if_statement -> IF expression block ELSE block .)
    LPAREN          reduce using rule 107 (if_statement -> IF expression block ELSE block .)
    INT             reduce using rule 107 (if_statement -> IF expression block ELSE block .)
    FLOAT64         reduce using rule 107 (if_statement -> IF expression block ELSE block .)
    TRUE            reduce using rule 107 (if_statement -> IF expression block ELSE block .)
    FALSE           reduce using rule 107 (if_statement -> IF expression block ELSE block .)
    STRING          reduce using rule 107 (if_statement -> IF expression block ELSE block .)
    RETURN          reduce using rule 107 (if_statement -> IF expression block ELSE block .)
    FOR             reduce using rule 107 (if_statement -> IF expression block ELSE block .)
    IF              reduce using rule 107 (if_statement -> IF expression block ELSE block .)
    SWITCH          reduce using rule 107 (if_statement -> IF expression block ELSE block .)
    BREAK           reduce using rule 107 (if_statement -> IF expression block ELSE block .)
    CONTINUE        reduce using rule 107 (if_statement -> IF expression block ELSE block .)
    FALLTHROUGH     reduce using rule 107 (if_statement -> IF expression block ELSE block .)
    $end            reduce using rule 107 (if_statement -> IF expression block ELSE block .)
    RBRACE          reduce using rule 107 (if_statement -> IF expression block ELSE block .)
    CASE            reduce using rule 107 (if_statement -> IF expression block ELSE block .)
    DEFAULT         reduce using rule 107 (if_statement -> IF expression block ELSE block .)
>>>>>>> Stashed changes


state 274

<<<<<<< Updated upstream
    (186) case_clause_list -> case_clause .

    RBRACE          reduce using rule 186 (case_clause_list -> case_clause .)
    CASE            reduce using rule 186 (case_clause_list -> case_clause .)
    DEFAULT         reduce using rule 186 (case_clause_list -> case_clause .)
=======
    (108) if_statement -> IF expression block ELSE if_statement .

    SEMICOLON       reduce using rule 108 (if_statement -> IF expression block ELSE if_statement .)
    FUNC            reduce using rule 108 (if_statement -> IF expression block ELSE if_statement .)
    TYPE            reduce using rule 108 (if_statement -> IF expression block ELSE if_statement .)
    IDENTIFIER      reduce using rule 108 (if_statement -> IF expression block ELSE if_statement .)
    VAR             reduce using rule 108 (if_statement -> IF expression block ELSE if_statement .)
    CONST           reduce using rule 108 (if_statement -> IF expression block ELSE if_statement .)
    PLUS            reduce using rule 108 (if_statement -> IF expression block ELSE if_statement .)
    MINUS           reduce using rule 108 (if_statement -> IF expression block ELSE if_statement .)
    LNOT            reduce using rule 108 (if_statement -> IF expression block ELSE if_statement .)
    LBRACKET        reduce using rule 108 (if_statement -> IF expression block ELSE if_statement .)
    LPAREN          reduce using rule 108 (if_statement -> IF expression block ELSE if_statement .)
    INT             reduce using rule 108 (if_statement -> IF expression block ELSE if_statement .)
    FLOAT64         reduce using rule 108 (if_statement -> IF expression block ELSE if_statement .)
    TRUE            reduce using rule 108 (if_statement -> IF expression block ELSE if_statement .)
    FALSE           reduce using rule 108 (if_statement -> IF expression block ELSE if_statement .)
    STRING          reduce using rule 108 (if_statement -> IF expression block ELSE if_statement .)
    RETURN          reduce using rule 108 (if_statement -> IF expression block ELSE if_statement .)
    FOR             reduce using rule 108 (if_statement -> IF expression block ELSE if_statement .)
    IF              reduce using rule 108 (if_statement -> IF expression block ELSE if_statement .)
    SWITCH          reduce using rule 108 (if_statement -> IF expression block ELSE if_statement .)
    BREAK           reduce using rule 108 (if_statement -> IF expression block ELSE if_statement .)
    CONTINUE        reduce using rule 108 (if_statement -> IF expression block ELSE if_statement .)
    FALLTHROUGH     reduce using rule 108 (if_statement -> IF expression block ELSE if_statement .)
    $end            reduce using rule 108 (if_statement -> IF expression block ELSE if_statement .)
    RBRACE          reduce using rule 108 (if_statement -> IF expression block ELSE if_statement .)
    CASE            reduce using rule 108 (if_statement -> IF expression block ELSE if_statement .)
    DEFAULT         reduce using rule 108 (if_statement -> IF expression block ELSE if_statement .)
>>>>>>> Stashed changes


state 275

<<<<<<< Updated upstream
    (191) case_clause -> CASE . case_expression_list COLON case_body
    (193) case_expression_list -> . expression
    (194) case_expression_list -> . case_expression_list COMMA expression
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (125) expression -> . LNOT expression
    (126) expression -> . IDENTIFIER PLUSPLUS
    (127) expression -> . IDENTIFIER MINUSMINUS
    (138) expression -> . map_type LBRACE expression_map_list RBRACE
    (139) expression -> . map_type LBRACE RBRACE
    (161) expression -> . type_name LBRACE keyed_element_list RBRACE
    (162) expression -> . type_name LBRACE RBRACE
    (198) expression -> . array_type LBRACE expression_list RBRACE
    (199) expression -> . array_type LBRACE RBRACE
    (200) expression -> . expression DOT IDENTIFIER
    (201) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> . expression LBRACKET expression RBRACKET
    (203) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (137) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (163) type_name -> . IDENTIFIER
    (164) type_name -> . slice_type
    (165) type_name -> . array_type
    (166) type_name -> . map_type
    (197) array_type -> . LBRACKET INT RBRACKET primitive_type

    LPAREN          shift and go to state 54
    INT             shift and go to state 55
    FLOAT64         shift and go to state 56
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 57
    TRUE            shift and go to state 58
    FALSE           shift and go to state 59
    LNOT            shift and go to state 60
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39
=======
    (109) if_statement -> IF assignment SEMICOLON expression block .
    (110) if_statement -> IF assignment SEMICOLON expression block . ELSE block
    (111) if_statement -> IF assignment SEMICOLON expression block . ELSE if_statement

    SEMICOLON       reduce using rule 109 (if_statement -> IF assignment SEMICOLON expression block .)
    FUNC            reduce using rule 109 (if_statement -> IF assignment SEMICOLON expression block .)
    TYPE            reduce using rule 109 (if_statement -> IF assignment SEMICOLON expression block .)
    IDENTIFIER      reduce using rule 109 (if_statement -> IF assignment SEMICOLON expression block .)
    VAR             reduce using rule 109 (if_statement -> IF assignment SEMICOLON expression block .)
    CONST           reduce using rule 109 (if_statement -> IF assignment SEMICOLON expression block .)
    PLUS            reduce using rule 109 (if_statement -> IF assignment SEMICOLON expression block .)
    MINUS           reduce using rule 109 (if_statement -> IF assignment SEMICOLON expression block .)
    LNOT            reduce using rule 109 (if_statement -> IF assignment SEMICOLON expression block .)
    LBRACKET        reduce using rule 109 (if_statement -> IF assignment SEMICOLON expression block .)
    LPAREN          reduce using rule 109 (if_statement -> IF assignment SEMICOLON expression block .)
    INT             reduce using rule 109 (if_statement -> IF assignment SEMICOLON expression block .)
    FLOAT64         reduce using rule 109 (if_statement -> IF assignment SEMICOLON expression block .)
    TRUE            reduce using rule 109 (if_statement -> IF assignment SEMICOLON expression block .)
    FALSE           reduce using rule 109 (if_statement -> IF assignment SEMICOLON expression block .)
    STRING          reduce using rule 109 (if_statement -> IF assignment SEMICOLON expression block .)
    RETURN          reduce using rule 109 (if_statement -> IF assignment SEMICOLON expression block .)
    FOR             reduce using rule 109 (if_statement -> IF assignment SEMICOLON expression block .)
    IF              reduce using rule 109 (if_statement -> IF assignment SEMICOLON expression block .)
    SWITCH          reduce using rule 109 (if_statement -> IF assignment SEMICOLON expression block .)
    BREAK           reduce using rule 109 (if_statement -> IF assignment SEMICOLON expression block .)
    CONTINUE        reduce using rule 109 (if_statement -> IF assignment SEMICOLON expression block .)
    FALLTHROUGH     reduce using rule 109 (if_statement -> IF assignment SEMICOLON expression block .)
    $end            reduce using rule 109 (if_statement -> IF assignment SEMICOLON expression block .)
    RBRACE          reduce using rule 109 (if_statement -> IF assignment SEMICOLON expression block .)
    CASE            reduce using rule 109 (if_statement -> IF assignment SEMICOLON expression block .)
    DEFAULT         reduce using rule 109 (if_statement -> IF assignment SEMICOLON expression block .)
    ELSE            shift and go to state 298
>>>>>>> Stashed changes

    case_expression_list           shift and go to state 296
    expression                     shift and go to state 297
    slice_type                     shift and go to state 53
    map_type                       shift and go to state 61
    type_name                      shift and go to state 62
    array_type                     shift and go to state 63

state 276

<<<<<<< Updated upstream
    (192) case_clause -> DEFAULT . COLON case_body

    COLON           shift and go to state 298
=======
    (189) switch_statement -> SWITCH enter_block switch_header LBRACE case_clauses . RBRACE exit_block
    (172) case_clauses -> case_clauses . case_clause
    (173) case_clause -> . CASE case_expression_list COLON enter_block case_body exit_block
    (174) case_clause -> . DEFAULT COLON enter_block case_body exit_block

    RBRACE          shift and go to state 299
    CASE            shift and go to state 278
    DEFAULT         shift and go to state 279
>>>>>>> Stashed changes

    case_clause                    shift and go to state 300

state 277

<<<<<<< Updated upstream
    (171) switch_statement -> SWITCH switch_assignment SEMICOLON . switch_expr LBRACE case_clause_list RBRACE
    (172) switch_statement -> SWITCH switch_assignment SEMICOLON . switch_expr LBRACE RBRACE
    (173) switch_statement -> SWITCH switch_assignment SEMICOLON . LBRACE case_clause_list RBRACE
    (174) switch_statement -> SWITCH switch_assignment SEMICOLON . LBRACE RBRACE
    (175) switch_expr -> . primary_expression
    (176) primary_expression -> . IDENTIFIER
    (177) primary_expression -> . INT
    (178) primary_expression -> . FLOAT64
    (179) primary_expression -> . STRING
    (180) primary_expression -> . TRUE
    (181) primary_expression -> . FALSE
    (182) primary_expression -> . LPAREN expression RPAREN
    (183) primary_expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (184) primary_expression -> . primary_expression DOT IDENTIFIER
    (185) primary_expression -> . primary_expression LBRACKET expression RBRACKET

    LBRACE          shift and go to state 300
    IDENTIFIER      shift and go to state 301
    INT             shift and go to state 245
    FLOAT64         shift and go to state 246
    STRING          shift and go to state 247
    TRUE            shift and go to state 248
    FALSE           shift and go to state 249
    LPAREN          shift and go to state 250

    switch_expr                    shift and go to state 299
    primary_expression             shift and go to state 240

state 278

    (184) primary_expression -> primary_expression DOT . IDENTIFIER

    IDENTIFIER      shift and go to state 302
=======
    (171) case_clauses -> case_clause .

    RBRACE          reduce using rule 171 (case_clauses -> case_clause .)
    CASE            reduce using rule 171 (case_clauses -> case_clause .)
    DEFAULT         reduce using rule 171 (case_clauses -> case_clause .)


state 278

    (173) case_clause -> CASE . case_expression_list COLON enter_block case_body exit_block
    (169) case_expression_list -> . expression
    (170) case_expression_list -> . case_expression_list COMMA expression
    (82) expression -> . binary_expression
    (83) expression -> . relational_expression
    (84) expression -> . logical_expression
    (85) expression -> . bitwise_expression
    (86) expression -> . PLUS expression
    (87) expression -> . MINUS expression
    (88) expression -> . LNOT expression
    (89) expression -> . LBRACKET RBRACKET primitive_type LBRACE expression_list RBRACE
    (90) expression -> . LBRACKET RBRACKET primitive_type LBRACE RBRACE
    (91) expression -> . LPAREN expression RPAREN
    (92) expression -> . INT
    (93) expression -> . FLOAT64
    (94) expression -> . TRUE
    (95) expression -> . FALSE
    (96) expression -> . IDENTIFIER
    (97) expression -> . STRING
    (98) expression -> . IDENTIFIER PLUSPLUS
    (99) expression -> . IDENTIFIER MINUSMINUS
    (100) expression -> . expression DOT IDENTIFIER
    (103) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (133) expression -> . IDENTIFIER LBRACE keyed_element_list RBRACE
    (134) expression -> . IDENTIFIER LBRACE RBRACE
    (135) binary_expression -> . expression PLUS expression
    (136) binary_expression -> . expression MINUS expression
    (137) binary_expression -> . expression TIMES expression
    (138) binary_expression -> . expression DIVIDE expression
    (139) binary_expression -> . expression MODULE expression
    (144) relational_expression -> . expression EQ expression
    (145) relational_expression -> . expression NEQ expression
    (146) relational_expression -> . expression LT expression
    (147) relational_expression -> . expression LE expression
    (148) relational_expression -> . expression GT expression
    (149) relational_expression -> . expression GE expression
    (150) logical_expression -> . expression LAND expression
    (151) logical_expression -> . expression LOR expression
    (152) bitwise_expression -> . expression AND expression
    (153) bitwise_expression -> . expression OR expression
    (154) bitwise_expression -> . expression XOR expression
    (155) bitwise_expression -> . expression AND_NOT expression
    (156) bitwise_expression -> . expression LSHIFT expression
    (157) bitwise_expression -> . expression RSHIFT expression

    PLUS            shift and go to state 37
    MINUS           shift and go to state 38
    LNOT            shift and go to state 39
    LBRACKET        shift and go to state 40
    LPAREN          shift and go to state 29
    INT             shift and go to state 41
    FLOAT64         shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44
    IDENTIFIER      shift and go to state 97
    STRING          shift and go to state 11
>>>>>>> Stashed changes

    case_expression_list           shift and go to state 301
    expression                     shift and go to state 302
    binary_expression              shift and go to state 33
    relational_expression          shift and go to state 34
    logical_expression             shift and go to state 35
    bitwise_expression             shift and go to state 36

state 279

<<<<<<< Updated upstream
    (185) primary_expression -> primary_expression LBRACKET . expression RBRACKET
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (125) expression -> . LNOT expression
    (126) expression -> . IDENTIFIER PLUSPLUS
    (127) expression -> . IDENTIFIER MINUSMINUS
    (138) expression -> . map_type LBRACE expression_map_list RBRACE
    (139) expression -> . map_type LBRACE RBRACE
    (161) expression -> . type_name LBRACE keyed_element_list RBRACE
    (162) expression -> . type_name LBRACE RBRACE
    (198) expression -> . array_type LBRACE expression_list RBRACE
    (199) expression -> . array_type LBRACE RBRACE
    (200) expression -> . expression DOT IDENTIFIER
    (201) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> . expression LBRACKET expression RBRACKET
    (203) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (137) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (163) type_name -> . IDENTIFIER
    (164) type_name -> . slice_type
    (165) type_name -> . array_type
    (166) type_name -> . map_type
    (197) array_type -> . LBRACKET INT RBRACKET primitive_type

    LPAREN          shift and go to state 54
    INT             shift and go to state 55
    FLOAT64         shift and go to state 56
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 57
    TRUE            shift and go to state 58
    FALSE           shift and go to state 59
    LNOT            shift and go to state 60
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39
=======
    (174) case_clause -> DEFAULT . COLON enter_block case_body exit_block

    COLON           shift and go to state 303
>>>>>>> Stashed changes

    expression                     shift and go to state 303
    slice_type                     shift and go to state 53
    map_type                       shift and go to state 61
    type_name                      shift and go to state 62
    array_type                     shift and go to state 63

state 280

<<<<<<< Updated upstream
    (183) primary_expression -> IDENTIFIER LPAREN . argument_list RPAREN
    (204) argument_list -> . expression_list
    (205) argument_list -> . empty
    (68) expression_list -> . expression
    (69) expression_list -> . expression_list COMMA expression
    (7) empty -> .
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (125) expression -> . LNOT expression
    (126) expression -> . IDENTIFIER PLUSPLUS
    (127) expression -> . IDENTIFIER MINUSMINUS
    (138) expression -> . map_type LBRACE expression_map_list RBRACE
    (139) expression -> . map_type LBRACE RBRACE
    (161) expression -> . type_name LBRACE keyed_element_list RBRACE
    (162) expression -> . type_name LBRACE RBRACE
    (198) expression -> . array_type LBRACE expression_list RBRACE
    (199) expression -> . array_type LBRACE RBRACE
    (200) expression -> . expression DOT IDENTIFIER
    (201) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> . expression LBRACKET expression RBRACKET
    (203) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (137) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (163) type_name -> . IDENTIFIER
    (164) type_name -> . slice_type
    (165) type_name -> . array_type
    (166) type_name -> . map_type
    (197) array_type -> . LBRACKET INT RBRACKET primitive_type

    RPAREN          reduce using rule 7 (empty -> .)
    LPAREN          shift and go to state 54
    INT             shift and go to state 55
    FLOAT64         shift and go to state 56
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 57
    TRUE            shift and go to state 58
    FALSE           shift and go to state 59
    LNOT            shift and go to state 60
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39
=======
    (184) switch_init -> assignment SEMICOLON switch_expression .

    LBRACE          reduce using rule 184 (switch_init -> assignment SEMICOLON switch_expression .)
>>>>>>> Stashed changes

    argument_list                  shift and go to state 304
    expression_list                shift and go to state 125
    empty                          shift and go to state 126
    expression                     shift and go to state 127
    slice_type                     shift and go to state 53
    map_type                       shift and go to state 61
    type_name                      shift and go to state 62
    array_type                     shift and go to state 63

state 281

<<<<<<< Updated upstream
    (182) primary_expression -> LPAREN expression . RPAREN
    (36) expression -> expression . binary_operator expression
    (200) expression -> expression . DOT IDENTIFIER
    (201) expression -> expression . DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> expression . LBRACKET expression RBRACKET
    (37) binary_operator -> . PLUS
    (38) binary_operator -> . MINUS
    (39) binary_operator -> . TIMES
    (40) binary_operator -> . DIVIDE
    (41) binary_operator -> . MODULE
    (42) binary_operator -> . EQ
    (43) binary_operator -> . NEQ
    (44) binary_operator -> . LT
    (45) binary_operator -> . LE
    (46) binary_operator -> . GT
    (47) binary_operator -> . GE
    (48) binary_operator -> . LAND
    (49) binary_operator -> . LOR
    (50) binary_operator -> . AND
    (51) binary_operator -> . OR
    (52) binary_operator -> . XOR
    (53) binary_operator -> . AND_NOT
    (54) binary_operator -> . LSHIFT
    (55) binary_operator -> . RSHIFT

    RPAREN          shift and go to state 305
    DOT             shift and go to state 82
    LBRACKET        shift and go to state 83
    PLUS            shift and go to state 84
    MINUS           shift and go to state 85
    TIMES           shift and go to state 86
    DIVIDE          shift and go to state 87
    MODULE          shift and go to state 88
    EQ              shift and go to state 89
    NEQ             shift and go to state 90
    LT              shift and go to state 91
    LE              shift and go to state 92
    GT              shift and go to state 93
    GE              shift and go to state 94
    LAND            shift and go to state 95
    LOR             shift and go to state 96
    AND             shift and go to state 97
    OR              shift and go to state 98
    XOR             shift and go to state 99
    AND_NOT         shift and go to state 100
    LSHIFT          shift and go to state 101
    RSHIFT          shift and go to state 102

    binary_operator                shift and go to state 81

state 282

    (111) return_list -> return_list COMMA . expression
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (125) expression -> . LNOT expression
    (126) expression -> . IDENTIFIER PLUSPLUS
    (127) expression -> . IDENTIFIER MINUSMINUS
    (138) expression -> . map_type LBRACE expression_map_list RBRACE
    (139) expression -> . map_type LBRACE RBRACE
    (161) expression -> . type_name LBRACE keyed_element_list RBRACE
    (162) expression -> . type_name LBRACE RBRACE
    (198) expression -> . array_type LBRACE expression_list RBRACE
    (199) expression -> . array_type LBRACE RBRACE
    (200) expression -> . expression DOT IDENTIFIER
    (201) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> . expression LBRACKET expression RBRACKET
    (203) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (137) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (163) type_name -> . IDENTIFIER
    (164) type_name -> . slice_type
    (165) type_name -> . array_type
    (166) type_name -> . map_type
    (197) array_type -> . LBRACKET INT RBRACKET primitive_type

    LPAREN          shift and go to state 54
    INT             shift and go to state 55
    FLOAT64         shift and go to state 56
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 57
    TRUE            shift and go to state 58
    FALSE           shift and go to state 59
    LNOT            shift and go to state 60
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39
=======
    (178) switch_primary -> IDENTIFIER .

    LBRACE          reduce using rule 178 (switch_primary -> IDENTIFIER .)


state 282

    (48) parameter -> IDENTIFIER ELLIPSIS primitive_type .

    RPAREN          reduce using rule 48 (parameter -> IDENTIFIER ELLIPSIS primitive_type .)
    COMMA           reduce using rule 48 (parameter -> IDENTIFIER ELLIPSIS primitive_type .)
>>>>>>> Stashed changes

    expression                     shift and go to state 306
    slice_type                     shift and go to state 53
    map_type                       shift and go to state 61
    type_name                      shift and go to state 62
    array_type                     shift and go to state 63

state 283

<<<<<<< Updated upstream
    (97) for_classic -> FOR for_init SEMICOLON . for_cond SEMICOLON for_post block
    (104) for_cond -> . expression
    (105) for_cond -> . empty
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (125) expression -> . LNOT expression
    (126) expression -> . IDENTIFIER PLUSPLUS
    (127) expression -> . IDENTIFIER MINUSMINUS
    (138) expression -> . map_type LBRACE expression_map_list RBRACE
    (139) expression -> . map_type LBRACE RBRACE
    (161) expression -> . type_name LBRACE keyed_element_list RBRACE
    (162) expression -> . type_name LBRACE RBRACE
    (198) expression -> . array_type LBRACE expression_list RBRACE
    (199) expression -> . array_type LBRACE RBRACE
    (200) expression -> . expression DOT IDENTIFIER
    (201) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> . expression LBRACKET expression RBRACKET
    (203) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (7) empty -> .
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (137) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (163) type_name -> . IDENTIFIER
    (164) type_name -> . slice_type
    (165) type_name -> . array_type
    (166) type_name -> . map_type
    (197) array_type -> . LBRACKET INT RBRACKET primitive_type

    LPAREN          shift and go to state 54
    INT             shift and go to state 55
    FLOAT64         shift and go to state 56
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 57
    TRUE            shift and go to state 58
    FALSE           shift and go to state 59
    LNOT            shift and go to state 60
    SEMICOLON       reduce using rule 7 (empty -> .)
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    for_cond                       shift and go to state 307
    expression                     shift and go to state 308
    empty                          shift and go to state 309
    slice_type                     shift and go to state 53
    map_type                       shift and go to state 61
    type_name                      shift and go to state 62
    array_type                     shift and go to state 63

state 284

    (98) for_condition -> FOR expression block .

    RBRACE          reduce using rule 98 (for_condition -> FOR expression block .)
    BREAK           reduce using rule 98 (for_condition -> FOR expression block .)
    CONTINUE        reduce using rule 98 (for_condition -> FOR expression block .)
    VAR             reduce using rule 98 (for_condition -> FOR expression block .)
    CONST           reduce using rule 98 (for_condition -> FOR expression block .)
    IDENTIFIER      reduce using rule 98 (for_condition -> FOR expression block .)
    LPAREN          reduce using rule 98 (for_condition -> FOR expression block .)
    INT             reduce using rule 98 (for_condition -> FOR expression block .)
    FLOAT64         reduce using rule 98 (for_condition -> FOR expression block .)
    STRING          reduce using rule 98 (for_condition -> FOR expression block .)
    TRUE            reduce using rule 98 (for_condition -> FOR expression block .)
    FALSE           reduce using rule 98 (for_condition -> FOR expression block .)
    LNOT            reduce using rule 98 (for_condition -> FOR expression block .)
    IF              reduce using rule 98 (for_condition -> FOR expression block .)
    SWITCH          reduce using rule 98 (for_condition -> FOR expression block .)
    RETURN          reduce using rule 98 (for_condition -> FOR expression block .)
    LBRACKET        reduce using rule 98 (for_condition -> FOR expression block .)
    MAP             reduce using rule 98 (for_condition -> FOR expression block .)
    FOR             reduce using rule 98 (for_condition -> FOR expression block .)
    CASE            reduce using rule 98 (for_condition -> FOR expression block .)
    DEFAULT         reduce using rule 98 (for_condition -> FOR expression block .)


state 285

    (146) method_declaration -> FUNC LPAREN receiver RPAREN IDENTIFIER LPAREN parameter_list RPAREN return_type block .

    VAR             reduce using rule 146 (method_declaration -> FUNC LPAREN receiver RPAREN IDENTIFIER LPAREN parameter_list RPAREN return_type block .)
    CONST           reduce using rule 146 (method_declaration -> FUNC LPAREN receiver RPAREN IDENTIFIER LPAREN parameter_list RPAREN return_type block .)
    FUNC            reduce using rule 146 (method_declaration -> FUNC LPAREN receiver RPAREN IDENTIFIER LPAREN parameter_list RPAREN return_type block .)
    TYPE            reduce using rule 146 (method_declaration -> FUNC LPAREN receiver RPAREN IDENTIFIER LPAREN parameter_list RPAREN return_type block .)
    $end            reduce using rule 146 (method_declaration -> FUNC LPAREN receiver RPAREN IDENTIFIER LPAREN parameter_list RPAREN return_type block .)
=======
    (50) return_type -> LPAREN . type_list RPAREN
    (52) type_list -> . type_list COMMA type
    (53) type_list -> . type
    (70) type -> . primitive_type
    (71) type -> . slice_type
    (72) type -> . array_type
    (73) type -> . map_type
    (74) type -> . struct_type
    (75) type -> . IDENTIFIER
    (76) primitive_type -> . INT_TYPE
    (77) primitive_type -> . FLOAT64_TYPE
    (78) primitive_type -> . STRING_TYPE
    (79) primitive_type -> . BOOL_TYPE
    (80) slice_type -> . LBRACKET RBRACKET primitive_type
    (81) array_type -> . LBRACKET INT RBRACKET type
    (127) map_type -> . MAP LBRACKET primitive_type RBRACKET type
    (118) struct_type -> . STRUCT LBRACE RBRACE
    (119) struct_type -> . STRUCT LBRACE field_list RBRACE

    IDENTIFIER      shift and go to state 177
    INT_TYPE        shift and go to state 171
    FLOAT64_TYPE    shift and go to state 172
    STRING_TYPE     shift and go to state 173
    BOOL_TYPE       shift and go to state 174
    LBRACKET        shift and go to state 175
    MAP             shift and go to state 176
    STRUCT          shift and go to state 170

    type_list                      shift and go to state 304
    type                           shift and go to state 305
    primitive_type                 shift and go to state 180
    slice_type                     shift and go to state 181
    array_type                     shift and go to state 182
    map_type                       shift and go to state 183
    struct_type                    shift and go to state 184

state 284

    (43) function_declaration -> FUNC IDENTIFIER LPAREN parameter_list RPAREN return_type . block
    (16) block -> . LBRACE enter_block exit_block RBRACE
    (17) block -> . LBRACE enter_block statement_list exit_block RBRACE

    LBRACE          shift and go to state 110

    block                          shift and go to state 306

state 285

    (49) return_type -> type .

    LBRACE          reduce using rule 49 (return_type -> type .)
>>>>>>> Stashed changes


state 286

<<<<<<< Updated upstream
    (21) local_var_dec -> VAR IDENTIFIER type ASSIGN . expression
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (125) expression -> . LNOT expression
    (126) expression -> . IDENTIFIER PLUSPLUS
    (127) expression -> . IDENTIFIER MINUSMINUS
    (138) expression -> . map_type LBRACE expression_map_list RBRACE
    (139) expression -> . map_type LBRACE RBRACE
    (161) expression -> . type_name LBRACE keyed_element_list RBRACE
    (162) expression -> . type_name LBRACE RBRACE
    (198) expression -> . array_type LBRACE expression_list RBRACE
    (199) expression -> . array_type LBRACE RBRACE
    (200) expression -> . expression DOT IDENTIFIER
    (201) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> . expression LBRACKET expression RBRACKET
    (203) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (137) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (163) type_name -> . IDENTIFIER
    (164) type_name -> . slice_type
    (165) type_name -> . array_type
    (166) type_name -> . map_type
    (197) array_type -> . LBRACKET INT RBRACKET primitive_type

    LPAREN          shift and go to state 54
    INT             shift and go to state 55
    FLOAT64         shift and go to state 56
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 57
    TRUE            shift and go to state 58
    FALSE           shift and go to state 59
    LNOT            shift and go to state 60
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39
=======
    (51) return_type -> empty .

    LBRACE          reduce using rule 51 (return_type -> empty .)
>>>>>>> Stashed changes

    expression                     shift and go to state 310
    slice_type                     shift and go to state 53
    map_type                       shift and go to state 61
    type_name                      shift and go to state 62
    array_type                     shift and go to state 63

state 287

<<<<<<< Updated upstream
    (22) local_var_dec -> VAR IDENTIFIER ASSIGN expression .
    (36) expression -> expression . binary_operator expression
    (200) expression -> expression . DOT IDENTIFIER
    (201) expression -> expression . DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> expression . LBRACKET expression RBRACKET
    (37) binary_operator -> . PLUS
    (38) binary_operator -> . MINUS
    (39) binary_operator -> . TIMES
    (40) binary_operator -> . DIVIDE
    (41) binary_operator -> . MODULE
    (42) binary_operator -> . EQ
    (43) binary_operator -> . NEQ
    (44) binary_operator -> . LT
    (45) binary_operator -> . LE
    (46) binary_operator -> . GT
    (47) binary_operator -> . GE
    (48) binary_operator -> . LAND
    (49) binary_operator -> . LOR
    (50) binary_operator -> . AND
    (51) binary_operator -> . OR
    (52) binary_operator -> . XOR
    (53) binary_operator -> . AND_NOT
    (54) binary_operator -> . LSHIFT
    (55) binary_operator -> . RSHIFT

  ! shift/reduce conflict for LBRACKET resolved as shift
    RBRACE          reduce using rule 22 (local_var_dec -> VAR IDENTIFIER ASSIGN expression .)
    BREAK           reduce using rule 22 (local_var_dec -> VAR IDENTIFIER ASSIGN expression .)
    CONTINUE        reduce using rule 22 (local_var_dec -> VAR IDENTIFIER ASSIGN expression .)
    VAR             reduce using rule 22 (local_var_dec -> VAR IDENTIFIER ASSIGN expression .)
    CONST           reduce using rule 22 (local_var_dec -> VAR IDENTIFIER ASSIGN expression .)
    IDENTIFIER      reduce using rule 22 (local_var_dec -> VAR IDENTIFIER ASSIGN expression .)
    LPAREN          reduce using rule 22 (local_var_dec -> VAR IDENTIFIER ASSIGN expression .)
    INT             reduce using rule 22 (local_var_dec -> VAR IDENTIFIER ASSIGN expression .)
    FLOAT64         reduce using rule 22 (local_var_dec -> VAR IDENTIFIER ASSIGN expression .)
    STRING          reduce using rule 22 (local_var_dec -> VAR IDENTIFIER ASSIGN expression .)
    TRUE            reduce using rule 22 (local_var_dec -> VAR IDENTIFIER ASSIGN expression .)
    FALSE           reduce using rule 22 (local_var_dec -> VAR IDENTIFIER ASSIGN expression .)
    LNOT            reduce using rule 22 (local_var_dec -> VAR IDENTIFIER ASSIGN expression .)
    IF              reduce using rule 22 (local_var_dec -> VAR IDENTIFIER ASSIGN expression .)
    SWITCH          reduce using rule 22 (local_var_dec -> VAR IDENTIFIER ASSIGN expression .)
    RETURN          reduce using rule 22 (local_var_dec -> VAR IDENTIFIER ASSIGN expression .)
    MAP             reduce using rule 22 (local_var_dec -> VAR IDENTIFIER ASSIGN expression .)
    FOR             reduce using rule 22 (local_var_dec -> VAR IDENTIFIER ASSIGN expression .)
    SEMICOLON       reduce using rule 22 (local_var_dec -> VAR IDENTIFIER ASSIGN expression .)
    CASE            reduce using rule 22 (local_var_dec -> VAR IDENTIFIER ASSIGN expression .)
    DEFAULT         reduce using rule 22 (local_var_dec -> VAR IDENTIFIER ASSIGN expression .)
    DOT             shift and go to state 82
    LBRACKET        shift and go to state 83
    PLUS            shift and go to state 84
    MINUS           shift and go to state 85
    TIMES           shift and go to state 86
    DIVIDE          shift and go to state 87
    MODULE          shift and go to state 88
    EQ              shift and go to state 89
    NEQ             shift and go to state 90
    LT              shift and go to state 91
    LE              shift and go to state 92
    GT              shift and go to state 93
    GE              shift and go to state 94
    LAND            shift and go to state 95
    LOR             shift and go to state 96
    AND             shift and go to state 97
    OR              shift and go to state 98
    XOR             shift and go to state 99
    AND_NOT         shift and go to state 100
    LSHIFT          shift and go to state 101
    RSHIFT          shift and go to state 102

  ! LBRACKET        [ reduce using rule 22 (local_var_dec -> VAR IDENTIFIER ASSIGN expression .) ]

    binary_operator                shift and go to state 81

state 288

    (23) local_const_dec -> CONST IDENTIFIER type ASSIGN . expression
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (125) expression -> . LNOT expression
    (126) expression -> . IDENTIFIER PLUSPLUS
    (127) expression -> . IDENTIFIER MINUSMINUS
    (138) expression -> . map_type LBRACE expression_map_list RBRACE
    (139) expression -> . map_type LBRACE RBRACE
    (161) expression -> . type_name LBRACE keyed_element_list RBRACE
    (162) expression -> . type_name LBRACE RBRACE
    (198) expression -> . array_type LBRACE expression_list RBRACE
    (199) expression -> . array_type LBRACE RBRACE
    (200) expression -> . expression DOT IDENTIFIER
    (201) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> . expression LBRACKET expression RBRACKET
    (203) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (137) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (163) type_name -> . IDENTIFIER
    (164) type_name -> . slice_type
    (165) type_name -> . array_type
    (166) type_name -> . map_type
    (197) array_type -> . LBRACKET INT RBRACKET primitive_type

    LPAREN          shift and go to state 54
    INT             shift and go to state 55
    FLOAT64         shift and go to state 56
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 57
    TRUE            shift and go to state 58
    FALSE           shift and go to state 59
    LNOT            shift and go to state 60
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    expression                     shift and go to state 311
    slice_type                     shift and go to state 53
    map_type                       shift and go to state 61
    type_name                      shift and go to state 62
    array_type                     shift and go to state 63

state 289

    (24) local_const_dec -> CONST IDENTIFIER ASSIGN expression .
    (36) expression -> expression . binary_operator expression
    (200) expression -> expression . DOT IDENTIFIER
    (201) expression -> expression . DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> expression . LBRACKET expression RBRACKET
    (37) binary_operator -> . PLUS
    (38) binary_operator -> . MINUS
    (39) binary_operator -> . TIMES
    (40) binary_operator -> . DIVIDE
    (41) binary_operator -> . MODULE
    (42) binary_operator -> . EQ
    (43) binary_operator -> . NEQ
    (44) binary_operator -> . LT
    (45) binary_operator -> . LE
    (46) binary_operator -> . GT
    (47) binary_operator -> . GE
    (48) binary_operator -> . LAND
    (49) binary_operator -> . LOR
    (50) binary_operator -> . AND
    (51) binary_operator -> . OR
    (52) binary_operator -> . XOR
    (53) binary_operator -> . AND_NOT
    (54) binary_operator -> . LSHIFT
    (55) binary_operator -> . RSHIFT

  ! shift/reduce conflict for LBRACKET resolved as shift
    RBRACE          reduce using rule 24 (local_const_dec -> CONST IDENTIFIER ASSIGN expression .)
    BREAK           reduce using rule 24 (local_const_dec -> CONST IDENTIFIER ASSIGN expression .)
    CONTINUE        reduce using rule 24 (local_const_dec -> CONST IDENTIFIER ASSIGN expression .)
    VAR             reduce using rule 24 (local_const_dec -> CONST IDENTIFIER ASSIGN expression .)
    CONST           reduce using rule 24 (local_const_dec -> CONST IDENTIFIER ASSIGN expression .)
    IDENTIFIER      reduce using rule 24 (local_const_dec -> CONST IDENTIFIER ASSIGN expression .)
    LPAREN          reduce using rule 24 (local_const_dec -> CONST IDENTIFIER ASSIGN expression .)
    INT             reduce using rule 24 (local_const_dec -> CONST IDENTIFIER ASSIGN expression .)
    FLOAT64         reduce using rule 24 (local_const_dec -> CONST IDENTIFIER ASSIGN expression .)
    STRING          reduce using rule 24 (local_const_dec -> CONST IDENTIFIER ASSIGN expression .)
    TRUE            reduce using rule 24 (local_const_dec -> CONST IDENTIFIER ASSIGN expression .)
    FALSE           reduce using rule 24 (local_const_dec -> CONST IDENTIFIER ASSIGN expression .)
    LNOT            reduce using rule 24 (local_const_dec -> CONST IDENTIFIER ASSIGN expression .)
    IF              reduce using rule 24 (local_const_dec -> CONST IDENTIFIER ASSIGN expression .)
    SWITCH          reduce using rule 24 (local_const_dec -> CONST IDENTIFIER ASSIGN expression .)
    RETURN          reduce using rule 24 (local_const_dec -> CONST IDENTIFIER ASSIGN expression .)
    MAP             reduce using rule 24 (local_const_dec -> CONST IDENTIFIER ASSIGN expression .)
    FOR             reduce using rule 24 (local_const_dec -> CONST IDENTIFIER ASSIGN expression .)
    CASE            reduce using rule 24 (local_const_dec -> CONST IDENTIFIER ASSIGN expression .)
    DEFAULT         reduce using rule 24 (local_const_dec -> CONST IDENTIFIER ASSIGN expression .)
    DOT             shift and go to state 82
    LBRACKET        shift and go to state 83
    PLUS            shift and go to state 84
    MINUS           shift and go to state 85
    TIMES           shift and go to state 86
    DIVIDE          shift and go to state 87
    MODULE          shift and go to state 88
    EQ              shift and go to state 89
    NEQ             shift and go to state 90
    LT              shift and go to state 91
    LE              shift and go to state 92
    GT              shift and go to state 93
    GE              shift and go to state 94
    LAND            shift and go to state 95
    LOR             shift and go to state 96
    AND             shift and go to state 97
    OR              shift and go to state 98
    XOR             shift and go to state 99
    AND_NOT         shift and go to state 100
    LSHIFT          shift and go to state 101
    RSHIFT          shift and go to state 102
=======
    (44) parameter_list -> parameter_list COMMA parameter .

    RPAREN          reduce using rule 44 (parameter_list -> parameter_list COMMA parameter .)
    COMMA           reduce using rule 44 (parameter_list -> parameter_list COMMA parameter .)


state 288

    (124) method_declaration -> FUNC LPAREN receiver RPAREN IDENTIFIER LPAREN . parameter_list RPAREN return_type block
    (44) parameter_list -> . parameter_list COMMA parameter
    (45) parameter_list -> . parameter
    (46) parameter_list -> . empty
    (47) parameter -> . IDENTIFIER type
    (48) parameter -> . IDENTIFIER ELLIPSIS primitive_type
    (7) empty -> .

    IDENTIFIER      shift and go to state 208
    RPAREN          reduce using rule 7 (empty -> .)
    COMMA           reduce using rule 7 (empty -> .)

    parameter_list                 shift and go to state 307
    parameter                      shift and go to state 210
    empty                          shift and go to state 211

state 289

    (119) struct_type -> STRUCT LBRACE field_list RBRACE .

    SEMICOLON       reduce using rule 119 (struct_type -> STRUCT LBRACE field_list RBRACE .)
    FUNC            reduce using rule 119 (struct_type -> STRUCT LBRACE field_list RBRACE .)
    TYPE            reduce using rule 119 (struct_type -> STRUCT LBRACE field_list RBRACE .)
    IDENTIFIER      reduce using rule 119 (struct_type -> STRUCT LBRACE field_list RBRACE .)
    VAR             reduce using rule 119 (struct_type -> STRUCT LBRACE field_list RBRACE .)
    CONST           reduce using rule 119 (struct_type -> STRUCT LBRACE field_list RBRACE .)
    PLUS            reduce using rule 119 (struct_type -> STRUCT LBRACE field_list RBRACE .)
    MINUS           reduce using rule 119 (struct_type -> STRUCT LBRACE field_list RBRACE .)
    LNOT            reduce using rule 119 (struct_type -> STRUCT LBRACE field_list RBRACE .)
    LBRACKET        reduce using rule 119 (struct_type -> STRUCT LBRACE field_list RBRACE .)
    LPAREN          reduce using rule 119 (struct_type -> STRUCT LBRACE field_list RBRACE .)
    INT             reduce using rule 119 (struct_type -> STRUCT LBRACE field_list RBRACE .)
    FLOAT64         reduce using rule 119 (struct_type -> STRUCT LBRACE field_list RBRACE .)
    TRUE            reduce using rule 119 (struct_type -> STRUCT LBRACE field_list RBRACE .)
    FALSE           reduce using rule 119 (struct_type -> STRUCT LBRACE field_list RBRACE .)
    STRING          reduce using rule 119 (struct_type -> STRUCT LBRACE field_list RBRACE .)
    RETURN          reduce using rule 119 (struct_type -> STRUCT LBRACE field_list RBRACE .)
    FOR             reduce using rule 119 (struct_type -> STRUCT LBRACE field_list RBRACE .)
    IF              reduce using rule 119 (struct_type -> STRUCT LBRACE field_list RBRACE .)
    SWITCH          reduce using rule 119 (struct_type -> STRUCT LBRACE field_list RBRACE .)
    BREAK           reduce using rule 119 (struct_type -> STRUCT LBRACE field_list RBRACE .)
    CONTINUE        reduce using rule 119 (struct_type -> STRUCT LBRACE field_list RBRACE .)
    FALLTHROUGH     reduce using rule 119 (struct_type -> STRUCT LBRACE field_list RBRACE .)
    $end            reduce using rule 119 (struct_type -> STRUCT LBRACE field_list RBRACE .)
    ASSIGN          reduce using rule 119 (struct_type -> STRUCT LBRACE field_list RBRACE .)
    RPAREN          reduce using rule 119 (struct_type -> STRUCT LBRACE field_list RBRACE .)
    COMMA           reduce using rule 119 (struct_type -> STRUCT LBRACE field_list RBRACE .)
    LBRACE          reduce using rule 119 (struct_type -> STRUCT LBRACE field_list RBRACE .)
    RBRACE          reduce using rule 119 (struct_type -> STRUCT LBRACE field_list RBRACE .)
>>>>>>> Stashed changes

  ! LBRACKET        [ reduce using rule 24 (local_const_dec -> CONST IDENTIFIER ASSIGN expression .) ]

    binary_operator                shift and go to state 81

state 290

<<<<<<< Updated upstream
    (129) if_statement -> IF expression block ELSE . block
    (130) if_statement -> IF expression block ELSE . if_statement
    (90) block -> . LBRACE local_statement_list RBRACE
    (91) block -> . LBRACE RBRACE
    (128) if_statement -> . IF expression block
    (129) if_statement -> . IF expression block ELSE block
    (130) if_statement -> . IF expression block ELSE if_statement
    (131) if_statement -> . IF if_assignment SEMICOLON expression block
    (132) if_statement -> . IF if_assignment SEMICOLON expression block ELSE block
    (133) if_statement -> . IF if_assignment SEMICOLON expression block ELSE if_statement

    LBRACE          shift and go to state 175
    IF              shift and go to state 207
=======
    (121) field_list -> field_list field_declaration .

    RBRACE          reduce using rule 121 (field_list -> field_list field_declaration .)
    IDENTIFIER      reduce using rule 121 (field_list -> field_list field_declaration .)
>>>>>>> Stashed changes

    block                          shift and go to state 312
    if_statement                   shift and go to state 313

state 291

<<<<<<< Updated upstream
    (131) if_statement -> IF if_assignment SEMICOLON expression . block
    (132) if_statement -> IF if_assignment SEMICOLON expression . block ELSE block
    (133) if_statement -> IF if_assignment SEMICOLON expression . block ELSE if_statement
    (36) expression -> expression . binary_operator expression
    (200) expression -> expression . DOT IDENTIFIER
    (201) expression -> expression . DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> expression . LBRACKET expression RBRACKET
    (90) block -> . LBRACE local_statement_list RBRACE
    (91) block -> . LBRACE RBRACE
    (37) binary_operator -> . PLUS
    (38) binary_operator -> . MINUS
    (39) binary_operator -> . TIMES
    (40) binary_operator -> . DIVIDE
    (41) binary_operator -> . MODULE
    (42) binary_operator -> . EQ
    (43) binary_operator -> . NEQ
    (44) binary_operator -> . LT
    (45) binary_operator -> . LE
    (46) binary_operator -> . GT
    (47) binary_operator -> . GE
    (48) binary_operator -> . LAND
    (49) binary_operator -> . LOR
    (50) binary_operator -> . AND
    (51) binary_operator -> . OR
    (52) binary_operator -> . XOR
    (53) binary_operator -> . AND_NOT
    (54) binary_operator -> . LSHIFT
    (55) binary_operator -> . RSHIFT

    DOT             shift and go to state 82
    LBRACKET        shift and go to state 83
    LBRACE          shift and go to state 175
    PLUS            shift and go to state 84
    MINUS           shift and go to state 85
    TIMES           shift and go to state 86
    DIVIDE          shift and go to state 87
    MODULE          shift and go to state 88
    EQ              shift and go to state 89
    NEQ             shift and go to state 90
    LT              shift and go to state 91
    LE              shift and go to state 92
    GT              shift and go to state 93
    GE              shift and go to state 94
    LAND            shift and go to state 95
    LOR             shift and go to state 96
    AND             shift and go to state 97
    OR              shift and go to state 98
    XOR             shift and go to state 99
    AND_NOT         shift and go to state 100
    LSHIFT          shift and go to state 101
    RSHIFT          shift and go to state 102

    block                          shift and go to state 314
    binary_operator                shift and go to state 81

state 292

    (167) switch_statement -> SWITCH switch_expr LBRACE case_clause_list . RBRACE
    (187) case_clause_list -> case_clause_list . case_clause
    (191) case_clause -> . CASE case_expression_list COLON case_body
    (192) case_clause -> . DEFAULT COLON case_body

    RBRACE          shift and go to state 315
    CASE            shift and go to state 275
    DEFAULT         shift and go to state 276
=======
    (122) field_declaration -> IDENTIFIER type .

    RBRACE          reduce using rule 122 (field_declaration -> IDENTIFIER type .)
    IDENTIFIER      reduce using rule 122 (field_declaration -> IDENTIFIER type .)


state 292

    (81) array_type -> LBRACKET INT RBRACKET type .

    SEMICOLON       reduce using rule 81 (array_type -> LBRACKET INT RBRACKET type .)
    FUNC            reduce using rule 81 (array_type -> LBRACKET INT RBRACKET type .)
    TYPE            reduce using rule 81 (array_type -> LBRACKET INT RBRACKET type .)
    IDENTIFIER      reduce using rule 81 (array_type -> LBRACKET INT RBRACKET type .)
    VAR             reduce using rule 81 (array_type -> LBRACKET INT RBRACKET type .)
    CONST           reduce using rule 81 (array_type -> LBRACKET INT RBRACKET type .)
    PLUS            reduce using rule 81 (array_type -> LBRACKET INT RBRACKET type .)
    MINUS           reduce using rule 81 (array_type -> LBRACKET INT RBRACKET type .)
    LNOT            reduce using rule 81 (array_type -> LBRACKET INT RBRACKET type .)
    LBRACKET        reduce using rule 81 (array_type -> LBRACKET INT RBRACKET type .)
    LPAREN          reduce using rule 81 (array_type -> LBRACKET INT RBRACKET type .)
    INT             reduce using rule 81 (array_type -> LBRACKET INT RBRACKET type .)
    FLOAT64         reduce using rule 81 (array_type -> LBRACKET INT RBRACKET type .)
    TRUE            reduce using rule 81 (array_type -> LBRACKET INT RBRACKET type .)
    FALSE           reduce using rule 81 (array_type -> LBRACKET INT RBRACKET type .)
    STRING          reduce using rule 81 (array_type -> LBRACKET INT RBRACKET type .)
    RETURN          reduce using rule 81 (array_type -> LBRACKET INT RBRACKET type .)
    FOR             reduce using rule 81 (array_type -> LBRACKET INT RBRACKET type .)
    IF              reduce using rule 81 (array_type -> LBRACKET INT RBRACKET type .)
    SWITCH          reduce using rule 81 (array_type -> LBRACKET INT RBRACKET type .)
    BREAK           reduce using rule 81 (array_type -> LBRACKET INT RBRACKET type .)
    CONTINUE        reduce using rule 81 (array_type -> LBRACKET INT RBRACKET type .)
    FALLTHROUGH     reduce using rule 81 (array_type -> LBRACKET INT RBRACKET type .)
    $end            reduce using rule 81 (array_type -> LBRACKET INT RBRACKET type .)
    ASSIGN          reduce using rule 81 (array_type -> LBRACKET INT RBRACKET type .)
    RPAREN          reduce using rule 81 (array_type -> LBRACKET INT RBRACKET type .)
    COMMA           reduce using rule 81 (array_type -> LBRACKET INT RBRACKET type .)
    LBRACE          reduce using rule 81 (array_type -> LBRACKET INT RBRACKET type .)
    RBRACE          reduce using rule 81 (array_type -> LBRACKET INT RBRACKET type .)
>>>>>>> Stashed changes

    case_clause                    shift and go to state 295

state 293

<<<<<<< Updated upstream
    (168) switch_statement -> SWITCH switch_expr LBRACE RBRACE .

    RBRACE          reduce using rule 168 (switch_statement -> SWITCH switch_expr LBRACE RBRACE .)
    BREAK           reduce using rule 168 (switch_statement -> SWITCH switch_expr LBRACE RBRACE .)
    CONTINUE        reduce using rule 168 (switch_statement -> SWITCH switch_expr LBRACE RBRACE .)
    VAR             reduce using rule 168 (switch_statement -> SWITCH switch_expr LBRACE RBRACE .)
    CONST           reduce using rule 168 (switch_statement -> SWITCH switch_expr LBRACE RBRACE .)
    IDENTIFIER      reduce using rule 168 (switch_statement -> SWITCH switch_expr LBRACE RBRACE .)
    LPAREN          reduce using rule 168 (switch_statement -> SWITCH switch_expr LBRACE RBRACE .)
    INT             reduce using rule 168 (switch_statement -> SWITCH switch_expr LBRACE RBRACE .)
    FLOAT64         reduce using rule 168 (switch_statement -> SWITCH switch_expr LBRACE RBRACE .)
    STRING          reduce using rule 168 (switch_statement -> SWITCH switch_expr LBRACE RBRACE .)
    TRUE            reduce using rule 168 (switch_statement -> SWITCH switch_expr LBRACE RBRACE .)
    FALSE           reduce using rule 168 (switch_statement -> SWITCH switch_expr LBRACE RBRACE .)
    LNOT            reduce using rule 168 (switch_statement -> SWITCH switch_expr LBRACE RBRACE .)
    IF              reduce using rule 168 (switch_statement -> SWITCH switch_expr LBRACE RBRACE .)
    SWITCH          reduce using rule 168 (switch_statement -> SWITCH switch_expr LBRACE RBRACE .)
    RETURN          reduce using rule 168 (switch_statement -> SWITCH switch_expr LBRACE RBRACE .)
    LBRACKET        reduce using rule 168 (switch_statement -> SWITCH switch_expr LBRACE RBRACE .)
    MAP             reduce using rule 168 (switch_statement -> SWITCH switch_expr LBRACE RBRACE .)
    FOR             reduce using rule 168 (switch_statement -> SWITCH switch_expr LBRACE RBRACE .)
    CASE            reduce using rule 168 (switch_statement -> SWITCH switch_expr LBRACE RBRACE .)
    DEFAULT         reduce using rule 168 (switch_statement -> SWITCH switch_expr LBRACE RBRACE .)
=======
    (127) map_type -> MAP LBRACKET primitive_type RBRACKET . type
    (70) type -> . primitive_type
    (71) type -> . slice_type
    (72) type -> . array_type
    (73) type -> . map_type
    (74) type -> . struct_type
    (75) type -> . IDENTIFIER
    (76) primitive_type -> . INT_TYPE
    (77) primitive_type -> . FLOAT64_TYPE
    (78) primitive_type -> . STRING_TYPE
    (79) primitive_type -> . BOOL_TYPE
    (80) slice_type -> . LBRACKET RBRACKET primitive_type
    (81) array_type -> . LBRACKET INT RBRACKET type
    (127) map_type -> . MAP LBRACKET primitive_type RBRACKET type
    (118) struct_type -> . STRUCT LBRACE RBRACE
    (119) struct_type -> . STRUCT LBRACE field_list RBRACE

    IDENTIFIER      shift and go to state 177
    INT_TYPE        shift and go to state 171
    FLOAT64_TYPE    shift and go to state 172
    STRING_TYPE     shift and go to state 173
    BOOL_TYPE       shift and go to state 174
    LBRACKET        shift and go to state 175
    MAP             shift and go to state 176
    STRUCT          shift and go to state 170
>>>>>>> Stashed changes

    primitive_type                 shift and go to state 180
    type                           shift and go to state 308
    slice_type                     shift and go to state 181
    array_type                     shift and go to state 182
    map_type                       shift and go to state 183
    struct_type                    shift and go to state 184

state 294

<<<<<<< Updated upstream
    (169) switch_statement -> SWITCH LBRACE case_clause_list RBRACE .

    RBRACE          reduce using rule 169 (switch_statement -> SWITCH LBRACE case_clause_list RBRACE .)
    BREAK           reduce using rule 169 (switch_statement -> SWITCH LBRACE case_clause_list RBRACE .)
    CONTINUE        reduce using rule 169 (switch_statement -> SWITCH LBRACE case_clause_list RBRACE .)
    VAR             reduce using rule 169 (switch_statement -> SWITCH LBRACE case_clause_list RBRACE .)
    CONST           reduce using rule 169 (switch_statement -> SWITCH LBRACE case_clause_list RBRACE .)
    IDENTIFIER      reduce using rule 169 (switch_statement -> SWITCH LBRACE case_clause_list RBRACE .)
    LPAREN          reduce using rule 169 (switch_statement -> SWITCH LBRACE case_clause_list RBRACE .)
    INT             reduce using rule 169 (switch_statement -> SWITCH LBRACE case_clause_list RBRACE .)
    FLOAT64         reduce using rule 169 (switch_statement -> SWITCH LBRACE case_clause_list RBRACE .)
    STRING          reduce using rule 169 (switch_statement -> SWITCH LBRACE case_clause_list RBRACE .)
    TRUE            reduce using rule 169 (switch_statement -> SWITCH LBRACE case_clause_list RBRACE .)
    FALSE           reduce using rule 169 (switch_statement -> SWITCH LBRACE case_clause_list RBRACE .)
    LNOT            reduce using rule 169 (switch_statement -> SWITCH LBRACE case_clause_list RBRACE .)
    IF              reduce using rule 169 (switch_statement -> SWITCH LBRACE case_clause_list RBRACE .)
    SWITCH          reduce using rule 169 (switch_statement -> SWITCH LBRACE case_clause_list RBRACE .)
    RETURN          reduce using rule 169 (switch_statement -> SWITCH LBRACE case_clause_list RBRACE .)
    LBRACKET        reduce using rule 169 (switch_statement -> SWITCH LBRACE case_clause_list RBRACE .)
    MAP             reduce using rule 169 (switch_statement -> SWITCH LBRACE case_clause_list RBRACE .)
    FOR             reduce using rule 169 (switch_statement -> SWITCH LBRACE case_clause_list RBRACE .)
    CASE            reduce using rule 169 (switch_statement -> SWITCH LBRACE case_clause_list RBRACE .)
    DEFAULT         reduce using rule 169 (switch_statement -> SWITCH LBRACE case_clause_list RBRACE .)
=======
    (89) expression -> LBRACKET RBRACKET primitive_type LBRACE expression_list RBRACE .

    DOT             reduce using rule 89 (expression -> LBRACKET RBRACKET primitive_type LBRACE expression_list RBRACE .)
    PLUS            reduce using rule 89 (expression -> LBRACKET RBRACKET primitive_type LBRACE expression_list RBRACE .)
    MINUS           reduce using rule 89 (expression -> LBRACKET RBRACKET primitive_type LBRACE expression_list RBRACE .)
    TIMES           reduce using rule 89 (expression -> LBRACKET RBRACKET primitive_type LBRACE expression_list RBRACE .)
    DIVIDE          reduce using rule 89 (expression -> LBRACKET RBRACKET primitive_type LBRACE expression_list RBRACE .)
    MODULE          reduce using rule 89 (expression -> LBRACKET RBRACKET primitive_type LBRACE expression_list RBRACE .)
    EQ              reduce using rule 89 (expression -> LBRACKET RBRACKET primitive_type LBRACE expression_list RBRACE .)
    NEQ             reduce using rule 89 (expression -> LBRACKET RBRACKET primitive_type LBRACE expression_list RBRACE .)
    LT              reduce using rule 89 (expression -> LBRACKET RBRACKET primitive_type LBRACE expression_list RBRACE .)
    LE              reduce using rule 89 (expression -> LBRACKET RBRACKET primitive_type LBRACE expression_list RBRACE .)
    GT              reduce using rule 89 (expression -> LBRACKET RBRACKET primitive_type LBRACE expression_list RBRACE .)
    GE              reduce using rule 89 (expression -> LBRACKET RBRACKET primitive_type LBRACE expression_list RBRACE .)
    LAND            reduce using rule 89 (expression -> LBRACKET RBRACKET primitive_type LBRACE expression_list RBRACE .)
    LOR             reduce using rule 89 (expression -> LBRACKET RBRACKET primitive_type LBRACE expression_list RBRACE .)
    AND             reduce using rule 89 (expression -> LBRACKET RBRACKET primitive_type LBRACE expression_list RBRACE .)
    OR              reduce using rule 89 (expression -> LBRACKET RBRACKET primitive_type LBRACE expression_list RBRACE .)
    XOR             reduce using rule 89 (expression -> LBRACKET RBRACKET primitive_type LBRACE expression_list RBRACE .)
    AND_NOT         reduce using rule 89 (expression -> LBRACKET RBRACKET primitive_type LBRACE expression_list RBRACE .)
    LSHIFT          reduce using rule 89 (expression -> LBRACKET RBRACKET primitive_type LBRACE expression_list RBRACE .)
    RSHIFT          reduce using rule 89 (expression -> LBRACKET RBRACKET primitive_type LBRACE expression_list RBRACE .)
    SEMICOLON       reduce using rule 89 (expression -> LBRACKET RBRACKET primitive_type LBRACE expression_list RBRACE .)
    FUNC            reduce using rule 89 (expression -> LBRACKET RBRACKET primitive_type LBRACE expression_list RBRACE .)
    TYPE            reduce using rule 89 (expression -> LBRACKET RBRACKET primitive_type LBRACE expression_list RBRACE .)
    IDENTIFIER      reduce using rule 89 (expression -> LBRACKET RBRACKET primitive_type LBRACE expression_list RBRACE .)
    VAR             reduce using rule 89 (expression -> LBRACKET RBRACKET primitive_type LBRACE expression_list RBRACE .)
    CONST           reduce using rule 89 (expression -> LBRACKET RBRACKET primitive_type LBRACE expression_list RBRACE .)
    LNOT            reduce using rule 89 (expression -> LBRACKET RBRACKET primitive_type LBRACE expression_list RBRACE .)
    LBRACKET        reduce using rule 89 (expression -> LBRACKET RBRACKET primitive_type LBRACE expression_list RBRACE .)
    LPAREN          reduce using rule 89 (expression -> LBRACKET RBRACKET primitive_type LBRACE expression_list RBRACE .)
    INT             reduce using rule 89 (expression -> LBRACKET RBRACKET primitive_type LBRACE expression_list RBRACE .)
    FLOAT64         reduce using rule 89 (expression -> LBRACKET RBRACKET primitive_type LBRACE expression_list RBRACE .)
    TRUE            reduce using rule 89 (expression -> LBRACKET RBRACKET primitive_type LBRACE expression_list RBRACE .)
    FALSE           reduce using rule 89 (expression -> LBRACKET RBRACKET primitive_type LBRACE expression_list RBRACE .)
    STRING          reduce using rule 89 (expression -> LBRACKET RBRACKET primitive_type LBRACE expression_list RBRACE .)
    RETURN          reduce using rule 89 (expression -> LBRACKET RBRACKET primitive_type LBRACE expression_list RBRACE .)
    FOR             reduce using rule 89 (expression -> LBRACKET RBRACKET primitive_type LBRACE expression_list RBRACE .)
    IF              reduce using rule 89 (expression -> LBRACKET RBRACKET primitive_type LBRACE expression_list RBRACE .)
    SWITCH          reduce using rule 89 (expression -> LBRACKET RBRACKET primitive_type LBRACE expression_list RBRACE .)
    BREAK           reduce using rule 89 (expression -> LBRACKET RBRACKET primitive_type LBRACE expression_list RBRACE .)
    CONTINUE        reduce using rule 89 (expression -> LBRACKET RBRACKET primitive_type LBRACE expression_list RBRACE .)
    FALLTHROUGH     reduce using rule 89 (expression -> LBRACKET RBRACKET primitive_type LBRACE expression_list RBRACE .)
    $end            reduce using rule 89 (expression -> LBRACKET RBRACKET primitive_type LBRACE expression_list RBRACE .)
    RPAREN          reduce using rule 89 (expression -> LBRACKET RBRACKET primitive_type LBRACE expression_list RBRACE .)
    COMMA           reduce using rule 89 (expression -> LBRACKET RBRACKET primitive_type LBRACE expression_list RBRACE .)
    RBRACE          reduce using rule 89 (expression -> LBRACKET RBRACKET primitive_type LBRACE expression_list RBRACE .)
    CASE            reduce using rule 89 (expression -> LBRACKET RBRACKET primitive_type LBRACE expression_list RBRACE .)
    DEFAULT         reduce using rule 89 (expression -> LBRACKET RBRACKET primitive_type LBRACE expression_list RBRACE .)
    LBRACE          reduce using rule 89 (expression -> LBRACKET RBRACKET primitive_type LBRACE expression_list RBRACE .)
    COLON           reduce using rule 89 (expression -> LBRACKET RBRACKET primitive_type LBRACE expression_list RBRACE .)
>>>>>>> Stashed changes


state 295

<<<<<<< Updated upstream
    (187) case_clause_list -> case_clause_list case_clause .

    RBRACE          reduce using rule 187 (case_clause_list -> case_clause_list case_clause .)
    CASE            reduce using rule 187 (case_clause_list -> case_clause_list case_clause .)
    DEFAULT         reduce using rule 187 (case_clause_list -> case_clause_list case_clause .)
=======
    (17) block -> LBRACE enter_block statement_list exit_block RBRACE .

    SEMICOLON       reduce using rule 17 (block -> LBRACE enter_block statement_list exit_block RBRACE .)
    FUNC            reduce using rule 17 (block -> LBRACE enter_block statement_list exit_block RBRACE .)
    TYPE            reduce using rule 17 (block -> LBRACE enter_block statement_list exit_block RBRACE .)
    IDENTIFIER      reduce using rule 17 (block -> LBRACE enter_block statement_list exit_block RBRACE .)
    VAR             reduce using rule 17 (block -> LBRACE enter_block statement_list exit_block RBRACE .)
    CONST           reduce using rule 17 (block -> LBRACE enter_block statement_list exit_block RBRACE .)
    PLUS            reduce using rule 17 (block -> LBRACE enter_block statement_list exit_block RBRACE .)
    MINUS           reduce using rule 17 (block -> LBRACE enter_block statement_list exit_block RBRACE .)
    LNOT            reduce using rule 17 (block -> LBRACE enter_block statement_list exit_block RBRACE .)
    LBRACKET        reduce using rule 17 (block -> LBRACE enter_block statement_list exit_block RBRACE .)
    LPAREN          reduce using rule 17 (block -> LBRACE enter_block statement_list exit_block RBRACE .)
    INT             reduce using rule 17 (block -> LBRACE enter_block statement_list exit_block RBRACE .)
    FLOAT64         reduce using rule 17 (block -> LBRACE enter_block statement_list exit_block RBRACE .)
    TRUE            reduce using rule 17 (block -> LBRACE enter_block statement_list exit_block RBRACE .)
    FALSE           reduce using rule 17 (block -> LBRACE enter_block statement_list exit_block RBRACE .)
    STRING          reduce using rule 17 (block -> LBRACE enter_block statement_list exit_block RBRACE .)
    RETURN          reduce using rule 17 (block -> LBRACE enter_block statement_list exit_block RBRACE .)
    FOR             reduce using rule 17 (block -> LBRACE enter_block statement_list exit_block RBRACE .)
    IF              reduce using rule 17 (block -> LBRACE enter_block statement_list exit_block RBRACE .)
    SWITCH          reduce using rule 17 (block -> LBRACE enter_block statement_list exit_block RBRACE .)
    BREAK           reduce using rule 17 (block -> LBRACE enter_block statement_list exit_block RBRACE .)
    CONTINUE        reduce using rule 17 (block -> LBRACE enter_block statement_list exit_block RBRACE .)
    FALLTHROUGH     reduce using rule 17 (block -> LBRACE enter_block statement_list exit_block RBRACE .)
    $end            reduce using rule 17 (block -> LBRACE enter_block statement_list exit_block RBRACE .)
    RBRACE          reduce using rule 17 (block -> LBRACE enter_block statement_list exit_block RBRACE .)
    CASE            reduce using rule 17 (block -> LBRACE enter_block statement_list exit_block RBRACE .)
    DEFAULT         reduce using rule 17 (block -> LBRACE enter_block statement_list exit_block RBRACE .)
    ELSE            reduce using rule 17 (block -> LBRACE enter_block statement_list exit_block RBRACE .)
>>>>>>> Stashed changes


state 296

<<<<<<< Updated upstream
    (191) case_clause -> CASE case_expression_list . COLON case_body
    (194) case_expression_list -> case_expression_list . COMMA expression

    COLON           shift and go to state 316
    COMMA           shift and go to state 317
=======
    (19) statement_list -> statement_list optional_semicolon statement .

    SEMICOLON       reduce using rule 19 (statement_list -> statement_list optional_semicolon statement .)
    RBRACE          reduce using rule 19 (statement_list -> statement_list optional_semicolon statement .)
    IDENTIFIER      reduce using rule 19 (statement_list -> statement_list optional_semicolon statement .)
    VAR             reduce using rule 19 (statement_list -> statement_list optional_semicolon statement .)
    CONST           reduce using rule 19 (statement_list -> statement_list optional_semicolon statement .)
    PLUS            reduce using rule 19 (statement_list -> statement_list optional_semicolon statement .)
    MINUS           reduce using rule 19 (statement_list -> statement_list optional_semicolon statement .)
    LNOT            reduce using rule 19 (statement_list -> statement_list optional_semicolon statement .)
    LBRACKET        reduce using rule 19 (statement_list -> statement_list optional_semicolon statement .)
    LPAREN          reduce using rule 19 (statement_list -> statement_list optional_semicolon statement .)
    INT             reduce using rule 19 (statement_list -> statement_list optional_semicolon statement .)
    FLOAT64         reduce using rule 19 (statement_list -> statement_list optional_semicolon statement .)
    TRUE            reduce using rule 19 (statement_list -> statement_list optional_semicolon statement .)
    FALSE           reduce using rule 19 (statement_list -> statement_list optional_semicolon statement .)
    STRING          reduce using rule 19 (statement_list -> statement_list optional_semicolon statement .)
    RETURN          reduce using rule 19 (statement_list -> statement_list optional_semicolon statement .)
    FOR             reduce using rule 19 (statement_list -> statement_list optional_semicolon statement .)
    IF              reduce using rule 19 (statement_list -> statement_list optional_semicolon statement .)
    SWITCH          reduce using rule 19 (statement_list -> statement_list optional_semicolon statement .)
    BREAK           reduce using rule 19 (statement_list -> statement_list optional_semicolon statement .)
    CONTINUE        reduce using rule 19 (statement_list -> statement_list optional_semicolon statement .)
    FALLTHROUGH     reduce using rule 19 (statement_list -> statement_list optional_semicolon statement .)
    CASE            reduce using rule 19 (statement_list -> statement_list optional_semicolon statement .)
    DEFAULT         reduce using rule 19 (statement_list -> statement_list optional_semicolon statement .)
>>>>>>> Stashed changes


state 297

<<<<<<< Updated upstream
    (193) case_expression_list -> expression .
    (36) expression -> expression . binary_operator expression
    (200) expression -> expression . DOT IDENTIFIER
    (201) expression -> expression . DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> expression . LBRACKET expression RBRACKET
    (37) binary_operator -> . PLUS
    (38) binary_operator -> . MINUS
    (39) binary_operator -> . TIMES
    (40) binary_operator -> . DIVIDE
    (41) binary_operator -> . MODULE
    (42) binary_operator -> . EQ
    (43) binary_operator -> . NEQ
    (44) binary_operator -> . LT
    (45) binary_operator -> . LE
    (46) binary_operator -> . GT
    (47) binary_operator -> . GE
    (48) binary_operator -> . LAND
    (49) binary_operator -> . LOR
    (50) binary_operator -> . AND
    (51) binary_operator -> . OR
    (52) binary_operator -> . XOR
    (53) binary_operator -> . AND_NOT
    (54) binary_operator -> . LSHIFT
    (55) binary_operator -> . RSHIFT

    COLON           reduce using rule 193 (case_expression_list -> expression .)
    COMMA           reduce using rule 193 (case_expression_list -> expression .)
    DOT             shift and go to state 82
    LBRACKET        shift and go to state 83
    PLUS            shift and go to state 84
    MINUS           shift and go to state 85
    TIMES           shift and go to state 86
    DIVIDE          shift and go to state 87
    MODULE          shift and go to state 88
    EQ              shift and go to state 89
    NEQ             shift and go to state 90
    LT              shift and go to state 91
    LE              shift and go to state 92
    GT              shift and go to state 93
    GE              shift and go to state 94
    LAND            shift and go to state 95
    LOR             shift and go to state 96
    AND             shift and go to state 97
    OR              shift and go to state 98
    XOR             shift and go to state 99
    AND_NOT         shift and go to state 100
    LSHIFT          shift and go to state 101
    RSHIFT          shift and go to state 102
=======
    (36) for_clause -> assignment SEMICOLON expression SEMICOLON assignment .

    LBRACE          reduce using rule 36 (for_clause -> assignment SEMICOLON expression SEMICOLON assignment .)
>>>>>>> Stashed changes

    binary_operator                shift and go to state 81

state 298

<<<<<<< Updated upstream
    (192) case_clause -> DEFAULT COLON . case_body
    (195) case_body -> . local_statement_list
    (196) case_body -> . empty
    (92) local_statement_list -> . local_statement
    (93) local_statement_list -> . local_statement_list local_statement
    (7) empty -> .
    (78) local_statement -> . local_var_dec
    (79) local_statement -> . local_const_dec
    (80) local_statement -> . short_assignment
    (81) local_statement -> . simple_assignment
    (82) local_statement -> . assignment_compound
    (83) local_statement -> . expression
    (84) local_statement -> . for_statement
    (85) local_statement -> . if_statement
    (86) local_statement -> . switch_statement
    (87) local_statement -> . return_statement
    (88) local_statement -> . BREAK
    (89) local_statement -> . CONTINUE
    (20) local_var_dec -> . VAR IDENTIFIER type
    (21) local_var_dec -> . VAR IDENTIFIER type ASSIGN expression
    (22) local_var_dec -> . VAR IDENTIFIER ASSIGN expression
    (23) local_const_dec -> . CONST IDENTIFIER type ASSIGN expression
    (24) local_const_dec -> . CONST IDENTIFIER ASSIGN expression
    (77) short_assignment -> . IDENTIFIER SHORT_ASSIGN expression
    (56) simple_assignment -> . IDENTIFIER ASSIGN expression
    (25) assignment_compound -> . IDENTIFIER operator_assign expression
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (125) expression -> . LNOT expression
    (126) expression -> . IDENTIFIER PLUSPLUS
    (127) expression -> . IDENTIFIER MINUSMINUS
    (138) expression -> . map_type LBRACE expression_map_list RBRACE
    (139) expression -> . map_type LBRACE RBRACE
    (161) expression -> . type_name LBRACE keyed_element_list RBRACE
    (162) expression -> . type_name LBRACE RBRACE
    (198) expression -> . array_type LBRACE expression_list RBRACE
    (199) expression -> . array_type LBRACE RBRACE
    (200) expression -> . expression DOT IDENTIFIER
    (201) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> . expression LBRACKET expression RBRACKET
    (203) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (94) for_statement -> . for_classic
    (95) for_statement -> . for_condition
    (96) for_statement -> . for_infinite
    (128) if_statement -> . IF expression block
    (129) if_statement -> . IF expression block ELSE block
    (130) if_statement -> . IF expression block ELSE if_statement
    (131) if_statement -> . IF if_assignment SEMICOLON expression block
    (132) if_statement -> . IF if_assignment SEMICOLON expression block ELSE block
    (133) if_statement -> . IF if_assignment SEMICOLON expression block ELSE if_statement
    (167) switch_statement -> . SWITCH switch_expr LBRACE case_clause_list RBRACE
    (168) switch_statement -> . SWITCH switch_expr LBRACE RBRACE
    (169) switch_statement -> . SWITCH LBRACE case_clause_list RBRACE
    (170) switch_statement -> . SWITCH LBRACE RBRACE
    (171) switch_statement -> . SWITCH switch_assignment SEMICOLON switch_expr LBRACE case_clause_list RBRACE
    (172) switch_statement -> . SWITCH switch_assignment SEMICOLON switch_expr LBRACE RBRACE
    (173) switch_statement -> . SWITCH switch_assignment SEMICOLON LBRACE case_clause_list RBRACE
    (174) switch_statement -> . SWITCH switch_assignment SEMICOLON LBRACE RBRACE
    (123) return_statement -> . RETURN
    (124) return_statement -> . RETURN return_list
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (137) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (163) type_name -> . IDENTIFIER
    (164) type_name -> . slice_type
    (165) type_name -> . array_type
    (166) type_name -> . map_type
    (197) array_type -> . LBRACKET INT RBRACKET primitive_type
    (97) for_classic -> . FOR for_init SEMICOLON for_cond SEMICOLON for_post block
    (98) for_condition -> . FOR expression block
    (99) for_infinite -> . FOR block

    RBRACE          reduce using rule 7 (empty -> .)
    CASE            reduce using rule 7 (empty -> .)
    DEFAULT         reduce using rule 7 (empty -> .)
    BREAK           shift and go to state 199
    CONTINUE        shift and go to state 200
    VAR             shift and go to state 201
    CONST           shift and go to state 203
    IDENTIFIER      shift and go to state 202
    LPAREN          shift and go to state 54
    INT             shift and go to state 55
    FLOAT64         shift and go to state 56
    STRING          shift and go to state 57
    TRUE            shift and go to state 58
    FALSE           shift and go to state 59
    LNOT            shift and go to state 60
    IF              shift and go to state 207
    SWITCH          shift and go to state 208
    RETURN          shift and go to state 209
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39
    FOR             shift and go to state 210

    case_body                      shift and go to state 318
    local_statement_list           shift and go to state 319
    empty                          shift and go to state 320
    local_statement                shift and go to state 188
    local_var_dec                  shift and go to state 189
    local_const_dec                shift and go to state 190
    short_assignment               shift and go to state 191
    simple_assignment              shift and go to state 192
    assignment_compound            shift and go to state 193
    expression                     shift and go to state 194
    for_statement                  shift and go to state 195
    if_statement                   shift and go to state 196
    switch_statement               shift and go to state 197
    return_statement               shift and go to state 198
    slice_type                     shift and go to state 53
    map_type                       shift and go to state 61
    type_name                      shift and go to state 62
    array_type                     shift and go to state 63
    for_classic                    shift and go to state 204
    for_condition                  shift and go to state 205
    for_infinite                   shift and go to state 206

state 299

    (171) switch_statement -> SWITCH switch_assignment SEMICOLON switch_expr . LBRACE case_clause_list RBRACE
    (172) switch_statement -> SWITCH switch_assignment SEMICOLON switch_expr . LBRACE RBRACE

    LBRACE          shift and go to state 321
=======
    (110) if_statement -> IF assignment SEMICOLON expression block ELSE . block
    (111) if_statement -> IF assignment SEMICOLON expression block ELSE . if_statement
    (16) block -> . LBRACE enter_block exit_block RBRACE
    (17) block -> . LBRACE enter_block statement_list exit_block RBRACE
    (106) if_statement -> . IF expression block
    (107) if_statement -> . IF expression block ELSE block
    (108) if_statement -> . IF expression block ELSE if_statement
    (109) if_statement -> . IF assignment SEMICOLON expression block
    (110) if_statement -> . IF assignment SEMICOLON expression block ELSE block
    (111) if_statement -> . IF assignment SEMICOLON expression block ELSE if_statement

    LBRACE          shift and go to state 110
    IF              shift and go to state 47

    block                          shift and go to state 309
    if_statement                   shift and go to state 310

state 299

    (189) switch_statement -> SWITCH enter_block switch_header LBRACE case_clauses RBRACE . exit_block
    (168) exit_block -> .

    SEMICOLON       reduce using rule 168 (exit_block -> .)
    FUNC            reduce using rule 168 (exit_block -> .)
    TYPE            reduce using rule 168 (exit_block -> .)
    IDENTIFIER      reduce using rule 168 (exit_block -> .)
    VAR             reduce using rule 168 (exit_block -> .)
    CONST           reduce using rule 168 (exit_block -> .)
    PLUS            reduce using rule 168 (exit_block -> .)
    MINUS           reduce using rule 168 (exit_block -> .)
    LNOT            reduce using rule 168 (exit_block -> .)
    LBRACKET        reduce using rule 168 (exit_block -> .)
    LPAREN          reduce using rule 168 (exit_block -> .)
    INT             reduce using rule 168 (exit_block -> .)
    FLOAT64         reduce using rule 168 (exit_block -> .)
    TRUE            reduce using rule 168 (exit_block -> .)
    FALSE           reduce using rule 168 (exit_block -> .)
    STRING          reduce using rule 168 (exit_block -> .)
    RETURN          reduce using rule 168 (exit_block -> .)
    FOR             reduce using rule 168 (exit_block -> .)
    IF              reduce using rule 168 (exit_block -> .)
    SWITCH          reduce using rule 168 (exit_block -> .)
    BREAK           reduce using rule 168 (exit_block -> .)
    CONTINUE        reduce using rule 168 (exit_block -> .)
    FALLTHROUGH     reduce using rule 168 (exit_block -> .)
    $end            reduce using rule 168 (exit_block -> .)
    RBRACE          reduce using rule 168 (exit_block -> .)
    CASE            reduce using rule 168 (exit_block -> .)
    DEFAULT         reduce using rule 168 (exit_block -> .)
>>>>>>> Stashed changes

    exit_block                     shift and go to state 311

state 300

<<<<<<< Updated upstream
    (173) switch_statement -> SWITCH switch_assignment SEMICOLON LBRACE . case_clause_list RBRACE
    (174) switch_statement -> SWITCH switch_assignment SEMICOLON LBRACE . RBRACE
    (186) case_clause_list -> . case_clause
    (187) case_clause_list -> . case_clause_list case_clause
    (191) case_clause -> . CASE case_expression_list COLON case_body
    (192) case_clause -> . DEFAULT COLON case_body

    RBRACE          shift and go to state 323
    CASE            shift and go to state 275
    DEFAULT         shift and go to state 276
=======
    (172) case_clauses -> case_clauses case_clause .

    RBRACE          reduce using rule 172 (case_clauses -> case_clauses case_clause .)
    CASE            reduce using rule 172 (case_clauses -> case_clauses case_clause .)
    DEFAULT         reduce using rule 172 (case_clauses -> case_clauses case_clause .)
>>>>>>> Stashed changes

    case_clause_list               shift and go to state 322
    case_clause                    shift and go to state 274

state 301

<<<<<<< Updated upstream
    (176) primary_expression -> IDENTIFIER .
    (183) primary_expression -> IDENTIFIER . LPAREN argument_list RPAREN

    DOT             reduce using rule 176 (primary_expression -> IDENTIFIER .)
    LBRACKET        reduce using rule 176 (primary_expression -> IDENTIFIER .)
    LBRACE          reduce using rule 176 (primary_expression -> IDENTIFIER .)
    LPAREN          shift and go to state 280

=======
    (173) case_clause -> CASE case_expression_list . COLON enter_block case_body exit_block
    (170) case_expression_list -> case_expression_list . COMMA expression

    COLON           shift and go to state 312
    COMMA           shift and go to state 313


state 302

    (169) case_expression_list -> expression .
    (100) expression -> expression . DOT IDENTIFIER
    (135) binary_expression -> expression . PLUS expression
    (136) binary_expression -> expression . MINUS expression
    (137) binary_expression -> expression . TIMES expression
    (138) binary_expression -> expression . DIVIDE expression
    (139) binary_expression -> expression . MODULE expression
    (144) relational_expression -> expression . EQ expression
    (145) relational_expression -> expression . NEQ expression
    (146) relational_expression -> expression . LT expression
    (147) relational_expression -> expression . LE expression
    (148) relational_expression -> expression . GT expression
    (149) relational_expression -> expression . GE expression
    (150) logical_expression -> expression . LAND expression
    (151) logical_expression -> expression . LOR expression
    (152) bitwise_expression -> expression . AND expression
    (153) bitwise_expression -> expression . OR expression
    (154) bitwise_expression -> expression . XOR expression
    (155) bitwise_expression -> expression . AND_NOT expression
    (156) bitwise_expression -> expression . LSHIFT expression
    (157) bitwise_expression -> expression . RSHIFT expression

    COLON           reduce using rule 169 (case_expression_list -> expression .)
    COMMA           reduce using rule 169 (case_expression_list -> expression .)
    DOT             shift and go to state 58
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    TIMES           shift and go to state 61
    DIVIDE          shift and go to state 62
    MODULE          shift and go to state 63
    EQ              shift and go to state 64
    NEQ             shift and go to state 65
    LT              shift and go to state 66
    LE              shift and go to state 67
    GT              shift and go to state 68
    GE              shift and go to state 69
    LAND            shift and go to state 70
    LOR             shift and go to state 71
    AND             shift and go to state 72
    OR              shift and go to state 73
    XOR             shift and go to state 74
    AND_NOT         shift and go to state 75
    LSHIFT          shift and go to state 76
    RSHIFT          shift and go to state 77


state 303

    (174) case_clause -> DEFAULT COLON . enter_block case_body exit_block
    (167) enter_block -> .

    IDENTIFIER      reduce using rule 167 (enter_block -> .)
    VAR             reduce using rule 167 (enter_block -> .)
    CONST           reduce using rule 167 (enter_block -> .)
    PLUS            reduce using rule 167 (enter_block -> .)
    MINUS           reduce using rule 167 (enter_block -> .)
    LNOT            reduce using rule 167 (enter_block -> .)
    LBRACKET        reduce using rule 167 (enter_block -> .)
    LPAREN          reduce using rule 167 (enter_block -> .)
    INT             reduce using rule 167 (enter_block -> .)
    FLOAT64         reduce using rule 167 (enter_block -> .)
    TRUE            reduce using rule 167 (enter_block -> .)
    FALSE           reduce using rule 167 (enter_block -> .)
    STRING          reduce using rule 167 (enter_block -> .)
    RETURN          reduce using rule 167 (enter_block -> .)
    FOR             reduce using rule 167 (enter_block -> .)
    IF              reduce using rule 167 (enter_block -> .)
    SWITCH          reduce using rule 167 (enter_block -> .)
    BREAK           reduce using rule 167 (enter_block -> .)
    CONTINUE        reduce using rule 167 (enter_block -> .)
    FALLTHROUGH     reduce using rule 167 (enter_block -> .)
    RBRACE          reduce using rule 167 (enter_block -> .)
    CASE            reduce using rule 167 (enter_block -> .)
    DEFAULT         reduce using rule 167 (enter_block -> .)

    enter_block                    shift and go to state 314

state 304

    (50) return_type -> LPAREN type_list . RPAREN
    (52) type_list -> type_list . COMMA type

    RPAREN          shift and go to state 315
    COMMA           shift and go to state 316


state 305

    (53) type_list -> type .

    RPAREN          reduce using rule 53 (type_list -> type .)
    COMMA           reduce using rule 53 (type_list -> type .)


state 306

    (43) function_declaration -> FUNC IDENTIFIER LPAREN parameter_list RPAREN return_type block .

    FUNC            reduce using rule 43 (function_declaration -> FUNC IDENTIFIER LPAREN parameter_list RPAREN return_type block .)
    TYPE            reduce using rule 43 (function_declaration -> FUNC IDENTIFIER LPAREN parameter_list RPAREN return_type block .)
    IDENTIFIER      reduce using rule 43 (function_declaration -> FUNC IDENTIFIER LPAREN parameter_list RPAREN return_type block .)
    VAR             reduce using rule 43 (function_declaration -> FUNC IDENTIFIER LPAREN parameter_list RPAREN return_type block .)
    CONST           reduce using rule 43 (function_declaration -> FUNC IDENTIFIER LPAREN parameter_list RPAREN return_type block .)
    PLUS            reduce using rule 43 (function_declaration -> FUNC IDENTIFIER LPAREN parameter_list RPAREN return_type block .)
    MINUS           reduce using rule 43 (function_declaration -> FUNC IDENTIFIER LPAREN parameter_list RPAREN return_type block .)
    LNOT            reduce using rule 43 (function_declaration -> FUNC IDENTIFIER LPAREN parameter_list RPAREN return_type block .)
    LBRACKET        reduce using rule 43 (function_declaration -> FUNC IDENTIFIER LPAREN parameter_list RPAREN return_type block .)
    LPAREN          reduce using rule 43 (function_declaration -> FUNC IDENTIFIER LPAREN parameter_list RPAREN return_type block .)
    INT             reduce using rule 43 (function_declaration -> FUNC IDENTIFIER LPAREN parameter_list RPAREN return_type block .)
    FLOAT64         reduce using rule 43 (function_declaration -> FUNC IDENTIFIER LPAREN parameter_list RPAREN return_type block .)
    TRUE            reduce using rule 43 (function_declaration -> FUNC IDENTIFIER LPAREN parameter_list RPAREN return_type block .)
    FALSE           reduce using rule 43 (function_declaration -> FUNC IDENTIFIER LPAREN parameter_list RPAREN return_type block .)
    STRING          reduce using rule 43 (function_declaration -> FUNC IDENTIFIER LPAREN parameter_list RPAREN return_type block .)
    RETURN          reduce using rule 43 (function_declaration -> FUNC IDENTIFIER LPAREN parameter_list RPAREN return_type block .)
    FOR             reduce using rule 43 (function_declaration -> FUNC IDENTIFIER LPAREN parameter_list RPAREN return_type block .)
    IF              reduce using rule 43 (function_declaration -> FUNC IDENTIFIER LPAREN parameter_list RPAREN return_type block .)
    SWITCH          reduce using rule 43 (function_declaration -> FUNC IDENTIFIER LPAREN parameter_list RPAREN return_type block .)
    BREAK           reduce using rule 43 (function_declaration -> FUNC IDENTIFIER LPAREN parameter_list RPAREN return_type block .)
    CONTINUE        reduce using rule 43 (function_declaration -> FUNC IDENTIFIER LPAREN parameter_list RPAREN return_type block .)
    FALLTHROUGH     reduce using rule 43 (function_declaration -> FUNC IDENTIFIER LPAREN parameter_list RPAREN return_type block .)
    $end            reduce using rule 43 (function_declaration -> FUNC IDENTIFIER LPAREN parameter_list RPAREN return_type block .)


state 307

    (124) method_declaration -> FUNC LPAREN receiver RPAREN IDENTIFIER LPAREN parameter_list . RPAREN return_type block
    (44) parameter_list -> parameter_list . COMMA parameter

    RPAREN          shift and go to state 317
    COMMA           shift and go to state 249


state 308

    (127) map_type -> MAP LBRACKET primitive_type RBRACKET type .

    SEMICOLON       reduce using rule 127 (map_type -> MAP LBRACKET primitive_type RBRACKET type .)
    FUNC            reduce using rule 127 (map_type -> MAP LBRACKET primitive_type RBRACKET type .)
    TYPE            reduce using rule 127 (map_type -> MAP LBRACKET primitive_type RBRACKET type .)
    IDENTIFIER      reduce using rule 127 (map_type -> MAP LBRACKET primitive_type RBRACKET type .)
    VAR             reduce using rule 127 (map_type -> MAP LBRACKET primitive_type RBRACKET type .)
    CONST           reduce using rule 127 (map_type -> MAP LBRACKET primitive_type RBRACKET type .)
    PLUS            reduce using rule 127 (map_type -> MAP LBRACKET primitive_type RBRACKET type .)
    MINUS           reduce using rule 127 (map_type -> MAP LBRACKET primitive_type RBRACKET type .)
    LNOT            reduce using rule 127 (map_type -> MAP LBRACKET primitive_type RBRACKET type .)
    LBRACKET        reduce using rule 127 (map_type -> MAP LBRACKET primitive_type RBRACKET type .)
    LPAREN          reduce using rule 127 (map_type -> MAP LBRACKET primitive_type RBRACKET type .)
    INT             reduce using rule 127 (map_type -> MAP LBRACKET primitive_type RBRACKET type .)
    FLOAT64         reduce using rule 127 (map_type -> MAP LBRACKET primitive_type RBRACKET type .)
    TRUE            reduce using rule 127 (map_type -> MAP LBRACKET primitive_type RBRACKET type .)
    FALSE           reduce using rule 127 (map_type -> MAP LBRACKET primitive_type RBRACKET type .)
    STRING          reduce using rule 127 (map_type -> MAP LBRACKET primitive_type RBRACKET type .)
    RETURN          reduce using rule 127 (map_type -> MAP LBRACKET primitive_type RBRACKET type .)
    FOR             reduce using rule 127 (map_type -> MAP LBRACKET primitive_type RBRACKET type .)
    IF              reduce using rule 127 (map_type -> MAP LBRACKET primitive_type RBRACKET type .)
    SWITCH          reduce using rule 127 (map_type -> MAP LBRACKET primitive_type RBRACKET type .)
    BREAK           reduce using rule 127 (map_type -> MAP LBRACKET primitive_type RBRACKET type .)
    CONTINUE        reduce using rule 127 (map_type -> MAP LBRACKET primitive_type RBRACKET type .)
    FALLTHROUGH     reduce using rule 127 (map_type -> MAP LBRACKET primitive_type RBRACKET type .)
    $end            reduce using rule 127 (map_type -> MAP LBRACKET primitive_type RBRACKET type .)
    ASSIGN          reduce using rule 127 (map_type -> MAP LBRACKET primitive_type RBRACKET type .)
    RPAREN          reduce using rule 127 (map_type -> MAP LBRACKET primitive_type RBRACKET type .)
    COMMA           reduce using rule 127 (map_type -> MAP LBRACKET primitive_type RBRACKET type .)
    LBRACE          reduce using rule 127 (map_type -> MAP LBRACKET primitive_type RBRACKET type .)
    RBRACE          reduce using rule 127 (map_type -> MAP LBRACKET primitive_type RBRACKET type .)


state 309

    (110) if_statement -> IF assignment SEMICOLON expression block ELSE block .

    SEMICOLON       reduce using rule 110 (if_statement -> IF assignment SEMICOLON expression block ELSE block .)
    FUNC            reduce using rule 110 (if_statement -> IF assignment SEMICOLON expression block ELSE block .)
    TYPE            reduce using rule 110 (if_statement -> IF assignment SEMICOLON expression block ELSE block .)
    IDENTIFIER      reduce using rule 110 (if_statement -> IF assignment SEMICOLON expression block ELSE block .)
    VAR             reduce using rule 110 (if_statement -> IF assignment SEMICOLON expression block ELSE block .)
    CONST           reduce using rule 110 (if_statement -> IF assignment SEMICOLON expression block ELSE block .)
    PLUS            reduce using rule 110 (if_statement -> IF assignment SEMICOLON expression block ELSE block .)
    MINUS           reduce using rule 110 (if_statement -> IF assignment SEMICOLON expression block ELSE block .)
    LNOT            reduce using rule 110 (if_statement -> IF assignment SEMICOLON expression block ELSE block .)
    LBRACKET        reduce using rule 110 (if_statement -> IF assignment SEMICOLON expression block ELSE block .)
    LPAREN          reduce using rule 110 (if_statement -> IF assignment SEMICOLON expression block ELSE block .)
    INT             reduce using rule 110 (if_statement -> IF assignment SEMICOLON expression block ELSE block .)
    FLOAT64         reduce using rule 110 (if_statement -> IF assignment SEMICOLON expression block ELSE block .)
    TRUE            reduce using rule 110 (if_statement -> IF assignment SEMICOLON expression block ELSE block .)
    FALSE           reduce using rule 110 (if_statement -> IF assignment SEMICOLON expression block ELSE block .)
    STRING          reduce using rule 110 (if_statement -> IF assignment SEMICOLON expression block ELSE block .)
    RETURN          reduce using rule 110 (if_statement -> IF assignment SEMICOLON expression block ELSE block .)
    FOR             reduce using rule 110 (if_statement -> IF assignment SEMICOLON expression block ELSE block .)
    IF              reduce using rule 110 (if_statement -> IF assignment SEMICOLON expression block ELSE block .)
    SWITCH          reduce using rule 110 (if_statement -> IF assignment SEMICOLON expression block ELSE block .)
    BREAK           reduce using rule 110 (if_statement -> IF assignment SEMICOLON expression block ELSE block .)
    CONTINUE        reduce using rule 110 (if_statement -> IF assignment SEMICOLON expression block ELSE block .)
    FALLTHROUGH     reduce using rule 110 (if_statement -> IF assignment SEMICOLON expression block ELSE block .)
    $end            reduce using rule 110 (if_statement -> IF assignment SEMICOLON expression block ELSE block .)
    RBRACE          reduce using rule 110 (if_statement -> IF assignment SEMICOLON expression block ELSE block .)
    CASE            reduce using rule 110 (if_statement -> IF assignment SEMICOLON expression block ELSE block .)
    DEFAULT         reduce using rule 110 (if_statement -> IF assignment SEMICOLON expression block ELSE block .)


state 310

    (111) if_statement -> IF assignment SEMICOLON expression block ELSE if_statement .

    SEMICOLON       reduce using rule 111 (if_statement -> IF assignment SEMICOLON expression block ELSE if_statement .)
    FUNC            reduce using rule 111 (if_statement -> IF assignment SEMICOLON expression block ELSE if_statement .)
    TYPE            reduce using rule 111 (if_statement -> IF assignment SEMICOLON expression block ELSE if_statement .)
    IDENTIFIER      reduce using rule 111 (if_statement -> IF assignment SEMICOLON expression block ELSE if_statement .)
    VAR             reduce using rule 111 (if_statement -> IF assignment SEMICOLON expression block ELSE if_statement .)
    CONST           reduce using rule 111 (if_statement -> IF assignment SEMICOLON expression block ELSE if_statement .)
    PLUS            reduce using rule 111 (if_statement -> IF assignment SEMICOLON expression block ELSE if_statement .)
    MINUS           reduce using rule 111 (if_statement -> IF assignment SEMICOLON expression block ELSE if_statement .)
    LNOT            reduce using rule 111 (if_statement -> IF assignment SEMICOLON expression block ELSE if_statement .)
    LBRACKET        reduce using rule 111 (if_statement -> IF assignment SEMICOLON expression block ELSE if_statement .)
    LPAREN          reduce using rule 111 (if_statement -> IF assignment SEMICOLON expression block ELSE if_statement .)
    INT             reduce using rule 111 (if_statement -> IF assignment SEMICOLON expression block ELSE if_statement .)
    FLOAT64         reduce using rule 111 (if_statement -> IF assignment SEMICOLON expression block ELSE if_statement .)
    TRUE            reduce using rule 111 (if_statement -> IF assignment SEMICOLON expression block ELSE if_statement .)
    FALSE           reduce using rule 111 (if_statement -> IF assignment SEMICOLON expression block ELSE if_statement .)
    STRING          reduce using rule 111 (if_statement -> IF assignment SEMICOLON expression block ELSE if_statement .)
    RETURN          reduce using rule 111 (if_statement -> IF assignment SEMICOLON expression block ELSE if_statement .)
    FOR             reduce using rule 111 (if_statement -> IF assignment SEMICOLON expression block ELSE if_statement .)
    IF              reduce using rule 111 (if_statement -> IF assignment SEMICOLON expression block ELSE if_statement .)
    SWITCH          reduce using rule 111 (if_statement -> IF assignment SEMICOLON expression block ELSE if_statement .)
    BREAK           reduce using rule 111 (if_statement -> IF assignment SEMICOLON expression block ELSE if_statement .)
    CONTINUE        reduce using rule 111 (if_statement -> IF assignment SEMICOLON expression block ELSE if_statement .)
    FALLTHROUGH     reduce using rule 111 (if_statement -> IF assignment SEMICOLON expression block ELSE if_statement .)
    $end            reduce using rule 111 (if_statement -> IF assignment SEMICOLON expression block ELSE if_statement .)
    RBRACE          reduce using rule 111 (if_statement -> IF assignment SEMICOLON expression block ELSE if_statement .)
    CASE            reduce using rule 111 (if_statement -> IF assignment SEMICOLON expression block ELSE if_statement .)
    DEFAULT         reduce using rule 111 (if_statement -> IF assignment SEMICOLON expression block ELSE if_statement .)


state 311

    (189) switch_statement -> SWITCH enter_block switch_header LBRACE case_clauses RBRACE exit_block .

    SEMICOLON       reduce using rule 189 (switch_statement -> SWITCH enter_block switch_header LBRACE case_clauses RBRACE exit_block .)
    FUNC            reduce using rule 189 (switch_statement -> SWITCH enter_block switch_header LBRACE case_clauses RBRACE exit_block .)
    TYPE            reduce using rule 189 (switch_statement -> SWITCH enter_block switch_header LBRACE case_clauses RBRACE exit_block .)
    IDENTIFIER      reduce using rule 189 (switch_statement -> SWITCH enter_block switch_header LBRACE case_clauses RBRACE exit_block .)
    VAR             reduce using rule 189 (switch_statement -> SWITCH enter_block switch_header LBRACE case_clauses RBRACE exit_block .)
    CONST           reduce using rule 189 (switch_statement -> SWITCH enter_block switch_header LBRACE case_clauses RBRACE exit_block .)
    PLUS            reduce using rule 189 (switch_statement -> SWITCH enter_block switch_header LBRACE case_clauses RBRACE exit_block .)
    MINUS           reduce using rule 189 (switch_statement -> SWITCH enter_block switch_header LBRACE case_clauses RBRACE exit_block .)
    LNOT            reduce using rule 189 (switch_statement -> SWITCH enter_block switch_header LBRACE case_clauses RBRACE exit_block .)
    LBRACKET        reduce using rule 189 (switch_statement -> SWITCH enter_block switch_header LBRACE case_clauses RBRACE exit_block .)
    LPAREN          reduce using rule 189 (switch_statement -> SWITCH enter_block switch_header LBRACE case_clauses RBRACE exit_block .)
    INT             reduce using rule 189 (switch_statement -> SWITCH enter_block switch_header LBRACE case_clauses RBRACE exit_block .)
    FLOAT64         reduce using rule 189 (switch_statement -> SWITCH enter_block switch_header LBRACE case_clauses RBRACE exit_block .)
    TRUE            reduce using rule 189 (switch_statement -> SWITCH enter_block switch_header LBRACE case_clauses RBRACE exit_block .)
    FALSE           reduce using rule 189 (switch_statement -> SWITCH enter_block switch_header LBRACE case_clauses RBRACE exit_block .)
    STRING          reduce using rule 189 (switch_statement -> SWITCH enter_block switch_header LBRACE case_clauses RBRACE exit_block .)
    RETURN          reduce using rule 189 (switch_statement -> SWITCH enter_block switch_header LBRACE case_clauses RBRACE exit_block .)
    FOR             reduce using rule 189 (switch_statement -> SWITCH enter_block switch_header LBRACE case_clauses RBRACE exit_block .)
    IF              reduce using rule 189 (switch_statement -> SWITCH enter_block switch_header LBRACE case_clauses RBRACE exit_block .)
    SWITCH          reduce using rule 189 (switch_statement -> SWITCH enter_block switch_header LBRACE case_clauses RBRACE exit_block .)
    BREAK           reduce using rule 189 (switch_statement -> SWITCH enter_block switch_header LBRACE case_clauses RBRACE exit_block .)
    CONTINUE        reduce using rule 189 (switch_statement -> SWITCH enter_block switch_header LBRACE case_clauses RBRACE exit_block .)
    FALLTHROUGH     reduce using rule 189 (switch_statement -> SWITCH enter_block switch_header LBRACE case_clauses RBRACE exit_block .)
    $end            reduce using rule 189 (switch_statement -> SWITCH enter_block switch_header LBRACE case_clauses RBRACE exit_block .)
    RBRACE          reduce using rule 189 (switch_statement -> SWITCH enter_block switch_header LBRACE case_clauses RBRACE exit_block .)
    CASE            reduce using rule 189 (switch_statement -> SWITCH enter_block switch_header LBRACE case_clauses RBRACE exit_block .)
    DEFAULT         reduce using rule 189 (switch_statement -> SWITCH enter_block switch_header LBRACE case_clauses RBRACE exit_block .)


state 312

    (173) case_clause -> CASE case_expression_list COLON . enter_block case_body exit_block
    (167) enter_block -> .

    IDENTIFIER      reduce using rule 167 (enter_block -> .)
    VAR             reduce using rule 167 (enter_block -> .)
    CONST           reduce using rule 167 (enter_block -> .)
    PLUS            reduce using rule 167 (enter_block -> .)
    MINUS           reduce using rule 167 (enter_block -> .)
    LNOT            reduce using rule 167 (enter_block -> .)
    LBRACKET        reduce using rule 167 (enter_block -> .)
    LPAREN          reduce using rule 167 (enter_block -> .)
    INT             reduce using rule 167 (enter_block -> .)
    FLOAT64         reduce using rule 167 (enter_block -> .)
    TRUE            reduce using rule 167 (enter_block -> .)
    FALSE           reduce using rule 167 (enter_block -> .)
    STRING          reduce using rule 167 (enter_block -> .)
    RETURN          reduce using rule 167 (enter_block -> .)
    FOR             reduce using rule 167 (enter_block -> .)
    IF              reduce using rule 167 (enter_block -> .)
    SWITCH          reduce using rule 167 (enter_block -> .)
    BREAK           reduce using rule 167 (enter_block -> .)
    CONTINUE        reduce using rule 167 (enter_block -> .)
    FALLTHROUGH     reduce using rule 167 (enter_block -> .)
    RBRACE          reduce using rule 167 (enter_block -> .)
    CASE            reduce using rule 167 (enter_block -> .)
    DEFAULT         reduce using rule 167 (enter_block -> .)

    enter_block                    shift and go to state 318

state 313

    (170) case_expression_list -> case_expression_list COMMA . expression
    (82) expression -> . binary_expression
    (83) expression -> . relational_expression
    (84) expression -> . logical_expression
    (85) expression -> . bitwise_expression
    (86) expression -> . PLUS expression
    (87) expression -> . MINUS expression
    (88) expression -> . LNOT expression
    (89) expression -> . LBRACKET RBRACKET primitive_type LBRACE expression_list RBRACE
    (90) expression -> . LBRACKET RBRACKET primitive_type LBRACE RBRACE
    (91) expression -> . LPAREN expression RPAREN
    (92) expression -> . INT
    (93) expression -> . FLOAT64
    (94) expression -> . TRUE
    (95) expression -> . FALSE
    (96) expression -> . IDENTIFIER
    (97) expression -> . STRING
    (98) expression -> . IDENTIFIER PLUSPLUS
    (99) expression -> . IDENTIFIER MINUSMINUS
    (100) expression -> . expression DOT IDENTIFIER
    (103) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (133) expression -> . IDENTIFIER LBRACE keyed_element_list RBRACE
    (134) expression -> . IDENTIFIER LBRACE RBRACE
    (135) binary_expression -> . expression PLUS expression
    (136) binary_expression -> . expression MINUS expression
    (137) binary_expression -> . expression TIMES expression
    (138) binary_expression -> . expression DIVIDE expression
    (139) binary_expression -> . expression MODULE expression
    (144) relational_expression -> . expression EQ expression
    (145) relational_expression -> . expression NEQ expression
    (146) relational_expression -> . expression LT expression
    (147) relational_expression -> . expression LE expression
    (148) relational_expression -> . expression GT expression
    (149) relational_expression -> . expression GE expression
    (150) logical_expression -> . expression LAND expression
    (151) logical_expression -> . expression LOR expression
    (152) bitwise_expression -> . expression AND expression
    (153) bitwise_expression -> . expression OR expression
    (154) bitwise_expression -> . expression XOR expression
    (155) bitwise_expression -> . expression AND_NOT expression
    (156) bitwise_expression -> . expression LSHIFT expression
    (157) bitwise_expression -> . expression RSHIFT expression

    PLUS            shift and go to state 37
    MINUS           shift and go to state 38
    LNOT            shift and go to state 39
    LBRACKET        shift and go to state 40
    LPAREN          shift and go to state 29
    INT             shift and go to state 41
    FLOAT64         shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44
    IDENTIFIER      shift and go to state 97
    STRING          shift and go to state 11

    expression                     shift and go to state 319
    binary_expression              shift and go to state 33
    relational_expression          shift and go to state 34
    logical_expression             shift and go to state 35
    bitwise_expression             shift and go to state 36

state 314

    (174) case_clause -> DEFAULT COLON enter_block . case_body exit_block
    (175) case_body -> . statement_list
    (176) case_body -> . empty
    (18) statement_list -> . statement
    (19) statement_list -> . statement_list optional_semicolon statement
    (7) empty -> .
    (20) statement -> . assignment
    (21) statement -> . assignment_compound
    (22) statement -> . variable_declaration
    (23) statement -> . expression
    (24) statement -> . return_statement
    (25) statement -> . for_statement
    (26) statement -> . if_statement
    (27) statement -> . switch_statement
    (28) statement -> . break_statement
    (29) statement -> . continue_statement
    (30) statement -> . fallthrough_statement
    (54) assignment -> . IDENTIFIER ASSIGN expression
    (55) assignment -> . IDENTIFIER SHORT_ASSIGN expression
    (56) assignment_compound -> . IDENTIFIER PLUS_ASSIGN expression
    (57) assignment_compound -> . IDENTIFIER MINUS_ASSIGN expression
    (58) assignment_compound -> . IDENTIFIER MULT_ASSIGN expression
    (59) assignment_compound -> . IDENTIFIER DIV_ASSIGN expression
    (60) assignment_compound -> . IDENTIFIER MOD_ASSIGN expression
    (61) assignment_compound -> . IDENTIFIER AND_ASSIGN expression
    (62) assignment_compound -> . IDENTIFIER OR_ASSIGN expression
    (63) assignment_compound -> . IDENTIFIER XOR_ASSIGN expression
    (64) assignment_compound -> . IDENTIFIER LSHIFT_ASSIGN expression
    (65) assignment_compound -> . IDENTIFIER RSHIFT_ASSIGN expression
    (66) variable_declaration -> . VAR IDENTIFIER type ASSIGN expression
    (67) variable_declaration -> . CONST IDENTIFIER type ASSIGN expression
    (68) variable_declaration -> . VAR IDENTIFIER ASSIGN expression
    (69) variable_declaration -> . CONST IDENTIFIER ASSIGN expression
    (82) expression -> . binary_expression
    (83) expression -> . relational_expression
    (84) expression -> . logical_expression
    (85) expression -> . bitwise_expression
    (86) expression -> . PLUS expression
    (87) expression -> . MINUS expression
    (88) expression -> . LNOT expression
    (89) expression -> . LBRACKET RBRACKET primitive_type LBRACE expression_list RBRACE
    (90) expression -> . LBRACKET RBRACKET primitive_type LBRACE RBRACE
    (91) expression -> . LPAREN expression RPAREN
    (92) expression -> . INT
    (93) expression -> . FLOAT64
    (94) expression -> . TRUE
    (95) expression -> . FALSE
    (96) expression -> . IDENTIFIER
    (97) expression -> . STRING
    (98) expression -> . IDENTIFIER PLUSPLUS
    (99) expression -> . IDENTIFIER MINUSMINUS
    (100) expression -> . expression DOT IDENTIFIER
    (103) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (133) expression -> . IDENTIFIER LBRACE keyed_element_list RBRACE
    (134) expression -> . IDENTIFIER LBRACE RBRACE
    (39) return_statement -> . RETURN
    (40) return_statement -> . RETURN return_list
    (33) for_statement -> . FOR expression block
    (34) for_statement -> . FOR block
    (35) for_statement -> . FOR for_clause block
    (106) if_statement -> . IF expression block
    (107) if_statement -> . IF expression block ELSE block
    (108) if_statement -> . IF expression block ELSE if_statement
    (109) if_statement -> . IF assignment SEMICOLON expression block
    (110) if_statement -> . IF assignment SEMICOLON expression block ELSE block
    (111) if_statement -> . IF assignment SEMICOLON expression block ELSE if_statement
    (189) switch_statement -> . SWITCH enter_block switch_header LBRACE case_clauses RBRACE exit_block
    (31) break_statement -> . BREAK
    (32) continue_statement -> . CONTINUE
    (177) fallthrough_statement -> . FALLTHROUGH
    (135) binary_expression -> . expression PLUS expression
    (136) binary_expression -> . expression MINUS expression
    (137) binary_expression -> . expression TIMES expression
    (138) binary_expression -> . expression DIVIDE expression
    (139) binary_expression -> . expression MODULE expression
    (144) relational_expression -> . expression EQ expression
    (145) relational_expression -> . expression NEQ expression
    (146) relational_expression -> . expression LT expression
    (147) relational_expression -> . expression LE expression
    (148) relational_expression -> . expression GT expression
    (149) relational_expression -> . expression GE expression
    (150) logical_expression -> . expression LAND expression
    (151) logical_expression -> . expression LOR expression
    (152) bitwise_expression -> . expression AND expression
    (153) bitwise_expression -> . expression OR expression
    (154) bitwise_expression -> . expression XOR expression
    (155) bitwise_expression -> . expression AND_NOT expression
    (156) bitwise_expression -> . expression LSHIFT expression
    (157) bitwise_expression -> . expression RSHIFT expression

    RBRACE          reduce using rule 7 (empty -> .)
    CASE            reduce using rule 7 (empty -> .)
    DEFAULT         reduce using rule 7 (empty -> .)
    IDENTIFIER      shift and go to state 28
    VAR             shift and go to state 31
    CONST           shift and go to state 32
    PLUS            shift and go to state 37
    MINUS           shift and go to state 38
    LNOT            shift and go to state 39
    LBRACKET        shift and go to state 40
    LPAREN          shift and go to state 29
    INT             shift and go to state 41
    FLOAT64         shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44
    STRING          shift and go to state 11
    RETURN          shift and go to state 45
    FOR             shift and go to state 46
    IF              shift and go to state 47
    SWITCH          shift and go to state 48
    BREAK           shift and go to state 49
    CONTINUE        shift and go to state 50
    FALLTHROUGH     shift and go to state 51

    case_body                      shift and go to state 320
    statement_list                 shift and go to state 321
    empty                          shift and go to state 322
    statement                      shift and go to state 239
    assignment                     shift and go to state 16
    assignment_compound            shift and go to state 17
    variable_declaration           shift and go to state 18
    expression                     shift and go to state 19
    return_statement               shift and go to state 20
    for_statement                  shift and go to state 21
    if_statement                   shift and go to state 22
    switch_statement               shift and go to state 23
    break_statement                shift and go to state 24
    continue_statement             shift and go to state 25
    fallthrough_statement          shift and go to state 26
    binary_expression              shift and go to state 33
    relational_expression          shift and go to state 34
    logical_expression             shift and go to state 35
    bitwise_expression             shift and go to state 36
>>>>>>> Stashed changes

state 315

<<<<<<< Updated upstream
    (184) primary_expression -> primary_expression DOT IDENTIFIER .

    DOT             reduce using rule 184 (primary_expression -> primary_expression DOT IDENTIFIER .)
    LBRACKET        reduce using rule 184 (primary_expression -> primary_expression DOT IDENTIFIER .)
    LBRACE          reduce using rule 184 (primary_expression -> primary_expression DOT IDENTIFIER .)
=======
    (50) return_type -> LPAREN type_list RPAREN .

    LBRACE          reduce using rule 50 (return_type -> LPAREN type_list RPAREN .)
>>>>>>> Stashed changes


state 316

<<<<<<< Updated upstream
    (185) primary_expression -> primary_expression LBRACKET expression . RBRACKET
    (36) expression -> expression . binary_operator expression
    (200) expression -> expression . DOT IDENTIFIER
    (201) expression -> expression . DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> expression . LBRACKET expression RBRACKET
    (37) binary_operator -> . PLUS
    (38) binary_operator -> . MINUS
    (39) binary_operator -> . TIMES
    (40) binary_operator -> . DIVIDE
    (41) binary_operator -> . MODULE
    (42) binary_operator -> . EQ
    (43) binary_operator -> . NEQ
    (44) binary_operator -> . LT
    (45) binary_operator -> . LE
    (46) binary_operator -> . GT
    (47) binary_operator -> . GE
    (48) binary_operator -> . LAND
    (49) binary_operator -> . LOR
    (50) binary_operator -> . AND
    (51) binary_operator -> . OR
    (52) binary_operator -> . XOR
    (53) binary_operator -> . AND_NOT
    (54) binary_operator -> . LSHIFT
    (55) binary_operator -> . RSHIFT

    RBRACKET        shift and go to state 324
    DOT             shift and go to state 82
    LBRACKET        shift and go to state 83
    PLUS            shift and go to state 84
    MINUS           shift and go to state 85
    TIMES           shift and go to state 86
    DIVIDE          shift and go to state 87
    MODULE          shift and go to state 88
    EQ              shift and go to state 89
    NEQ             shift and go to state 90
    LT              shift and go to state 91
    LE              shift and go to state 92
    GT              shift and go to state 93
    GE              shift and go to state 94
    LAND            shift and go to state 95
    LOR             shift and go to state 96
    AND             shift and go to state 97
    OR              shift and go to state 98
    XOR             shift and go to state 99
    AND_NOT         shift and go to state 100
    LSHIFT          shift and go to state 101
    RSHIFT          shift and go to state 102

    binary_operator                shift and go to state 81
=======
    (52) type_list -> type_list COMMA . type
    (70) type -> . primitive_type
    (71) type -> . slice_type
    (72) type -> . array_type
    (73) type -> . map_type
    (74) type -> . struct_type
    (75) type -> . IDENTIFIER
    (76) primitive_type -> . INT_TYPE
    (77) primitive_type -> . FLOAT64_TYPE
    (78) primitive_type -> . STRING_TYPE
    (79) primitive_type -> . BOOL_TYPE
    (80) slice_type -> . LBRACKET RBRACKET primitive_type
    (81) array_type -> . LBRACKET INT RBRACKET type
    (127) map_type -> . MAP LBRACKET primitive_type RBRACKET type
    (118) struct_type -> . STRUCT LBRACE RBRACE
    (119) struct_type -> . STRUCT LBRACE field_list RBRACE

    IDENTIFIER      shift and go to state 177
    INT_TYPE        shift and go to state 171
    FLOAT64_TYPE    shift and go to state 172
    STRING_TYPE     shift and go to state 173
    BOOL_TYPE       shift and go to state 174
    LBRACKET        shift and go to state 175
    MAP             shift and go to state 176
    STRUCT          shift and go to state 170

    type                           shift and go to state 323
    primitive_type                 shift and go to state 180
    slice_type                     shift and go to state 181
    array_type                     shift and go to state 182
    map_type                       shift and go to state 183
    struct_type                    shift and go to state 184
>>>>>>> Stashed changes

state 317

<<<<<<< Updated upstream
    (183) primary_expression -> IDENTIFIER LPAREN argument_list . RPAREN

    RPAREN          shift and go to state 325


state 305

    (182) primary_expression -> LPAREN expression RPAREN .

    DOT             reduce using rule 182 (primary_expression -> LPAREN expression RPAREN .)
    LBRACKET        reduce using rule 182 (primary_expression -> LPAREN expression RPAREN .)
    LBRACE          reduce using rule 182 (primary_expression -> LPAREN expression RPAREN .)


state 306

    (111) return_list -> return_list COMMA expression .
    (36) expression -> expression . binary_operator expression
    (200) expression -> expression . DOT IDENTIFIER
    (201) expression -> expression . DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> expression . LBRACKET expression RBRACKET
    (37) binary_operator -> . PLUS
    (38) binary_operator -> . MINUS
    (39) binary_operator -> . TIMES
    (40) binary_operator -> . DIVIDE
    (41) binary_operator -> . MODULE
    (42) binary_operator -> . EQ
    (43) binary_operator -> . NEQ
    (44) binary_operator -> . LT
    (45) binary_operator -> . LE
    (46) binary_operator -> . GT
    (47) binary_operator -> . GE
    (48) binary_operator -> . LAND
    (49) binary_operator -> . LOR
    (50) binary_operator -> . AND
    (51) binary_operator -> . OR
    (52) binary_operator -> . XOR
    (53) binary_operator -> . AND_NOT
    (54) binary_operator -> . LSHIFT
    (55) binary_operator -> . RSHIFT

  ! shift/reduce conflict for LBRACKET resolved as shift
    COMMA           reduce using rule 111 (return_list -> return_list COMMA expression .)
    RBRACE          reduce using rule 111 (return_list -> return_list COMMA expression .)
    BREAK           reduce using rule 111 (return_list -> return_list COMMA expression .)
    CONTINUE        reduce using rule 111 (return_list -> return_list COMMA expression .)
    VAR             reduce using rule 111 (return_list -> return_list COMMA expression .)
    CONST           reduce using rule 111 (return_list -> return_list COMMA expression .)
    IDENTIFIER      reduce using rule 111 (return_list -> return_list COMMA expression .)
    LPAREN          reduce using rule 111 (return_list -> return_list COMMA expression .)
    INT             reduce using rule 111 (return_list -> return_list COMMA expression .)
    FLOAT64         reduce using rule 111 (return_list -> return_list COMMA expression .)
    STRING          reduce using rule 111 (return_list -> return_list COMMA expression .)
    TRUE            reduce using rule 111 (return_list -> return_list COMMA expression .)
    FALSE           reduce using rule 111 (return_list -> return_list COMMA expression .)
    LNOT            reduce using rule 111 (return_list -> return_list COMMA expression .)
    IF              reduce using rule 111 (return_list -> return_list COMMA expression .)
    SWITCH          reduce using rule 111 (return_list -> return_list COMMA expression .)
    RETURN          reduce using rule 111 (return_list -> return_list COMMA expression .)
    MAP             reduce using rule 111 (return_list -> return_list COMMA expression .)
    FOR             reduce using rule 111 (return_list -> return_list COMMA expression .)
    CASE            reduce using rule 111 (return_list -> return_list COMMA expression .)
    DEFAULT         reduce using rule 111 (return_list -> return_list COMMA expression .)
    DOT             shift and go to state 82
    LBRACKET        shift and go to state 83
    PLUS            shift and go to state 84
    MINUS           shift and go to state 85
    TIMES           shift and go to state 86
    DIVIDE          shift and go to state 87
    MODULE          shift and go to state 88
    EQ              shift and go to state 89
    NEQ             shift and go to state 90
    LT              shift and go to state 91
    LE              shift and go to state 92
    GT              shift and go to state 93
    GE              shift and go to state 94
    LAND            shift and go to state 95
    LOR             shift and go to state 96
    AND             shift and go to state 97
    OR              shift and go to state 98
    XOR             shift and go to state 99
    AND_NOT         shift and go to state 100
    LSHIFT          shift and go to state 101
    RSHIFT          shift and go to state 102

  ! LBRACKET        [ reduce using rule 111 (return_list -> return_list COMMA expression .) ]

    binary_operator                shift and go to state 81

state 307

    (97) for_classic -> FOR for_init SEMICOLON for_cond . SEMICOLON for_post block

    SEMICOLON       shift and go to state 326


state 308

    (104) for_cond -> expression .
    (36) expression -> expression . binary_operator expression
    (200) expression -> expression . DOT IDENTIFIER
    (201) expression -> expression . DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> expression . LBRACKET expression RBRACKET
    (37) binary_operator -> . PLUS
    (38) binary_operator -> . MINUS
    (39) binary_operator -> . TIMES
    (40) binary_operator -> . DIVIDE
    (41) binary_operator -> . MODULE
    (42) binary_operator -> . EQ
    (43) binary_operator -> . NEQ
    (44) binary_operator -> . LT
    (45) binary_operator -> . LE
    (46) binary_operator -> . GT
    (47) binary_operator -> . GE
    (48) binary_operator -> . LAND
    (49) binary_operator -> . LOR
    (50) binary_operator -> . AND
    (51) binary_operator -> . OR
    (52) binary_operator -> . XOR
    (53) binary_operator -> . AND_NOT
    (54) binary_operator -> . LSHIFT
    (55) binary_operator -> . RSHIFT

    SEMICOLON       reduce using rule 104 (for_cond -> expression .)
    DOT             shift and go to state 82
    LBRACKET        shift and go to state 83
    PLUS            shift and go to state 84
    MINUS           shift and go to state 85
    TIMES           shift and go to state 86
    DIVIDE          shift and go to state 87
    MODULE          shift and go to state 88
    EQ              shift and go to state 89
    NEQ             shift and go to state 90
    LT              shift and go to state 91
    LE              shift and go to state 92
    GT              shift and go to state 93
    GE              shift and go to state 94
    LAND            shift and go to state 95
    LOR             shift and go to state 96
    AND             shift and go to state 97
    OR              shift and go to state 98
    XOR             shift and go to state 99
    AND_NOT         shift and go to state 100
    LSHIFT          shift and go to state 101
    RSHIFT          shift and go to state 102

    binary_operator                shift and go to state 81
=======
    (124) method_declaration -> FUNC LPAREN receiver RPAREN IDENTIFIER LPAREN parameter_list RPAREN . return_type block
    (49) return_type -> . type
    (50) return_type -> . LPAREN type_list RPAREN
    (51) return_type -> . empty
    (70) type -> . primitive_type
    (71) type -> . slice_type
    (72) type -> . array_type
    (73) type -> . map_type
    (74) type -> . struct_type
    (75) type -> . IDENTIFIER
    (7) empty -> .
    (76) primitive_type -> . INT_TYPE
    (77) primitive_type -> . FLOAT64_TYPE
    (78) primitive_type -> . STRING_TYPE
    (79) primitive_type -> . BOOL_TYPE
    (80) slice_type -> . LBRACKET RBRACKET primitive_type
    (81) array_type -> . LBRACKET INT RBRACKET type
    (127) map_type -> . MAP LBRACKET primitive_type RBRACKET type
    (118) struct_type -> . STRUCT LBRACE RBRACE
    (119) struct_type -> . STRUCT LBRACE field_list RBRACE

    LPAREN          shift and go to state 283
    IDENTIFIER      shift and go to state 177
    LBRACE          reduce using rule 7 (empty -> .)
    INT_TYPE        shift and go to state 171
    FLOAT64_TYPE    shift and go to state 172
    STRING_TYPE     shift and go to state 173
    BOOL_TYPE       shift and go to state 174
    LBRACKET        shift and go to state 175
    MAP             shift and go to state 176
    STRUCT          shift and go to state 170

    return_type                    shift and go to state 324
    type                           shift and go to state 285
    empty                          shift and go to state 286
    primitive_type                 shift and go to state 180
    slice_type                     shift and go to state 181
    array_type                     shift and go to state 182
    map_type                       shift and go to state 183
    struct_type                    shift and go to state 184
>>>>>>> Stashed changes

state 318

<<<<<<< Updated upstream
    (105) for_cond -> empty .

    SEMICOLON       reduce using rule 105 (for_cond -> empty .)
=======
    (173) case_clause -> CASE case_expression_list COLON enter_block . case_body exit_block
    (175) case_body -> . statement_list
    (176) case_body -> . empty
    (18) statement_list -> . statement
    (19) statement_list -> . statement_list optional_semicolon statement
    (7) empty -> .
    (20) statement -> . assignment
    (21) statement -> . assignment_compound
    (22) statement -> . variable_declaration
    (23) statement -> . expression
    (24) statement -> . return_statement
    (25) statement -> . for_statement
    (26) statement -> . if_statement
    (27) statement -> . switch_statement
    (28) statement -> . break_statement
    (29) statement -> . continue_statement
    (30) statement -> . fallthrough_statement
    (54) assignment -> . IDENTIFIER ASSIGN expression
    (55) assignment -> . IDENTIFIER SHORT_ASSIGN expression
    (56) assignment_compound -> . IDENTIFIER PLUS_ASSIGN expression
    (57) assignment_compound -> . IDENTIFIER MINUS_ASSIGN expression
    (58) assignment_compound -> . IDENTIFIER MULT_ASSIGN expression
    (59) assignment_compound -> . IDENTIFIER DIV_ASSIGN expression
    (60) assignment_compound -> . IDENTIFIER MOD_ASSIGN expression
    (61) assignment_compound -> . IDENTIFIER AND_ASSIGN expression
    (62) assignment_compound -> . IDENTIFIER OR_ASSIGN expression
    (63) assignment_compound -> . IDENTIFIER XOR_ASSIGN expression
    (64) assignment_compound -> . IDENTIFIER LSHIFT_ASSIGN expression
    (65) assignment_compound -> . IDENTIFIER RSHIFT_ASSIGN expression
    (66) variable_declaration -> . VAR IDENTIFIER type ASSIGN expression
    (67) variable_declaration -> . CONST IDENTIFIER type ASSIGN expression
    (68) variable_declaration -> . VAR IDENTIFIER ASSIGN expression
    (69) variable_declaration -> . CONST IDENTIFIER ASSIGN expression
    (82) expression -> . binary_expression
    (83) expression -> . relational_expression
    (84) expression -> . logical_expression
    (85) expression -> . bitwise_expression
    (86) expression -> . PLUS expression
    (87) expression -> . MINUS expression
    (88) expression -> . LNOT expression
    (89) expression -> . LBRACKET RBRACKET primitive_type LBRACE expression_list RBRACE
    (90) expression -> . LBRACKET RBRACKET primitive_type LBRACE RBRACE
    (91) expression -> . LPAREN expression RPAREN
    (92) expression -> . INT
    (93) expression -> . FLOAT64
    (94) expression -> . TRUE
    (95) expression -> . FALSE
    (96) expression -> . IDENTIFIER
    (97) expression -> . STRING
    (98) expression -> . IDENTIFIER PLUSPLUS
    (99) expression -> . IDENTIFIER MINUSMINUS
    (100) expression -> . expression DOT IDENTIFIER
    (103) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (133) expression -> . IDENTIFIER LBRACE keyed_element_list RBRACE
    (134) expression -> . IDENTIFIER LBRACE RBRACE
    (39) return_statement -> . RETURN
    (40) return_statement -> . RETURN return_list
    (33) for_statement -> . FOR expression block
    (34) for_statement -> . FOR block
    (35) for_statement -> . FOR for_clause block
    (106) if_statement -> . IF expression block
    (107) if_statement -> . IF expression block ELSE block
    (108) if_statement -> . IF expression block ELSE if_statement
    (109) if_statement -> . IF assignment SEMICOLON expression block
    (110) if_statement -> . IF assignment SEMICOLON expression block ELSE block
    (111) if_statement -> . IF assignment SEMICOLON expression block ELSE if_statement
    (189) switch_statement -> . SWITCH enter_block switch_header LBRACE case_clauses RBRACE exit_block
    (31) break_statement -> . BREAK
    (32) continue_statement -> . CONTINUE
    (177) fallthrough_statement -> . FALLTHROUGH
    (135) binary_expression -> . expression PLUS expression
    (136) binary_expression -> . expression MINUS expression
    (137) binary_expression -> . expression TIMES expression
    (138) binary_expression -> . expression DIVIDE expression
    (139) binary_expression -> . expression MODULE expression
    (144) relational_expression -> . expression EQ expression
    (145) relational_expression -> . expression NEQ expression
    (146) relational_expression -> . expression LT expression
    (147) relational_expression -> . expression LE expression
    (148) relational_expression -> . expression GT expression
    (149) relational_expression -> . expression GE expression
    (150) logical_expression -> . expression LAND expression
    (151) logical_expression -> . expression LOR expression
    (152) bitwise_expression -> . expression AND expression
    (153) bitwise_expression -> . expression OR expression
    (154) bitwise_expression -> . expression XOR expression
    (155) bitwise_expression -> . expression AND_NOT expression
    (156) bitwise_expression -> . expression LSHIFT expression
    (157) bitwise_expression -> . expression RSHIFT expression

    RBRACE          reduce using rule 7 (empty -> .)
    CASE            reduce using rule 7 (empty -> .)
    DEFAULT         reduce using rule 7 (empty -> .)
    IDENTIFIER      shift and go to state 28
    VAR             shift and go to state 31
    CONST           shift and go to state 32
    PLUS            shift and go to state 37
    MINUS           shift and go to state 38
    LNOT            shift and go to state 39
    LBRACKET        shift and go to state 40
    LPAREN          shift and go to state 29
    INT             shift and go to state 41
    FLOAT64         shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44
    STRING          shift and go to state 11
    RETURN          shift and go to state 45
    FOR             shift and go to state 46
    IF              shift and go to state 47
    SWITCH          shift and go to state 48
    BREAK           shift and go to state 49
    CONTINUE        shift and go to state 50
    FALLTHROUGH     shift and go to state 51

    case_body                      shift and go to state 325
    statement_list                 shift and go to state 321
    empty                          shift and go to state 322
    statement                      shift and go to state 239
    assignment                     shift and go to state 16
    assignment_compound            shift and go to state 17
    variable_declaration           shift and go to state 18
    expression                     shift and go to state 19
    return_statement               shift and go to state 20
    for_statement                  shift and go to state 21
    if_statement                   shift and go to state 22
    switch_statement               shift and go to state 23
    break_statement                shift and go to state 24
    continue_statement             shift and go to state 25
    fallthrough_statement          shift and go to state 26
    binary_expression              shift and go to state 33
    relational_expression          shift and go to state 34
    logical_expression             shift and go to state 35
    bitwise_expression             shift and go to state 36

state 319

    (170) case_expression_list -> case_expression_list COMMA expression .
    (100) expression -> expression . DOT IDENTIFIER
    (135) binary_expression -> expression . PLUS expression
    (136) binary_expression -> expression . MINUS expression
    (137) binary_expression -> expression . TIMES expression
    (138) binary_expression -> expression . DIVIDE expression
    (139) binary_expression -> expression . MODULE expression
    (144) relational_expression -> expression . EQ expression
    (145) relational_expression -> expression . NEQ expression
    (146) relational_expression -> expression . LT expression
    (147) relational_expression -> expression . LE expression
    (148) relational_expression -> expression . GT expression
    (149) relational_expression -> expression . GE expression
    (150) logical_expression -> expression . LAND expression
    (151) logical_expression -> expression . LOR expression
    (152) bitwise_expression -> expression . AND expression
    (153) bitwise_expression -> expression . OR expression
    (154) bitwise_expression -> expression . XOR expression
    (155) bitwise_expression -> expression . AND_NOT expression
    (156) bitwise_expression -> expression . LSHIFT expression
    (157) bitwise_expression -> expression . RSHIFT expression

    COLON           reduce using rule 170 (case_expression_list -> case_expression_list COMMA expression .)
    COMMA           reduce using rule 170 (case_expression_list -> case_expression_list COMMA expression .)
    DOT             shift and go to state 58
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    TIMES           shift and go to state 61
    DIVIDE          shift and go to state 62
    MODULE          shift and go to state 63
    EQ              shift and go to state 64
    NEQ             shift and go to state 65
    LT              shift and go to state 66
    LE              shift and go to state 67
    GT              shift and go to state 68
    GE              shift and go to state 69
    LAND            shift and go to state 70
    LOR             shift and go to state 71
    AND             shift and go to state 72
    OR              shift and go to state 73
    XOR             shift and go to state 74
    AND_NOT         shift and go to state 75
    LSHIFT          shift and go to state 76
    RSHIFT          shift and go to state 77
>>>>>>> Stashed changes


state 320

<<<<<<< Updated upstream
    (21) local_var_dec -> VAR IDENTIFIER type ASSIGN expression .
    (36) expression -> expression . binary_operator expression
    (200) expression -> expression . DOT IDENTIFIER
    (201) expression -> expression . DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> expression . LBRACKET expression RBRACKET
    (37) binary_operator -> . PLUS
    (38) binary_operator -> . MINUS
    (39) binary_operator -> . TIMES
    (40) binary_operator -> . DIVIDE
    (41) binary_operator -> . MODULE
    (42) binary_operator -> . EQ
    (43) binary_operator -> . NEQ
    (44) binary_operator -> . LT
    (45) binary_operator -> . LE
    (46) binary_operator -> . GT
    (47) binary_operator -> . GE
    (48) binary_operator -> . LAND
    (49) binary_operator -> . LOR
    (50) binary_operator -> . AND
    (51) binary_operator -> . OR
    (52) binary_operator -> . XOR
    (53) binary_operator -> . AND_NOT
    (54) binary_operator -> . LSHIFT
    (55) binary_operator -> . RSHIFT

  ! shift/reduce conflict for LBRACKET resolved as shift
    RBRACE          reduce using rule 21 (local_var_dec -> VAR IDENTIFIER type ASSIGN expression .)
    BREAK           reduce using rule 21 (local_var_dec -> VAR IDENTIFIER type ASSIGN expression .)
    CONTINUE        reduce using rule 21 (local_var_dec -> VAR IDENTIFIER type ASSIGN expression .)
    VAR             reduce using rule 21 (local_var_dec -> VAR IDENTIFIER type ASSIGN expression .)
    CONST           reduce using rule 21 (local_var_dec -> VAR IDENTIFIER type ASSIGN expression .)
    IDENTIFIER      reduce using rule 21 (local_var_dec -> VAR IDENTIFIER type ASSIGN expression .)
    LPAREN          reduce using rule 21 (local_var_dec -> VAR IDENTIFIER type ASSIGN expression .)
    INT             reduce using rule 21 (local_var_dec -> VAR IDENTIFIER type ASSIGN expression .)
    FLOAT64         reduce using rule 21 (local_var_dec -> VAR IDENTIFIER type ASSIGN expression .)
    STRING          reduce using rule 21 (local_var_dec -> VAR IDENTIFIER type ASSIGN expression .)
    TRUE            reduce using rule 21 (local_var_dec -> VAR IDENTIFIER type ASSIGN expression .)
    FALSE           reduce using rule 21 (local_var_dec -> VAR IDENTIFIER type ASSIGN expression .)
    LNOT            reduce using rule 21 (local_var_dec -> VAR IDENTIFIER type ASSIGN expression .)
    IF              reduce using rule 21 (local_var_dec -> VAR IDENTIFIER type ASSIGN expression .)
    SWITCH          reduce using rule 21 (local_var_dec -> VAR IDENTIFIER type ASSIGN expression .)
    RETURN          reduce using rule 21 (local_var_dec -> VAR IDENTIFIER type ASSIGN expression .)
    MAP             reduce using rule 21 (local_var_dec -> VAR IDENTIFIER type ASSIGN expression .)
    FOR             reduce using rule 21 (local_var_dec -> VAR IDENTIFIER type ASSIGN expression .)
    SEMICOLON       reduce using rule 21 (local_var_dec -> VAR IDENTIFIER type ASSIGN expression .)
    CASE            reduce using rule 21 (local_var_dec -> VAR IDENTIFIER type ASSIGN expression .)
    DEFAULT         reduce using rule 21 (local_var_dec -> VAR IDENTIFIER type ASSIGN expression .)
    DOT             shift and go to state 82
    LBRACKET        shift and go to state 83
    PLUS            shift and go to state 84
    MINUS           shift and go to state 85
    TIMES           shift and go to state 86
    DIVIDE          shift and go to state 87
    MODULE          shift and go to state 88
    EQ              shift and go to state 89
    NEQ             shift and go to state 90
    LT              shift and go to state 91
    LE              shift and go to state 92
    GT              shift and go to state 93
    GE              shift and go to state 94
    LAND            shift and go to state 95
    LOR             shift and go to state 96
    AND             shift and go to state 97
    OR              shift and go to state 98
    XOR             shift and go to state 99
    AND_NOT         shift and go to state 100
    LSHIFT          shift and go to state 101
    RSHIFT          shift and go to state 102
=======
    (174) case_clause -> DEFAULT COLON enter_block case_body . exit_block
    (168) exit_block -> .

    RBRACE          reduce using rule 168 (exit_block -> .)
    CASE            reduce using rule 168 (exit_block -> .)
    DEFAULT         reduce using rule 168 (exit_block -> .)

    exit_block                     shift and go to state 326

state 321

    (175) case_body -> statement_list .
    (19) statement_list -> statement_list . optional_semicolon statement
    (8) optional_semicolon -> . SEMICOLON
    (9) optional_semicolon -> . empty
    (7) empty -> .

    RBRACE          reduce using rule 175 (case_body -> statement_list .)
    CASE            reduce using rule 175 (case_body -> statement_list .)
    DEFAULT         reduce using rule 175 (case_body -> statement_list .)
    SEMICOLON       shift and go to state 53
    IDENTIFIER      reduce using rule 7 (empty -> .)
    VAR             reduce using rule 7 (empty -> .)
    CONST           reduce using rule 7 (empty -> .)
    PLUS            reduce using rule 7 (empty -> .)
    MINUS           reduce using rule 7 (empty -> .)
    LNOT            reduce using rule 7 (empty -> .)
    LBRACKET        reduce using rule 7 (empty -> .)
    LPAREN          reduce using rule 7 (empty -> .)
    INT             reduce using rule 7 (empty -> .)
    FLOAT64         reduce using rule 7 (empty -> .)
    TRUE            reduce using rule 7 (empty -> .)
    FALSE           reduce using rule 7 (empty -> .)
    STRING          reduce using rule 7 (empty -> .)
    RETURN          reduce using rule 7 (empty -> .)
    FOR             reduce using rule 7 (empty -> .)
    IF              reduce using rule 7 (empty -> .)
    SWITCH          reduce using rule 7 (empty -> .)
    BREAK           reduce using rule 7 (empty -> .)
    CONTINUE        reduce using rule 7 (empty -> .)
    FALLTHROUGH     reduce using rule 7 (empty -> .)

    optional_semicolon             shift and go to state 269
    empty                          shift and go to state 54

state 322

    (176) case_body -> empty .

    RBRACE          reduce using rule 176 (case_body -> empty .)
    CASE            reduce using rule 176 (case_body -> empty .)
    DEFAULT         reduce using rule 176 (case_body -> empty .)
>>>>>>> Stashed changes

  ! LBRACKET        [ reduce using rule 21 (local_var_dec -> VAR IDENTIFIER type ASSIGN expression .) ]

    binary_operator                shift and go to state 81

state 323

<<<<<<< Updated upstream
    (23) local_const_dec -> CONST IDENTIFIER type ASSIGN expression .
    (36) expression -> expression . binary_operator expression
    (200) expression -> expression . DOT IDENTIFIER
    (201) expression -> expression . DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> expression . LBRACKET expression RBRACKET
    (37) binary_operator -> . PLUS
    (38) binary_operator -> . MINUS
    (39) binary_operator -> . TIMES
    (40) binary_operator -> . DIVIDE
    (41) binary_operator -> . MODULE
    (42) binary_operator -> . EQ
    (43) binary_operator -> . NEQ
    (44) binary_operator -> . LT
    (45) binary_operator -> . LE
    (46) binary_operator -> . GT
    (47) binary_operator -> . GE
    (48) binary_operator -> . LAND
    (49) binary_operator -> . LOR
    (50) binary_operator -> . AND
    (51) binary_operator -> . OR
    (52) binary_operator -> . XOR
    (53) binary_operator -> . AND_NOT
    (54) binary_operator -> . LSHIFT
    (55) binary_operator -> . RSHIFT

  ! shift/reduce conflict for LBRACKET resolved as shift
    RBRACE          reduce using rule 23 (local_const_dec -> CONST IDENTIFIER type ASSIGN expression .)
    BREAK           reduce using rule 23 (local_const_dec -> CONST IDENTIFIER type ASSIGN expression .)
    CONTINUE        reduce using rule 23 (local_const_dec -> CONST IDENTIFIER type ASSIGN expression .)
    VAR             reduce using rule 23 (local_const_dec -> CONST IDENTIFIER type ASSIGN expression .)
    CONST           reduce using rule 23 (local_const_dec -> CONST IDENTIFIER type ASSIGN expression .)
    IDENTIFIER      reduce using rule 23 (local_const_dec -> CONST IDENTIFIER type ASSIGN expression .)
    LPAREN          reduce using rule 23 (local_const_dec -> CONST IDENTIFIER type ASSIGN expression .)
    INT             reduce using rule 23 (local_const_dec -> CONST IDENTIFIER type ASSIGN expression .)
    FLOAT64         reduce using rule 23 (local_const_dec -> CONST IDENTIFIER type ASSIGN expression .)
    STRING          reduce using rule 23 (local_const_dec -> CONST IDENTIFIER type ASSIGN expression .)
    TRUE            reduce using rule 23 (local_const_dec -> CONST IDENTIFIER type ASSIGN expression .)
    FALSE           reduce using rule 23 (local_const_dec -> CONST IDENTIFIER type ASSIGN expression .)
    LNOT            reduce using rule 23 (local_const_dec -> CONST IDENTIFIER type ASSIGN expression .)
    IF              reduce using rule 23 (local_const_dec -> CONST IDENTIFIER type ASSIGN expression .)
    SWITCH          reduce using rule 23 (local_const_dec -> CONST IDENTIFIER type ASSIGN expression .)
    RETURN          reduce using rule 23 (local_const_dec -> CONST IDENTIFIER type ASSIGN expression .)
    MAP             reduce using rule 23 (local_const_dec -> CONST IDENTIFIER type ASSIGN expression .)
    FOR             reduce using rule 23 (local_const_dec -> CONST IDENTIFIER type ASSIGN expression .)
    CASE            reduce using rule 23 (local_const_dec -> CONST IDENTIFIER type ASSIGN expression .)
    DEFAULT         reduce using rule 23 (local_const_dec -> CONST IDENTIFIER type ASSIGN expression .)
    DOT             shift and go to state 82
    LBRACKET        shift and go to state 83
    PLUS            shift and go to state 84
    MINUS           shift and go to state 85
    TIMES           shift and go to state 86
    DIVIDE          shift and go to state 87
    MODULE          shift and go to state 88
    EQ              shift and go to state 89
    NEQ             shift and go to state 90
    LT              shift and go to state 91
    LE              shift and go to state 92
    GT              shift and go to state 93
    GE              shift and go to state 94
    LAND            shift and go to state 95
    LOR             shift and go to state 96
    AND             shift and go to state 97
    OR              shift and go to state 98
    XOR             shift and go to state 99
    AND_NOT         shift and go to state 100
    LSHIFT          shift and go to state 101
    RSHIFT          shift and go to state 102
=======
    (52) type_list -> type_list COMMA type .

    RPAREN          reduce using rule 52 (type_list -> type_list COMMA type .)
    COMMA           reduce using rule 52 (type_list -> type_list COMMA type .)
>>>>>>> Stashed changes

  ! LBRACKET        [ reduce using rule 23 (local_const_dec -> CONST IDENTIFIER type ASSIGN expression .) ]

    binary_operator                shift and go to state 81

state 324

<<<<<<< Updated upstream
    (129) if_statement -> IF expression block ELSE block .

    RBRACE          reduce using rule 129 (if_statement -> IF expression block ELSE block .)
    BREAK           reduce using rule 129 (if_statement -> IF expression block ELSE block .)
    CONTINUE        reduce using rule 129 (if_statement -> IF expression block ELSE block .)
    VAR             reduce using rule 129 (if_statement -> IF expression block ELSE block .)
    CONST           reduce using rule 129 (if_statement -> IF expression block ELSE block .)
    IDENTIFIER      reduce using rule 129 (if_statement -> IF expression block ELSE block .)
    LPAREN          reduce using rule 129 (if_statement -> IF expression block ELSE block .)
    INT             reduce using rule 129 (if_statement -> IF expression block ELSE block .)
    FLOAT64         reduce using rule 129 (if_statement -> IF expression block ELSE block .)
    STRING          reduce using rule 129 (if_statement -> IF expression block ELSE block .)
    TRUE            reduce using rule 129 (if_statement -> IF expression block ELSE block .)
    FALSE           reduce using rule 129 (if_statement -> IF expression block ELSE block .)
    LNOT            reduce using rule 129 (if_statement -> IF expression block ELSE block .)
    IF              reduce using rule 129 (if_statement -> IF expression block ELSE block .)
    SWITCH          reduce using rule 129 (if_statement -> IF expression block ELSE block .)
    RETURN          reduce using rule 129 (if_statement -> IF expression block ELSE block .)
    LBRACKET        reduce using rule 129 (if_statement -> IF expression block ELSE block .)
    MAP             reduce using rule 129 (if_statement -> IF expression block ELSE block .)
    FOR             reduce using rule 129 (if_statement -> IF expression block ELSE block .)
    CASE            reduce using rule 129 (if_statement -> IF expression block ELSE block .)
    DEFAULT         reduce using rule 129 (if_statement -> IF expression block ELSE block .)

=======
    (124) method_declaration -> FUNC LPAREN receiver RPAREN IDENTIFIER LPAREN parameter_list RPAREN return_type . block
    (16) block -> . LBRACE enter_block exit_block RBRACE
    (17) block -> . LBRACE enter_block statement_list exit_block RBRACE

    LBRACE          shift and go to state 110

    block                          shift and go to state 327
>>>>>>> Stashed changes

state 325

<<<<<<< Updated upstream
    (130) if_statement -> IF expression block ELSE if_statement .

    RBRACE          reduce using rule 130 (if_statement -> IF expression block ELSE if_statement .)
    BREAK           reduce using rule 130 (if_statement -> IF expression block ELSE if_statement .)
    CONTINUE        reduce using rule 130 (if_statement -> IF expression block ELSE if_statement .)
    VAR             reduce using rule 130 (if_statement -> IF expression block ELSE if_statement .)
    CONST           reduce using rule 130 (if_statement -> IF expression block ELSE if_statement .)
    IDENTIFIER      reduce using rule 130 (if_statement -> IF expression block ELSE if_statement .)
    LPAREN          reduce using rule 130 (if_statement -> IF expression block ELSE if_statement .)
    INT             reduce using rule 130 (if_statement -> IF expression block ELSE if_statement .)
    FLOAT64         reduce using rule 130 (if_statement -> IF expression block ELSE if_statement .)
    STRING          reduce using rule 130 (if_statement -> IF expression block ELSE if_statement .)
    TRUE            reduce using rule 130 (if_statement -> IF expression block ELSE if_statement .)
    FALSE           reduce using rule 130 (if_statement -> IF expression block ELSE if_statement .)
    LNOT            reduce using rule 130 (if_statement -> IF expression block ELSE if_statement .)
    IF              reduce using rule 130 (if_statement -> IF expression block ELSE if_statement .)
    SWITCH          reduce using rule 130 (if_statement -> IF expression block ELSE if_statement .)
    RETURN          reduce using rule 130 (if_statement -> IF expression block ELSE if_statement .)
    LBRACKET        reduce using rule 130 (if_statement -> IF expression block ELSE if_statement .)
    MAP             reduce using rule 130 (if_statement -> IF expression block ELSE if_statement .)
    FOR             reduce using rule 130 (if_statement -> IF expression block ELSE if_statement .)
    CASE            reduce using rule 130 (if_statement -> IF expression block ELSE if_statement .)
    DEFAULT         reduce using rule 130 (if_statement -> IF expression block ELSE if_statement .)
=======
    (173) case_clause -> CASE case_expression_list COLON enter_block case_body . exit_block
    (168) exit_block -> .

    RBRACE          reduce using rule 168 (exit_block -> .)
    CASE            reduce using rule 168 (exit_block -> .)
    DEFAULT         reduce using rule 168 (exit_block -> .)

    exit_block                     shift and go to state 328

state 326

    (174) case_clause -> DEFAULT COLON enter_block case_body exit_block .

    RBRACE          reduce using rule 174 (case_clause -> DEFAULT COLON enter_block case_body exit_block .)
    CASE            reduce using rule 174 (case_clause -> DEFAULT COLON enter_block case_body exit_block .)
    DEFAULT         reduce using rule 174 (case_clause -> DEFAULT COLON enter_block case_body exit_block .)
>>>>>>> Stashed changes


state 327

<<<<<<< Updated upstream
    (131) if_statement -> IF if_assignment SEMICOLON expression block .
    (132) if_statement -> IF if_assignment SEMICOLON expression block . ELSE block
    (133) if_statement -> IF if_assignment SEMICOLON expression block . ELSE if_statement

    RBRACE          reduce using rule 131 (if_statement -> IF if_assignment SEMICOLON expression block .)
    BREAK           reduce using rule 131 (if_statement -> IF if_assignment SEMICOLON expression block .)
    CONTINUE        reduce using rule 131 (if_statement -> IF if_assignment SEMICOLON expression block .)
    VAR             reduce using rule 131 (if_statement -> IF if_assignment SEMICOLON expression block .)
    CONST           reduce using rule 131 (if_statement -> IF if_assignment SEMICOLON expression block .)
    IDENTIFIER      reduce using rule 131 (if_statement -> IF if_assignment SEMICOLON expression block .)
    LPAREN          reduce using rule 131 (if_statement -> IF if_assignment SEMICOLON expression block .)
    INT             reduce using rule 131 (if_statement -> IF if_assignment SEMICOLON expression block .)
    FLOAT64         reduce using rule 131 (if_statement -> IF if_assignment SEMICOLON expression block .)
    STRING          reduce using rule 131 (if_statement -> IF if_assignment SEMICOLON expression block .)
    TRUE            reduce using rule 131 (if_statement -> IF if_assignment SEMICOLON expression block .)
    FALSE           reduce using rule 131 (if_statement -> IF if_assignment SEMICOLON expression block .)
    LNOT            reduce using rule 131 (if_statement -> IF if_assignment SEMICOLON expression block .)
    IF              reduce using rule 131 (if_statement -> IF if_assignment SEMICOLON expression block .)
    SWITCH          reduce using rule 131 (if_statement -> IF if_assignment SEMICOLON expression block .)
    RETURN          reduce using rule 131 (if_statement -> IF if_assignment SEMICOLON expression block .)
    LBRACKET        reduce using rule 131 (if_statement -> IF if_assignment SEMICOLON expression block .)
    MAP             reduce using rule 131 (if_statement -> IF if_assignment SEMICOLON expression block .)
    FOR             reduce using rule 131 (if_statement -> IF if_assignment SEMICOLON expression block .)
    CASE            reduce using rule 131 (if_statement -> IF if_assignment SEMICOLON expression block .)
    DEFAULT         reduce using rule 131 (if_statement -> IF if_assignment SEMICOLON expression block .)
    ELSE            shift and go to state 327


state 315

    (167) switch_statement -> SWITCH switch_expr LBRACE case_clause_list RBRACE .

    RBRACE          reduce using rule 167 (switch_statement -> SWITCH switch_expr LBRACE case_clause_list RBRACE .)
    BREAK           reduce using rule 167 (switch_statement -> SWITCH switch_expr LBRACE case_clause_list RBRACE .)
    CONTINUE        reduce using rule 167 (switch_statement -> SWITCH switch_expr LBRACE case_clause_list RBRACE .)
    VAR             reduce using rule 167 (switch_statement -> SWITCH switch_expr LBRACE case_clause_list RBRACE .)
    CONST           reduce using rule 167 (switch_statement -> SWITCH switch_expr LBRACE case_clause_list RBRACE .)
    IDENTIFIER      reduce using rule 167 (switch_statement -> SWITCH switch_expr LBRACE case_clause_list RBRACE .)
    LPAREN          reduce using rule 167 (switch_statement -> SWITCH switch_expr LBRACE case_clause_list RBRACE .)
    INT             reduce using rule 167 (switch_statement -> SWITCH switch_expr LBRACE case_clause_list RBRACE .)
    FLOAT64         reduce using rule 167 (switch_statement -> SWITCH switch_expr LBRACE case_clause_list RBRACE .)
    STRING          reduce using rule 167 (switch_statement -> SWITCH switch_expr LBRACE case_clause_list RBRACE .)
    TRUE            reduce using rule 167 (switch_statement -> SWITCH switch_expr LBRACE case_clause_list RBRACE .)
    FALSE           reduce using rule 167 (switch_statement -> SWITCH switch_expr LBRACE case_clause_list RBRACE .)
    LNOT            reduce using rule 167 (switch_statement -> SWITCH switch_expr LBRACE case_clause_list RBRACE .)
    IF              reduce using rule 167 (switch_statement -> SWITCH switch_expr LBRACE case_clause_list RBRACE .)
    SWITCH          reduce using rule 167 (switch_statement -> SWITCH switch_expr LBRACE case_clause_list RBRACE .)
    RETURN          reduce using rule 167 (switch_statement -> SWITCH switch_expr LBRACE case_clause_list RBRACE .)
    LBRACKET        reduce using rule 167 (switch_statement -> SWITCH switch_expr LBRACE case_clause_list RBRACE .)
    MAP             reduce using rule 167 (switch_statement -> SWITCH switch_expr LBRACE case_clause_list RBRACE .)
    FOR             reduce using rule 167 (switch_statement -> SWITCH switch_expr LBRACE case_clause_list RBRACE .)
    CASE            reduce using rule 167 (switch_statement -> SWITCH switch_expr LBRACE case_clause_list RBRACE .)
    DEFAULT         reduce using rule 167 (switch_statement -> SWITCH switch_expr LBRACE case_clause_list RBRACE .)


state 316

    (191) case_clause -> CASE case_expression_list COLON . case_body
    (195) case_body -> . local_statement_list
    (196) case_body -> . empty
    (92) local_statement_list -> . local_statement
    (93) local_statement_list -> . local_statement_list local_statement
    (7) empty -> .
    (78) local_statement -> . local_var_dec
    (79) local_statement -> . local_const_dec
    (80) local_statement -> . short_assignment
    (81) local_statement -> . simple_assignment
    (82) local_statement -> . assignment_compound
    (83) local_statement -> . expression
    (84) local_statement -> . for_statement
    (85) local_statement -> . if_statement
    (86) local_statement -> . switch_statement
    (87) local_statement -> . return_statement
    (88) local_statement -> . BREAK
    (89) local_statement -> . CONTINUE
    (20) local_var_dec -> . VAR IDENTIFIER type
    (21) local_var_dec -> . VAR IDENTIFIER type ASSIGN expression
    (22) local_var_dec -> . VAR IDENTIFIER ASSIGN expression
    (23) local_const_dec -> . CONST IDENTIFIER type ASSIGN expression
    (24) local_const_dec -> . CONST IDENTIFIER ASSIGN expression
    (77) short_assignment -> . IDENTIFIER SHORT_ASSIGN expression
    (56) simple_assignment -> . IDENTIFIER ASSIGN expression
    (25) assignment_compound -> . IDENTIFIER operator_assign expression
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (125) expression -> . LNOT expression
    (126) expression -> . IDENTIFIER PLUSPLUS
    (127) expression -> . IDENTIFIER MINUSMINUS
    (138) expression -> . map_type LBRACE expression_map_list RBRACE
    (139) expression -> . map_type LBRACE RBRACE
    (161) expression -> . type_name LBRACE keyed_element_list RBRACE
    (162) expression -> . type_name LBRACE RBRACE
    (198) expression -> . array_type LBRACE expression_list RBRACE
    (199) expression -> . array_type LBRACE RBRACE
    (200) expression -> . expression DOT IDENTIFIER
    (201) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> . expression LBRACKET expression RBRACKET
    (203) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (94) for_statement -> . for_classic
    (95) for_statement -> . for_condition
    (96) for_statement -> . for_infinite
    (128) if_statement -> . IF expression block
    (129) if_statement -> . IF expression block ELSE block
    (130) if_statement -> . IF expression block ELSE if_statement
    (131) if_statement -> . IF if_assignment SEMICOLON expression block
    (132) if_statement -> . IF if_assignment SEMICOLON expression block ELSE block
    (133) if_statement -> . IF if_assignment SEMICOLON expression block ELSE if_statement
    (167) switch_statement -> . SWITCH switch_expr LBRACE case_clause_list RBRACE
    (168) switch_statement -> . SWITCH switch_expr LBRACE RBRACE
    (169) switch_statement -> . SWITCH LBRACE case_clause_list RBRACE
    (170) switch_statement -> . SWITCH LBRACE RBRACE
    (171) switch_statement -> . SWITCH switch_assignment SEMICOLON switch_expr LBRACE case_clause_list RBRACE
    (172) switch_statement -> . SWITCH switch_assignment SEMICOLON switch_expr LBRACE RBRACE
    (173) switch_statement -> . SWITCH switch_assignment SEMICOLON LBRACE case_clause_list RBRACE
    (174) switch_statement -> . SWITCH switch_assignment SEMICOLON LBRACE RBRACE
    (123) return_statement -> . RETURN
    (124) return_statement -> . RETURN return_list
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (137) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (163) type_name -> . IDENTIFIER
    (164) type_name -> . slice_type
    (165) type_name -> . array_type
    (166) type_name -> . map_type
    (197) array_type -> . LBRACKET INT RBRACKET primitive_type
    (97) for_classic -> . FOR for_init SEMICOLON for_cond SEMICOLON for_post block
    (98) for_condition -> . FOR expression block
    (99) for_infinite -> . FOR block

    RBRACE          reduce using rule 7 (empty -> .)
    CASE            reduce using rule 7 (empty -> .)
    DEFAULT         reduce using rule 7 (empty -> .)
    BREAK           shift and go to state 199
    CONTINUE        shift and go to state 200
    VAR             shift and go to state 201
    CONST           shift and go to state 203
    IDENTIFIER      shift and go to state 202
    LPAREN          shift and go to state 54
    INT             shift and go to state 55
    FLOAT64         shift and go to state 56
    STRING          shift and go to state 57
    TRUE            shift and go to state 58
    FALSE           shift and go to state 59
    LNOT            shift and go to state 60
    IF              shift and go to state 207
    SWITCH          shift and go to state 208
    RETURN          shift and go to state 209
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39
    FOR             shift and go to state 210

    case_body                      shift and go to state 328
    local_statement_list           shift and go to state 319
    empty                          shift and go to state 320
    local_statement                shift and go to state 188
    local_var_dec                  shift and go to state 189
    local_const_dec                shift and go to state 190
    short_assignment               shift and go to state 191
    simple_assignment              shift and go to state 192
    assignment_compound            shift and go to state 193
    expression                     shift and go to state 194
    for_statement                  shift and go to state 195
    if_statement                   shift and go to state 196
    switch_statement               shift and go to state 197
    return_statement               shift and go to state 198
    slice_type                     shift and go to state 53
    map_type                       shift and go to state 61
    type_name                      shift and go to state 62
    array_type                     shift and go to state 63
    for_classic                    shift and go to state 204
    for_condition                  shift and go to state 205
    for_infinite                   shift and go to state 206

state 317

    (194) case_expression_list -> case_expression_list COMMA . expression
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (125) expression -> . LNOT expression
    (126) expression -> . IDENTIFIER PLUSPLUS
    (127) expression -> . IDENTIFIER MINUSMINUS
    (138) expression -> . map_type LBRACE expression_map_list RBRACE
    (139) expression -> . map_type LBRACE RBRACE
    (161) expression -> . type_name LBRACE keyed_element_list RBRACE
    (162) expression -> . type_name LBRACE RBRACE
    (198) expression -> . array_type LBRACE expression_list RBRACE
    (199) expression -> . array_type LBRACE RBRACE
    (200) expression -> . expression DOT IDENTIFIER
    (201) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> . expression LBRACKET expression RBRACKET
    (203) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (137) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (163) type_name -> . IDENTIFIER
    (164) type_name -> . slice_type
    (165) type_name -> . array_type
    (166) type_name -> . map_type
    (197) array_type -> . LBRACKET INT RBRACKET primitive_type

    LPAREN          shift and go to state 54
    INT             shift and go to state 55
    FLOAT64         shift and go to state 56
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 57
    TRUE            shift and go to state 58
    FALSE           shift and go to state 59
    LNOT            shift and go to state 60
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    expression                     shift and go to state 329
    slice_type                     shift and go to state 53
    map_type                       shift and go to state 61
    type_name                      shift and go to state 62
    array_type                     shift and go to state 63

state 318

    (192) case_clause -> DEFAULT COLON case_body .

    RBRACE          reduce using rule 192 (case_clause -> DEFAULT COLON case_body .)
    CASE            reduce using rule 192 (case_clause -> DEFAULT COLON case_body .)
    DEFAULT         reduce using rule 192 (case_clause -> DEFAULT COLON case_body .)


state 319

    (195) case_body -> local_statement_list .
    (93) local_statement_list -> local_statement_list . local_statement
    (78) local_statement -> . local_var_dec
    (79) local_statement -> . local_const_dec
    (80) local_statement -> . short_assignment
    (81) local_statement -> . simple_assignment
    (82) local_statement -> . assignment_compound
    (83) local_statement -> . expression
    (84) local_statement -> . for_statement
    (85) local_statement -> . if_statement
    (86) local_statement -> . switch_statement
    (87) local_statement -> . return_statement
    (88) local_statement -> . BREAK
    (89) local_statement -> . CONTINUE
    (20) local_var_dec -> . VAR IDENTIFIER type
    (21) local_var_dec -> . VAR IDENTIFIER type ASSIGN expression
    (22) local_var_dec -> . VAR IDENTIFIER ASSIGN expression
    (23) local_const_dec -> . CONST IDENTIFIER type ASSIGN expression
    (24) local_const_dec -> . CONST IDENTIFIER ASSIGN expression
    (77) short_assignment -> . IDENTIFIER SHORT_ASSIGN expression
    (56) simple_assignment -> . IDENTIFIER ASSIGN expression
    (25) assignment_compound -> . IDENTIFIER operator_assign expression
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (125) expression -> . LNOT expression
    (126) expression -> . IDENTIFIER PLUSPLUS
    (127) expression -> . IDENTIFIER MINUSMINUS
    (138) expression -> . map_type LBRACE expression_map_list RBRACE
    (139) expression -> . map_type LBRACE RBRACE
    (161) expression -> . type_name LBRACE keyed_element_list RBRACE
    (162) expression -> . type_name LBRACE RBRACE
    (198) expression -> . array_type LBRACE expression_list RBRACE
    (199) expression -> . array_type LBRACE RBRACE
    (200) expression -> . expression DOT IDENTIFIER
    (201) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> . expression LBRACKET expression RBRACKET
    (203) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (94) for_statement -> . for_classic
    (95) for_statement -> . for_condition
    (96) for_statement -> . for_infinite
    (128) if_statement -> . IF expression block
    (129) if_statement -> . IF expression block ELSE block
    (130) if_statement -> . IF expression block ELSE if_statement
    (131) if_statement -> . IF if_assignment SEMICOLON expression block
    (132) if_statement -> . IF if_assignment SEMICOLON expression block ELSE block
    (133) if_statement -> . IF if_assignment SEMICOLON expression block ELSE if_statement
    (167) switch_statement -> . SWITCH switch_expr LBRACE case_clause_list RBRACE
    (168) switch_statement -> . SWITCH switch_expr LBRACE RBRACE
    (169) switch_statement -> . SWITCH LBRACE case_clause_list RBRACE
    (170) switch_statement -> . SWITCH LBRACE RBRACE
    (171) switch_statement -> . SWITCH switch_assignment SEMICOLON switch_expr LBRACE case_clause_list RBRACE
    (172) switch_statement -> . SWITCH switch_assignment SEMICOLON switch_expr LBRACE RBRACE
    (173) switch_statement -> . SWITCH switch_assignment SEMICOLON LBRACE case_clause_list RBRACE
    (174) switch_statement -> . SWITCH switch_assignment SEMICOLON LBRACE RBRACE
    (123) return_statement -> . RETURN
    (124) return_statement -> . RETURN return_list
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (137) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (163) type_name -> . IDENTIFIER
    (164) type_name -> . slice_type
    (165) type_name -> . array_type
    (166) type_name -> . map_type
    (197) array_type -> . LBRACKET INT RBRACKET primitive_type
    (97) for_classic -> . FOR for_init SEMICOLON for_cond SEMICOLON for_post block
    (98) for_condition -> . FOR expression block
    (99) for_infinite -> . FOR block

    RBRACE          reduce using rule 195 (case_body -> local_statement_list .)
    CASE            reduce using rule 195 (case_body -> local_statement_list .)
    DEFAULT         reduce using rule 195 (case_body -> local_statement_list .)
    BREAK           shift and go to state 199
    CONTINUE        shift and go to state 200
    VAR             shift and go to state 201
    CONST           shift and go to state 203
    IDENTIFIER      shift and go to state 202
    LPAREN          shift and go to state 54
    INT             shift and go to state 55
    FLOAT64         shift and go to state 56
    STRING          shift and go to state 57
    TRUE            shift and go to state 58
    FALSE           shift and go to state 59
    LNOT            shift and go to state 60
    IF              shift and go to state 207
    SWITCH          shift and go to state 208
    RETURN          shift and go to state 209
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39
    FOR             shift and go to state 210

    local_statement                shift and go to state 215
    local_var_dec                  shift and go to state 189
    local_const_dec                shift and go to state 190
    short_assignment               shift and go to state 191
    simple_assignment              shift and go to state 192
    assignment_compound            shift and go to state 193
    expression                     shift and go to state 194
    for_statement                  shift and go to state 195
    if_statement                   shift and go to state 196
    switch_statement               shift and go to state 197
    return_statement               shift and go to state 198
    slice_type                     shift and go to state 53
    map_type                       shift and go to state 61
    type_name                      shift and go to state 62
    array_type                     shift and go to state 63
    for_classic                    shift and go to state 204
    for_condition                  shift and go to state 205
    for_infinite                   shift and go to state 206

state 320

    (196) case_body -> empty .

    RBRACE          reduce using rule 196 (case_body -> empty .)
    CASE            reduce using rule 196 (case_body -> empty .)
    DEFAULT         reduce using rule 196 (case_body -> empty .)


state 321

    (171) switch_statement -> SWITCH switch_assignment SEMICOLON switch_expr LBRACE . case_clause_list RBRACE
    (172) switch_statement -> SWITCH switch_assignment SEMICOLON switch_expr LBRACE . RBRACE
    (186) case_clause_list -> . case_clause
    (187) case_clause_list -> . case_clause_list case_clause
    (191) case_clause -> . CASE case_expression_list COLON case_body
    (192) case_clause -> . DEFAULT COLON case_body

    RBRACE          shift and go to state 331
    CASE            shift and go to state 275
    DEFAULT         shift and go to state 276

    case_clause_list               shift and go to state 330
    case_clause                    shift and go to state 274

state 322

    (173) switch_statement -> SWITCH switch_assignment SEMICOLON LBRACE case_clause_list . RBRACE
    (187) case_clause_list -> case_clause_list . case_clause
    (191) case_clause -> . CASE case_expression_list COLON case_body
    (192) case_clause -> . DEFAULT COLON case_body

    RBRACE          shift and go to state 332
    CASE            shift and go to state 275
    DEFAULT         shift and go to state 276

    case_clause                    shift and go to state 295

state 323

    (174) switch_statement -> SWITCH switch_assignment SEMICOLON LBRACE RBRACE .

    RBRACE          reduce using rule 174 (switch_statement -> SWITCH switch_assignment SEMICOLON LBRACE RBRACE .)
    BREAK           reduce using rule 174 (switch_statement -> SWITCH switch_assignment SEMICOLON LBRACE RBRACE .)
    CONTINUE        reduce using rule 174 (switch_statement -> SWITCH switch_assignment SEMICOLON LBRACE RBRACE .)
    VAR             reduce using rule 174 (switch_statement -> SWITCH switch_assignment SEMICOLON LBRACE RBRACE .)
    CONST           reduce using rule 174 (switch_statement -> SWITCH switch_assignment SEMICOLON LBRACE RBRACE .)
    IDENTIFIER      reduce using rule 174 (switch_statement -> SWITCH switch_assignment SEMICOLON LBRACE RBRACE .)
    LPAREN          reduce using rule 174 (switch_statement -> SWITCH switch_assignment SEMICOLON LBRACE RBRACE .)
    INT             reduce using rule 174 (switch_statement -> SWITCH switch_assignment SEMICOLON LBRACE RBRACE .)
    FLOAT64         reduce using rule 174 (switch_statement -> SWITCH switch_assignment SEMICOLON LBRACE RBRACE .)
    STRING          reduce using rule 174 (switch_statement -> SWITCH switch_assignment SEMICOLON LBRACE RBRACE .)
    TRUE            reduce using rule 174 (switch_statement -> SWITCH switch_assignment SEMICOLON LBRACE RBRACE .)
    FALSE           reduce using rule 174 (switch_statement -> SWITCH switch_assignment SEMICOLON LBRACE RBRACE .)
    LNOT            reduce using rule 174 (switch_statement -> SWITCH switch_assignment SEMICOLON LBRACE RBRACE .)
    IF              reduce using rule 174 (switch_statement -> SWITCH switch_assignment SEMICOLON LBRACE RBRACE .)
    SWITCH          reduce using rule 174 (switch_statement -> SWITCH switch_assignment SEMICOLON LBRACE RBRACE .)
    RETURN          reduce using rule 174 (switch_statement -> SWITCH switch_assignment SEMICOLON LBRACE RBRACE .)
    LBRACKET        reduce using rule 174 (switch_statement -> SWITCH switch_assignment SEMICOLON LBRACE RBRACE .)
    MAP             reduce using rule 174 (switch_statement -> SWITCH switch_assignment SEMICOLON LBRACE RBRACE .)
    FOR             reduce using rule 174 (switch_statement -> SWITCH switch_assignment SEMICOLON LBRACE RBRACE .)
    CASE            reduce using rule 174 (switch_statement -> SWITCH switch_assignment SEMICOLON LBRACE RBRACE .)
    DEFAULT         reduce using rule 174 (switch_statement -> SWITCH switch_assignment SEMICOLON LBRACE RBRACE .)


state 324

    (185) primary_expression -> primary_expression LBRACKET expression RBRACKET .

    DOT             reduce using rule 185 (primary_expression -> primary_expression LBRACKET expression RBRACKET .)
    LBRACKET        reduce using rule 185 (primary_expression -> primary_expression LBRACKET expression RBRACKET .)
    LBRACE          reduce using rule 185 (primary_expression -> primary_expression LBRACKET expression RBRACKET .)


state 325

    (183) primary_expression -> IDENTIFIER LPAREN argument_list RPAREN .

    DOT             reduce using rule 183 (primary_expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    LBRACKET        reduce using rule 183 (primary_expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    LBRACE          reduce using rule 183 (primary_expression -> IDENTIFIER LPAREN argument_list RPAREN .)


state 326

    (97) for_classic -> FOR for_init SEMICOLON for_cond SEMICOLON . for_post block
    (106) for_post -> . simple_assignment
    (107) for_post -> . assignment_compound
    (108) for_post -> . expression
    (109) for_post -> . empty
    (56) simple_assignment -> . IDENTIFIER ASSIGN expression
    (25) assignment_compound -> . IDENTIFIER operator_assign expression
    (36) expression -> . expression binary_operator expression
    (66) expression -> . slice_type LBRACE expression_list RBRACE
    (67) expression -> . slice_type LBRACE RBRACE
    (70) expression -> . LPAREN expression RPAREN
    (71) expression -> . INT
    (72) expression -> . FLOAT64
    (73) expression -> . IDENTIFIER
    (74) expression -> . STRING
    (75) expression -> . TRUE
    (76) expression -> . FALSE
    (125) expression -> . LNOT expression
    (126) expression -> . IDENTIFIER PLUSPLUS
    (127) expression -> . IDENTIFIER MINUSMINUS
    (138) expression -> . map_type LBRACE expression_map_list RBRACE
    (139) expression -> . map_type LBRACE RBRACE
    (161) expression -> . type_name LBRACE keyed_element_list RBRACE
    (162) expression -> . type_name LBRACE RBRACE
    (198) expression -> . array_type LBRACE expression_list RBRACE
    (199) expression -> . array_type LBRACE RBRACE
    (200) expression -> . expression DOT IDENTIFIER
    (201) expression -> . expression DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> . expression LBRACKET expression RBRACKET
    (203) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (7) empty -> .
    (65) slice_type -> . LBRACKET RBRACKET primitive_type
    (137) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (163) type_name -> . IDENTIFIER
    (164) type_name -> . slice_type
    (165) type_name -> . array_type
    (166) type_name -> . map_type
    (197) array_type -> . LBRACKET INT RBRACKET primitive_type

    IDENTIFIER      shift and go to state 338
    LPAREN          shift and go to state 54
    INT             shift and go to state 55
    FLOAT64         shift and go to state 56
    STRING          shift and go to state 57
    TRUE            shift and go to state 58
    FALSE           shift and go to state 59
    LNOT            shift and go to state 60
    LBRACE          reduce using rule 7 (empty -> .)
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    for_post                       shift and go to state 333
    simple_assignment              shift and go to state 334
    assignment_compound            shift and go to state 335
    expression                     shift and go to state 336
    empty                          shift and go to state 337
    slice_type                     shift and go to state 53
    map_type                       shift and go to state 61
    type_name                      shift and go to state 62
    array_type                     shift and go to state 63

state 327

    (132) if_statement -> IF if_assignment SEMICOLON expression block ELSE . block
    (133) if_statement -> IF if_assignment SEMICOLON expression block ELSE . if_statement
    (90) block -> . LBRACE local_statement_list RBRACE
    (91) block -> . LBRACE RBRACE
    (128) if_statement -> . IF expression block
    (129) if_statement -> . IF expression block ELSE block
    (130) if_statement -> . IF expression block ELSE if_statement
    (131) if_statement -> . IF if_assignment SEMICOLON expression block
    (132) if_statement -> . IF if_assignment SEMICOLON expression block ELSE block
    (133) if_statement -> . IF if_assignment SEMICOLON expression block ELSE if_statement

    LBRACE          shift and go to state 175
    IF              shift and go to state 207

    block                          shift and go to state 339
    if_statement                   shift and go to state 340

state 328

    (191) case_clause -> CASE case_expression_list COLON case_body .

    RBRACE          reduce using rule 191 (case_clause -> CASE case_expression_list COLON case_body .)
    CASE            reduce using rule 191 (case_clause -> CASE case_expression_list COLON case_body .)
    DEFAULT         reduce using rule 191 (case_clause -> CASE case_expression_list COLON case_body .)


state 329

    (194) case_expression_list -> case_expression_list COMMA expression .
    (36) expression -> expression . binary_operator expression
    (200) expression -> expression . DOT IDENTIFIER
    (201) expression -> expression . DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> expression . LBRACKET expression RBRACKET
    (37) binary_operator -> . PLUS
    (38) binary_operator -> . MINUS
    (39) binary_operator -> . TIMES
    (40) binary_operator -> . DIVIDE
    (41) binary_operator -> . MODULE
    (42) binary_operator -> . EQ
    (43) binary_operator -> . NEQ
    (44) binary_operator -> . LT
    (45) binary_operator -> . LE
    (46) binary_operator -> . GT
    (47) binary_operator -> . GE
    (48) binary_operator -> . LAND
    (49) binary_operator -> . LOR
    (50) binary_operator -> . AND
    (51) binary_operator -> . OR
    (52) binary_operator -> . XOR
    (53) binary_operator -> . AND_NOT
    (54) binary_operator -> . LSHIFT
    (55) binary_operator -> . RSHIFT

    COLON           reduce using rule 194 (case_expression_list -> case_expression_list COMMA expression .)
    COMMA           reduce using rule 194 (case_expression_list -> case_expression_list COMMA expression .)
    DOT             shift and go to state 82
    LBRACKET        shift and go to state 83
    PLUS            shift and go to state 84
    MINUS           shift and go to state 85
    TIMES           shift and go to state 86
    DIVIDE          shift and go to state 87
    MODULE          shift and go to state 88
    EQ              shift and go to state 89
    NEQ             shift and go to state 90
    LT              shift and go to state 91
    LE              shift and go to state 92
    GT              shift and go to state 93
    GE              shift and go to state 94
    LAND            shift and go to state 95
    LOR             shift and go to state 96
    AND             shift and go to state 97
    OR              shift and go to state 98
    XOR             shift and go to state 99
    AND_NOT         shift and go to state 100
    LSHIFT          shift and go to state 101
    RSHIFT          shift and go to state 102

    binary_operator                shift and go to state 81

state 330

    (171) switch_statement -> SWITCH switch_assignment SEMICOLON switch_expr LBRACE case_clause_list . RBRACE
    (187) case_clause_list -> case_clause_list . case_clause
    (191) case_clause -> . CASE case_expression_list COLON case_body
    (192) case_clause -> . DEFAULT COLON case_body

    RBRACE          shift and go to state 341
    CASE            shift and go to state 275
    DEFAULT         shift and go to state 276

    case_clause                    shift and go to state 295

state 331

    (172) switch_statement -> SWITCH switch_assignment SEMICOLON switch_expr LBRACE RBRACE .

    RBRACE          reduce using rule 172 (switch_statement -> SWITCH switch_assignment SEMICOLON switch_expr LBRACE RBRACE .)
    BREAK           reduce using rule 172 (switch_statement -> SWITCH switch_assignment SEMICOLON switch_expr LBRACE RBRACE .)
    CONTINUE        reduce using rule 172 (switch_statement -> SWITCH switch_assignment SEMICOLON switch_expr LBRACE RBRACE .)
    VAR             reduce using rule 172 (switch_statement -> SWITCH switch_assignment SEMICOLON switch_expr LBRACE RBRACE .)
    CONST           reduce using rule 172 (switch_statement -> SWITCH switch_assignment SEMICOLON switch_expr LBRACE RBRACE .)
    IDENTIFIER      reduce using rule 172 (switch_statement -> SWITCH switch_assignment SEMICOLON switch_expr LBRACE RBRACE .)
    LPAREN          reduce using rule 172 (switch_statement -> SWITCH switch_assignment SEMICOLON switch_expr LBRACE RBRACE .)
    INT             reduce using rule 172 (switch_statement -> SWITCH switch_assignment SEMICOLON switch_expr LBRACE RBRACE .)
    FLOAT64         reduce using rule 172 (switch_statement -> SWITCH switch_assignment SEMICOLON switch_expr LBRACE RBRACE .)
    STRING          reduce using rule 172 (switch_statement -> SWITCH switch_assignment SEMICOLON switch_expr LBRACE RBRACE .)
    TRUE            reduce using rule 172 (switch_statement -> SWITCH switch_assignment SEMICOLON switch_expr LBRACE RBRACE .)
    FALSE           reduce using rule 172 (switch_statement -> SWITCH switch_assignment SEMICOLON switch_expr LBRACE RBRACE .)
    LNOT            reduce using rule 172 (switch_statement -> SWITCH switch_assignment SEMICOLON switch_expr LBRACE RBRACE .)
    IF              reduce using rule 172 (switch_statement -> SWITCH switch_assignment SEMICOLON switch_expr LBRACE RBRACE .)
    SWITCH          reduce using rule 172 (switch_statement -> SWITCH switch_assignment SEMICOLON switch_expr LBRACE RBRACE .)
    RETURN          reduce using rule 172 (switch_statement -> SWITCH switch_assignment SEMICOLON switch_expr LBRACE RBRACE .)
    LBRACKET        reduce using rule 172 (switch_statement -> SWITCH switch_assignment SEMICOLON switch_expr LBRACE RBRACE .)
    MAP             reduce using rule 172 (switch_statement -> SWITCH switch_assignment SEMICOLON switch_expr LBRACE RBRACE .)
    FOR             reduce using rule 172 (switch_statement -> SWITCH switch_assignment SEMICOLON switch_expr LBRACE RBRACE .)
    CASE            reduce using rule 172 (switch_statement -> SWITCH switch_assignment SEMICOLON switch_expr LBRACE RBRACE .)
    DEFAULT         reduce using rule 172 (switch_statement -> SWITCH switch_assignment SEMICOLON switch_expr LBRACE RBRACE .)


state 332

    (173) switch_statement -> SWITCH switch_assignment SEMICOLON LBRACE case_clause_list RBRACE .

    RBRACE          reduce using rule 173 (switch_statement -> SWITCH switch_assignment SEMICOLON LBRACE case_clause_list RBRACE .)
    BREAK           reduce using rule 173 (switch_statement -> SWITCH switch_assignment SEMICOLON LBRACE case_clause_list RBRACE .)
    CONTINUE        reduce using rule 173 (switch_statement -> SWITCH switch_assignment SEMICOLON LBRACE case_clause_list RBRACE .)
    VAR             reduce using rule 173 (switch_statement -> SWITCH switch_assignment SEMICOLON LBRACE case_clause_list RBRACE .)
    CONST           reduce using rule 173 (switch_statement -> SWITCH switch_assignment SEMICOLON LBRACE case_clause_list RBRACE .)
    IDENTIFIER      reduce using rule 173 (switch_statement -> SWITCH switch_assignment SEMICOLON LBRACE case_clause_list RBRACE .)
    LPAREN          reduce using rule 173 (switch_statement -> SWITCH switch_assignment SEMICOLON LBRACE case_clause_list RBRACE .)
    INT             reduce using rule 173 (switch_statement -> SWITCH switch_assignment SEMICOLON LBRACE case_clause_list RBRACE .)
    FLOAT64         reduce using rule 173 (switch_statement -> SWITCH switch_assignment SEMICOLON LBRACE case_clause_list RBRACE .)
    STRING          reduce using rule 173 (switch_statement -> SWITCH switch_assignment SEMICOLON LBRACE case_clause_list RBRACE .)
    TRUE            reduce using rule 173 (switch_statement -> SWITCH switch_assignment SEMICOLON LBRACE case_clause_list RBRACE .)
    FALSE           reduce using rule 173 (switch_statement -> SWITCH switch_assignment SEMICOLON LBRACE case_clause_list RBRACE .)
    LNOT            reduce using rule 173 (switch_statement -> SWITCH switch_assignment SEMICOLON LBRACE case_clause_list RBRACE .)
    IF              reduce using rule 173 (switch_statement -> SWITCH switch_assignment SEMICOLON LBRACE case_clause_list RBRACE .)
    SWITCH          reduce using rule 173 (switch_statement -> SWITCH switch_assignment SEMICOLON LBRACE case_clause_list RBRACE .)
    RETURN          reduce using rule 173 (switch_statement -> SWITCH switch_assignment SEMICOLON LBRACE case_clause_list RBRACE .)
    LBRACKET        reduce using rule 173 (switch_statement -> SWITCH switch_assignment SEMICOLON LBRACE case_clause_list RBRACE .)
    MAP             reduce using rule 173 (switch_statement -> SWITCH switch_assignment SEMICOLON LBRACE case_clause_list RBRACE .)
    FOR             reduce using rule 173 (switch_statement -> SWITCH switch_assignment SEMICOLON LBRACE case_clause_list RBRACE .)
    CASE            reduce using rule 173 (switch_statement -> SWITCH switch_assignment SEMICOLON LBRACE case_clause_list RBRACE .)
    DEFAULT         reduce using rule 173 (switch_statement -> SWITCH switch_assignment SEMICOLON LBRACE case_clause_list RBRACE .)


state 333

    (97) for_classic -> FOR for_init SEMICOLON for_cond SEMICOLON for_post . block
    (90) block -> . LBRACE local_statement_list RBRACE
    (91) block -> . LBRACE RBRACE

    LBRACE          shift and go to state 175

    block                          shift and go to state 342

state 334

    (106) for_post -> simple_assignment .

    LBRACE          reduce using rule 106 (for_post -> simple_assignment .)


state 335

    (107) for_post -> assignment_compound .

    LBRACE          reduce using rule 107 (for_post -> assignment_compound .)


state 336

    (108) for_post -> expression .
    (36) expression -> expression . binary_operator expression
    (200) expression -> expression . DOT IDENTIFIER
    (201) expression -> expression . DOT IDENTIFIER LPAREN argument_list RPAREN
    (202) expression -> expression . LBRACKET expression RBRACKET
    (37) binary_operator -> . PLUS
    (38) binary_operator -> . MINUS
    (39) binary_operator -> . TIMES
    (40) binary_operator -> . DIVIDE
    (41) binary_operator -> . MODULE
    (42) binary_operator -> . EQ
    (43) binary_operator -> . NEQ
    (44) binary_operator -> . LT
    (45) binary_operator -> . LE
    (46) binary_operator -> . GT
    (47) binary_operator -> . GE
    (48) binary_operator -> . LAND
    (49) binary_operator -> . LOR
    (50) binary_operator -> . AND
    (51) binary_operator -> . OR
    (52) binary_operator -> . XOR
    (53) binary_operator -> . AND_NOT
    (54) binary_operator -> . LSHIFT
    (55) binary_operator -> . RSHIFT

    LBRACE          reduce using rule 108 (for_post -> expression .)
    DOT             shift and go to state 82
    LBRACKET        shift and go to state 83
    PLUS            shift and go to state 84
    MINUS           shift and go to state 85
    TIMES           shift and go to state 86
    DIVIDE          shift and go to state 87
    MODULE          shift and go to state 88
    EQ              shift and go to state 89
    NEQ             shift and go to state 90
    LT              shift and go to state 91
    LE              shift and go to state 92
    GT              shift and go to state 93
    GE              shift and go to state 94
    LAND            shift and go to state 95
    LOR             shift and go to state 96
    AND             shift and go to state 97
    OR              shift and go to state 98
    XOR             shift and go to state 99
    AND_NOT         shift and go to state 100
    LSHIFT          shift and go to state 101
    RSHIFT          shift and go to state 102

    binary_operator                shift and go to state 81

state 337

    (109) for_post -> empty .

    LBRACE          reduce using rule 109 (for_post -> empty .)


state 338

    (56) simple_assignment -> IDENTIFIER . ASSIGN expression
    (25) assignment_compound -> IDENTIFIER . operator_assign expression
    (73) expression -> IDENTIFIER .
    (126) expression -> IDENTIFIER . PLUSPLUS
    (127) expression -> IDENTIFIER . MINUSMINUS
    (203) expression -> IDENTIFIER . LPAREN argument_list RPAREN
    (163) type_name -> IDENTIFIER .
    (26) operator_assign -> . PLUS_ASSIGN
    (27) operator_assign -> . MINUS_ASSIGN
    (28) operator_assign -> . MULT_ASSIGN
    (29) operator_assign -> . DIV_ASSIGN
    (30) operator_assign -> . MOD_ASSIGN
    (31) operator_assign -> . AND_ASSIGN
    (32) operator_assign -> . OR_ASSIGN
    (33) operator_assign -> . XOR_ASSIGN
    (34) operator_assign -> . LSHIFT_ASSIGN
    (35) operator_assign -> . RSHIFT_ASSIGN

  ! reduce/reduce conflict for LBRACE resolved using rule 73 (expression -> IDENTIFIER .)
    ASSIGN          shift and go to state 218
    DOT             reduce using rule 73 (expression -> IDENTIFIER .)
    LBRACKET        reduce using rule 73 (expression -> IDENTIFIER .)
    PLUS            reduce using rule 73 (expression -> IDENTIFIER .)
    MINUS           reduce using rule 73 (expression -> IDENTIFIER .)
    TIMES           reduce using rule 73 (expression -> IDENTIFIER .)
    DIVIDE          reduce using rule 73 (expression -> IDENTIFIER .)
    MODULE          reduce using rule 73 (expression -> IDENTIFIER .)
    EQ              reduce using rule 73 (expression -> IDENTIFIER .)
    NEQ             reduce using rule 73 (expression -> IDENTIFIER .)
    LT              reduce using rule 73 (expression -> IDENTIFIER .)
    LE              reduce using rule 73 (expression -> IDENTIFIER .)
    GT              reduce using rule 73 (expression -> IDENTIFIER .)
    GE              reduce using rule 73 (expression -> IDENTIFIER .)
    LAND            reduce using rule 73 (expression -> IDENTIFIER .)
    LOR             reduce using rule 73 (expression -> IDENTIFIER .)
    AND             reduce using rule 73 (expression -> IDENTIFIER .)
    OR              reduce using rule 73 (expression -> IDENTIFIER .)
    XOR             reduce using rule 73 (expression -> IDENTIFIER .)
    AND_NOT         reduce using rule 73 (expression -> IDENTIFIER .)
    LSHIFT          reduce using rule 73 (expression -> IDENTIFIER .)
    RSHIFT          reduce using rule 73 (expression -> IDENTIFIER .)
    LBRACE          reduce using rule 73 (expression -> IDENTIFIER .)
    PLUSPLUS        shift and go to state 78
    MINUSMINUS      shift and go to state 79
    LPAREN          shift and go to state 80
    PLUS_ASSIGN     shift and go to state 220
    MINUS_ASSIGN    shift and go to state 221
    MULT_ASSIGN     shift and go to state 222
    DIV_ASSIGN      shift and go to state 223
    MOD_ASSIGN      shift and go to state 224
    AND_ASSIGN      shift and go to state 225
    OR_ASSIGN       shift and go to state 226
    XOR_ASSIGN      shift and go to state 227
    LSHIFT_ASSIGN   shift and go to state 228
    RSHIFT_ASSIGN   shift and go to state 229

  ! LBRACE          [ reduce using rule 163 (type_name -> IDENTIFIER .) ]

    operator_assign                shift and go to state 219

state 339

    (132) if_statement -> IF if_assignment SEMICOLON expression block ELSE block .

    RBRACE          reduce using rule 132 (if_statement -> IF if_assignment SEMICOLON expression block ELSE block .)
    BREAK           reduce using rule 132 (if_statement -> IF if_assignment SEMICOLON expression block ELSE block .)
    CONTINUE        reduce using rule 132 (if_statement -> IF if_assignment SEMICOLON expression block ELSE block .)
    VAR             reduce using rule 132 (if_statement -> IF if_assignment SEMICOLON expression block ELSE block .)
    CONST           reduce using rule 132 (if_statement -> IF if_assignment SEMICOLON expression block ELSE block .)
    IDENTIFIER      reduce using rule 132 (if_statement -> IF if_assignment SEMICOLON expression block ELSE block .)
    LPAREN          reduce using rule 132 (if_statement -> IF if_assignment SEMICOLON expression block ELSE block .)
    INT             reduce using rule 132 (if_statement -> IF if_assignment SEMICOLON expression block ELSE block .)
    FLOAT64         reduce using rule 132 (if_statement -> IF if_assignment SEMICOLON expression block ELSE block .)
    STRING          reduce using rule 132 (if_statement -> IF if_assignment SEMICOLON expression block ELSE block .)
    TRUE            reduce using rule 132 (if_statement -> IF if_assignment SEMICOLON expression block ELSE block .)
    FALSE           reduce using rule 132 (if_statement -> IF if_assignment SEMICOLON expression block ELSE block .)
    LNOT            reduce using rule 132 (if_statement -> IF if_assignment SEMICOLON expression block ELSE block .)
    IF              reduce using rule 132 (if_statement -> IF if_assignment SEMICOLON expression block ELSE block .)
    SWITCH          reduce using rule 132 (if_statement -> IF if_assignment SEMICOLON expression block ELSE block .)
    RETURN          reduce using rule 132 (if_statement -> IF if_assignment SEMICOLON expression block ELSE block .)
    LBRACKET        reduce using rule 132 (if_statement -> IF if_assignment SEMICOLON expression block ELSE block .)
    MAP             reduce using rule 132 (if_statement -> IF if_assignment SEMICOLON expression block ELSE block .)
    FOR             reduce using rule 132 (if_statement -> IF if_assignment SEMICOLON expression block ELSE block .)
    CASE            reduce using rule 132 (if_statement -> IF if_assignment SEMICOLON expression block ELSE block .)
    DEFAULT         reduce using rule 132 (if_statement -> IF if_assignment SEMICOLON expression block ELSE block .)


state 340

    (133) if_statement -> IF if_assignment SEMICOLON expression block ELSE if_statement .

    RBRACE          reduce using rule 133 (if_statement -> IF if_assignment SEMICOLON expression block ELSE if_statement .)
    BREAK           reduce using rule 133 (if_statement -> IF if_assignment SEMICOLON expression block ELSE if_statement .)
    CONTINUE        reduce using rule 133 (if_statement -> IF if_assignment SEMICOLON expression block ELSE if_statement .)
    VAR             reduce using rule 133 (if_statement -> IF if_assignment SEMICOLON expression block ELSE if_statement .)
    CONST           reduce using rule 133 (if_statement -> IF if_assignment SEMICOLON expression block ELSE if_statement .)
    IDENTIFIER      reduce using rule 133 (if_statement -> IF if_assignment SEMICOLON expression block ELSE if_statement .)
    LPAREN          reduce using rule 133 (if_statement -> IF if_assignment SEMICOLON expression block ELSE if_statement .)
    INT             reduce using rule 133 (if_statement -> IF if_assignment SEMICOLON expression block ELSE if_statement .)
    FLOAT64         reduce using rule 133 (if_statement -> IF if_assignment SEMICOLON expression block ELSE if_statement .)
    STRING          reduce using rule 133 (if_statement -> IF if_assignment SEMICOLON expression block ELSE if_statement .)
    TRUE            reduce using rule 133 (if_statement -> IF if_assignment SEMICOLON expression block ELSE if_statement .)
    FALSE           reduce using rule 133 (if_statement -> IF if_assignment SEMICOLON expression block ELSE if_statement .)
    LNOT            reduce using rule 133 (if_statement -> IF if_assignment SEMICOLON expression block ELSE if_statement .)
    IF              reduce using rule 133 (if_statement -> IF if_assignment SEMICOLON expression block ELSE if_statement .)
    SWITCH          reduce using rule 133 (if_statement -> IF if_assignment SEMICOLON expression block ELSE if_statement .)
    RETURN          reduce using rule 133 (if_statement -> IF if_assignment SEMICOLON expression block ELSE if_statement .)
    LBRACKET        reduce using rule 133 (if_statement -> IF if_assignment SEMICOLON expression block ELSE if_statement .)
    MAP             reduce using rule 133 (if_statement -> IF if_assignment SEMICOLON expression block ELSE if_statement .)
    FOR             reduce using rule 133 (if_statement -> IF if_assignment SEMICOLON expression block ELSE if_statement .)
    CASE            reduce using rule 133 (if_statement -> IF if_assignment SEMICOLON expression block ELSE if_statement .)
    DEFAULT         reduce using rule 133 (if_statement -> IF if_assignment SEMICOLON expression block ELSE if_statement .)


state 341

    (171) switch_statement -> SWITCH switch_assignment SEMICOLON switch_expr LBRACE case_clause_list RBRACE .

    RBRACE          reduce using rule 171 (switch_statement -> SWITCH switch_assignment SEMICOLON switch_expr LBRACE case_clause_list RBRACE .)
    BREAK           reduce using rule 171 (switch_statement -> SWITCH switch_assignment SEMICOLON switch_expr LBRACE case_clause_list RBRACE .)
    CONTINUE        reduce using rule 171 (switch_statement -> SWITCH switch_assignment SEMICOLON switch_expr LBRACE case_clause_list RBRACE .)
    VAR             reduce using rule 171 (switch_statement -> SWITCH switch_assignment SEMICOLON switch_expr LBRACE case_clause_list RBRACE .)
    CONST           reduce using rule 171 (switch_statement -> SWITCH switch_assignment SEMICOLON switch_expr LBRACE case_clause_list RBRACE .)
    IDENTIFIER      reduce using rule 171 (switch_statement -> SWITCH switch_assignment SEMICOLON switch_expr LBRACE case_clause_list RBRACE .)
    LPAREN          reduce using rule 171 (switch_statement -> SWITCH switch_assignment SEMICOLON switch_expr LBRACE case_clause_list RBRACE .)
    INT             reduce using rule 171 (switch_statement -> SWITCH switch_assignment SEMICOLON switch_expr LBRACE case_clause_list RBRACE .)
    FLOAT64         reduce using rule 171 (switch_statement -> SWITCH switch_assignment SEMICOLON switch_expr LBRACE case_clause_list RBRACE .)
    STRING          reduce using rule 171 (switch_statement -> SWITCH switch_assignment SEMICOLON switch_expr LBRACE case_clause_list RBRACE .)
    TRUE            reduce using rule 171 (switch_statement -> SWITCH switch_assignment SEMICOLON switch_expr LBRACE case_clause_list RBRACE .)
    FALSE           reduce using rule 171 (switch_statement -> SWITCH switch_assignment SEMICOLON switch_expr LBRACE case_clause_list RBRACE .)
    LNOT            reduce using rule 171 (switch_statement -> SWITCH switch_assignment SEMICOLON switch_expr LBRACE case_clause_list RBRACE .)
    IF              reduce using rule 171 (switch_statement -> SWITCH switch_assignment SEMICOLON switch_expr LBRACE case_clause_list RBRACE .)
    SWITCH          reduce using rule 171 (switch_statement -> SWITCH switch_assignment SEMICOLON switch_expr LBRACE case_clause_list RBRACE .)
    RETURN          reduce using rule 171 (switch_statement -> SWITCH switch_assignment SEMICOLON switch_expr LBRACE case_clause_list RBRACE .)
    LBRACKET        reduce using rule 171 (switch_statement -> SWITCH switch_assignment SEMICOLON switch_expr LBRACE case_clause_list RBRACE .)
    MAP             reduce using rule 171 (switch_statement -> SWITCH switch_assignment SEMICOLON switch_expr LBRACE case_clause_list RBRACE .)
    FOR             reduce using rule 171 (switch_statement -> SWITCH switch_assignment SEMICOLON switch_expr LBRACE case_clause_list RBRACE .)
    CASE            reduce using rule 171 (switch_statement -> SWITCH switch_assignment SEMICOLON switch_expr LBRACE case_clause_list RBRACE .)
    DEFAULT         reduce using rule 171 (switch_statement -> SWITCH switch_assignment SEMICOLON switch_expr LBRACE case_clause_list RBRACE .)


state 342

    (97) for_classic -> FOR for_init SEMICOLON for_cond SEMICOLON for_post block .

    RBRACE          reduce using rule 97 (for_classic -> FOR for_init SEMICOLON for_cond SEMICOLON for_post block .)
    BREAK           reduce using rule 97 (for_classic -> FOR for_init SEMICOLON for_cond SEMICOLON for_post block .)
    CONTINUE        reduce using rule 97 (for_classic -> FOR for_init SEMICOLON for_cond SEMICOLON for_post block .)
    VAR             reduce using rule 97 (for_classic -> FOR for_init SEMICOLON for_cond SEMICOLON for_post block .)
    CONST           reduce using rule 97 (for_classic -> FOR for_init SEMICOLON for_cond SEMICOLON for_post block .)
    IDENTIFIER      reduce using rule 97 (for_classic -> FOR for_init SEMICOLON for_cond SEMICOLON for_post block .)
    LPAREN          reduce using rule 97 (for_classic -> FOR for_init SEMICOLON for_cond SEMICOLON for_post block .)
    INT             reduce using rule 97 (for_classic -> FOR for_init SEMICOLON for_cond SEMICOLON for_post block .)
    FLOAT64         reduce using rule 97 (for_classic -> FOR for_init SEMICOLON for_cond SEMICOLON for_post block .)
    STRING          reduce using rule 97 (for_classic -> FOR for_init SEMICOLON for_cond SEMICOLON for_post block .)
    TRUE            reduce using rule 97 (for_classic -> FOR for_init SEMICOLON for_cond SEMICOLON for_post block .)
    FALSE           reduce using rule 97 (for_classic -> FOR for_init SEMICOLON for_cond SEMICOLON for_post block .)
    LNOT            reduce using rule 97 (for_classic -> FOR for_init SEMICOLON for_cond SEMICOLON for_post block .)
    IF              reduce using rule 97 (for_classic -> FOR for_init SEMICOLON for_cond SEMICOLON for_post block .)
    SWITCH          reduce using rule 97 (for_classic -> FOR for_init SEMICOLON for_cond SEMICOLON for_post block .)
    RETURN          reduce using rule 97 (for_classic -> FOR for_init SEMICOLON for_cond SEMICOLON for_post block .)
    LBRACKET        reduce using rule 97 (for_classic -> FOR for_init SEMICOLON for_cond SEMICOLON for_post block .)
    MAP             reduce using rule 97 (for_classic -> FOR for_init SEMICOLON for_cond SEMICOLON for_post block .)
    FOR             reduce using rule 97 (for_classic -> FOR for_init SEMICOLON for_cond SEMICOLON for_post block .)
    CASE            reduce using rule 97 (for_classic -> FOR for_init SEMICOLON for_cond SEMICOLON for_post block .)
    DEFAULT         reduce using rule 97 (for_classic -> FOR for_init SEMICOLON for_cond SEMICOLON for_post block .)
=======
    (124) method_declaration -> FUNC LPAREN receiver RPAREN IDENTIFIER LPAREN parameter_list RPAREN return_type block .

    FUNC            reduce using rule 124 (method_declaration -> FUNC LPAREN receiver RPAREN IDENTIFIER LPAREN parameter_list RPAREN return_type block .)
    TYPE            reduce using rule 124 (method_declaration -> FUNC LPAREN receiver RPAREN IDENTIFIER LPAREN parameter_list RPAREN return_type block .)
    IDENTIFIER      reduce using rule 124 (method_declaration -> FUNC LPAREN receiver RPAREN IDENTIFIER LPAREN parameter_list RPAREN return_type block .)
    VAR             reduce using rule 124 (method_declaration -> FUNC LPAREN receiver RPAREN IDENTIFIER LPAREN parameter_list RPAREN return_type block .)
    CONST           reduce using rule 124 (method_declaration -> FUNC LPAREN receiver RPAREN IDENTIFIER LPAREN parameter_list RPAREN return_type block .)
    PLUS            reduce using rule 124 (method_declaration -> FUNC LPAREN receiver RPAREN IDENTIFIER LPAREN parameter_list RPAREN return_type block .)
    MINUS           reduce using rule 124 (method_declaration -> FUNC LPAREN receiver RPAREN IDENTIFIER LPAREN parameter_list RPAREN return_type block .)
    LNOT            reduce using rule 124 (method_declaration -> FUNC LPAREN receiver RPAREN IDENTIFIER LPAREN parameter_list RPAREN return_type block .)
    LBRACKET        reduce using rule 124 (method_declaration -> FUNC LPAREN receiver RPAREN IDENTIFIER LPAREN parameter_list RPAREN return_type block .)
    LPAREN          reduce using rule 124 (method_declaration -> FUNC LPAREN receiver RPAREN IDENTIFIER LPAREN parameter_list RPAREN return_type block .)
    INT             reduce using rule 124 (method_declaration -> FUNC LPAREN receiver RPAREN IDENTIFIER LPAREN parameter_list RPAREN return_type block .)
    FLOAT64         reduce using rule 124 (method_declaration -> FUNC LPAREN receiver RPAREN IDENTIFIER LPAREN parameter_list RPAREN return_type block .)
    TRUE            reduce using rule 124 (method_declaration -> FUNC LPAREN receiver RPAREN IDENTIFIER LPAREN parameter_list RPAREN return_type block .)
    FALSE           reduce using rule 124 (method_declaration -> FUNC LPAREN receiver RPAREN IDENTIFIER LPAREN parameter_list RPAREN return_type block .)
    STRING          reduce using rule 124 (method_declaration -> FUNC LPAREN receiver RPAREN IDENTIFIER LPAREN parameter_list RPAREN return_type block .)
    RETURN          reduce using rule 124 (method_declaration -> FUNC LPAREN receiver RPAREN IDENTIFIER LPAREN parameter_list RPAREN return_type block .)
    FOR             reduce using rule 124 (method_declaration -> FUNC LPAREN receiver RPAREN IDENTIFIER LPAREN parameter_list RPAREN return_type block .)
    IF              reduce using rule 124 (method_declaration -> FUNC LPAREN receiver RPAREN IDENTIFIER LPAREN parameter_list RPAREN return_type block .)
    SWITCH          reduce using rule 124 (method_declaration -> FUNC LPAREN receiver RPAREN IDENTIFIER LPAREN parameter_list RPAREN return_type block .)
    BREAK           reduce using rule 124 (method_declaration -> FUNC LPAREN receiver RPAREN IDENTIFIER LPAREN parameter_list RPAREN return_type block .)
    CONTINUE        reduce using rule 124 (method_declaration -> FUNC LPAREN receiver RPAREN IDENTIFIER LPAREN parameter_list RPAREN return_type block .)
    FALLTHROUGH     reduce using rule 124 (method_declaration -> FUNC LPAREN receiver RPAREN IDENTIFIER LPAREN parameter_list RPAREN return_type block .)
    $end            reduce using rule 124 (method_declaration -> FUNC LPAREN receiver RPAREN IDENTIFIER LPAREN parameter_list RPAREN return_type block .)


state 328

    (173) case_clause -> CASE case_expression_list COLON enter_block case_body exit_block .

    RBRACE          reduce using rule 173 (case_clause -> CASE case_expression_list COLON enter_block case_body exit_block .)
    CASE            reduce using rule 173 (case_clause -> CASE case_expression_list COLON enter_block case_body exit_block .)
    DEFAULT         reduce using rule 173 (case_clause -> CASE case_expression_list COLON enter_block case_body exit_block .)
>>>>>>> Stashed changes

WARNING: 
WARNING: Conflicts:
WARNING: 
<<<<<<< Updated upstream
WARNING: shift/reduce conflict for IMPORT in state 2 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 51 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 53 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 61 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 63 resolved as shift
WARNING: shift/reduce conflict for DOT in state 105 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 105 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 105 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 105 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 105 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 105 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 105 resolved as shift
WARNING: shift/reduce conflict for EQ in state 105 resolved as shift
WARNING: shift/reduce conflict for NEQ in state 105 resolved as shift
WARNING: shift/reduce conflict for LT in state 105 resolved as shift
WARNING: shift/reduce conflict for LE in state 105 resolved as shift
WARNING: shift/reduce conflict for GT in state 105 resolved as shift
WARNING: shift/reduce conflict for GE in state 105 resolved as shift
WARNING: shift/reduce conflict for LAND in state 105 resolved as shift
WARNING: shift/reduce conflict for LOR in state 105 resolved as shift
WARNING: shift/reduce conflict for AND in state 105 resolved as shift
WARNING: shift/reduce conflict for OR in state 105 resolved as shift
WARNING: shift/reduce conflict for XOR in state 105 resolved as shift
WARNING: shift/reduce conflict for AND_NOT in state 105 resolved as shift
WARNING: shift/reduce conflict for LSHIFT in state 105 resolved as shift
WARNING: shift/reduce conflict for RSHIFT in state 105 resolved as shift
WARNING: shift/reduce conflict for DOT in state 128 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 128 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 128 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 128 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 128 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 128 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 128 resolved as shift
WARNING: shift/reduce conflict for EQ in state 128 resolved as shift
WARNING: shift/reduce conflict for NEQ in state 128 resolved as shift
WARNING: shift/reduce conflict for LT in state 128 resolved as shift
WARNING: shift/reduce conflict for LE in state 128 resolved as shift
WARNING: shift/reduce conflict for GT in state 128 resolved as shift
WARNING: shift/reduce conflict for GE in state 128 resolved as shift
WARNING: shift/reduce conflict for LAND in state 128 resolved as shift
WARNING: shift/reduce conflict for LOR in state 128 resolved as shift
WARNING: shift/reduce conflict for AND in state 128 resolved as shift
WARNING: shift/reduce conflict for OR in state 128 resolved as shift
WARNING: shift/reduce conflict for XOR in state 128 resolved as shift
WARNING: shift/reduce conflict for AND_NOT in state 128 resolved as shift
WARNING: shift/reduce conflict for LSHIFT in state 128 resolved as shift
WARNING: shift/reduce conflict for RSHIFT in state 128 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 129 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 194 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 202 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 209 resolved as shift
WARNING: shift/reduce conflict for INT in state 209 resolved as shift
WARNING: shift/reduce conflict for FLOAT64 in state 209 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 209 resolved as shift
WARNING: shift/reduce conflict for STRING in state 209 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 209 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 209 resolved as shift
WARNING: shift/reduce conflict for LNOT in state 209 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 209 resolved as shift
WARNING: shift/reduce conflict for MAP in state 209 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 252 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 264 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 265 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 266 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 287 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 289 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 306 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 310 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 311 resolved as shift
WARNING: reduce/reduce conflict in state 51 resolved using rule (expression -> IDENTIFIER)
WARNING: rejected rule (type_name -> IDENTIFIER) in state 51
WARNING: reduce/reduce conflict in state 233 resolved using rule (expression -> IDENTIFIER)
WARNING: rejected rule (type_name -> IDENTIFIER) in state 233
WARNING: reduce/reduce conflict in state 260 resolved using rule (expression -> IDENTIFIER)
WARNING: rejected rule (type_name -> IDENTIFIER) in state 260
WARNING: reduce/reduce conflict in state 338 resolved using rule (expression -> IDENTIFIER)
WARNING: rejected rule (type_name -> IDENTIFIER) in state 338
=======
WARNING: shift/reduce conflict for PLUS in state 19 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 19 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 28 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 45 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 45 resolved as shift
WARNING: shift/reduce conflict for LNOT in state 45 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 45 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 45 resolved as shift
WARNING: shift/reduce conflict for INT in state 45 resolved as shift
WARNING: shift/reduce conflict for FLOAT64 in state 45 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 45 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 45 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 45 resolved as shift
WARNING: shift/reduce conflict for STRING in state 45 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 97 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 97 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 106 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 106 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 111 resolved as shift
WARNING: shift/reduce conflict for DOT in state 135 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 135 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 135 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 135 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 135 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 135 resolved as shift
WARNING: shift/reduce conflict for EQ in state 135 resolved as shift
WARNING: shift/reduce conflict for NEQ in state 135 resolved as shift
WARNING: shift/reduce conflict for LT in state 135 resolved as shift
WARNING: shift/reduce conflict for LE in state 135 resolved as shift
WARNING: shift/reduce conflict for GT in state 135 resolved as shift
WARNING: shift/reduce conflict for GE in state 135 resolved as shift
WARNING: shift/reduce conflict for LAND in state 135 resolved as shift
WARNING: shift/reduce conflict for LOR in state 135 resolved as shift
WARNING: shift/reduce conflict for AND in state 135 resolved as shift
WARNING: shift/reduce conflict for OR in state 135 resolved as shift
WARNING: shift/reduce conflict for XOR in state 135 resolved as shift
WARNING: shift/reduce conflict for AND_NOT in state 135 resolved as shift
WARNING: shift/reduce conflict for LSHIFT in state 135 resolved as shift
WARNING: shift/reduce conflict for RSHIFT in state 135 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 141 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 141 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 142 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 142 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 143 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 143 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 144 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 144 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 145 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 145 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 146 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 146 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 147 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 147 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 148 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 148 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 149 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 149 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 150 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 150 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 151 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 151 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 152 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 152 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 232 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 232 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 234 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 234 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 236 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 236 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 259 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 263 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 263 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 264 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 264 resolved as shift
>>>>>>> Stashed changes
