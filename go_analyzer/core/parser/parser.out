Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> package_declaration import global_statement_list
Rule 2     package_declaration -> PACKAGE IDENTIFIER
Rule 3     import -> simple_import
Rule 4     import -> import simple_import
Rule 5     import -> empty
Rule 6     simple_import -> IMPORT STRING
Rule 7     empty -> <empty>
Rule 8     global_statement_list -> global_statement
Rule 9     global_statement_list -> global_statement_list global_statement
Rule 10    global_statement -> global_var_dec
Rule 11    global_statement -> global_const_dec
Rule 12    global_statement -> function_declaration
Rule 13    global_statement -> method_declaration
Rule 14    global_statement -> type_declaration
Rule 15    block -> LBRACE enter_block exit_block RBRACE
Rule 16    block -> LBRACE enter_block statement_list exit_block RBRACE
Rule 17    statement_list -> statement
Rule 18    statement_list -> statement_list statement
Rule 19    statement -> assignment
Rule 20    statement -> assignment_compound
Rule 21    statement -> variable_declaration
Rule 22    statement -> expression
Rule 23    statement -> return_statement
Rule 24    statement -> for_statement
Rule 25    statement -> if_statement
Rule 26    statement -> switch_statement
Rule 27    statement -> break_statement
Rule 28    statement -> continue_statement
Rule 29    statement -> call_expression
Rule 30    global_var_dec -> VAR IDENTIFIER type
Rule 31    global_var_dec -> VAR IDENTIFIER type ASSIGN expression
Rule 32    global_var_dec -> VAR IDENTIFIER ASSIGN expression
Rule 33    global_const_dec -> CONST IDENTIFIER type ASSIGN expression
Rule 34    global_const_dec -> CONST IDENTIFIER ASSIGN expression
Rule 35    local_var_dec -> VAR IDENTIFIER type
Rule 36    local_var_dec -> VAR IDENTIFIER type ASSIGN expression
Rule 37    local_var_dec -> VAR IDENTIFIER ASSIGN expression
Rule 38    local_const_dec -> CONST IDENTIFIER type ASSIGN expression
Rule 39    local_const_dec -> CONST IDENTIFIER ASSIGN expression
Rule 40    assignment_compound -> IDENTIFIER operator_assign expression
Rule 41    operator_assign -> PLUS_ASSIGN
Rule 42    operator_assign -> MINUS_ASSIGN
Rule 43    operator_assign -> MULT_ASSIGN
Rule 44    operator_assign -> DIV_ASSIGN
Rule 45    operator_assign -> MOD_ASSIGN
Rule 46    operator_assign -> AND_ASSIGN
Rule 47    operator_assign -> OR_ASSIGN
Rule 48    operator_assign -> XOR_ASSIGN
Rule 49    operator_assign -> LSHIFT_ASSIGN
Rule 50    operator_assign -> RSHIFT_ASSIGN
Rule 51    simple_assignment -> IDENTIFIER ASSIGN expression
Rule 52    type -> primitive_type
Rule 53    type -> slice_type
Rule 54    type -> array_type
Rule 55    type -> map_type
Rule 56    slice_type -> LBRACKET RBRACKET primitive_type
Rule 57    expression -> slice_type LBRACE expression_list RBRACE
Rule 58    expression -> slice_type LBRACE RBRACE
Rule 59    expression_list -> expression
Rule 60    expression_list -> expression_list COMMA expression
Rule 61    expression -> LPAREN expression RPAREN
Rule 62    short_assignment -> IDENTIFIER SHORT_ASSIGN expression
Rule 63    local_statement -> local_var_dec
Rule 64    local_statement -> local_const_dec
Rule 65    local_statement -> short_assignment
Rule 66    local_statement -> simple_assignment
Rule 67    local_statement -> assignment_compound
Rule 68    local_statement -> expression
Rule 69    local_statement -> for_statement
Rule 70    local_statement -> if_statement
Rule 71    local_statement -> switch_statement
Rule 72    local_statement -> break_statement
Rule 73    local_statement -> continue_statement
Rule 74    break_statement -> BREAK
Rule 75    continue_statement -> CONTINUE
Rule 76    local_statement_list -> local_statement
Rule 77    local_statement_list -> local_statement_list local_statement
Rule 78    for_statement -> for_classic
Rule 79    for_statement -> for_condition
Rule 80    for_statement -> for_infinite
Rule 81    for_classic -> FOR for_init SEMICOLON for_cond SEMICOLON for_post block
Rule 82    for_condition -> FOR expression block
Rule 83    for_infinite -> FOR block
Rule 84    for_init -> simple_assignment
Rule 85    for_init -> short_assignment
Rule 86    for_init -> local_var_dec
Rule 87    for_init -> empty
Rule 88    for_cond -> expression
Rule 89    for_cond -> empty
Rule 90    for_post -> simple_assignment
Rule 91    for_post -> assignment_compound
Rule 92    for_post -> expression
Rule 93    for_post -> empty
Rule 94    return_list -> expression
Rule 95    return_list -> return_list COMMA expression
Rule 96    function_declaration -> FUNC IDENTIFIER LPAREN parameter_list RPAREN return_type block
Rule 97    parameter_list -> parameter_list COMMA parameter
Rule 98    parameter_list -> parameter
Rule 99    parameter_list -> empty
Rule 100   parameter -> IDENTIFIER type
Rule 101   parameter -> IDENTIFIER ELLIPSIS primitive_type
Rule 102   return_type -> type
Rule 103   return_type -> LPAREN type_list RPAREN
Rule 104   return_type -> empty
Rule 105   return_statement -> RETURN
Rule 106   return_statement -> RETURN return_list
Rule 107   type_list -> type_list COMMA type
Rule 108   type_list -> type
Rule 109   assignment -> IDENTIFIER ASSIGN expression
Rule 110   assignment -> IDENTIFIER SHORT_ASSIGN expression
Rule 111   variable_declaration -> VAR IDENTIFIER type ASSIGN expression
Rule 112   variable_declaration -> CONST IDENTIFIER type ASSIGN expression
Rule 113   variable_declaration -> VAR IDENTIFIER ASSIGN expression
Rule 114   variable_declaration -> CONST IDENTIFIER ASSIGN expression
Rule 115   primitive_type -> INT_TYPE
Rule 116   primitive_type -> FLOAT64_TYPE
Rule 117   primitive_type -> STRING_TYPE
Rule 118   primitive_type -> BOOL_TYPE
Rule 119   array_type -> LBRACKET INT RBRACKET type
Rule 120   expression -> binary_expression
Rule 121   expression -> relational_expression
Rule 122   expression -> logical_expression
Rule 123   expression -> bitwise_expression
Rule 124   expression -> PLUS expression
Rule 125   expression -> MINUS expression
Rule 126   expression -> LNOT expression
Rule 127   expression -> INT
Rule 128   expression -> FLOAT64
Rule 129   expression -> TRUE
Rule 130   expression -> FALSE
Rule 131   expression -> IDENTIFIER
Rule 132   expression -> STRING
Rule 133   expression -> IDENTIFIER PLUSPLUS
Rule 134   expression -> IDENTIFIER MINUSMINUS
Rule 135   if_statement -> IF expression block
Rule 136   if_statement -> IF expression block ELSE block
Rule 137   if_statement -> IF expression block ELSE if_statement
Rule 138   if_statement -> IF if_assignment SEMICOLON expression block
Rule 139   if_statement -> IF if_assignment SEMICOLON expression block ELSE block
Rule 140   if_statement -> IF if_assignment SEMICOLON expression block ELSE if_statement
Rule 141   if_assignment -> simple_assignment
Rule 142   if_assignment -> short_assignment
Rule 143   if_assignment -> local_var_dec
Rule 144   map_type -> MAP LBRACKET primitive_type RBRACKET primitive_type
Rule 145   expression -> map_type LBRACE expression_map_list RBRACE
Rule 146   expression -> map_type LBRACE RBRACE
Rule 147   expression_map_list -> key_value
Rule 148   expression_map_list -> expression_map_list COMMA key_value
Rule 149   key_value -> expression COLON expression
Rule 150   field_list -> field_declaration
Rule 151   field_list -> field_list field_declaration
Rule 152   field_declaration -> IDENTIFIER type
Rule 153   field_declaration -> IDENTIFIER
Rule 154   method_declaration -> FUNC LPAREN receiver RPAREN IDENTIFIER LPAREN parameter_list RPAREN return_type block
Rule 155   receiver -> IDENTIFIER IDENTIFIER
Rule 156   receiver -> IDENTIFIER TIMES IDENTIFIER
Rule 157   receiver -> IDENTIFIER TIMES type
Rule 158   type_declaration -> TYPE IDENTIFIER type_alias
Rule 159   type_alias -> struct_type
Rule 160   type_alias -> type
Rule 161   type_alias -> IDENTIFIER
Rule 162   struct_type -> STRUCT LBRACE RBRACE
Rule 163   struct_type -> STRUCT LBRACE field_list RBRACE
Rule 164   keyed_element_list -> keyed_element
Rule 165   keyed_element_list -> keyed_element_list COMMA keyed_element
Rule 166   keyed_element -> IDENTIFIER COLON expression
Rule 167   keyed_element -> INT COLON expression
Rule 168   keyed_element -> expression
Rule 169   expression -> type_name LBRACE keyed_element_list RBRACE
Rule 170   expression -> type_name LBRACE RBRACE
Rule 171   type_name -> IDENTIFIER
Rule 172   type_name -> slice_type
Rule 173   type_name -> array_type
Rule 174   type_name -> map_type
Rule 175   binary_expression -> expression PLUS expression
Rule 176   binary_expression -> expression MINUS expression
Rule 177   binary_expression -> expression TIMES expression
Rule 178   binary_expression -> expression DIVIDE expression
Rule 179   binary_expression -> expression MODULE expression
Rule 180   grouped_expression -> LPAREN expression RPAREN
Rule 181   unary_expression -> PLUS expression
Rule 182   unary_expression -> MINUS expression
Rule 183   unary_expression -> LNOT expression
Rule 184   relational_expression -> expression EQ expression
Rule 185   relational_expression -> expression NEQ expression
Rule 186   relational_expression -> expression LT expression
Rule 187   relational_expression -> expression LE expression
Rule 188   relational_expression -> expression GT expression
Rule 189   relational_expression -> expression GE expression
Rule 190   logical_expression -> expression LAND expression
Rule 191   logical_expression -> expression LOR expression
Rule 192   bitwise_expression -> expression AND expression
Rule 193   bitwise_expression -> expression OR expression
Rule 194   bitwise_expression -> expression XOR expression
Rule 195   bitwise_expression -> expression AND_NOT expression
Rule 196   bitwise_expression -> expression LSHIFT expression
Rule 197   bitwise_expression -> expression RSHIFT expression
Rule 198   postfix_expression -> IDENTIFIER PLUSPLUS
Rule 199   postfix_expression -> IDENTIFIER MINUSMINUS
Rule 200   selector_expression -> expression DOT IDENTIFIER
Rule 201   func_call_expression -> IDENTIFIER LPAREN argument_list RPAREN
Rule 202   call_expression -> print_expression
Rule 203   call_expression -> input_expression
Rule 204   call_expression -> func_call_expression
Rule 205   slice_expression -> LBRACKET RBRACKET primitive_type LBRACE expression_list RBRACE
Rule 206   slice_expression -> LBRACKET RBRACKET primitive_type LBRACE RBRACE
Rule 207   enter_block -> <empty>
Rule 208   exit_block -> <empty>
Rule 209   case_expression_list -> expression
Rule 210   case_expression_list -> case_expression_list COMMA expression
Rule 211   case_clauses -> case_clause
Rule 212   case_clauses -> case_clauses case_clause
Rule 213   case_clause -> CASE case_expression_list COLON enter_block case_body exit_block
Rule 214   case_clause -> DEFAULT COLON enter_block case_body exit_block
Rule 215   case_body -> statement_list
Rule 216   case_body -> empty
Rule 217   switch_primary -> IDENTIFIER
Rule 218   switch_primary -> INT
Rule 219   switch_primary -> FLOAT64
Rule 220   switch_primary -> STRING
Rule 221   switch_primary -> TRUE
Rule 222   switch_primary -> FALSE
Rule 223   switch_init -> assignment SEMICOLON switch_expression
Rule 224   switch_expression -> switch_primary
Rule 225   switch_expression -> empty
Rule 226   switch_header -> switch_expression
Rule 227   switch_header -> switch_init
Rule 228   switch_statement -> SWITCH enter_block switch_header LBRACE case_clauses RBRACE exit_block
Rule 229   print_expression -> IDENTIFIER DOT IDENTIFIER LPAREN argument_list RPAREN
Rule 230   input_expression -> IDENTIFIER DOT IDENTIFIER LPAREN AND IDENTIFIER COMMA argument_list RPAREN
Rule 231   argument_list -> expression_list
Rule 232   argument_list -> empty

Terminals, with rules where they appear

AND                  : 192 230
AND_ASSIGN           : 46
AND_NOT              : 195
ASSIGN               : 31 32 33 34 36 37 38 39 51 109 111 112 113 114
BOOL_TYPE            : 118
BREAK                : 74
CASE                 : 213
COLON                : 149 166 167 213 214
COMMA                : 60 95 97 107 148 165 210 230
CONST                : 33 34 38 39 112 114
CONTINUE             : 75
DEFAULT              : 214
DIVIDE               : 178
DIV_ASSIGN           : 44
DOT                  : 200 229 230
ELLIPSIS             : 101
ELSE                 : 136 137 139 140
EQ                   : 184
FALSE                : 130 222
FLOAT64              : 128 219
FLOAT64_TYPE         : 116
FOR                  : 81 82 83
FUNC                 : 96 154
GE                   : 189
GT                   : 188
IDENTIFIER           : 2 30 31 32 33 34 35 36 37 38 39 40 51 62 96 100 101 109 110 111 112 113 114 131 133 134 152 153 154 155 155 156 156 157 158 161 166 171 198 199 200 201 217 229 229 230 230 230
IF                   : 135 136 137 138 139 140
IMPORT               : 6
INT                  : 119 127 167 218
INT_TYPE             : 115
LAND                 : 190
LBRACE               : 15 16 57 58 145 146 162 163 169 170 205 206 228
LBRACKET             : 56 119 144 205 206
LE                   : 187
LNOT                 : 126 183
LOR                  : 191
LPAREN               : 61 96 103 154 154 180 201 229 230
LSHIFT               : 196
LSHIFT_ASSIGN        : 49
LT                   : 186
MAP                  : 144
MINUS                : 125 176 182
MINUSMINUS           : 134 199
MINUS_ASSIGN         : 42
MODULE               : 179
MOD_ASSIGN           : 45
MULT_ASSIGN          : 43
NEQ                  : 185
OR                   : 193
OR_ASSIGN            : 47
PACKAGE              : 2
PLUS                 : 124 175 181
PLUSPLUS             : 133 198
PLUS_ASSIGN          : 41
RBRACE               : 15 16 57 58 145 146 162 163 169 170 205 206 228
RBRACKET             : 56 119 144 205 206
RETURN               : 105 106
RPAREN               : 61 96 103 154 154 180 201 229 230
RSHIFT               : 197
RSHIFT_ASSIGN        : 50
SEMICOLON            : 81 81 138 139 140 223
SHORT_ASSIGN         : 62 110
STRING               : 6 132 220
STRING_TYPE          : 117
STRUCT               : 162 163
SWITCH               : 228
TIMES                : 156 157 177
TRUE                 : 129 221
TYPE                 : 158
VAR                  : 30 31 32 35 36 37 111 113
XOR                  : 194
XOR_ASSIGN           : 48
error                : 

Nonterminals, with rules where they appear

argument_list        : 201 229 230
array_type           : 54 173
assignment           : 19 223
assignment_compound  : 20 67 91
binary_expression    : 120
bitwise_expression   : 123
block                : 81 82 83 96 135 136 136 137 138 139 139 140 154
break_statement      : 27 72
call_expression      : 29
case_body            : 213 214
case_clause          : 211 212
case_clauses         : 212 228
case_expression_list : 210 213
continue_statement   : 28 73
empty                : 5 87 89 93 99 104 216 225 232
enter_block          : 15 16 213 214 228
exit_block           : 15 16 213 214 228
expression           : 22 31 32 33 34 36 37 38 39 40 51 59 60 61 62 68 82 88 92 94 95 109 110 111 112 113 114 124 125 126 135 136 137 138 139 140 149 149 166 167 168 175 175 176 176 177 177 178 178 179 179 180 181 182 183 184 184 185 185 186 186 187 187 188 188 189 189 190 190 191 191 192 192 193 193 194 194 195 195 196 196 197 197 200 209 210
expression_list      : 57 60 205 231
expression_map_list  : 145 148
field_declaration    : 150 151
field_list           : 151 163
for_classic          : 78
for_cond             : 81
for_condition        : 79
for_infinite         : 80
for_init             : 81
for_post             : 81
for_statement        : 24 69
func_call_expression : 204
function_declaration : 12
global_const_dec     : 11
global_statement     : 8 9
global_statement_list : 1 9
global_var_dec       : 10
grouped_expression   : 
if_assignment        : 138 139 140
if_statement         : 25 70 137 140
import               : 1 4
input_expression     : 203
key_value            : 147 148
keyed_element        : 164 165
keyed_element_list   : 165 169
local_const_dec      : 64
local_statement      : 76 77
local_statement_list : 77
local_var_dec        : 63 86 143
logical_expression   : 122
map_type             : 55 145 146 174
method_declaration   : 13
operator_assign      : 40
package_declaration  : 1
parameter            : 97 98
parameter_list       : 96 97 154
postfix_expression   : 
primitive_type       : 52 56 101 144 144 205 206
print_expression     : 202
program              : 0
receiver             : 154
relational_expression : 121
return_list          : 95 106
return_statement     : 23
return_type          : 96 154
selector_expression  : 
short_assignment     : 65 85 142
simple_assignment    : 66 84 90 141
simple_import        : 3 4
slice_expression     : 
slice_type           : 53 57 58 172
statement            : 17 18
statement_list       : 16 18 215
struct_type          : 159
switch_expression    : 223 226
switch_header        : 228
switch_init          : 227
switch_primary       : 224
switch_statement     : 26 71
type                 : 30 31 33 35 36 38 100 102 107 108 111 112 119 152 157 160
type_alias           : 158
type_declaration     : 14
type_list            : 103 107
type_name            : 169 170
unary_expression     : 
variable_declaration : 21

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . package_declaration import global_statement_list
    (2) package_declaration -> . PACKAGE IDENTIFIER

    PACKAGE         shift and go to state 3

    program                        shift and go to state 1
    package_declaration            shift and go to state 2

state 1

    (0) S' -> program .



state 2

    (1) program -> package_declaration . import global_statement_list
    (3) import -> . simple_import
    (4) import -> . import simple_import
    (5) import -> . empty
    (6) simple_import -> . IMPORT STRING
    (7) empty -> .

  ! shift/reduce conflict for IMPORT resolved as shift
    IMPORT          shift and go to state 7
    VAR             reduce using rule 7 (empty -> .)
    CONST           reduce using rule 7 (empty -> .)
    FUNC            reduce using rule 7 (empty -> .)
    TYPE            reduce using rule 7 (empty -> .)

  ! IMPORT          [ reduce using rule 7 (empty -> .) ]

    import                         shift and go to state 4
    simple_import                  shift and go to state 5
    empty                          shift and go to state 6

state 3

    (2) package_declaration -> PACKAGE . IDENTIFIER

    IDENTIFIER      shift and go to state 8


state 4

    (1) program -> package_declaration import . global_statement_list
    (4) import -> import . simple_import
    (8) global_statement_list -> . global_statement
    (9) global_statement_list -> . global_statement_list global_statement
    (6) simple_import -> . IMPORT STRING
    (10) global_statement -> . global_var_dec
    (11) global_statement -> . global_const_dec
    (12) global_statement -> . function_declaration
    (13) global_statement -> . method_declaration
    (14) global_statement -> . type_declaration
    (30) global_var_dec -> . VAR IDENTIFIER type
    (31) global_var_dec -> . VAR IDENTIFIER type ASSIGN expression
    (32) global_var_dec -> . VAR IDENTIFIER ASSIGN expression
    (33) global_const_dec -> . CONST IDENTIFIER type ASSIGN expression
    (34) global_const_dec -> . CONST IDENTIFIER ASSIGN expression
    (96) function_declaration -> . FUNC IDENTIFIER LPAREN parameter_list RPAREN return_type block
    (154) method_declaration -> . FUNC LPAREN receiver RPAREN IDENTIFIER LPAREN parameter_list RPAREN return_type block
    (158) type_declaration -> . TYPE IDENTIFIER type_alias

    IMPORT          shift and go to state 7
    VAR             shift and go to state 17
    CONST           shift and go to state 18
    FUNC            shift and go to state 19
    TYPE            shift and go to state 20

    global_statement_list          shift and go to state 9
    simple_import                  shift and go to state 10
    global_statement               shift and go to state 11
    global_var_dec                 shift and go to state 12
    global_const_dec               shift and go to state 13
    function_declaration           shift and go to state 14
    method_declaration             shift and go to state 15
    type_declaration               shift and go to state 16

state 5

    (3) import -> simple_import .

    IMPORT          reduce using rule 3 (import -> simple_import .)
    VAR             reduce using rule 3 (import -> simple_import .)
    CONST           reduce using rule 3 (import -> simple_import .)
    FUNC            reduce using rule 3 (import -> simple_import .)
    TYPE            reduce using rule 3 (import -> simple_import .)


state 6

    (5) import -> empty .

    IMPORT          reduce using rule 5 (import -> empty .)
    VAR             reduce using rule 5 (import -> empty .)
    CONST           reduce using rule 5 (import -> empty .)
    FUNC            reduce using rule 5 (import -> empty .)
    TYPE            reduce using rule 5 (import -> empty .)


state 7

    (6) simple_import -> IMPORT . STRING

    STRING          shift and go to state 21


state 8

    (2) package_declaration -> PACKAGE IDENTIFIER .

    IMPORT          reduce using rule 2 (package_declaration -> PACKAGE IDENTIFIER .)
    VAR             reduce using rule 2 (package_declaration -> PACKAGE IDENTIFIER .)
    CONST           reduce using rule 2 (package_declaration -> PACKAGE IDENTIFIER .)
    FUNC            reduce using rule 2 (package_declaration -> PACKAGE IDENTIFIER .)
    TYPE            reduce using rule 2 (package_declaration -> PACKAGE IDENTIFIER .)


state 9

    (1) program -> package_declaration import global_statement_list .
    (9) global_statement_list -> global_statement_list . global_statement
    (10) global_statement -> . global_var_dec
    (11) global_statement -> . global_const_dec
    (12) global_statement -> . function_declaration
    (13) global_statement -> . method_declaration
    (14) global_statement -> . type_declaration
    (30) global_var_dec -> . VAR IDENTIFIER type
    (31) global_var_dec -> . VAR IDENTIFIER type ASSIGN expression
    (32) global_var_dec -> . VAR IDENTIFIER ASSIGN expression
    (33) global_const_dec -> . CONST IDENTIFIER type ASSIGN expression
    (34) global_const_dec -> . CONST IDENTIFIER ASSIGN expression
    (96) function_declaration -> . FUNC IDENTIFIER LPAREN parameter_list RPAREN return_type block
    (154) method_declaration -> . FUNC LPAREN receiver RPAREN IDENTIFIER LPAREN parameter_list RPAREN return_type block
    (158) type_declaration -> . TYPE IDENTIFIER type_alias

    $end            reduce using rule 1 (program -> package_declaration import global_statement_list .)
    VAR             shift and go to state 17
    CONST           shift and go to state 18
    FUNC            shift and go to state 19
    TYPE            shift and go to state 20

    global_statement               shift and go to state 22
    global_var_dec                 shift and go to state 12
    global_const_dec               shift and go to state 13
    function_declaration           shift and go to state 14
    method_declaration             shift and go to state 15
    type_declaration               shift and go to state 16

state 10

    (4) import -> import simple_import .

    IMPORT          reduce using rule 4 (import -> import simple_import .)
    VAR             reduce using rule 4 (import -> import simple_import .)
    CONST           reduce using rule 4 (import -> import simple_import .)
    FUNC            reduce using rule 4 (import -> import simple_import .)
    TYPE            reduce using rule 4 (import -> import simple_import .)


state 11

    (8) global_statement_list -> global_statement .

    VAR             reduce using rule 8 (global_statement_list -> global_statement .)
    CONST           reduce using rule 8 (global_statement_list -> global_statement .)
    FUNC            reduce using rule 8 (global_statement_list -> global_statement .)
    TYPE            reduce using rule 8 (global_statement_list -> global_statement .)
    $end            reduce using rule 8 (global_statement_list -> global_statement .)


state 12

    (10) global_statement -> global_var_dec .

    VAR             reduce using rule 10 (global_statement -> global_var_dec .)
    CONST           reduce using rule 10 (global_statement -> global_var_dec .)
    FUNC            reduce using rule 10 (global_statement -> global_var_dec .)
    TYPE            reduce using rule 10 (global_statement -> global_var_dec .)
    $end            reduce using rule 10 (global_statement -> global_var_dec .)


state 13

    (11) global_statement -> global_const_dec .

    VAR             reduce using rule 11 (global_statement -> global_const_dec .)
    CONST           reduce using rule 11 (global_statement -> global_const_dec .)
    FUNC            reduce using rule 11 (global_statement -> global_const_dec .)
    TYPE            reduce using rule 11 (global_statement -> global_const_dec .)
    $end            reduce using rule 11 (global_statement -> global_const_dec .)


state 14

    (12) global_statement -> function_declaration .

    VAR             reduce using rule 12 (global_statement -> function_declaration .)
    CONST           reduce using rule 12 (global_statement -> function_declaration .)
    FUNC            reduce using rule 12 (global_statement -> function_declaration .)
    TYPE            reduce using rule 12 (global_statement -> function_declaration .)
    $end            reduce using rule 12 (global_statement -> function_declaration .)


state 15

    (13) global_statement -> method_declaration .

    VAR             reduce using rule 13 (global_statement -> method_declaration .)
    CONST           reduce using rule 13 (global_statement -> method_declaration .)
    FUNC            reduce using rule 13 (global_statement -> method_declaration .)
    TYPE            reduce using rule 13 (global_statement -> method_declaration .)
    $end            reduce using rule 13 (global_statement -> method_declaration .)


state 16

    (14) global_statement -> type_declaration .

    VAR             reduce using rule 14 (global_statement -> type_declaration .)
    CONST           reduce using rule 14 (global_statement -> type_declaration .)
    FUNC            reduce using rule 14 (global_statement -> type_declaration .)
    TYPE            reduce using rule 14 (global_statement -> type_declaration .)
    $end            reduce using rule 14 (global_statement -> type_declaration .)


state 17

    (30) global_var_dec -> VAR . IDENTIFIER type
    (31) global_var_dec -> VAR . IDENTIFIER type ASSIGN expression
    (32) global_var_dec -> VAR . IDENTIFIER ASSIGN expression

    IDENTIFIER      shift and go to state 23


state 18

    (33) global_const_dec -> CONST . IDENTIFIER type ASSIGN expression
    (34) global_const_dec -> CONST . IDENTIFIER ASSIGN expression

    IDENTIFIER      shift and go to state 24


state 19

    (96) function_declaration -> FUNC . IDENTIFIER LPAREN parameter_list RPAREN return_type block
    (154) method_declaration -> FUNC . LPAREN receiver RPAREN IDENTIFIER LPAREN parameter_list RPAREN return_type block

    IDENTIFIER      shift and go to state 25
    LPAREN          shift and go to state 26


state 20

    (158) type_declaration -> TYPE . IDENTIFIER type_alias

    IDENTIFIER      shift and go to state 27


state 21

    (6) simple_import -> IMPORT STRING .

    IMPORT          reduce using rule 6 (simple_import -> IMPORT STRING .)
    VAR             reduce using rule 6 (simple_import -> IMPORT STRING .)
    CONST           reduce using rule 6 (simple_import -> IMPORT STRING .)
    FUNC            reduce using rule 6 (simple_import -> IMPORT STRING .)
    TYPE            reduce using rule 6 (simple_import -> IMPORT STRING .)


state 22

    (9) global_statement_list -> global_statement_list global_statement .

    VAR             reduce using rule 9 (global_statement_list -> global_statement_list global_statement .)
    CONST           reduce using rule 9 (global_statement_list -> global_statement_list global_statement .)
    FUNC            reduce using rule 9 (global_statement_list -> global_statement_list global_statement .)
    TYPE            reduce using rule 9 (global_statement_list -> global_statement_list global_statement .)
    $end            reduce using rule 9 (global_statement_list -> global_statement_list global_statement .)


state 23

    (30) global_var_dec -> VAR IDENTIFIER . type
    (31) global_var_dec -> VAR IDENTIFIER . type ASSIGN expression
    (32) global_var_dec -> VAR IDENTIFIER . ASSIGN expression
    (52) type -> . primitive_type
    (53) type -> . slice_type
    (54) type -> . array_type
    (55) type -> . map_type
    (115) primitive_type -> . INT_TYPE
    (116) primitive_type -> . FLOAT64_TYPE
    (117) primitive_type -> . STRING_TYPE
    (118) primitive_type -> . BOOL_TYPE
    (56) slice_type -> . LBRACKET RBRACKET primitive_type
    (119) array_type -> . LBRACKET INT RBRACKET type
    (144) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type

    ASSIGN          shift and go to state 29
    INT_TYPE        shift and go to state 34
    FLOAT64_TYPE    shift and go to state 35
    STRING_TYPE     shift and go to state 36
    BOOL_TYPE       shift and go to state 37
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    type                           shift and go to state 28
    primitive_type                 shift and go to state 30
    slice_type                     shift and go to state 31
    array_type                     shift and go to state 32
    map_type                       shift and go to state 33

state 24

    (33) global_const_dec -> CONST IDENTIFIER . type ASSIGN expression
    (34) global_const_dec -> CONST IDENTIFIER . ASSIGN expression
    (52) type -> . primitive_type
    (53) type -> . slice_type
    (54) type -> . array_type
    (55) type -> . map_type
    (115) primitive_type -> . INT_TYPE
    (116) primitive_type -> . FLOAT64_TYPE
    (117) primitive_type -> . STRING_TYPE
    (118) primitive_type -> . BOOL_TYPE
    (56) slice_type -> . LBRACKET RBRACKET primitive_type
    (119) array_type -> . LBRACKET INT RBRACKET type
    (144) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type

    ASSIGN          shift and go to state 41
    INT_TYPE        shift and go to state 34
    FLOAT64_TYPE    shift and go to state 35
    STRING_TYPE     shift and go to state 36
    BOOL_TYPE       shift and go to state 37
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    type                           shift and go to state 40
    primitive_type                 shift and go to state 30
    slice_type                     shift and go to state 31
    array_type                     shift and go to state 32
    map_type                       shift and go to state 33

state 25

    (96) function_declaration -> FUNC IDENTIFIER . LPAREN parameter_list RPAREN return_type block

    LPAREN          shift and go to state 42


state 26

    (154) method_declaration -> FUNC LPAREN . receiver RPAREN IDENTIFIER LPAREN parameter_list RPAREN return_type block
    (155) receiver -> . IDENTIFIER IDENTIFIER
    (156) receiver -> . IDENTIFIER TIMES IDENTIFIER
    (157) receiver -> . IDENTIFIER TIMES type

    IDENTIFIER      shift and go to state 44

    receiver                       shift and go to state 43

state 27

    (158) type_declaration -> TYPE IDENTIFIER . type_alias
    (159) type_alias -> . struct_type
    (160) type_alias -> . type
    (161) type_alias -> . IDENTIFIER
    (162) struct_type -> . STRUCT LBRACE RBRACE
    (163) struct_type -> . STRUCT LBRACE field_list RBRACE
    (52) type -> . primitive_type
    (53) type -> . slice_type
    (54) type -> . array_type
    (55) type -> . map_type
    (115) primitive_type -> . INT_TYPE
    (116) primitive_type -> . FLOAT64_TYPE
    (117) primitive_type -> . STRING_TYPE
    (118) primitive_type -> . BOOL_TYPE
    (56) slice_type -> . LBRACKET RBRACKET primitive_type
    (119) array_type -> . LBRACKET INT RBRACKET type
    (144) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type

    IDENTIFIER      shift and go to state 45
    STRUCT          shift and go to state 49
    INT_TYPE        shift and go to state 34
    FLOAT64_TYPE    shift and go to state 35
    STRING_TYPE     shift and go to state 36
    BOOL_TYPE       shift and go to state 37
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    type_alias                     shift and go to state 46
    struct_type                    shift and go to state 47
    type                           shift and go to state 48
    primitive_type                 shift and go to state 30
    slice_type                     shift and go to state 31
    array_type                     shift and go to state 32
    map_type                       shift and go to state 33

state 28

    (30) global_var_dec -> VAR IDENTIFIER type .
    (31) global_var_dec -> VAR IDENTIFIER type . ASSIGN expression

    VAR             reduce using rule 30 (global_var_dec -> VAR IDENTIFIER type .)
    CONST           reduce using rule 30 (global_var_dec -> VAR IDENTIFIER type .)
    FUNC            reduce using rule 30 (global_var_dec -> VAR IDENTIFIER type .)
    TYPE            reduce using rule 30 (global_var_dec -> VAR IDENTIFIER type .)
    $end            reduce using rule 30 (global_var_dec -> VAR IDENTIFIER type .)
    ASSIGN          shift and go to state 50


state 29

    (32) global_var_dec -> VAR IDENTIFIER ASSIGN . expression
    (57) expression -> . slice_type LBRACE expression_list RBRACE
    (58) expression -> . slice_type LBRACE RBRACE
    (61) expression -> . LPAREN expression RPAREN
    (120) expression -> . binary_expression
    (121) expression -> . relational_expression
    (122) expression -> . logical_expression
    (123) expression -> . bitwise_expression
    (124) expression -> . PLUS expression
    (125) expression -> . MINUS expression
    (126) expression -> . LNOT expression
    (127) expression -> . INT
    (128) expression -> . FLOAT64
    (129) expression -> . TRUE
    (130) expression -> . FALSE
    (131) expression -> . IDENTIFIER
    (132) expression -> . STRING
    (133) expression -> . IDENTIFIER PLUSPLUS
    (134) expression -> . IDENTIFIER MINUSMINUS
    (145) expression -> . map_type LBRACE expression_map_list RBRACE
    (146) expression -> . map_type LBRACE RBRACE
    (169) expression -> . type_name LBRACE keyed_element_list RBRACE
    (170) expression -> . type_name LBRACE RBRACE
    (56) slice_type -> . LBRACKET RBRACKET primitive_type
    (175) binary_expression -> . expression PLUS expression
    (176) binary_expression -> . expression MINUS expression
    (177) binary_expression -> . expression TIMES expression
    (178) binary_expression -> . expression DIVIDE expression
    (179) binary_expression -> . expression MODULE expression
    (184) relational_expression -> . expression EQ expression
    (185) relational_expression -> . expression NEQ expression
    (186) relational_expression -> . expression LT expression
    (187) relational_expression -> . expression LE expression
    (188) relational_expression -> . expression GT expression
    (189) relational_expression -> . expression GE expression
    (190) logical_expression -> . expression LAND expression
    (191) logical_expression -> . expression LOR expression
    (192) bitwise_expression -> . expression AND expression
    (193) bitwise_expression -> . expression OR expression
    (194) bitwise_expression -> . expression XOR expression
    (195) bitwise_expression -> . expression AND_NOT expression
    (196) bitwise_expression -> . expression LSHIFT expression
    (197) bitwise_expression -> . expression RSHIFT expression
    (144) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (171) type_name -> . IDENTIFIER
    (172) type_name -> . slice_type
    (173) type_name -> . array_type
    (174) type_name -> . map_type
    (119) array_type -> . LBRACKET INT RBRACKET type

    LPAREN          shift and go to state 54
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    LNOT            shift and go to state 61
    INT             shift and go to state 62
    FLOAT64         shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 66
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    expression                     shift and go to state 52
    slice_type                     shift and go to state 53
    binary_expression              shift and go to state 55
    relational_expression          shift and go to state 56
    logical_expression             shift and go to state 57
    bitwise_expression             shift and go to state 58
    map_type                       shift and go to state 67
    type_name                      shift and go to state 68
    array_type                     shift and go to state 69

state 30

    (52) type -> primitive_type .

    ASSIGN          reduce using rule 52 (type -> primitive_type .)
    VAR             reduce using rule 52 (type -> primitive_type .)
    CONST           reduce using rule 52 (type -> primitive_type .)
    FUNC            reduce using rule 52 (type -> primitive_type .)
    TYPE            reduce using rule 52 (type -> primitive_type .)
    $end            reduce using rule 52 (type -> primitive_type .)
    RPAREN          reduce using rule 52 (type -> primitive_type .)
    COMMA           reduce using rule 52 (type -> primitive_type .)
    LBRACE          reduce using rule 52 (type -> primitive_type .)
    RBRACE          reduce using rule 52 (type -> primitive_type .)
    IDENTIFIER      reduce using rule 52 (type -> primitive_type .)
    SEMICOLON       reduce using rule 52 (type -> primitive_type .)


state 31

    (53) type -> slice_type .

    ASSIGN          reduce using rule 53 (type -> slice_type .)
    VAR             reduce using rule 53 (type -> slice_type .)
    CONST           reduce using rule 53 (type -> slice_type .)
    FUNC            reduce using rule 53 (type -> slice_type .)
    TYPE            reduce using rule 53 (type -> slice_type .)
    $end            reduce using rule 53 (type -> slice_type .)
    RPAREN          reduce using rule 53 (type -> slice_type .)
    COMMA           reduce using rule 53 (type -> slice_type .)
    LBRACE          reduce using rule 53 (type -> slice_type .)
    RBRACE          reduce using rule 53 (type -> slice_type .)
    IDENTIFIER      reduce using rule 53 (type -> slice_type .)
    SEMICOLON       reduce using rule 53 (type -> slice_type .)


state 32

    (54) type -> array_type .

    ASSIGN          reduce using rule 54 (type -> array_type .)
    VAR             reduce using rule 54 (type -> array_type .)
    CONST           reduce using rule 54 (type -> array_type .)
    FUNC            reduce using rule 54 (type -> array_type .)
    TYPE            reduce using rule 54 (type -> array_type .)
    $end            reduce using rule 54 (type -> array_type .)
    RPAREN          reduce using rule 54 (type -> array_type .)
    COMMA           reduce using rule 54 (type -> array_type .)
    LBRACE          reduce using rule 54 (type -> array_type .)
    RBRACE          reduce using rule 54 (type -> array_type .)
    IDENTIFIER      reduce using rule 54 (type -> array_type .)
    SEMICOLON       reduce using rule 54 (type -> array_type .)


state 33

    (55) type -> map_type .

    ASSIGN          reduce using rule 55 (type -> map_type .)
    VAR             reduce using rule 55 (type -> map_type .)
    CONST           reduce using rule 55 (type -> map_type .)
    FUNC            reduce using rule 55 (type -> map_type .)
    TYPE            reduce using rule 55 (type -> map_type .)
    $end            reduce using rule 55 (type -> map_type .)
    RPAREN          reduce using rule 55 (type -> map_type .)
    COMMA           reduce using rule 55 (type -> map_type .)
    LBRACE          reduce using rule 55 (type -> map_type .)
    RBRACE          reduce using rule 55 (type -> map_type .)
    IDENTIFIER      reduce using rule 55 (type -> map_type .)
    SEMICOLON       reduce using rule 55 (type -> map_type .)


state 34

    (115) primitive_type -> INT_TYPE .

    ASSIGN          reduce using rule 115 (primitive_type -> INT_TYPE .)
    VAR             reduce using rule 115 (primitive_type -> INT_TYPE .)
    CONST           reduce using rule 115 (primitive_type -> INT_TYPE .)
    FUNC            reduce using rule 115 (primitive_type -> INT_TYPE .)
    TYPE            reduce using rule 115 (primitive_type -> INT_TYPE .)
    $end            reduce using rule 115 (primitive_type -> INT_TYPE .)
    LBRACE          reduce using rule 115 (primitive_type -> INT_TYPE .)
    RPAREN          reduce using rule 115 (primitive_type -> INT_TYPE .)
    COMMA           reduce using rule 115 (primitive_type -> INT_TYPE .)
    RBRACE          reduce using rule 115 (primitive_type -> INT_TYPE .)
    IDENTIFIER      reduce using rule 115 (primitive_type -> INT_TYPE .)
    SEMICOLON       reduce using rule 115 (primitive_type -> INT_TYPE .)
    RBRACKET        reduce using rule 115 (primitive_type -> INT_TYPE .)


state 35

    (116) primitive_type -> FLOAT64_TYPE .

    ASSIGN          reduce using rule 116 (primitive_type -> FLOAT64_TYPE .)
    VAR             reduce using rule 116 (primitive_type -> FLOAT64_TYPE .)
    CONST           reduce using rule 116 (primitive_type -> FLOAT64_TYPE .)
    FUNC            reduce using rule 116 (primitive_type -> FLOAT64_TYPE .)
    TYPE            reduce using rule 116 (primitive_type -> FLOAT64_TYPE .)
    $end            reduce using rule 116 (primitive_type -> FLOAT64_TYPE .)
    LBRACE          reduce using rule 116 (primitive_type -> FLOAT64_TYPE .)
    RPAREN          reduce using rule 116 (primitive_type -> FLOAT64_TYPE .)
    COMMA           reduce using rule 116 (primitive_type -> FLOAT64_TYPE .)
    RBRACE          reduce using rule 116 (primitive_type -> FLOAT64_TYPE .)
    IDENTIFIER      reduce using rule 116 (primitive_type -> FLOAT64_TYPE .)
    SEMICOLON       reduce using rule 116 (primitive_type -> FLOAT64_TYPE .)
    RBRACKET        reduce using rule 116 (primitive_type -> FLOAT64_TYPE .)


state 36

    (117) primitive_type -> STRING_TYPE .

    ASSIGN          reduce using rule 117 (primitive_type -> STRING_TYPE .)
    VAR             reduce using rule 117 (primitive_type -> STRING_TYPE .)
    CONST           reduce using rule 117 (primitive_type -> STRING_TYPE .)
    FUNC            reduce using rule 117 (primitive_type -> STRING_TYPE .)
    TYPE            reduce using rule 117 (primitive_type -> STRING_TYPE .)
    $end            reduce using rule 117 (primitive_type -> STRING_TYPE .)
    LBRACE          reduce using rule 117 (primitive_type -> STRING_TYPE .)
    RPAREN          reduce using rule 117 (primitive_type -> STRING_TYPE .)
    COMMA           reduce using rule 117 (primitive_type -> STRING_TYPE .)
    RBRACE          reduce using rule 117 (primitive_type -> STRING_TYPE .)
    IDENTIFIER      reduce using rule 117 (primitive_type -> STRING_TYPE .)
    SEMICOLON       reduce using rule 117 (primitive_type -> STRING_TYPE .)
    RBRACKET        reduce using rule 117 (primitive_type -> STRING_TYPE .)


state 37

    (118) primitive_type -> BOOL_TYPE .

    ASSIGN          reduce using rule 118 (primitive_type -> BOOL_TYPE .)
    VAR             reduce using rule 118 (primitive_type -> BOOL_TYPE .)
    CONST           reduce using rule 118 (primitive_type -> BOOL_TYPE .)
    FUNC            reduce using rule 118 (primitive_type -> BOOL_TYPE .)
    TYPE            reduce using rule 118 (primitive_type -> BOOL_TYPE .)
    $end            reduce using rule 118 (primitive_type -> BOOL_TYPE .)
    LBRACE          reduce using rule 118 (primitive_type -> BOOL_TYPE .)
    RPAREN          reduce using rule 118 (primitive_type -> BOOL_TYPE .)
    COMMA           reduce using rule 118 (primitive_type -> BOOL_TYPE .)
    RBRACE          reduce using rule 118 (primitive_type -> BOOL_TYPE .)
    IDENTIFIER      reduce using rule 118 (primitive_type -> BOOL_TYPE .)
    SEMICOLON       reduce using rule 118 (primitive_type -> BOOL_TYPE .)
    RBRACKET        reduce using rule 118 (primitive_type -> BOOL_TYPE .)


state 38

    (56) slice_type -> LBRACKET . RBRACKET primitive_type
    (119) array_type -> LBRACKET . INT RBRACKET type

    RBRACKET        shift and go to state 70
    INT             shift and go to state 71


state 39

    (144) map_type -> MAP . LBRACKET primitive_type RBRACKET primitive_type

    LBRACKET        shift and go to state 72


state 40

    (33) global_const_dec -> CONST IDENTIFIER type . ASSIGN expression

    ASSIGN          shift and go to state 73


state 41

    (34) global_const_dec -> CONST IDENTIFIER ASSIGN . expression
    (57) expression -> . slice_type LBRACE expression_list RBRACE
    (58) expression -> . slice_type LBRACE RBRACE
    (61) expression -> . LPAREN expression RPAREN
    (120) expression -> . binary_expression
    (121) expression -> . relational_expression
    (122) expression -> . logical_expression
    (123) expression -> . bitwise_expression
    (124) expression -> . PLUS expression
    (125) expression -> . MINUS expression
    (126) expression -> . LNOT expression
    (127) expression -> . INT
    (128) expression -> . FLOAT64
    (129) expression -> . TRUE
    (130) expression -> . FALSE
    (131) expression -> . IDENTIFIER
    (132) expression -> . STRING
    (133) expression -> . IDENTIFIER PLUSPLUS
    (134) expression -> . IDENTIFIER MINUSMINUS
    (145) expression -> . map_type LBRACE expression_map_list RBRACE
    (146) expression -> . map_type LBRACE RBRACE
    (169) expression -> . type_name LBRACE keyed_element_list RBRACE
    (170) expression -> . type_name LBRACE RBRACE
    (56) slice_type -> . LBRACKET RBRACKET primitive_type
    (175) binary_expression -> . expression PLUS expression
    (176) binary_expression -> . expression MINUS expression
    (177) binary_expression -> . expression TIMES expression
    (178) binary_expression -> . expression DIVIDE expression
    (179) binary_expression -> . expression MODULE expression
    (184) relational_expression -> . expression EQ expression
    (185) relational_expression -> . expression NEQ expression
    (186) relational_expression -> . expression LT expression
    (187) relational_expression -> . expression LE expression
    (188) relational_expression -> . expression GT expression
    (189) relational_expression -> . expression GE expression
    (190) logical_expression -> . expression LAND expression
    (191) logical_expression -> . expression LOR expression
    (192) bitwise_expression -> . expression AND expression
    (193) bitwise_expression -> . expression OR expression
    (194) bitwise_expression -> . expression XOR expression
    (195) bitwise_expression -> . expression AND_NOT expression
    (196) bitwise_expression -> . expression LSHIFT expression
    (197) bitwise_expression -> . expression RSHIFT expression
    (144) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (171) type_name -> . IDENTIFIER
    (172) type_name -> . slice_type
    (173) type_name -> . array_type
    (174) type_name -> . map_type
    (119) array_type -> . LBRACKET INT RBRACKET type

    LPAREN          shift and go to state 54
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    LNOT            shift and go to state 61
    INT             shift and go to state 62
    FLOAT64         shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 66
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    expression                     shift and go to state 74
    slice_type                     shift and go to state 53
    binary_expression              shift and go to state 55
    relational_expression          shift and go to state 56
    logical_expression             shift and go to state 57
    bitwise_expression             shift and go to state 58
    map_type                       shift and go to state 67
    type_name                      shift and go to state 68
    array_type                     shift and go to state 69

state 42

    (96) function_declaration -> FUNC IDENTIFIER LPAREN . parameter_list RPAREN return_type block
    (97) parameter_list -> . parameter_list COMMA parameter
    (98) parameter_list -> . parameter
    (99) parameter_list -> . empty
    (100) parameter -> . IDENTIFIER type
    (101) parameter -> . IDENTIFIER ELLIPSIS primitive_type
    (7) empty -> .

    IDENTIFIER      shift and go to state 75
    RPAREN          reduce using rule 7 (empty -> .)
    COMMA           reduce using rule 7 (empty -> .)

    parameter_list                 shift and go to state 76
    parameter                      shift and go to state 77
    empty                          shift and go to state 78

state 43

    (154) method_declaration -> FUNC LPAREN receiver . RPAREN IDENTIFIER LPAREN parameter_list RPAREN return_type block

    RPAREN          shift and go to state 79


state 44

    (155) receiver -> IDENTIFIER . IDENTIFIER
    (156) receiver -> IDENTIFIER . TIMES IDENTIFIER
    (157) receiver -> IDENTIFIER . TIMES type

    IDENTIFIER      shift and go to state 80
    TIMES           shift and go to state 81


state 45

    (161) type_alias -> IDENTIFIER .

    VAR             reduce using rule 161 (type_alias -> IDENTIFIER .)
    CONST           reduce using rule 161 (type_alias -> IDENTIFIER .)
    FUNC            reduce using rule 161 (type_alias -> IDENTIFIER .)
    TYPE            reduce using rule 161 (type_alias -> IDENTIFIER .)
    $end            reduce using rule 161 (type_alias -> IDENTIFIER .)


state 46

    (158) type_declaration -> TYPE IDENTIFIER type_alias .

    VAR             reduce using rule 158 (type_declaration -> TYPE IDENTIFIER type_alias .)
    CONST           reduce using rule 158 (type_declaration -> TYPE IDENTIFIER type_alias .)
    FUNC            reduce using rule 158 (type_declaration -> TYPE IDENTIFIER type_alias .)
    TYPE            reduce using rule 158 (type_declaration -> TYPE IDENTIFIER type_alias .)
    $end            reduce using rule 158 (type_declaration -> TYPE IDENTIFIER type_alias .)


state 47

    (159) type_alias -> struct_type .

    VAR             reduce using rule 159 (type_alias -> struct_type .)
    CONST           reduce using rule 159 (type_alias -> struct_type .)
    FUNC            reduce using rule 159 (type_alias -> struct_type .)
    TYPE            reduce using rule 159 (type_alias -> struct_type .)
    $end            reduce using rule 159 (type_alias -> struct_type .)


state 48

    (160) type_alias -> type .

    VAR             reduce using rule 160 (type_alias -> type .)
    CONST           reduce using rule 160 (type_alias -> type .)
    FUNC            reduce using rule 160 (type_alias -> type .)
    TYPE            reduce using rule 160 (type_alias -> type .)
    $end            reduce using rule 160 (type_alias -> type .)


state 49

    (162) struct_type -> STRUCT . LBRACE RBRACE
    (163) struct_type -> STRUCT . LBRACE field_list RBRACE

    LBRACE          shift and go to state 82


state 50

    (31) global_var_dec -> VAR IDENTIFIER type ASSIGN . expression
    (57) expression -> . slice_type LBRACE expression_list RBRACE
    (58) expression -> . slice_type LBRACE RBRACE
    (61) expression -> . LPAREN expression RPAREN
    (120) expression -> . binary_expression
    (121) expression -> . relational_expression
    (122) expression -> . logical_expression
    (123) expression -> . bitwise_expression
    (124) expression -> . PLUS expression
    (125) expression -> . MINUS expression
    (126) expression -> . LNOT expression
    (127) expression -> . INT
    (128) expression -> . FLOAT64
    (129) expression -> . TRUE
    (130) expression -> . FALSE
    (131) expression -> . IDENTIFIER
    (132) expression -> . STRING
    (133) expression -> . IDENTIFIER PLUSPLUS
    (134) expression -> . IDENTIFIER MINUSMINUS
    (145) expression -> . map_type LBRACE expression_map_list RBRACE
    (146) expression -> . map_type LBRACE RBRACE
    (169) expression -> . type_name LBRACE keyed_element_list RBRACE
    (170) expression -> . type_name LBRACE RBRACE
    (56) slice_type -> . LBRACKET RBRACKET primitive_type
    (175) binary_expression -> . expression PLUS expression
    (176) binary_expression -> . expression MINUS expression
    (177) binary_expression -> . expression TIMES expression
    (178) binary_expression -> . expression DIVIDE expression
    (179) binary_expression -> . expression MODULE expression
    (184) relational_expression -> . expression EQ expression
    (185) relational_expression -> . expression NEQ expression
    (186) relational_expression -> . expression LT expression
    (187) relational_expression -> . expression LE expression
    (188) relational_expression -> . expression GT expression
    (189) relational_expression -> . expression GE expression
    (190) logical_expression -> . expression LAND expression
    (191) logical_expression -> . expression LOR expression
    (192) bitwise_expression -> . expression AND expression
    (193) bitwise_expression -> . expression OR expression
    (194) bitwise_expression -> . expression XOR expression
    (195) bitwise_expression -> . expression AND_NOT expression
    (196) bitwise_expression -> . expression LSHIFT expression
    (197) bitwise_expression -> . expression RSHIFT expression
    (144) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (171) type_name -> . IDENTIFIER
    (172) type_name -> . slice_type
    (173) type_name -> . array_type
    (174) type_name -> . map_type
    (119) array_type -> . LBRACKET INT RBRACKET type

    LPAREN          shift and go to state 54
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    LNOT            shift and go to state 61
    INT             shift and go to state 62
    FLOAT64         shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 66
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    expression                     shift and go to state 83
    slice_type                     shift and go to state 53
    binary_expression              shift and go to state 55
    relational_expression          shift and go to state 56
    logical_expression             shift and go to state 57
    bitwise_expression             shift and go to state 58
    map_type                       shift and go to state 67
    type_name                      shift and go to state 68
    array_type                     shift and go to state 69

state 51

    (131) expression -> IDENTIFIER .
    (133) expression -> IDENTIFIER . PLUSPLUS
    (134) expression -> IDENTIFIER . MINUSMINUS
    (171) type_name -> IDENTIFIER .

  ! reduce/reduce conflict for LBRACE resolved using rule 131 (expression -> IDENTIFIER .)
    PLUS            reduce using rule 131 (expression -> IDENTIFIER .)
    MINUS           reduce using rule 131 (expression -> IDENTIFIER .)
    TIMES           reduce using rule 131 (expression -> IDENTIFIER .)
    DIVIDE          reduce using rule 131 (expression -> IDENTIFIER .)
    MODULE          reduce using rule 131 (expression -> IDENTIFIER .)
    EQ              reduce using rule 131 (expression -> IDENTIFIER .)
    NEQ             reduce using rule 131 (expression -> IDENTIFIER .)
    LT              reduce using rule 131 (expression -> IDENTIFIER .)
    LE              reduce using rule 131 (expression -> IDENTIFIER .)
    GT              reduce using rule 131 (expression -> IDENTIFIER .)
    GE              reduce using rule 131 (expression -> IDENTIFIER .)
    LAND            reduce using rule 131 (expression -> IDENTIFIER .)
    LOR             reduce using rule 131 (expression -> IDENTIFIER .)
    AND             reduce using rule 131 (expression -> IDENTIFIER .)
    OR              reduce using rule 131 (expression -> IDENTIFIER .)
    XOR             reduce using rule 131 (expression -> IDENTIFIER .)
    AND_NOT         reduce using rule 131 (expression -> IDENTIFIER .)
    LSHIFT          reduce using rule 131 (expression -> IDENTIFIER .)
    RSHIFT          reduce using rule 131 (expression -> IDENTIFIER .)
    VAR             reduce using rule 131 (expression -> IDENTIFIER .)
    CONST           reduce using rule 131 (expression -> IDENTIFIER .)
    FUNC            reduce using rule 131 (expression -> IDENTIFIER .)
    TYPE            reduce using rule 131 (expression -> IDENTIFIER .)
    $end            reduce using rule 131 (expression -> IDENTIFIER .)
    RPAREN          reduce using rule 131 (expression -> IDENTIFIER .)
    RBRACE          reduce using rule 131 (expression -> IDENTIFIER .)
    COMMA           reduce using rule 131 (expression -> IDENTIFIER .)
    COLON           reduce using rule 131 (expression -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 131 (expression -> IDENTIFIER .)
    LPAREN          reduce using rule 131 (expression -> IDENTIFIER .)
    LNOT            reduce using rule 131 (expression -> IDENTIFIER .)
    INT             reduce using rule 131 (expression -> IDENTIFIER .)
    FLOAT64         reduce using rule 131 (expression -> IDENTIFIER .)
    TRUE            reduce using rule 131 (expression -> IDENTIFIER .)
    FALSE           reduce using rule 131 (expression -> IDENTIFIER .)
    STRING          reduce using rule 131 (expression -> IDENTIFIER .)
    RETURN          reduce using rule 131 (expression -> IDENTIFIER .)
    IF              reduce using rule 131 (expression -> IDENTIFIER .)
    SWITCH          reduce using rule 131 (expression -> IDENTIFIER .)
    BREAK           reduce using rule 131 (expression -> IDENTIFIER .)
    CONTINUE        reduce using rule 131 (expression -> IDENTIFIER .)
    LBRACKET        reduce using rule 131 (expression -> IDENTIFIER .)
    MAP             reduce using rule 131 (expression -> IDENTIFIER .)
    FOR             reduce using rule 131 (expression -> IDENTIFIER .)
    CASE            reduce using rule 131 (expression -> IDENTIFIER .)
    DEFAULT         reduce using rule 131 (expression -> IDENTIFIER .)
    LBRACE          reduce using rule 131 (expression -> IDENTIFIER .)
    SEMICOLON       reduce using rule 131 (expression -> IDENTIFIER .)
    PLUSPLUS        shift and go to state 84
    MINUSMINUS      shift and go to state 85

  ! LBRACE          [ reduce using rule 171 (type_name -> IDENTIFIER .) ]


state 52

    (32) global_var_dec -> VAR IDENTIFIER ASSIGN expression .
    (175) binary_expression -> expression . PLUS expression
    (176) binary_expression -> expression . MINUS expression
    (177) binary_expression -> expression . TIMES expression
    (178) binary_expression -> expression . DIVIDE expression
    (179) binary_expression -> expression . MODULE expression
    (184) relational_expression -> expression . EQ expression
    (185) relational_expression -> expression . NEQ expression
    (186) relational_expression -> expression . LT expression
    (187) relational_expression -> expression . LE expression
    (188) relational_expression -> expression . GT expression
    (189) relational_expression -> expression . GE expression
    (190) logical_expression -> expression . LAND expression
    (191) logical_expression -> expression . LOR expression
    (192) bitwise_expression -> expression . AND expression
    (193) bitwise_expression -> expression . OR expression
    (194) bitwise_expression -> expression . XOR expression
    (195) bitwise_expression -> expression . AND_NOT expression
    (196) bitwise_expression -> expression . LSHIFT expression
    (197) bitwise_expression -> expression . RSHIFT expression

    VAR             reduce using rule 32 (global_var_dec -> VAR IDENTIFIER ASSIGN expression .)
    CONST           reduce using rule 32 (global_var_dec -> VAR IDENTIFIER ASSIGN expression .)
    FUNC            reduce using rule 32 (global_var_dec -> VAR IDENTIFIER ASSIGN expression .)
    TYPE            reduce using rule 32 (global_var_dec -> VAR IDENTIFIER ASSIGN expression .)
    $end            reduce using rule 32 (global_var_dec -> VAR IDENTIFIER ASSIGN expression .)
    PLUS            shift and go to state 86
    MINUS           shift and go to state 87
    TIMES           shift and go to state 88
    DIVIDE          shift and go to state 89
    MODULE          shift and go to state 90
    EQ              shift and go to state 91
    NEQ             shift and go to state 92
    LT              shift and go to state 93
    LE              shift and go to state 94
    GT              shift and go to state 95
    GE              shift and go to state 96
    LAND            shift and go to state 97
    LOR             shift and go to state 98
    AND             shift and go to state 99
    OR              shift and go to state 100
    XOR             shift and go to state 101
    AND_NOT         shift and go to state 102
    LSHIFT          shift and go to state 103
    RSHIFT          shift and go to state 104


state 53

    (57) expression -> slice_type . LBRACE expression_list RBRACE
    (58) expression -> slice_type . LBRACE RBRACE
    (172) type_name -> slice_type .

  ! shift/reduce conflict for LBRACE resolved as shift
    LBRACE          shift and go to state 105

  ! LBRACE          [ reduce using rule 172 (type_name -> slice_type .) ]


state 54

    (61) expression -> LPAREN . expression RPAREN
    (57) expression -> . slice_type LBRACE expression_list RBRACE
    (58) expression -> . slice_type LBRACE RBRACE
    (61) expression -> . LPAREN expression RPAREN
    (120) expression -> . binary_expression
    (121) expression -> . relational_expression
    (122) expression -> . logical_expression
    (123) expression -> . bitwise_expression
    (124) expression -> . PLUS expression
    (125) expression -> . MINUS expression
    (126) expression -> . LNOT expression
    (127) expression -> . INT
    (128) expression -> . FLOAT64
    (129) expression -> . TRUE
    (130) expression -> . FALSE
    (131) expression -> . IDENTIFIER
    (132) expression -> . STRING
    (133) expression -> . IDENTIFIER PLUSPLUS
    (134) expression -> . IDENTIFIER MINUSMINUS
    (145) expression -> . map_type LBRACE expression_map_list RBRACE
    (146) expression -> . map_type LBRACE RBRACE
    (169) expression -> . type_name LBRACE keyed_element_list RBRACE
    (170) expression -> . type_name LBRACE RBRACE
    (56) slice_type -> . LBRACKET RBRACKET primitive_type
    (175) binary_expression -> . expression PLUS expression
    (176) binary_expression -> . expression MINUS expression
    (177) binary_expression -> . expression TIMES expression
    (178) binary_expression -> . expression DIVIDE expression
    (179) binary_expression -> . expression MODULE expression
    (184) relational_expression -> . expression EQ expression
    (185) relational_expression -> . expression NEQ expression
    (186) relational_expression -> . expression LT expression
    (187) relational_expression -> . expression LE expression
    (188) relational_expression -> . expression GT expression
    (189) relational_expression -> . expression GE expression
    (190) logical_expression -> . expression LAND expression
    (191) logical_expression -> . expression LOR expression
    (192) bitwise_expression -> . expression AND expression
    (193) bitwise_expression -> . expression OR expression
    (194) bitwise_expression -> . expression XOR expression
    (195) bitwise_expression -> . expression AND_NOT expression
    (196) bitwise_expression -> . expression LSHIFT expression
    (197) bitwise_expression -> . expression RSHIFT expression
    (144) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (171) type_name -> . IDENTIFIER
    (172) type_name -> . slice_type
    (173) type_name -> . array_type
    (174) type_name -> . map_type
    (119) array_type -> . LBRACKET INT RBRACKET type

    LPAREN          shift and go to state 54
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    LNOT            shift and go to state 61
    INT             shift and go to state 62
    FLOAT64         shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 66
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    expression                     shift and go to state 106
    slice_type                     shift and go to state 53
    binary_expression              shift and go to state 55
    relational_expression          shift and go to state 56
    logical_expression             shift and go to state 57
    bitwise_expression             shift and go to state 58
    map_type                       shift and go to state 67
    type_name                      shift and go to state 68
    array_type                     shift and go to state 69

state 55

    (120) expression -> binary_expression .

    PLUS            reduce using rule 120 (expression -> binary_expression .)
    MINUS           reduce using rule 120 (expression -> binary_expression .)
    TIMES           reduce using rule 120 (expression -> binary_expression .)
    DIVIDE          reduce using rule 120 (expression -> binary_expression .)
    MODULE          reduce using rule 120 (expression -> binary_expression .)
    EQ              reduce using rule 120 (expression -> binary_expression .)
    NEQ             reduce using rule 120 (expression -> binary_expression .)
    LT              reduce using rule 120 (expression -> binary_expression .)
    LE              reduce using rule 120 (expression -> binary_expression .)
    GT              reduce using rule 120 (expression -> binary_expression .)
    GE              reduce using rule 120 (expression -> binary_expression .)
    LAND            reduce using rule 120 (expression -> binary_expression .)
    LOR             reduce using rule 120 (expression -> binary_expression .)
    AND             reduce using rule 120 (expression -> binary_expression .)
    OR              reduce using rule 120 (expression -> binary_expression .)
    XOR             reduce using rule 120 (expression -> binary_expression .)
    AND_NOT         reduce using rule 120 (expression -> binary_expression .)
    LSHIFT          reduce using rule 120 (expression -> binary_expression .)
    RSHIFT          reduce using rule 120 (expression -> binary_expression .)
    VAR             reduce using rule 120 (expression -> binary_expression .)
    CONST           reduce using rule 120 (expression -> binary_expression .)
    FUNC            reduce using rule 120 (expression -> binary_expression .)
    TYPE            reduce using rule 120 (expression -> binary_expression .)
    $end            reduce using rule 120 (expression -> binary_expression .)
    RPAREN          reduce using rule 120 (expression -> binary_expression .)
    RBRACE          reduce using rule 120 (expression -> binary_expression .)
    COMMA           reduce using rule 120 (expression -> binary_expression .)
    COLON           reduce using rule 120 (expression -> binary_expression .)
    IDENTIFIER      reduce using rule 120 (expression -> binary_expression .)
    LPAREN          reduce using rule 120 (expression -> binary_expression .)
    LNOT            reduce using rule 120 (expression -> binary_expression .)
    INT             reduce using rule 120 (expression -> binary_expression .)
    FLOAT64         reduce using rule 120 (expression -> binary_expression .)
    TRUE            reduce using rule 120 (expression -> binary_expression .)
    FALSE           reduce using rule 120 (expression -> binary_expression .)
    STRING          reduce using rule 120 (expression -> binary_expression .)
    RETURN          reduce using rule 120 (expression -> binary_expression .)
    IF              reduce using rule 120 (expression -> binary_expression .)
    SWITCH          reduce using rule 120 (expression -> binary_expression .)
    BREAK           reduce using rule 120 (expression -> binary_expression .)
    CONTINUE        reduce using rule 120 (expression -> binary_expression .)
    LBRACKET        reduce using rule 120 (expression -> binary_expression .)
    MAP             reduce using rule 120 (expression -> binary_expression .)
    FOR             reduce using rule 120 (expression -> binary_expression .)
    CASE            reduce using rule 120 (expression -> binary_expression .)
    DEFAULT         reduce using rule 120 (expression -> binary_expression .)
    LBRACE          reduce using rule 120 (expression -> binary_expression .)
    SEMICOLON       reduce using rule 120 (expression -> binary_expression .)


state 56

    (121) expression -> relational_expression .

    PLUS            reduce using rule 121 (expression -> relational_expression .)
    MINUS           reduce using rule 121 (expression -> relational_expression .)
    TIMES           reduce using rule 121 (expression -> relational_expression .)
    DIVIDE          reduce using rule 121 (expression -> relational_expression .)
    MODULE          reduce using rule 121 (expression -> relational_expression .)
    EQ              reduce using rule 121 (expression -> relational_expression .)
    NEQ             reduce using rule 121 (expression -> relational_expression .)
    LT              reduce using rule 121 (expression -> relational_expression .)
    LE              reduce using rule 121 (expression -> relational_expression .)
    GT              reduce using rule 121 (expression -> relational_expression .)
    GE              reduce using rule 121 (expression -> relational_expression .)
    LAND            reduce using rule 121 (expression -> relational_expression .)
    LOR             reduce using rule 121 (expression -> relational_expression .)
    AND             reduce using rule 121 (expression -> relational_expression .)
    OR              reduce using rule 121 (expression -> relational_expression .)
    XOR             reduce using rule 121 (expression -> relational_expression .)
    AND_NOT         reduce using rule 121 (expression -> relational_expression .)
    LSHIFT          reduce using rule 121 (expression -> relational_expression .)
    RSHIFT          reduce using rule 121 (expression -> relational_expression .)
    VAR             reduce using rule 121 (expression -> relational_expression .)
    CONST           reduce using rule 121 (expression -> relational_expression .)
    FUNC            reduce using rule 121 (expression -> relational_expression .)
    TYPE            reduce using rule 121 (expression -> relational_expression .)
    $end            reduce using rule 121 (expression -> relational_expression .)
    RPAREN          reduce using rule 121 (expression -> relational_expression .)
    RBRACE          reduce using rule 121 (expression -> relational_expression .)
    COMMA           reduce using rule 121 (expression -> relational_expression .)
    COLON           reduce using rule 121 (expression -> relational_expression .)
    IDENTIFIER      reduce using rule 121 (expression -> relational_expression .)
    LPAREN          reduce using rule 121 (expression -> relational_expression .)
    LNOT            reduce using rule 121 (expression -> relational_expression .)
    INT             reduce using rule 121 (expression -> relational_expression .)
    FLOAT64         reduce using rule 121 (expression -> relational_expression .)
    TRUE            reduce using rule 121 (expression -> relational_expression .)
    FALSE           reduce using rule 121 (expression -> relational_expression .)
    STRING          reduce using rule 121 (expression -> relational_expression .)
    RETURN          reduce using rule 121 (expression -> relational_expression .)
    IF              reduce using rule 121 (expression -> relational_expression .)
    SWITCH          reduce using rule 121 (expression -> relational_expression .)
    BREAK           reduce using rule 121 (expression -> relational_expression .)
    CONTINUE        reduce using rule 121 (expression -> relational_expression .)
    LBRACKET        reduce using rule 121 (expression -> relational_expression .)
    MAP             reduce using rule 121 (expression -> relational_expression .)
    FOR             reduce using rule 121 (expression -> relational_expression .)
    CASE            reduce using rule 121 (expression -> relational_expression .)
    DEFAULT         reduce using rule 121 (expression -> relational_expression .)
    LBRACE          reduce using rule 121 (expression -> relational_expression .)
    SEMICOLON       reduce using rule 121 (expression -> relational_expression .)


state 57

    (122) expression -> logical_expression .

    PLUS            reduce using rule 122 (expression -> logical_expression .)
    MINUS           reduce using rule 122 (expression -> logical_expression .)
    TIMES           reduce using rule 122 (expression -> logical_expression .)
    DIVIDE          reduce using rule 122 (expression -> logical_expression .)
    MODULE          reduce using rule 122 (expression -> logical_expression .)
    EQ              reduce using rule 122 (expression -> logical_expression .)
    NEQ             reduce using rule 122 (expression -> logical_expression .)
    LT              reduce using rule 122 (expression -> logical_expression .)
    LE              reduce using rule 122 (expression -> logical_expression .)
    GT              reduce using rule 122 (expression -> logical_expression .)
    GE              reduce using rule 122 (expression -> logical_expression .)
    LAND            reduce using rule 122 (expression -> logical_expression .)
    LOR             reduce using rule 122 (expression -> logical_expression .)
    AND             reduce using rule 122 (expression -> logical_expression .)
    OR              reduce using rule 122 (expression -> logical_expression .)
    XOR             reduce using rule 122 (expression -> logical_expression .)
    AND_NOT         reduce using rule 122 (expression -> logical_expression .)
    LSHIFT          reduce using rule 122 (expression -> logical_expression .)
    RSHIFT          reduce using rule 122 (expression -> logical_expression .)
    VAR             reduce using rule 122 (expression -> logical_expression .)
    CONST           reduce using rule 122 (expression -> logical_expression .)
    FUNC            reduce using rule 122 (expression -> logical_expression .)
    TYPE            reduce using rule 122 (expression -> logical_expression .)
    $end            reduce using rule 122 (expression -> logical_expression .)
    RPAREN          reduce using rule 122 (expression -> logical_expression .)
    RBRACE          reduce using rule 122 (expression -> logical_expression .)
    COMMA           reduce using rule 122 (expression -> logical_expression .)
    COLON           reduce using rule 122 (expression -> logical_expression .)
    IDENTIFIER      reduce using rule 122 (expression -> logical_expression .)
    LPAREN          reduce using rule 122 (expression -> logical_expression .)
    LNOT            reduce using rule 122 (expression -> logical_expression .)
    INT             reduce using rule 122 (expression -> logical_expression .)
    FLOAT64         reduce using rule 122 (expression -> logical_expression .)
    TRUE            reduce using rule 122 (expression -> logical_expression .)
    FALSE           reduce using rule 122 (expression -> logical_expression .)
    STRING          reduce using rule 122 (expression -> logical_expression .)
    RETURN          reduce using rule 122 (expression -> logical_expression .)
    IF              reduce using rule 122 (expression -> logical_expression .)
    SWITCH          reduce using rule 122 (expression -> logical_expression .)
    BREAK           reduce using rule 122 (expression -> logical_expression .)
    CONTINUE        reduce using rule 122 (expression -> logical_expression .)
    LBRACKET        reduce using rule 122 (expression -> logical_expression .)
    MAP             reduce using rule 122 (expression -> logical_expression .)
    FOR             reduce using rule 122 (expression -> logical_expression .)
    CASE            reduce using rule 122 (expression -> logical_expression .)
    DEFAULT         reduce using rule 122 (expression -> logical_expression .)
    LBRACE          reduce using rule 122 (expression -> logical_expression .)
    SEMICOLON       reduce using rule 122 (expression -> logical_expression .)


state 58

    (123) expression -> bitwise_expression .

    PLUS            reduce using rule 123 (expression -> bitwise_expression .)
    MINUS           reduce using rule 123 (expression -> bitwise_expression .)
    TIMES           reduce using rule 123 (expression -> bitwise_expression .)
    DIVIDE          reduce using rule 123 (expression -> bitwise_expression .)
    MODULE          reduce using rule 123 (expression -> bitwise_expression .)
    EQ              reduce using rule 123 (expression -> bitwise_expression .)
    NEQ             reduce using rule 123 (expression -> bitwise_expression .)
    LT              reduce using rule 123 (expression -> bitwise_expression .)
    LE              reduce using rule 123 (expression -> bitwise_expression .)
    GT              reduce using rule 123 (expression -> bitwise_expression .)
    GE              reduce using rule 123 (expression -> bitwise_expression .)
    LAND            reduce using rule 123 (expression -> bitwise_expression .)
    LOR             reduce using rule 123 (expression -> bitwise_expression .)
    AND             reduce using rule 123 (expression -> bitwise_expression .)
    OR              reduce using rule 123 (expression -> bitwise_expression .)
    XOR             reduce using rule 123 (expression -> bitwise_expression .)
    AND_NOT         reduce using rule 123 (expression -> bitwise_expression .)
    LSHIFT          reduce using rule 123 (expression -> bitwise_expression .)
    RSHIFT          reduce using rule 123 (expression -> bitwise_expression .)
    VAR             reduce using rule 123 (expression -> bitwise_expression .)
    CONST           reduce using rule 123 (expression -> bitwise_expression .)
    FUNC            reduce using rule 123 (expression -> bitwise_expression .)
    TYPE            reduce using rule 123 (expression -> bitwise_expression .)
    $end            reduce using rule 123 (expression -> bitwise_expression .)
    RPAREN          reduce using rule 123 (expression -> bitwise_expression .)
    RBRACE          reduce using rule 123 (expression -> bitwise_expression .)
    COMMA           reduce using rule 123 (expression -> bitwise_expression .)
    COLON           reduce using rule 123 (expression -> bitwise_expression .)
    IDENTIFIER      reduce using rule 123 (expression -> bitwise_expression .)
    LPAREN          reduce using rule 123 (expression -> bitwise_expression .)
    LNOT            reduce using rule 123 (expression -> bitwise_expression .)
    INT             reduce using rule 123 (expression -> bitwise_expression .)
    FLOAT64         reduce using rule 123 (expression -> bitwise_expression .)
    TRUE            reduce using rule 123 (expression -> bitwise_expression .)
    FALSE           reduce using rule 123 (expression -> bitwise_expression .)
    STRING          reduce using rule 123 (expression -> bitwise_expression .)
    RETURN          reduce using rule 123 (expression -> bitwise_expression .)
    IF              reduce using rule 123 (expression -> bitwise_expression .)
    SWITCH          reduce using rule 123 (expression -> bitwise_expression .)
    BREAK           reduce using rule 123 (expression -> bitwise_expression .)
    CONTINUE        reduce using rule 123 (expression -> bitwise_expression .)
    LBRACKET        reduce using rule 123 (expression -> bitwise_expression .)
    MAP             reduce using rule 123 (expression -> bitwise_expression .)
    FOR             reduce using rule 123 (expression -> bitwise_expression .)
    CASE            reduce using rule 123 (expression -> bitwise_expression .)
    DEFAULT         reduce using rule 123 (expression -> bitwise_expression .)
    LBRACE          reduce using rule 123 (expression -> bitwise_expression .)
    SEMICOLON       reduce using rule 123 (expression -> bitwise_expression .)


state 59

    (124) expression -> PLUS . expression
    (57) expression -> . slice_type LBRACE expression_list RBRACE
    (58) expression -> . slice_type LBRACE RBRACE
    (61) expression -> . LPAREN expression RPAREN
    (120) expression -> . binary_expression
    (121) expression -> . relational_expression
    (122) expression -> . logical_expression
    (123) expression -> . bitwise_expression
    (124) expression -> . PLUS expression
    (125) expression -> . MINUS expression
    (126) expression -> . LNOT expression
    (127) expression -> . INT
    (128) expression -> . FLOAT64
    (129) expression -> . TRUE
    (130) expression -> . FALSE
    (131) expression -> . IDENTIFIER
    (132) expression -> . STRING
    (133) expression -> . IDENTIFIER PLUSPLUS
    (134) expression -> . IDENTIFIER MINUSMINUS
    (145) expression -> . map_type LBRACE expression_map_list RBRACE
    (146) expression -> . map_type LBRACE RBRACE
    (169) expression -> . type_name LBRACE keyed_element_list RBRACE
    (170) expression -> . type_name LBRACE RBRACE
    (56) slice_type -> . LBRACKET RBRACKET primitive_type
    (175) binary_expression -> . expression PLUS expression
    (176) binary_expression -> . expression MINUS expression
    (177) binary_expression -> . expression TIMES expression
    (178) binary_expression -> . expression DIVIDE expression
    (179) binary_expression -> . expression MODULE expression
    (184) relational_expression -> . expression EQ expression
    (185) relational_expression -> . expression NEQ expression
    (186) relational_expression -> . expression LT expression
    (187) relational_expression -> . expression LE expression
    (188) relational_expression -> . expression GT expression
    (189) relational_expression -> . expression GE expression
    (190) logical_expression -> . expression LAND expression
    (191) logical_expression -> . expression LOR expression
    (192) bitwise_expression -> . expression AND expression
    (193) bitwise_expression -> . expression OR expression
    (194) bitwise_expression -> . expression XOR expression
    (195) bitwise_expression -> . expression AND_NOT expression
    (196) bitwise_expression -> . expression LSHIFT expression
    (197) bitwise_expression -> . expression RSHIFT expression
    (144) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (171) type_name -> . IDENTIFIER
    (172) type_name -> . slice_type
    (173) type_name -> . array_type
    (174) type_name -> . map_type
    (119) array_type -> . LBRACKET INT RBRACKET type

    LPAREN          shift and go to state 54
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    LNOT            shift and go to state 61
    INT             shift and go to state 62
    FLOAT64         shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 66
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    expression                     shift and go to state 107
    slice_type                     shift and go to state 53
    binary_expression              shift and go to state 55
    relational_expression          shift and go to state 56
    logical_expression             shift and go to state 57
    bitwise_expression             shift and go to state 58
    map_type                       shift and go to state 67
    type_name                      shift and go to state 68
    array_type                     shift and go to state 69

state 60

    (125) expression -> MINUS . expression
    (57) expression -> . slice_type LBRACE expression_list RBRACE
    (58) expression -> . slice_type LBRACE RBRACE
    (61) expression -> . LPAREN expression RPAREN
    (120) expression -> . binary_expression
    (121) expression -> . relational_expression
    (122) expression -> . logical_expression
    (123) expression -> . bitwise_expression
    (124) expression -> . PLUS expression
    (125) expression -> . MINUS expression
    (126) expression -> . LNOT expression
    (127) expression -> . INT
    (128) expression -> . FLOAT64
    (129) expression -> . TRUE
    (130) expression -> . FALSE
    (131) expression -> . IDENTIFIER
    (132) expression -> . STRING
    (133) expression -> . IDENTIFIER PLUSPLUS
    (134) expression -> . IDENTIFIER MINUSMINUS
    (145) expression -> . map_type LBRACE expression_map_list RBRACE
    (146) expression -> . map_type LBRACE RBRACE
    (169) expression -> . type_name LBRACE keyed_element_list RBRACE
    (170) expression -> . type_name LBRACE RBRACE
    (56) slice_type -> . LBRACKET RBRACKET primitive_type
    (175) binary_expression -> . expression PLUS expression
    (176) binary_expression -> . expression MINUS expression
    (177) binary_expression -> . expression TIMES expression
    (178) binary_expression -> . expression DIVIDE expression
    (179) binary_expression -> . expression MODULE expression
    (184) relational_expression -> . expression EQ expression
    (185) relational_expression -> . expression NEQ expression
    (186) relational_expression -> . expression LT expression
    (187) relational_expression -> . expression LE expression
    (188) relational_expression -> . expression GT expression
    (189) relational_expression -> . expression GE expression
    (190) logical_expression -> . expression LAND expression
    (191) logical_expression -> . expression LOR expression
    (192) bitwise_expression -> . expression AND expression
    (193) bitwise_expression -> . expression OR expression
    (194) bitwise_expression -> . expression XOR expression
    (195) bitwise_expression -> . expression AND_NOT expression
    (196) bitwise_expression -> . expression LSHIFT expression
    (197) bitwise_expression -> . expression RSHIFT expression
    (144) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (171) type_name -> . IDENTIFIER
    (172) type_name -> . slice_type
    (173) type_name -> . array_type
    (174) type_name -> . map_type
    (119) array_type -> . LBRACKET INT RBRACKET type

    LPAREN          shift and go to state 54
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    LNOT            shift and go to state 61
    INT             shift and go to state 62
    FLOAT64         shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 66
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    expression                     shift and go to state 108
    slice_type                     shift and go to state 53
    binary_expression              shift and go to state 55
    relational_expression          shift and go to state 56
    logical_expression             shift and go to state 57
    bitwise_expression             shift and go to state 58
    map_type                       shift and go to state 67
    type_name                      shift and go to state 68
    array_type                     shift and go to state 69

state 61

    (126) expression -> LNOT . expression
    (57) expression -> . slice_type LBRACE expression_list RBRACE
    (58) expression -> . slice_type LBRACE RBRACE
    (61) expression -> . LPAREN expression RPAREN
    (120) expression -> . binary_expression
    (121) expression -> . relational_expression
    (122) expression -> . logical_expression
    (123) expression -> . bitwise_expression
    (124) expression -> . PLUS expression
    (125) expression -> . MINUS expression
    (126) expression -> . LNOT expression
    (127) expression -> . INT
    (128) expression -> . FLOAT64
    (129) expression -> . TRUE
    (130) expression -> . FALSE
    (131) expression -> . IDENTIFIER
    (132) expression -> . STRING
    (133) expression -> . IDENTIFIER PLUSPLUS
    (134) expression -> . IDENTIFIER MINUSMINUS
    (145) expression -> . map_type LBRACE expression_map_list RBRACE
    (146) expression -> . map_type LBRACE RBRACE
    (169) expression -> . type_name LBRACE keyed_element_list RBRACE
    (170) expression -> . type_name LBRACE RBRACE
    (56) slice_type -> . LBRACKET RBRACKET primitive_type
    (175) binary_expression -> . expression PLUS expression
    (176) binary_expression -> . expression MINUS expression
    (177) binary_expression -> . expression TIMES expression
    (178) binary_expression -> . expression DIVIDE expression
    (179) binary_expression -> . expression MODULE expression
    (184) relational_expression -> . expression EQ expression
    (185) relational_expression -> . expression NEQ expression
    (186) relational_expression -> . expression LT expression
    (187) relational_expression -> . expression LE expression
    (188) relational_expression -> . expression GT expression
    (189) relational_expression -> . expression GE expression
    (190) logical_expression -> . expression LAND expression
    (191) logical_expression -> . expression LOR expression
    (192) bitwise_expression -> . expression AND expression
    (193) bitwise_expression -> . expression OR expression
    (194) bitwise_expression -> . expression XOR expression
    (195) bitwise_expression -> . expression AND_NOT expression
    (196) bitwise_expression -> . expression LSHIFT expression
    (197) bitwise_expression -> . expression RSHIFT expression
    (144) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (171) type_name -> . IDENTIFIER
    (172) type_name -> . slice_type
    (173) type_name -> . array_type
    (174) type_name -> . map_type
    (119) array_type -> . LBRACKET INT RBRACKET type

    LPAREN          shift and go to state 54
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    LNOT            shift and go to state 61
    INT             shift and go to state 62
    FLOAT64         shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 66
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    expression                     shift and go to state 109
    slice_type                     shift and go to state 53
    binary_expression              shift and go to state 55
    relational_expression          shift and go to state 56
    logical_expression             shift and go to state 57
    bitwise_expression             shift and go to state 58
    map_type                       shift and go to state 67
    type_name                      shift and go to state 68
    array_type                     shift and go to state 69

state 62

    (127) expression -> INT .

    PLUS            reduce using rule 127 (expression -> INT .)
    MINUS           reduce using rule 127 (expression -> INT .)
    TIMES           reduce using rule 127 (expression -> INT .)
    DIVIDE          reduce using rule 127 (expression -> INT .)
    MODULE          reduce using rule 127 (expression -> INT .)
    EQ              reduce using rule 127 (expression -> INT .)
    NEQ             reduce using rule 127 (expression -> INT .)
    LT              reduce using rule 127 (expression -> INT .)
    LE              reduce using rule 127 (expression -> INT .)
    GT              reduce using rule 127 (expression -> INT .)
    GE              reduce using rule 127 (expression -> INT .)
    LAND            reduce using rule 127 (expression -> INT .)
    LOR             reduce using rule 127 (expression -> INT .)
    AND             reduce using rule 127 (expression -> INT .)
    OR              reduce using rule 127 (expression -> INT .)
    XOR             reduce using rule 127 (expression -> INT .)
    AND_NOT         reduce using rule 127 (expression -> INT .)
    LSHIFT          reduce using rule 127 (expression -> INT .)
    RSHIFT          reduce using rule 127 (expression -> INT .)
    VAR             reduce using rule 127 (expression -> INT .)
    CONST           reduce using rule 127 (expression -> INT .)
    FUNC            reduce using rule 127 (expression -> INT .)
    TYPE            reduce using rule 127 (expression -> INT .)
    $end            reduce using rule 127 (expression -> INT .)
    RPAREN          reduce using rule 127 (expression -> INT .)
    RBRACE          reduce using rule 127 (expression -> INT .)
    COMMA           reduce using rule 127 (expression -> INT .)
    COLON           reduce using rule 127 (expression -> INT .)
    IDENTIFIER      reduce using rule 127 (expression -> INT .)
    LPAREN          reduce using rule 127 (expression -> INT .)
    LNOT            reduce using rule 127 (expression -> INT .)
    INT             reduce using rule 127 (expression -> INT .)
    FLOAT64         reduce using rule 127 (expression -> INT .)
    TRUE            reduce using rule 127 (expression -> INT .)
    FALSE           reduce using rule 127 (expression -> INT .)
    STRING          reduce using rule 127 (expression -> INT .)
    RETURN          reduce using rule 127 (expression -> INT .)
    IF              reduce using rule 127 (expression -> INT .)
    SWITCH          reduce using rule 127 (expression -> INT .)
    BREAK           reduce using rule 127 (expression -> INT .)
    CONTINUE        reduce using rule 127 (expression -> INT .)
    LBRACKET        reduce using rule 127 (expression -> INT .)
    MAP             reduce using rule 127 (expression -> INT .)
    FOR             reduce using rule 127 (expression -> INT .)
    CASE            reduce using rule 127 (expression -> INT .)
    DEFAULT         reduce using rule 127 (expression -> INT .)
    LBRACE          reduce using rule 127 (expression -> INT .)
    SEMICOLON       reduce using rule 127 (expression -> INT .)


state 63

    (128) expression -> FLOAT64 .

    PLUS            reduce using rule 128 (expression -> FLOAT64 .)
    MINUS           reduce using rule 128 (expression -> FLOAT64 .)
    TIMES           reduce using rule 128 (expression -> FLOAT64 .)
    DIVIDE          reduce using rule 128 (expression -> FLOAT64 .)
    MODULE          reduce using rule 128 (expression -> FLOAT64 .)
    EQ              reduce using rule 128 (expression -> FLOAT64 .)
    NEQ             reduce using rule 128 (expression -> FLOAT64 .)
    LT              reduce using rule 128 (expression -> FLOAT64 .)
    LE              reduce using rule 128 (expression -> FLOAT64 .)
    GT              reduce using rule 128 (expression -> FLOAT64 .)
    GE              reduce using rule 128 (expression -> FLOAT64 .)
    LAND            reduce using rule 128 (expression -> FLOAT64 .)
    LOR             reduce using rule 128 (expression -> FLOAT64 .)
    AND             reduce using rule 128 (expression -> FLOAT64 .)
    OR              reduce using rule 128 (expression -> FLOAT64 .)
    XOR             reduce using rule 128 (expression -> FLOAT64 .)
    AND_NOT         reduce using rule 128 (expression -> FLOAT64 .)
    LSHIFT          reduce using rule 128 (expression -> FLOAT64 .)
    RSHIFT          reduce using rule 128 (expression -> FLOAT64 .)
    VAR             reduce using rule 128 (expression -> FLOAT64 .)
    CONST           reduce using rule 128 (expression -> FLOAT64 .)
    FUNC            reduce using rule 128 (expression -> FLOAT64 .)
    TYPE            reduce using rule 128 (expression -> FLOAT64 .)
    $end            reduce using rule 128 (expression -> FLOAT64 .)
    RPAREN          reduce using rule 128 (expression -> FLOAT64 .)
    RBRACE          reduce using rule 128 (expression -> FLOAT64 .)
    COMMA           reduce using rule 128 (expression -> FLOAT64 .)
    COLON           reduce using rule 128 (expression -> FLOAT64 .)
    IDENTIFIER      reduce using rule 128 (expression -> FLOAT64 .)
    LPAREN          reduce using rule 128 (expression -> FLOAT64 .)
    LNOT            reduce using rule 128 (expression -> FLOAT64 .)
    INT             reduce using rule 128 (expression -> FLOAT64 .)
    FLOAT64         reduce using rule 128 (expression -> FLOAT64 .)
    TRUE            reduce using rule 128 (expression -> FLOAT64 .)
    FALSE           reduce using rule 128 (expression -> FLOAT64 .)
    STRING          reduce using rule 128 (expression -> FLOAT64 .)
    RETURN          reduce using rule 128 (expression -> FLOAT64 .)
    IF              reduce using rule 128 (expression -> FLOAT64 .)
    SWITCH          reduce using rule 128 (expression -> FLOAT64 .)
    BREAK           reduce using rule 128 (expression -> FLOAT64 .)
    CONTINUE        reduce using rule 128 (expression -> FLOAT64 .)
    LBRACKET        reduce using rule 128 (expression -> FLOAT64 .)
    MAP             reduce using rule 128 (expression -> FLOAT64 .)
    FOR             reduce using rule 128 (expression -> FLOAT64 .)
    CASE            reduce using rule 128 (expression -> FLOAT64 .)
    DEFAULT         reduce using rule 128 (expression -> FLOAT64 .)
    LBRACE          reduce using rule 128 (expression -> FLOAT64 .)
    SEMICOLON       reduce using rule 128 (expression -> FLOAT64 .)


state 64

    (129) expression -> TRUE .

    PLUS            reduce using rule 129 (expression -> TRUE .)
    MINUS           reduce using rule 129 (expression -> TRUE .)
    TIMES           reduce using rule 129 (expression -> TRUE .)
    DIVIDE          reduce using rule 129 (expression -> TRUE .)
    MODULE          reduce using rule 129 (expression -> TRUE .)
    EQ              reduce using rule 129 (expression -> TRUE .)
    NEQ             reduce using rule 129 (expression -> TRUE .)
    LT              reduce using rule 129 (expression -> TRUE .)
    LE              reduce using rule 129 (expression -> TRUE .)
    GT              reduce using rule 129 (expression -> TRUE .)
    GE              reduce using rule 129 (expression -> TRUE .)
    LAND            reduce using rule 129 (expression -> TRUE .)
    LOR             reduce using rule 129 (expression -> TRUE .)
    AND             reduce using rule 129 (expression -> TRUE .)
    OR              reduce using rule 129 (expression -> TRUE .)
    XOR             reduce using rule 129 (expression -> TRUE .)
    AND_NOT         reduce using rule 129 (expression -> TRUE .)
    LSHIFT          reduce using rule 129 (expression -> TRUE .)
    RSHIFT          reduce using rule 129 (expression -> TRUE .)
    VAR             reduce using rule 129 (expression -> TRUE .)
    CONST           reduce using rule 129 (expression -> TRUE .)
    FUNC            reduce using rule 129 (expression -> TRUE .)
    TYPE            reduce using rule 129 (expression -> TRUE .)
    $end            reduce using rule 129 (expression -> TRUE .)
    RPAREN          reduce using rule 129 (expression -> TRUE .)
    RBRACE          reduce using rule 129 (expression -> TRUE .)
    COMMA           reduce using rule 129 (expression -> TRUE .)
    COLON           reduce using rule 129 (expression -> TRUE .)
    IDENTIFIER      reduce using rule 129 (expression -> TRUE .)
    LPAREN          reduce using rule 129 (expression -> TRUE .)
    LNOT            reduce using rule 129 (expression -> TRUE .)
    INT             reduce using rule 129 (expression -> TRUE .)
    FLOAT64         reduce using rule 129 (expression -> TRUE .)
    TRUE            reduce using rule 129 (expression -> TRUE .)
    FALSE           reduce using rule 129 (expression -> TRUE .)
    STRING          reduce using rule 129 (expression -> TRUE .)
    RETURN          reduce using rule 129 (expression -> TRUE .)
    IF              reduce using rule 129 (expression -> TRUE .)
    SWITCH          reduce using rule 129 (expression -> TRUE .)
    BREAK           reduce using rule 129 (expression -> TRUE .)
    CONTINUE        reduce using rule 129 (expression -> TRUE .)
    LBRACKET        reduce using rule 129 (expression -> TRUE .)
    MAP             reduce using rule 129 (expression -> TRUE .)
    FOR             reduce using rule 129 (expression -> TRUE .)
    CASE            reduce using rule 129 (expression -> TRUE .)
    DEFAULT         reduce using rule 129 (expression -> TRUE .)
    LBRACE          reduce using rule 129 (expression -> TRUE .)
    SEMICOLON       reduce using rule 129 (expression -> TRUE .)


state 65

    (130) expression -> FALSE .

    PLUS            reduce using rule 130 (expression -> FALSE .)
    MINUS           reduce using rule 130 (expression -> FALSE .)
    TIMES           reduce using rule 130 (expression -> FALSE .)
    DIVIDE          reduce using rule 130 (expression -> FALSE .)
    MODULE          reduce using rule 130 (expression -> FALSE .)
    EQ              reduce using rule 130 (expression -> FALSE .)
    NEQ             reduce using rule 130 (expression -> FALSE .)
    LT              reduce using rule 130 (expression -> FALSE .)
    LE              reduce using rule 130 (expression -> FALSE .)
    GT              reduce using rule 130 (expression -> FALSE .)
    GE              reduce using rule 130 (expression -> FALSE .)
    LAND            reduce using rule 130 (expression -> FALSE .)
    LOR             reduce using rule 130 (expression -> FALSE .)
    AND             reduce using rule 130 (expression -> FALSE .)
    OR              reduce using rule 130 (expression -> FALSE .)
    XOR             reduce using rule 130 (expression -> FALSE .)
    AND_NOT         reduce using rule 130 (expression -> FALSE .)
    LSHIFT          reduce using rule 130 (expression -> FALSE .)
    RSHIFT          reduce using rule 130 (expression -> FALSE .)
    VAR             reduce using rule 130 (expression -> FALSE .)
    CONST           reduce using rule 130 (expression -> FALSE .)
    FUNC            reduce using rule 130 (expression -> FALSE .)
    TYPE            reduce using rule 130 (expression -> FALSE .)
    $end            reduce using rule 130 (expression -> FALSE .)
    RPAREN          reduce using rule 130 (expression -> FALSE .)
    RBRACE          reduce using rule 130 (expression -> FALSE .)
    COMMA           reduce using rule 130 (expression -> FALSE .)
    COLON           reduce using rule 130 (expression -> FALSE .)
    IDENTIFIER      reduce using rule 130 (expression -> FALSE .)
    LPAREN          reduce using rule 130 (expression -> FALSE .)
    LNOT            reduce using rule 130 (expression -> FALSE .)
    INT             reduce using rule 130 (expression -> FALSE .)
    FLOAT64         reduce using rule 130 (expression -> FALSE .)
    TRUE            reduce using rule 130 (expression -> FALSE .)
    FALSE           reduce using rule 130 (expression -> FALSE .)
    STRING          reduce using rule 130 (expression -> FALSE .)
    RETURN          reduce using rule 130 (expression -> FALSE .)
    IF              reduce using rule 130 (expression -> FALSE .)
    SWITCH          reduce using rule 130 (expression -> FALSE .)
    BREAK           reduce using rule 130 (expression -> FALSE .)
    CONTINUE        reduce using rule 130 (expression -> FALSE .)
    LBRACKET        reduce using rule 130 (expression -> FALSE .)
    MAP             reduce using rule 130 (expression -> FALSE .)
    FOR             reduce using rule 130 (expression -> FALSE .)
    CASE            reduce using rule 130 (expression -> FALSE .)
    DEFAULT         reduce using rule 130 (expression -> FALSE .)
    LBRACE          reduce using rule 130 (expression -> FALSE .)
    SEMICOLON       reduce using rule 130 (expression -> FALSE .)


state 66

    (132) expression -> STRING .

    PLUS            reduce using rule 132 (expression -> STRING .)
    MINUS           reduce using rule 132 (expression -> STRING .)
    TIMES           reduce using rule 132 (expression -> STRING .)
    DIVIDE          reduce using rule 132 (expression -> STRING .)
    MODULE          reduce using rule 132 (expression -> STRING .)
    EQ              reduce using rule 132 (expression -> STRING .)
    NEQ             reduce using rule 132 (expression -> STRING .)
    LT              reduce using rule 132 (expression -> STRING .)
    LE              reduce using rule 132 (expression -> STRING .)
    GT              reduce using rule 132 (expression -> STRING .)
    GE              reduce using rule 132 (expression -> STRING .)
    LAND            reduce using rule 132 (expression -> STRING .)
    LOR             reduce using rule 132 (expression -> STRING .)
    AND             reduce using rule 132 (expression -> STRING .)
    OR              reduce using rule 132 (expression -> STRING .)
    XOR             reduce using rule 132 (expression -> STRING .)
    AND_NOT         reduce using rule 132 (expression -> STRING .)
    LSHIFT          reduce using rule 132 (expression -> STRING .)
    RSHIFT          reduce using rule 132 (expression -> STRING .)
    VAR             reduce using rule 132 (expression -> STRING .)
    CONST           reduce using rule 132 (expression -> STRING .)
    FUNC            reduce using rule 132 (expression -> STRING .)
    TYPE            reduce using rule 132 (expression -> STRING .)
    $end            reduce using rule 132 (expression -> STRING .)
    RPAREN          reduce using rule 132 (expression -> STRING .)
    RBRACE          reduce using rule 132 (expression -> STRING .)
    COMMA           reduce using rule 132 (expression -> STRING .)
    COLON           reduce using rule 132 (expression -> STRING .)
    IDENTIFIER      reduce using rule 132 (expression -> STRING .)
    LPAREN          reduce using rule 132 (expression -> STRING .)
    LNOT            reduce using rule 132 (expression -> STRING .)
    INT             reduce using rule 132 (expression -> STRING .)
    FLOAT64         reduce using rule 132 (expression -> STRING .)
    TRUE            reduce using rule 132 (expression -> STRING .)
    FALSE           reduce using rule 132 (expression -> STRING .)
    STRING          reduce using rule 132 (expression -> STRING .)
    RETURN          reduce using rule 132 (expression -> STRING .)
    IF              reduce using rule 132 (expression -> STRING .)
    SWITCH          reduce using rule 132 (expression -> STRING .)
    BREAK           reduce using rule 132 (expression -> STRING .)
    CONTINUE        reduce using rule 132 (expression -> STRING .)
    LBRACKET        reduce using rule 132 (expression -> STRING .)
    MAP             reduce using rule 132 (expression -> STRING .)
    FOR             reduce using rule 132 (expression -> STRING .)
    CASE            reduce using rule 132 (expression -> STRING .)
    DEFAULT         reduce using rule 132 (expression -> STRING .)
    LBRACE          reduce using rule 132 (expression -> STRING .)
    SEMICOLON       reduce using rule 132 (expression -> STRING .)


state 67

    (145) expression -> map_type . LBRACE expression_map_list RBRACE
    (146) expression -> map_type . LBRACE RBRACE
    (174) type_name -> map_type .

  ! shift/reduce conflict for LBRACE resolved as shift
    LBRACE          shift and go to state 110

  ! LBRACE          [ reduce using rule 174 (type_name -> map_type .) ]


state 68

    (169) expression -> type_name . LBRACE keyed_element_list RBRACE
    (170) expression -> type_name . LBRACE RBRACE

    LBRACE          shift and go to state 111


state 69

    (173) type_name -> array_type .

    LBRACE          reduce using rule 173 (type_name -> array_type .)


state 70

    (56) slice_type -> LBRACKET RBRACKET . primitive_type
    (115) primitive_type -> . INT_TYPE
    (116) primitive_type -> . FLOAT64_TYPE
    (117) primitive_type -> . STRING_TYPE
    (118) primitive_type -> . BOOL_TYPE

    INT_TYPE        shift and go to state 34
    FLOAT64_TYPE    shift and go to state 35
    STRING_TYPE     shift and go to state 36
    BOOL_TYPE       shift and go to state 37

    primitive_type                 shift and go to state 112

state 71

    (119) array_type -> LBRACKET INT . RBRACKET type

    RBRACKET        shift and go to state 113


state 72

    (144) map_type -> MAP LBRACKET . primitive_type RBRACKET primitive_type
    (115) primitive_type -> . INT_TYPE
    (116) primitive_type -> . FLOAT64_TYPE
    (117) primitive_type -> . STRING_TYPE
    (118) primitive_type -> . BOOL_TYPE

    INT_TYPE        shift and go to state 34
    FLOAT64_TYPE    shift and go to state 35
    STRING_TYPE     shift and go to state 36
    BOOL_TYPE       shift and go to state 37

    primitive_type                 shift and go to state 114

state 73

    (33) global_const_dec -> CONST IDENTIFIER type ASSIGN . expression
    (57) expression -> . slice_type LBRACE expression_list RBRACE
    (58) expression -> . slice_type LBRACE RBRACE
    (61) expression -> . LPAREN expression RPAREN
    (120) expression -> . binary_expression
    (121) expression -> . relational_expression
    (122) expression -> . logical_expression
    (123) expression -> . bitwise_expression
    (124) expression -> . PLUS expression
    (125) expression -> . MINUS expression
    (126) expression -> . LNOT expression
    (127) expression -> . INT
    (128) expression -> . FLOAT64
    (129) expression -> . TRUE
    (130) expression -> . FALSE
    (131) expression -> . IDENTIFIER
    (132) expression -> . STRING
    (133) expression -> . IDENTIFIER PLUSPLUS
    (134) expression -> . IDENTIFIER MINUSMINUS
    (145) expression -> . map_type LBRACE expression_map_list RBRACE
    (146) expression -> . map_type LBRACE RBRACE
    (169) expression -> . type_name LBRACE keyed_element_list RBRACE
    (170) expression -> . type_name LBRACE RBRACE
    (56) slice_type -> . LBRACKET RBRACKET primitive_type
    (175) binary_expression -> . expression PLUS expression
    (176) binary_expression -> . expression MINUS expression
    (177) binary_expression -> . expression TIMES expression
    (178) binary_expression -> . expression DIVIDE expression
    (179) binary_expression -> . expression MODULE expression
    (184) relational_expression -> . expression EQ expression
    (185) relational_expression -> . expression NEQ expression
    (186) relational_expression -> . expression LT expression
    (187) relational_expression -> . expression LE expression
    (188) relational_expression -> . expression GT expression
    (189) relational_expression -> . expression GE expression
    (190) logical_expression -> . expression LAND expression
    (191) logical_expression -> . expression LOR expression
    (192) bitwise_expression -> . expression AND expression
    (193) bitwise_expression -> . expression OR expression
    (194) bitwise_expression -> . expression XOR expression
    (195) bitwise_expression -> . expression AND_NOT expression
    (196) bitwise_expression -> . expression LSHIFT expression
    (197) bitwise_expression -> . expression RSHIFT expression
    (144) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (171) type_name -> . IDENTIFIER
    (172) type_name -> . slice_type
    (173) type_name -> . array_type
    (174) type_name -> . map_type
    (119) array_type -> . LBRACKET INT RBRACKET type

    LPAREN          shift and go to state 54
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    LNOT            shift and go to state 61
    INT             shift and go to state 62
    FLOAT64         shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 66
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    expression                     shift and go to state 115
    slice_type                     shift and go to state 53
    binary_expression              shift and go to state 55
    relational_expression          shift and go to state 56
    logical_expression             shift and go to state 57
    bitwise_expression             shift and go to state 58
    map_type                       shift and go to state 67
    type_name                      shift and go to state 68
    array_type                     shift and go to state 69

state 74

    (34) global_const_dec -> CONST IDENTIFIER ASSIGN expression .
    (175) binary_expression -> expression . PLUS expression
    (176) binary_expression -> expression . MINUS expression
    (177) binary_expression -> expression . TIMES expression
    (178) binary_expression -> expression . DIVIDE expression
    (179) binary_expression -> expression . MODULE expression
    (184) relational_expression -> expression . EQ expression
    (185) relational_expression -> expression . NEQ expression
    (186) relational_expression -> expression . LT expression
    (187) relational_expression -> expression . LE expression
    (188) relational_expression -> expression . GT expression
    (189) relational_expression -> expression . GE expression
    (190) logical_expression -> expression . LAND expression
    (191) logical_expression -> expression . LOR expression
    (192) bitwise_expression -> expression . AND expression
    (193) bitwise_expression -> expression . OR expression
    (194) bitwise_expression -> expression . XOR expression
    (195) bitwise_expression -> expression . AND_NOT expression
    (196) bitwise_expression -> expression . LSHIFT expression
    (197) bitwise_expression -> expression . RSHIFT expression

    VAR             reduce using rule 34 (global_const_dec -> CONST IDENTIFIER ASSIGN expression .)
    CONST           reduce using rule 34 (global_const_dec -> CONST IDENTIFIER ASSIGN expression .)
    FUNC            reduce using rule 34 (global_const_dec -> CONST IDENTIFIER ASSIGN expression .)
    TYPE            reduce using rule 34 (global_const_dec -> CONST IDENTIFIER ASSIGN expression .)
    $end            reduce using rule 34 (global_const_dec -> CONST IDENTIFIER ASSIGN expression .)
    PLUS            shift and go to state 86
    MINUS           shift and go to state 87
    TIMES           shift and go to state 88
    DIVIDE          shift and go to state 89
    MODULE          shift and go to state 90
    EQ              shift and go to state 91
    NEQ             shift and go to state 92
    LT              shift and go to state 93
    LE              shift and go to state 94
    GT              shift and go to state 95
    GE              shift and go to state 96
    LAND            shift and go to state 97
    LOR             shift and go to state 98
    AND             shift and go to state 99
    OR              shift and go to state 100
    XOR             shift and go to state 101
    AND_NOT         shift and go to state 102
    LSHIFT          shift and go to state 103
    RSHIFT          shift and go to state 104


state 75

    (100) parameter -> IDENTIFIER . type
    (101) parameter -> IDENTIFIER . ELLIPSIS primitive_type
    (52) type -> . primitive_type
    (53) type -> . slice_type
    (54) type -> . array_type
    (55) type -> . map_type
    (115) primitive_type -> . INT_TYPE
    (116) primitive_type -> . FLOAT64_TYPE
    (117) primitive_type -> . STRING_TYPE
    (118) primitive_type -> . BOOL_TYPE
    (56) slice_type -> . LBRACKET RBRACKET primitive_type
    (119) array_type -> . LBRACKET INT RBRACKET type
    (144) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type

    ELLIPSIS        shift and go to state 117
    INT_TYPE        shift and go to state 34
    FLOAT64_TYPE    shift and go to state 35
    STRING_TYPE     shift and go to state 36
    BOOL_TYPE       shift and go to state 37
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    type                           shift and go to state 116
    primitive_type                 shift and go to state 30
    slice_type                     shift and go to state 31
    array_type                     shift and go to state 32
    map_type                       shift and go to state 33

state 76

    (96) function_declaration -> FUNC IDENTIFIER LPAREN parameter_list . RPAREN return_type block
    (97) parameter_list -> parameter_list . COMMA parameter

    RPAREN          shift and go to state 118
    COMMA           shift and go to state 119


state 77

    (98) parameter_list -> parameter .

    RPAREN          reduce using rule 98 (parameter_list -> parameter .)
    COMMA           reduce using rule 98 (parameter_list -> parameter .)


state 78

    (99) parameter_list -> empty .

    RPAREN          reduce using rule 99 (parameter_list -> empty .)
    COMMA           reduce using rule 99 (parameter_list -> empty .)


state 79

    (154) method_declaration -> FUNC LPAREN receiver RPAREN . IDENTIFIER LPAREN parameter_list RPAREN return_type block

    IDENTIFIER      shift and go to state 120


state 80

    (155) receiver -> IDENTIFIER IDENTIFIER .

    RPAREN          reduce using rule 155 (receiver -> IDENTIFIER IDENTIFIER .)


state 81

    (156) receiver -> IDENTIFIER TIMES . IDENTIFIER
    (157) receiver -> IDENTIFIER TIMES . type
    (52) type -> . primitive_type
    (53) type -> . slice_type
    (54) type -> . array_type
    (55) type -> . map_type
    (115) primitive_type -> . INT_TYPE
    (116) primitive_type -> . FLOAT64_TYPE
    (117) primitive_type -> . STRING_TYPE
    (118) primitive_type -> . BOOL_TYPE
    (56) slice_type -> . LBRACKET RBRACKET primitive_type
    (119) array_type -> . LBRACKET INT RBRACKET type
    (144) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type

    IDENTIFIER      shift and go to state 121
    INT_TYPE        shift and go to state 34
    FLOAT64_TYPE    shift and go to state 35
    STRING_TYPE     shift and go to state 36
    BOOL_TYPE       shift and go to state 37
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    type                           shift and go to state 122
    primitive_type                 shift and go to state 30
    slice_type                     shift and go to state 31
    array_type                     shift and go to state 32
    map_type                       shift and go to state 33

state 82

    (162) struct_type -> STRUCT LBRACE . RBRACE
    (163) struct_type -> STRUCT LBRACE . field_list RBRACE
    (150) field_list -> . field_declaration
    (151) field_list -> . field_list field_declaration
    (152) field_declaration -> . IDENTIFIER type
    (153) field_declaration -> . IDENTIFIER

    RBRACE          shift and go to state 123
    IDENTIFIER      shift and go to state 126

    field_list                     shift and go to state 124
    field_declaration              shift and go to state 125

state 83

    (31) global_var_dec -> VAR IDENTIFIER type ASSIGN expression .
    (175) binary_expression -> expression . PLUS expression
    (176) binary_expression -> expression . MINUS expression
    (177) binary_expression -> expression . TIMES expression
    (178) binary_expression -> expression . DIVIDE expression
    (179) binary_expression -> expression . MODULE expression
    (184) relational_expression -> expression . EQ expression
    (185) relational_expression -> expression . NEQ expression
    (186) relational_expression -> expression . LT expression
    (187) relational_expression -> expression . LE expression
    (188) relational_expression -> expression . GT expression
    (189) relational_expression -> expression . GE expression
    (190) logical_expression -> expression . LAND expression
    (191) logical_expression -> expression . LOR expression
    (192) bitwise_expression -> expression . AND expression
    (193) bitwise_expression -> expression . OR expression
    (194) bitwise_expression -> expression . XOR expression
    (195) bitwise_expression -> expression . AND_NOT expression
    (196) bitwise_expression -> expression . LSHIFT expression
    (197) bitwise_expression -> expression . RSHIFT expression

    VAR             reduce using rule 31 (global_var_dec -> VAR IDENTIFIER type ASSIGN expression .)
    CONST           reduce using rule 31 (global_var_dec -> VAR IDENTIFIER type ASSIGN expression .)
    FUNC            reduce using rule 31 (global_var_dec -> VAR IDENTIFIER type ASSIGN expression .)
    TYPE            reduce using rule 31 (global_var_dec -> VAR IDENTIFIER type ASSIGN expression .)
    $end            reduce using rule 31 (global_var_dec -> VAR IDENTIFIER type ASSIGN expression .)
    PLUS            shift and go to state 86
    MINUS           shift and go to state 87
    TIMES           shift and go to state 88
    DIVIDE          shift and go to state 89
    MODULE          shift and go to state 90
    EQ              shift and go to state 91
    NEQ             shift and go to state 92
    LT              shift and go to state 93
    LE              shift and go to state 94
    GT              shift and go to state 95
    GE              shift and go to state 96
    LAND            shift and go to state 97
    LOR             shift and go to state 98
    AND             shift and go to state 99
    OR              shift and go to state 100
    XOR             shift and go to state 101
    AND_NOT         shift and go to state 102
    LSHIFT          shift and go to state 103
    RSHIFT          shift and go to state 104


state 84

    (133) expression -> IDENTIFIER PLUSPLUS .

    PLUS            reduce using rule 133 (expression -> IDENTIFIER PLUSPLUS .)
    MINUS           reduce using rule 133 (expression -> IDENTIFIER PLUSPLUS .)
    TIMES           reduce using rule 133 (expression -> IDENTIFIER PLUSPLUS .)
    DIVIDE          reduce using rule 133 (expression -> IDENTIFIER PLUSPLUS .)
    MODULE          reduce using rule 133 (expression -> IDENTIFIER PLUSPLUS .)
    EQ              reduce using rule 133 (expression -> IDENTIFIER PLUSPLUS .)
    NEQ             reduce using rule 133 (expression -> IDENTIFIER PLUSPLUS .)
    LT              reduce using rule 133 (expression -> IDENTIFIER PLUSPLUS .)
    LE              reduce using rule 133 (expression -> IDENTIFIER PLUSPLUS .)
    GT              reduce using rule 133 (expression -> IDENTIFIER PLUSPLUS .)
    GE              reduce using rule 133 (expression -> IDENTIFIER PLUSPLUS .)
    LAND            reduce using rule 133 (expression -> IDENTIFIER PLUSPLUS .)
    LOR             reduce using rule 133 (expression -> IDENTIFIER PLUSPLUS .)
    AND             reduce using rule 133 (expression -> IDENTIFIER PLUSPLUS .)
    OR              reduce using rule 133 (expression -> IDENTIFIER PLUSPLUS .)
    XOR             reduce using rule 133 (expression -> IDENTIFIER PLUSPLUS .)
    AND_NOT         reduce using rule 133 (expression -> IDENTIFIER PLUSPLUS .)
    LSHIFT          reduce using rule 133 (expression -> IDENTIFIER PLUSPLUS .)
    RSHIFT          reduce using rule 133 (expression -> IDENTIFIER PLUSPLUS .)
    VAR             reduce using rule 133 (expression -> IDENTIFIER PLUSPLUS .)
    CONST           reduce using rule 133 (expression -> IDENTIFIER PLUSPLUS .)
    FUNC            reduce using rule 133 (expression -> IDENTIFIER PLUSPLUS .)
    TYPE            reduce using rule 133 (expression -> IDENTIFIER PLUSPLUS .)
    $end            reduce using rule 133 (expression -> IDENTIFIER PLUSPLUS .)
    RPAREN          reduce using rule 133 (expression -> IDENTIFIER PLUSPLUS .)
    RBRACE          reduce using rule 133 (expression -> IDENTIFIER PLUSPLUS .)
    COMMA           reduce using rule 133 (expression -> IDENTIFIER PLUSPLUS .)
    COLON           reduce using rule 133 (expression -> IDENTIFIER PLUSPLUS .)
    IDENTIFIER      reduce using rule 133 (expression -> IDENTIFIER PLUSPLUS .)
    LPAREN          reduce using rule 133 (expression -> IDENTIFIER PLUSPLUS .)
    LNOT            reduce using rule 133 (expression -> IDENTIFIER PLUSPLUS .)
    INT             reduce using rule 133 (expression -> IDENTIFIER PLUSPLUS .)
    FLOAT64         reduce using rule 133 (expression -> IDENTIFIER PLUSPLUS .)
    TRUE            reduce using rule 133 (expression -> IDENTIFIER PLUSPLUS .)
    FALSE           reduce using rule 133 (expression -> IDENTIFIER PLUSPLUS .)
    STRING          reduce using rule 133 (expression -> IDENTIFIER PLUSPLUS .)
    RETURN          reduce using rule 133 (expression -> IDENTIFIER PLUSPLUS .)
    IF              reduce using rule 133 (expression -> IDENTIFIER PLUSPLUS .)
    SWITCH          reduce using rule 133 (expression -> IDENTIFIER PLUSPLUS .)
    BREAK           reduce using rule 133 (expression -> IDENTIFIER PLUSPLUS .)
    CONTINUE        reduce using rule 133 (expression -> IDENTIFIER PLUSPLUS .)
    LBRACKET        reduce using rule 133 (expression -> IDENTIFIER PLUSPLUS .)
    MAP             reduce using rule 133 (expression -> IDENTIFIER PLUSPLUS .)
    FOR             reduce using rule 133 (expression -> IDENTIFIER PLUSPLUS .)
    CASE            reduce using rule 133 (expression -> IDENTIFIER PLUSPLUS .)
    DEFAULT         reduce using rule 133 (expression -> IDENTIFIER PLUSPLUS .)
    LBRACE          reduce using rule 133 (expression -> IDENTIFIER PLUSPLUS .)
    SEMICOLON       reduce using rule 133 (expression -> IDENTIFIER PLUSPLUS .)


state 85

    (134) expression -> IDENTIFIER MINUSMINUS .

    PLUS            reduce using rule 134 (expression -> IDENTIFIER MINUSMINUS .)
    MINUS           reduce using rule 134 (expression -> IDENTIFIER MINUSMINUS .)
    TIMES           reduce using rule 134 (expression -> IDENTIFIER MINUSMINUS .)
    DIVIDE          reduce using rule 134 (expression -> IDENTIFIER MINUSMINUS .)
    MODULE          reduce using rule 134 (expression -> IDENTIFIER MINUSMINUS .)
    EQ              reduce using rule 134 (expression -> IDENTIFIER MINUSMINUS .)
    NEQ             reduce using rule 134 (expression -> IDENTIFIER MINUSMINUS .)
    LT              reduce using rule 134 (expression -> IDENTIFIER MINUSMINUS .)
    LE              reduce using rule 134 (expression -> IDENTIFIER MINUSMINUS .)
    GT              reduce using rule 134 (expression -> IDENTIFIER MINUSMINUS .)
    GE              reduce using rule 134 (expression -> IDENTIFIER MINUSMINUS .)
    LAND            reduce using rule 134 (expression -> IDENTIFIER MINUSMINUS .)
    LOR             reduce using rule 134 (expression -> IDENTIFIER MINUSMINUS .)
    AND             reduce using rule 134 (expression -> IDENTIFIER MINUSMINUS .)
    OR              reduce using rule 134 (expression -> IDENTIFIER MINUSMINUS .)
    XOR             reduce using rule 134 (expression -> IDENTIFIER MINUSMINUS .)
    AND_NOT         reduce using rule 134 (expression -> IDENTIFIER MINUSMINUS .)
    LSHIFT          reduce using rule 134 (expression -> IDENTIFIER MINUSMINUS .)
    RSHIFT          reduce using rule 134 (expression -> IDENTIFIER MINUSMINUS .)
    VAR             reduce using rule 134 (expression -> IDENTIFIER MINUSMINUS .)
    CONST           reduce using rule 134 (expression -> IDENTIFIER MINUSMINUS .)
    FUNC            reduce using rule 134 (expression -> IDENTIFIER MINUSMINUS .)
    TYPE            reduce using rule 134 (expression -> IDENTIFIER MINUSMINUS .)
    $end            reduce using rule 134 (expression -> IDENTIFIER MINUSMINUS .)
    RPAREN          reduce using rule 134 (expression -> IDENTIFIER MINUSMINUS .)
    RBRACE          reduce using rule 134 (expression -> IDENTIFIER MINUSMINUS .)
    COMMA           reduce using rule 134 (expression -> IDENTIFIER MINUSMINUS .)
    COLON           reduce using rule 134 (expression -> IDENTIFIER MINUSMINUS .)
    IDENTIFIER      reduce using rule 134 (expression -> IDENTIFIER MINUSMINUS .)
    LPAREN          reduce using rule 134 (expression -> IDENTIFIER MINUSMINUS .)
    LNOT            reduce using rule 134 (expression -> IDENTIFIER MINUSMINUS .)
    INT             reduce using rule 134 (expression -> IDENTIFIER MINUSMINUS .)
    FLOAT64         reduce using rule 134 (expression -> IDENTIFIER MINUSMINUS .)
    TRUE            reduce using rule 134 (expression -> IDENTIFIER MINUSMINUS .)
    FALSE           reduce using rule 134 (expression -> IDENTIFIER MINUSMINUS .)
    STRING          reduce using rule 134 (expression -> IDENTIFIER MINUSMINUS .)
    RETURN          reduce using rule 134 (expression -> IDENTIFIER MINUSMINUS .)
    IF              reduce using rule 134 (expression -> IDENTIFIER MINUSMINUS .)
    SWITCH          reduce using rule 134 (expression -> IDENTIFIER MINUSMINUS .)
    BREAK           reduce using rule 134 (expression -> IDENTIFIER MINUSMINUS .)
    CONTINUE        reduce using rule 134 (expression -> IDENTIFIER MINUSMINUS .)
    LBRACKET        reduce using rule 134 (expression -> IDENTIFIER MINUSMINUS .)
    MAP             reduce using rule 134 (expression -> IDENTIFIER MINUSMINUS .)
    FOR             reduce using rule 134 (expression -> IDENTIFIER MINUSMINUS .)
    CASE            reduce using rule 134 (expression -> IDENTIFIER MINUSMINUS .)
    DEFAULT         reduce using rule 134 (expression -> IDENTIFIER MINUSMINUS .)
    LBRACE          reduce using rule 134 (expression -> IDENTIFIER MINUSMINUS .)
    SEMICOLON       reduce using rule 134 (expression -> IDENTIFIER MINUSMINUS .)


state 86

    (175) binary_expression -> expression PLUS . expression
    (57) expression -> . slice_type LBRACE expression_list RBRACE
    (58) expression -> . slice_type LBRACE RBRACE
    (61) expression -> . LPAREN expression RPAREN
    (120) expression -> . binary_expression
    (121) expression -> . relational_expression
    (122) expression -> . logical_expression
    (123) expression -> . bitwise_expression
    (124) expression -> . PLUS expression
    (125) expression -> . MINUS expression
    (126) expression -> . LNOT expression
    (127) expression -> . INT
    (128) expression -> . FLOAT64
    (129) expression -> . TRUE
    (130) expression -> . FALSE
    (131) expression -> . IDENTIFIER
    (132) expression -> . STRING
    (133) expression -> . IDENTIFIER PLUSPLUS
    (134) expression -> . IDENTIFIER MINUSMINUS
    (145) expression -> . map_type LBRACE expression_map_list RBRACE
    (146) expression -> . map_type LBRACE RBRACE
    (169) expression -> . type_name LBRACE keyed_element_list RBRACE
    (170) expression -> . type_name LBRACE RBRACE
    (56) slice_type -> . LBRACKET RBRACKET primitive_type
    (175) binary_expression -> . expression PLUS expression
    (176) binary_expression -> . expression MINUS expression
    (177) binary_expression -> . expression TIMES expression
    (178) binary_expression -> . expression DIVIDE expression
    (179) binary_expression -> . expression MODULE expression
    (184) relational_expression -> . expression EQ expression
    (185) relational_expression -> . expression NEQ expression
    (186) relational_expression -> . expression LT expression
    (187) relational_expression -> . expression LE expression
    (188) relational_expression -> . expression GT expression
    (189) relational_expression -> . expression GE expression
    (190) logical_expression -> . expression LAND expression
    (191) logical_expression -> . expression LOR expression
    (192) bitwise_expression -> . expression AND expression
    (193) bitwise_expression -> . expression OR expression
    (194) bitwise_expression -> . expression XOR expression
    (195) bitwise_expression -> . expression AND_NOT expression
    (196) bitwise_expression -> . expression LSHIFT expression
    (197) bitwise_expression -> . expression RSHIFT expression
    (144) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (171) type_name -> . IDENTIFIER
    (172) type_name -> . slice_type
    (173) type_name -> . array_type
    (174) type_name -> . map_type
    (119) array_type -> . LBRACKET INT RBRACKET type

    LPAREN          shift and go to state 54
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    LNOT            shift and go to state 61
    INT             shift and go to state 62
    FLOAT64         shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 66
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    expression                     shift and go to state 127
    slice_type                     shift and go to state 53
    binary_expression              shift and go to state 55
    relational_expression          shift and go to state 56
    logical_expression             shift and go to state 57
    bitwise_expression             shift and go to state 58
    map_type                       shift and go to state 67
    type_name                      shift and go to state 68
    array_type                     shift and go to state 69

state 87

    (176) binary_expression -> expression MINUS . expression
    (57) expression -> . slice_type LBRACE expression_list RBRACE
    (58) expression -> . slice_type LBRACE RBRACE
    (61) expression -> . LPAREN expression RPAREN
    (120) expression -> . binary_expression
    (121) expression -> . relational_expression
    (122) expression -> . logical_expression
    (123) expression -> . bitwise_expression
    (124) expression -> . PLUS expression
    (125) expression -> . MINUS expression
    (126) expression -> . LNOT expression
    (127) expression -> . INT
    (128) expression -> . FLOAT64
    (129) expression -> . TRUE
    (130) expression -> . FALSE
    (131) expression -> . IDENTIFIER
    (132) expression -> . STRING
    (133) expression -> . IDENTIFIER PLUSPLUS
    (134) expression -> . IDENTIFIER MINUSMINUS
    (145) expression -> . map_type LBRACE expression_map_list RBRACE
    (146) expression -> . map_type LBRACE RBRACE
    (169) expression -> . type_name LBRACE keyed_element_list RBRACE
    (170) expression -> . type_name LBRACE RBRACE
    (56) slice_type -> . LBRACKET RBRACKET primitive_type
    (175) binary_expression -> . expression PLUS expression
    (176) binary_expression -> . expression MINUS expression
    (177) binary_expression -> . expression TIMES expression
    (178) binary_expression -> . expression DIVIDE expression
    (179) binary_expression -> . expression MODULE expression
    (184) relational_expression -> . expression EQ expression
    (185) relational_expression -> . expression NEQ expression
    (186) relational_expression -> . expression LT expression
    (187) relational_expression -> . expression LE expression
    (188) relational_expression -> . expression GT expression
    (189) relational_expression -> . expression GE expression
    (190) logical_expression -> . expression LAND expression
    (191) logical_expression -> . expression LOR expression
    (192) bitwise_expression -> . expression AND expression
    (193) bitwise_expression -> . expression OR expression
    (194) bitwise_expression -> . expression XOR expression
    (195) bitwise_expression -> . expression AND_NOT expression
    (196) bitwise_expression -> . expression LSHIFT expression
    (197) bitwise_expression -> . expression RSHIFT expression
    (144) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (171) type_name -> . IDENTIFIER
    (172) type_name -> . slice_type
    (173) type_name -> . array_type
    (174) type_name -> . map_type
    (119) array_type -> . LBRACKET INT RBRACKET type

    LPAREN          shift and go to state 54
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    LNOT            shift and go to state 61
    INT             shift and go to state 62
    FLOAT64         shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 66
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    expression                     shift and go to state 128
    slice_type                     shift and go to state 53
    binary_expression              shift and go to state 55
    relational_expression          shift and go to state 56
    logical_expression             shift and go to state 57
    bitwise_expression             shift and go to state 58
    map_type                       shift and go to state 67
    type_name                      shift and go to state 68
    array_type                     shift and go to state 69

state 88

    (177) binary_expression -> expression TIMES . expression
    (57) expression -> . slice_type LBRACE expression_list RBRACE
    (58) expression -> . slice_type LBRACE RBRACE
    (61) expression -> . LPAREN expression RPAREN
    (120) expression -> . binary_expression
    (121) expression -> . relational_expression
    (122) expression -> . logical_expression
    (123) expression -> . bitwise_expression
    (124) expression -> . PLUS expression
    (125) expression -> . MINUS expression
    (126) expression -> . LNOT expression
    (127) expression -> . INT
    (128) expression -> . FLOAT64
    (129) expression -> . TRUE
    (130) expression -> . FALSE
    (131) expression -> . IDENTIFIER
    (132) expression -> . STRING
    (133) expression -> . IDENTIFIER PLUSPLUS
    (134) expression -> . IDENTIFIER MINUSMINUS
    (145) expression -> . map_type LBRACE expression_map_list RBRACE
    (146) expression -> . map_type LBRACE RBRACE
    (169) expression -> . type_name LBRACE keyed_element_list RBRACE
    (170) expression -> . type_name LBRACE RBRACE
    (56) slice_type -> . LBRACKET RBRACKET primitive_type
    (175) binary_expression -> . expression PLUS expression
    (176) binary_expression -> . expression MINUS expression
    (177) binary_expression -> . expression TIMES expression
    (178) binary_expression -> . expression DIVIDE expression
    (179) binary_expression -> . expression MODULE expression
    (184) relational_expression -> . expression EQ expression
    (185) relational_expression -> . expression NEQ expression
    (186) relational_expression -> . expression LT expression
    (187) relational_expression -> . expression LE expression
    (188) relational_expression -> . expression GT expression
    (189) relational_expression -> . expression GE expression
    (190) logical_expression -> . expression LAND expression
    (191) logical_expression -> . expression LOR expression
    (192) bitwise_expression -> . expression AND expression
    (193) bitwise_expression -> . expression OR expression
    (194) bitwise_expression -> . expression XOR expression
    (195) bitwise_expression -> . expression AND_NOT expression
    (196) bitwise_expression -> . expression LSHIFT expression
    (197) bitwise_expression -> . expression RSHIFT expression
    (144) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (171) type_name -> . IDENTIFIER
    (172) type_name -> . slice_type
    (173) type_name -> . array_type
    (174) type_name -> . map_type
    (119) array_type -> . LBRACKET INT RBRACKET type

    LPAREN          shift and go to state 54
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    LNOT            shift and go to state 61
    INT             shift and go to state 62
    FLOAT64         shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 66
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    expression                     shift and go to state 129
    slice_type                     shift and go to state 53
    binary_expression              shift and go to state 55
    relational_expression          shift and go to state 56
    logical_expression             shift and go to state 57
    bitwise_expression             shift and go to state 58
    map_type                       shift and go to state 67
    type_name                      shift and go to state 68
    array_type                     shift and go to state 69

state 89

    (178) binary_expression -> expression DIVIDE . expression
    (57) expression -> . slice_type LBRACE expression_list RBRACE
    (58) expression -> . slice_type LBRACE RBRACE
    (61) expression -> . LPAREN expression RPAREN
    (120) expression -> . binary_expression
    (121) expression -> . relational_expression
    (122) expression -> . logical_expression
    (123) expression -> . bitwise_expression
    (124) expression -> . PLUS expression
    (125) expression -> . MINUS expression
    (126) expression -> . LNOT expression
    (127) expression -> . INT
    (128) expression -> . FLOAT64
    (129) expression -> . TRUE
    (130) expression -> . FALSE
    (131) expression -> . IDENTIFIER
    (132) expression -> . STRING
    (133) expression -> . IDENTIFIER PLUSPLUS
    (134) expression -> . IDENTIFIER MINUSMINUS
    (145) expression -> . map_type LBRACE expression_map_list RBRACE
    (146) expression -> . map_type LBRACE RBRACE
    (169) expression -> . type_name LBRACE keyed_element_list RBRACE
    (170) expression -> . type_name LBRACE RBRACE
    (56) slice_type -> . LBRACKET RBRACKET primitive_type
    (175) binary_expression -> . expression PLUS expression
    (176) binary_expression -> . expression MINUS expression
    (177) binary_expression -> . expression TIMES expression
    (178) binary_expression -> . expression DIVIDE expression
    (179) binary_expression -> . expression MODULE expression
    (184) relational_expression -> . expression EQ expression
    (185) relational_expression -> . expression NEQ expression
    (186) relational_expression -> . expression LT expression
    (187) relational_expression -> . expression LE expression
    (188) relational_expression -> . expression GT expression
    (189) relational_expression -> . expression GE expression
    (190) logical_expression -> . expression LAND expression
    (191) logical_expression -> . expression LOR expression
    (192) bitwise_expression -> . expression AND expression
    (193) bitwise_expression -> . expression OR expression
    (194) bitwise_expression -> . expression XOR expression
    (195) bitwise_expression -> . expression AND_NOT expression
    (196) bitwise_expression -> . expression LSHIFT expression
    (197) bitwise_expression -> . expression RSHIFT expression
    (144) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (171) type_name -> . IDENTIFIER
    (172) type_name -> . slice_type
    (173) type_name -> . array_type
    (174) type_name -> . map_type
    (119) array_type -> . LBRACKET INT RBRACKET type

    LPAREN          shift and go to state 54
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    LNOT            shift and go to state 61
    INT             shift and go to state 62
    FLOAT64         shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 66
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    expression                     shift and go to state 130
    slice_type                     shift and go to state 53
    binary_expression              shift and go to state 55
    relational_expression          shift and go to state 56
    logical_expression             shift and go to state 57
    bitwise_expression             shift and go to state 58
    map_type                       shift and go to state 67
    type_name                      shift and go to state 68
    array_type                     shift and go to state 69

state 90

    (179) binary_expression -> expression MODULE . expression
    (57) expression -> . slice_type LBRACE expression_list RBRACE
    (58) expression -> . slice_type LBRACE RBRACE
    (61) expression -> . LPAREN expression RPAREN
    (120) expression -> . binary_expression
    (121) expression -> . relational_expression
    (122) expression -> . logical_expression
    (123) expression -> . bitwise_expression
    (124) expression -> . PLUS expression
    (125) expression -> . MINUS expression
    (126) expression -> . LNOT expression
    (127) expression -> . INT
    (128) expression -> . FLOAT64
    (129) expression -> . TRUE
    (130) expression -> . FALSE
    (131) expression -> . IDENTIFIER
    (132) expression -> . STRING
    (133) expression -> . IDENTIFIER PLUSPLUS
    (134) expression -> . IDENTIFIER MINUSMINUS
    (145) expression -> . map_type LBRACE expression_map_list RBRACE
    (146) expression -> . map_type LBRACE RBRACE
    (169) expression -> . type_name LBRACE keyed_element_list RBRACE
    (170) expression -> . type_name LBRACE RBRACE
    (56) slice_type -> . LBRACKET RBRACKET primitive_type
    (175) binary_expression -> . expression PLUS expression
    (176) binary_expression -> . expression MINUS expression
    (177) binary_expression -> . expression TIMES expression
    (178) binary_expression -> . expression DIVIDE expression
    (179) binary_expression -> . expression MODULE expression
    (184) relational_expression -> . expression EQ expression
    (185) relational_expression -> . expression NEQ expression
    (186) relational_expression -> . expression LT expression
    (187) relational_expression -> . expression LE expression
    (188) relational_expression -> . expression GT expression
    (189) relational_expression -> . expression GE expression
    (190) logical_expression -> . expression LAND expression
    (191) logical_expression -> . expression LOR expression
    (192) bitwise_expression -> . expression AND expression
    (193) bitwise_expression -> . expression OR expression
    (194) bitwise_expression -> . expression XOR expression
    (195) bitwise_expression -> . expression AND_NOT expression
    (196) bitwise_expression -> . expression LSHIFT expression
    (197) bitwise_expression -> . expression RSHIFT expression
    (144) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (171) type_name -> . IDENTIFIER
    (172) type_name -> . slice_type
    (173) type_name -> . array_type
    (174) type_name -> . map_type
    (119) array_type -> . LBRACKET INT RBRACKET type

    LPAREN          shift and go to state 54
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    LNOT            shift and go to state 61
    INT             shift and go to state 62
    FLOAT64         shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 66
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    expression                     shift and go to state 131
    slice_type                     shift and go to state 53
    binary_expression              shift and go to state 55
    relational_expression          shift and go to state 56
    logical_expression             shift and go to state 57
    bitwise_expression             shift and go to state 58
    map_type                       shift and go to state 67
    type_name                      shift and go to state 68
    array_type                     shift and go to state 69

state 91

    (184) relational_expression -> expression EQ . expression
    (57) expression -> . slice_type LBRACE expression_list RBRACE
    (58) expression -> . slice_type LBRACE RBRACE
    (61) expression -> . LPAREN expression RPAREN
    (120) expression -> . binary_expression
    (121) expression -> . relational_expression
    (122) expression -> . logical_expression
    (123) expression -> . bitwise_expression
    (124) expression -> . PLUS expression
    (125) expression -> . MINUS expression
    (126) expression -> . LNOT expression
    (127) expression -> . INT
    (128) expression -> . FLOAT64
    (129) expression -> . TRUE
    (130) expression -> . FALSE
    (131) expression -> . IDENTIFIER
    (132) expression -> . STRING
    (133) expression -> . IDENTIFIER PLUSPLUS
    (134) expression -> . IDENTIFIER MINUSMINUS
    (145) expression -> . map_type LBRACE expression_map_list RBRACE
    (146) expression -> . map_type LBRACE RBRACE
    (169) expression -> . type_name LBRACE keyed_element_list RBRACE
    (170) expression -> . type_name LBRACE RBRACE
    (56) slice_type -> . LBRACKET RBRACKET primitive_type
    (175) binary_expression -> . expression PLUS expression
    (176) binary_expression -> . expression MINUS expression
    (177) binary_expression -> . expression TIMES expression
    (178) binary_expression -> . expression DIVIDE expression
    (179) binary_expression -> . expression MODULE expression
    (184) relational_expression -> . expression EQ expression
    (185) relational_expression -> . expression NEQ expression
    (186) relational_expression -> . expression LT expression
    (187) relational_expression -> . expression LE expression
    (188) relational_expression -> . expression GT expression
    (189) relational_expression -> . expression GE expression
    (190) logical_expression -> . expression LAND expression
    (191) logical_expression -> . expression LOR expression
    (192) bitwise_expression -> . expression AND expression
    (193) bitwise_expression -> . expression OR expression
    (194) bitwise_expression -> . expression XOR expression
    (195) bitwise_expression -> . expression AND_NOT expression
    (196) bitwise_expression -> . expression LSHIFT expression
    (197) bitwise_expression -> . expression RSHIFT expression
    (144) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (171) type_name -> . IDENTIFIER
    (172) type_name -> . slice_type
    (173) type_name -> . array_type
    (174) type_name -> . map_type
    (119) array_type -> . LBRACKET INT RBRACKET type

    LPAREN          shift and go to state 54
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    LNOT            shift and go to state 61
    INT             shift and go to state 62
    FLOAT64         shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 66
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    expression                     shift and go to state 132
    slice_type                     shift and go to state 53
    binary_expression              shift and go to state 55
    relational_expression          shift and go to state 56
    logical_expression             shift and go to state 57
    bitwise_expression             shift and go to state 58
    map_type                       shift and go to state 67
    type_name                      shift and go to state 68
    array_type                     shift and go to state 69

state 92

    (185) relational_expression -> expression NEQ . expression
    (57) expression -> . slice_type LBRACE expression_list RBRACE
    (58) expression -> . slice_type LBRACE RBRACE
    (61) expression -> . LPAREN expression RPAREN
    (120) expression -> . binary_expression
    (121) expression -> . relational_expression
    (122) expression -> . logical_expression
    (123) expression -> . bitwise_expression
    (124) expression -> . PLUS expression
    (125) expression -> . MINUS expression
    (126) expression -> . LNOT expression
    (127) expression -> . INT
    (128) expression -> . FLOAT64
    (129) expression -> . TRUE
    (130) expression -> . FALSE
    (131) expression -> . IDENTIFIER
    (132) expression -> . STRING
    (133) expression -> . IDENTIFIER PLUSPLUS
    (134) expression -> . IDENTIFIER MINUSMINUS
    (145) expression -> . map_type LBRACE expression_map_list RBRACE
    (146) expression -> . map_type LBRACE RBRACE
    (169) expression -> . type_name LBRACE keyed_element_list RBRACE
    (170) expression -> . type_name LBRACE RBRACE
    (56) slice_type -> . LBRACKET RBRACKET primitive_type
    (175) binary_expression -> . expression PLUS expression
    (176) binary_expression -> . expression MINUS expression
    (177) binary_expression -> . expression TIMES expression
    (178) binary_expression -> . expression DIVIDE expression
    (179) binary_expression -> . expression MODULE expression
    (184) relational_expression -> . expression EQ expression
    (185) relational_expression -> . expression NEQ expression
    (186) relational_expression -> . expression LT expression
    (187) relational_expression -> . expression LE expression
    (188) relational_expression -> . expression GT expression
    (189) relational_expression -> . expression GE expression
    (190) logical_expression -> . expression LAND expression
    (191) logical_expression -> . expression LOR expression
    (192) bitwise_expression -> . expression AND expression
    (193) bitwise_expression -> . expression OR expression
    (194) bitwise_expression -> . expression XOR expression
    (195) bitwise_expression -> . expression AND_NOT expression
    (196) bitwise_expression -> . expression LSHIFT expression
    (197) bitwise_expression -> . expression RSHIFT expression
    (144) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (171) type_name -> . IDENTIFIER
    (172) type_name -> . slice_type
    (173) type_name -> . array_type
    (174) type_name -> . map_type
    (119) array_type -> . LBRACKET INT RBRACKET type

    LPAREN          shift and go to state 54
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    LNOT            shift and go to state 61
    INT             shift and go to state 62
    FLOAT64         shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 66
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    expression                     shift and go to state 133
    slice_type                     shift and go to state 53
    binary_expression              shift and go to state 55
    relational_expression          shift and go to state 56
    logical_expression             shift and go to state 57
    bitwise_expression             shift and go to state 58
    map_type                       shift and go to state 67
    type_name                      shift and go to state 68
    array_type                     shift and go to state 69

state 93

    (186) relational_expression -> expression LT . expression
    (57) expression -> . slice_type LBRACE expression_list RBRACE
    (58) expression -> . slice_type LBRACE RBRACE
    (61) expression -> . LPAREN expression RPAREN
    (120) expression -> . binary_expression
    (121) expression -> . relational_expression
    (122) expression -> . logical_expression
    (123) expression -> . bitwise_expression
    (124) expression -> . PLUS expression
    (125) expression -> . MINUS expression
    (126) expression -> . LNOT expression
    (127) expression -> . INT
    (128) expression -> . FLOAT64
    (129) expression -> . TRUE
    (130) expression -> . FALSE
    (131) expression -> . IDENTIFIER
    (132) expression -> . STRING
    (133) expression -> . IDENTIFIER PLUSPLUS
    (134) expression -> . IDENTIFIER MINUSMINUS
    (145) expression -> . map_type LBRACE expression_map_list RBRACE
    (146) expression -> . map_type LBRACE RBRACE
    (169) expression -> . type_name LBRACE keyed_element_list RBRACE
    (170) expression -> . type_name LBRACE RBRACE
    (56) slice_type -> . LBRACKET RBRACKET primitive_type
    (175) binary_expression -> . expression PLUS expression
    (176) binary_expression -> . expression MINUS expression
    (177) binary_expression -> . expression TIMES expression
    (178) binary_expression -> . expression DIVIDE expression
    (179) binary_expression -> . expression MODULE expression
    (184) relational_expression -> . expression EQ expression
    (185) relational_expression -> . expression NEQ expression
    (186) relational_expression -> . expression LT expression
    (187) relational_expression -> . expression LE expression
    (188) relational_expression -> . expression GT expression
    (189) relational_expression -> . expression GE expression
    (190) logical_expression -> . expression LAND expression
    (191) logical_expression -> . expression LOR expression
    (192) bitwise_expression -> . expression AND expression
    (193) bitwise_expression -> . expression OR expression
    (194) bitwise_expression -> . expression XOR expression
    (195) bitwise_expression -> . expression AND_NOT expression
    (196) bitwise_expression -> . expression LSHIFT expression
    (197) bitwise_expression -> . expression RSHIFT expression
    (144) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (171) type_name -> . IDENTIFIER
    (172) type_name -> . slice_type
    (173) type_name -> . array_type
    (174) type_name -> . map_type
    (119) array_type -> . LBRACKET INT RBRACKET type

    LPAREN          shift and go to state 54
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    LNOT            shift and go to state 61
    INT             shift and go to state 62
    FLOAT64         shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 66
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    expression                     shift and go to state 134
    slice_type                     shift and go to state 53
    binary_expression              shift and go to state 55
    relational_expression          shift and go to state 56
    logical_expression             shift and go to state 57
    bitwise_expression             shift and go to state 58
    map_type                       shift and go to state 67
    type_name                      shift and go to state 68
    array_type                     shift and go to state 69

state 94

    (187) relational_expression -> expression LE . expression
    (57) expression -> . slice_type LBRACE expression_list RBRACE
    (58) expression -> . slice_type LBRACE RBRACE
    (61) expression -> . LPAREN expression RPAREN
    (120) expression -> . binary_expression
    (121) expression -> . relational_expression
    (122) expression -> . logical_expression
    (123) expression -> . bitwise_expression
    (124) expression -> . PLUS expression
    (125) expression -> . MINUS expression
    (126) expression -> . LNOT expression
    (127) expression -> . INT
    (128) expression -> . FLOAT64
    (129) expression -> . TRUE
    (130) expression -> . FALSE
    (131) expression -> . IDENTIFIER
    (132) expression -> . STRING
    (133) expression -> . IDENTIFIER PLUSPLUS
    (134) expression -> . IDENTIFIER MINUSMINUS
    (145) expression -> . map_type LBRACE expression_map_list RBRACE
    (146) expression -> . map_type LBRACE RBRACE
    (169) expression -> . type_name LBRACE keyed_element_list RBRACE
    (170) expression -> . type_name LBRACE RBRACE
    (56) slice_type -> . LBRACKET RBRACKET primitive_type
    (175) binary_expression -> . expression PLUS expression
    (176) binary_expression -> . expression MINUS expression
    (177) binary_expression -> . expression TIMES expression
    (178) binary_expression -> . expression DIVIDE expression
    (179) binary_expression -> . expression MODULE expression
    (184) relational_expression -> . expression EQ expression
    (185) relational_expression -> . expression NEQ expression
    (186) relational_expression -> . expression LT expression
    (187) relational_expression -> . expression LE expression
    (188) relational_expression -> . expression GT expression
    (189) relational_expression -> . expression GE expression
    (190) logical_expression -> . expression LAND expression
    (191) logical_expression -> . expression LOR expression
    (192) bitwise_expression -> . expression AND expression
    (193) bitwise_expression -> . expression OR expression
    (194) bitwise_expression -> . expression XOR expression
    (195) bitwise_expression -> . expression AND_NOT expression
    (196) bitwise_expression -> . expression LSHIFT expression
    (197) bitwise_expression -> . expression RSHIFT expression
    (144) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (171) type_name -> . IDENTIFIER
    (172) type_name -> . slice_type
    (173) type_name -> . array_type
    (174) type_name -> . map_type
    (119) array_type -> . LBRACKET INT RBRACKET type

    LPAREN          shift and go to state 54
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    LNOT            shift and go to state 61
    INT             shift and go to state 62
    FLOAT64         shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 66
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    expression                     shift and go to state 135
    slice_type                     shift and go to state 53
    binary_expression              shift and go to state 55
    relational_expression          shift and go to state 56
    logical_expression             shift and go to state 57
    bitwise_expression             shift and go to state 58
    map_type                       shift and go to state 67
    type_name                      shift and go to state 68
    array_type                     shift and go to state 69

state 95

    (188) relational_expression -> expression GT . expression
    (57) expression -> . slice_type LBRACE expression_list RBRACE
    (58) expression -> . slice_type LBRACE RBRACE
    (61) expression -> . LPAREN expression RPAREN
    (120) expression -> . binary_expression
    (121) expression -> . relational_expression
    (122) expression -> . logical_expression
    (123) expression -> . bitwise_expression
    (124) expression -> . PLUS expression
    (125) expression -> . MINUS expression
    (126) expression -> . LNOT expression
    (127) expression -> . INT
    (128) expression -> . FLOAT64
    (129) expression -> . TRUE
    (130) expression -> . FALSE
    (131) expression -> . IDENTIFIER
    (132) expression -> . STRING
    (133) expression -> . IDENTIFIER PLUSPLUS
    (134) expression -> . IDENTIFIER MINUSMINUS
    (145) expression -> . map_type LBRACE expression_map_list RBRACE
    (146) expression -> . map_type LBRACE RBRACE
    (169) expression -> . type_name LBRACE keyed_element_list RBRACE
    (170) expression -> . type_name LBRACE RBRACE
    (56) slice_type -> . LBRACKET RBRACKET primitive_type
    (175) binary_expression -> . expression PLUS expression
    (176) binary_expression -> . expression MINUS expression
    (177) binary_expression -> . expression TIMES expression
    (178) binary_expression -> . expression DIVIDE expression
    (179) binary_expression -> . expression MODULE expression
    (184) relational_expression -> . expression EQ expression
    (185) relational_expression -> . expression NEQ expression
    (186) relational_expression -> . expression LT expression
    (187) relational_expression -> . expression LE expression
    (188) relational_expression -> . expression GT expression
    (189) relational_expression -> . expression GE expression
    (190) logical_expression -> . expression LAND expression
    (191) logical_expression -> . expression LOR expression
    (192) bitwise_expression -> . expression AND expression
    (193) bitwise_expression -> . expression OR expression
    (194) bitwise_expression -> . expression XOR expression
    (195) bitwise_expression -> . expression AND_NOT expression
    (196) bitwise_expression -> . expression LSHIFT expression
    (197) bitwise_expression -> . expression RSHIFT expression
    (144) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (171) type_name -> . IDENTIFIER
    (172) type_name -> . slice_type
    (173) type_name -> . array_type
    (174) type_name -> . map_type
    (119) array_type -> . LBRACKET INT RBRACKET type

    LPAREN          shift and go to state 54
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    LNOT            shift and go to state 61
    INT             shift and go to state 62
    FLOAT64         shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 66
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    expression                     shift and go to state 136
    slice_type                     shift and go to state 53
    binary_expression              shift and go to state 55
    relational_expression          shift and go to state 56
    logical_expression             shift and go to state 57
    bitwise_expression             shift and go to state 58
    map_type                       shift and go to state 67
    type_name                      shift and go to state 68
    array_type                     shift and go to state 69

state 96

    (189) relational_expression -> expression GE . expression
    (57) expression -> . slice_type LBRACE expression_list RBRACE
    (58) expression -> . slice_type LBRACE RBRACE
    (61) expression -> . LPAREN expression RPAREN
    (120) expression -> . binary_expression
    (121) expression -> . relational_expression
    (122) expression -> . logical_expression
    (123) expression -> . bitwise_expression
    (124) expression -> . PLUS expression
    (125) expression -> . MINUS expression
    (126) expression -> . LNOT expression
    (127) expression -> . INT
    (128) expression -> . FLOAT64
    (129) expression -> . TRUE
    (130) expression -> . FALSE
    (131) expression -> . IDENTIFIER
    (132) expression -> . STRING
    (133) expression -> . IDENTIFIER PLUSPLUS
    (134) expression -> . IDENTIFIER MINUSMINUS
    (145) expression -> . map_type LBRACE expression_map_list RBRACE
    (146) expression -> . map_type LBRACE RBRACE
    (169) expression -> . type_name LBRACE keyed_element_list RBRACE
    (170) expression -> . type_name LBRACE RBRACE
    (56) slice_type -> . LBRACKET RBRACKET primitive_type
    (175) binary_expression -> . expression PLUS expression
    (176) binary_expression -> . expression MINUS expression
    (177) binary_expression -> . expression TIMES expression
    (178) binary_expression -> . expression DIVIDE expression
    (179) binary_expression -> . expression MODULE expression
    (184) relational_expression -> . expression EQ expression
    (185) relational_expression -> . expression NEQ expression
    (186) relational_expression -> . expression LT expression
    (187) relational_expression -> . expression LE expression
    (188) relational_expression -> . expression GT expression
    (189) relational_expression -> . expression GE expression
    (190) logical_expression -> . expression LAND expression
    (191) logical_expression -> . expression LOR expression
    (192) bitwise_expression -> . expression AND expression
    (193) bitwise_expression -> . expression OR expression
    (194) bitwise_expression -> . expression XOR expression
    (195) bitwise_expression -> . expression AND_NOT expression
    (196) bitwise_expression -> . expression LSHIFT expression
    (197) bitwise_expression -> . expression RSHIFT expression
    (144) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (171) type_name -> . IDENTIFIER
    (172) type_name -> . slice_type
    (173) type_name -> . array_type
    (174) type_name -> . map_type
    (119) array_type -> . LBRACKET INT RBRACKET type

    LPAREN          shift and go to state 54
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    LNOT            shift and go to state 61
    INT             shift and go to state 62
    FLOAT64         shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 66
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    expression                     shift and go to state 137
    slice_type                     shift and go to state 53
    binary_expression              shift and go to state 55
    relational_expression          shift and go to state 56
    logical_expression             shift and go to state 57
    bitwise_expression             shift and go to state 58
    map_type                       shift and go to state 67
    type_name                      shift and go to state 68
    array_type                     shift and go to state 69

state 97

    (190) logical_expression -> expression LAND . expression
    (57) expression -> . slice_type LBRACE expression_list RBRACE
    (58) expression -> . slice_type LBRACE RBRACE
    (61) expression -> . LPAREN expression RPAREN
    (120) expression -> . binary_expression
    (121) expression -> . relational_expression
    (122) expression -> . logical_expression
    (123) expression -> . bitwise_expression
    (124) expression -> . PLUS expression
    (125) expression -> . MINUS expression
    (126) expression -> . LNOT expression
    (127) expression -> . INT
    (128) expression -> . FLOAT64
    (129) expression -> . TRUE
    (130) expression -> . FALSE
    (131) expression -> . IDENTIFIER
    (132) expression -> . STRING
    (133) expression -> . IDENTIFIER PLUSPLUS
    (134) expression -> . IDENTIFIER MINUSMINUS
    (145) expression -> . map_type LBRACE expression_map_list RBRACE
    (146) expression -> . map_type LBRACE RBRACE
    (169) expression -> . type_name LBRACE keyed_element_list RBRACE
    (170) expression -> . type_name LBRACE RBRACE
    (56) slice_type -> . LBRACKET RBRACKET primitive_type
    (175) binary_expression -> . expression PLUS expression
    (176) binary_expression -> . expression MINUS expression
    (177) binary_expression -> . expression TIMES expression
    (178) binary_expression -> . expression DIVIDE expression
    (179) binary_expression -> . expression MODULE expression
    (184) relational_expression -> . expression EQ expression
    (185) relational_expression -> . expression NEQ expression
    (186) relational_expression -> . expression LT expression
    (187) relational_expression -> . expression LE expression
    (188) relational_expression -> . expression GT expression
    (189) relational_expression -> . expression GE expression
    (190) logical_expression -> . expression LAND expression
    (191) logical_expression -> . expression LOR expression
    (192) bitwise_expression -> . expression AND expression
    (193) bitwise_expression -> . expression OR expression
    (194) bitwise_expression -> . expression XOR expression
    (195) bitwise_expression -> . expression AND_NOT expression
    (196) bitwise_expression -> . expression LSHIFT expression
    (197) bitwise_expression -> . expression RSHIFT expression
    (144) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (171) type_name -> . IDENTIFIER
    (172) type_name -> . slice_type
    (173) type_name -> . array_type
    (174) type_name -> . map_type
    (119) array_type -> . LBRACKET INT RBRACKET type

    LPAREN          shift and go to state 54
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    LNOT            shift and go to state 61
    INT             shift and go to state 62
    FLOAT64         shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 66
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    expression                     shift and go to state 138
    slice_type                     shift and go to state 53
    binary_expression              shift and go to state 55
    relational_expression          shift and go to state 56
    logical_expression             shift and go to state 57
    bitwise_expression             shift and go to state 58
    map_type                       shift and go to state 67
    type_name                      shift and go to state 68
    array_type                     shift and go to state 69

state 98

    (191) logical_expression -> expression LOR . expression
    (57) expression -> . slice_type LBRACE expression_list RBRACE
    (58) expression -> . slice_type LBRACE RBRACE
    (61) expression -> . LPAREN expression RPAREN
    (120) expression -> . binary_expression
    (121) expression -> . relational_expression
    (122) expression -> . logical_expression
    (123) expression -> . bitwise_expression
    (124) expression -> . PLUS expression
    (125) expression -> . MINUS expression
    (126) expression -> . LNOT expression
    (127) expression -> . INT
    (128) expression -> . FLOAT64
    (129) expression -> . TRUE
    (130) expression -> . FALSE
    (131) expression -> . IDENTIFIER
    (132) expression -> . STRING
    (133) expression -> . IDENTIFIER PLUSPLUS
    (134) expression -> . IDENTIFIER MINUSMINUS
    (145) expression -> . map_type LBRACE expression_map_list RBRACE
    (146) expression -> . map_type LBRACE RBRACE
    (169) expression -> . type_name LBRACE keyed_element_list RBRACE
    (170) expression -> . type_name LBRACE RBRACE
    (56) slice_type -> . LBRACKET RBRACKET primitive_type
    (175) binary_expression -> . expression PLUS expression
    (176) binary_expression -> . expression MINUS expression
    (177) binary_expression -> . expression TIMES expression
    (178) binary_expression -> . expression DIVIDE expression
    (179) binary_expression -> . expression MODULE expression
    (184) relational_expression -> . expression EQ expression
    (185) relational_expression -> . expression NEQ expression
    (186) relational_expression -> . expression LT expression
    (187) relational_expression -> . expression LE expression
    (188) relational_expression -> . expression GT expression
    (189) relational_expression -> . expression GE expression
    (190) logical_expression -> . expression LAND expression
    (191) logical_expression -> . expression LOR expression
    (192) bitwise_expression -> . expression AND expression
    (193) bitwise_expression -> . expression OR expression
    (194) bitwise_expression -> . expression XOR expression
    (195) bitwise_expression -> . expression AND_NOT expression
    (196) bitwise_expression -> . expression LSHIFT expression
    (197) bitwise_expression -> . expression RSHIFT expression
    (144) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (171) type_name -> . IDENTIFIER
    (172) type_name -> . slice_type
    (173) type_name -> . array_type
    (174) type_name -> . map_type
    (119) array_type -> . LBRACKET INT RBRACKET type

    LPAREN          shift and go to state 54
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    LNOT            shift and go to state 61
    INT             shift and go to state 62
    FLOAT64         shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 66
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    expression                     shift and go to state 139
    slice_type                     shift and go to state 53
    binary_expression              shift and go to state 55
    relational_expression          shift and go to state 56
    logical_expression             shift and go to state 57
    bitwise_expression             shift and go to state 58
    map_type                       shift and go to state 67
    type_name                      shift and go to state 68
    array_type                     shift and go to state 69

state 99

    (192) bitwise_expression -> expression AND . expression
    (57) expression -> . slice_type LBRACE expression_list RBRACE
    (58) expression -> . slice_type LBRACE RBRACE
    (61) expression -> . LPAREN expression RPAREN
    (120) expression -> . binary_expression
    (121) expression -> . relational_expression
    (122) expression -> . logical_expression
    (123) expression -> . bitwise_expression
    (124) expression -> . PLUS expression
    (125) expression -> . MINUS expression
    (126) expression -> . LNOT expression
    (127) expression -> . INT
    (128) expression -> . FLOAT64
    (129) expression -> . TRUE
    (130) expression -> . FALSE
    (131) expression -> . IDENTIFIER
    (132) expression -> . STRING
    (133) expression -> . IDENTIFIER PLUSPLUS
    (134) expression -> . IDENTIFIER MINUSMINUS
    (145) expression -> . map_type LBRACE expression_map_list RBRACE
    (146) expression -> . map_type LBRACE RBRACE
    (169) expression -> . type_name LBRACE keyed_element_list RBRACE
    (170) expression -> . type_name LBRACE RBRACE
    (56) slice_type -> . LBRACKET RBRACKET primitive_type
    (175) binary_expression -> . expression PLUS expression
    (176) binary_expression -> . expression MINUS expression
    (177) binary_expression -> . expression TIMES expression
    (178) binary_expression -> . expression DIVIDE expression
    (179) binary_expression -> . expression MODULE expression
    (184) relational_expression -> . expression EQ expression
    (185) relational_expression -> . expression NEQ expression
    (186) relational_expression -> . expression LT expression
    (187) relational_expression -> . expression LE expression
    (188) relational_expression -> . expression GT expression
    (189) relational_expression -> . expression GE expression
    (190) logical_expression -> . expression LAND expression
    (191) logical_expression -> . expression LOR expression
    (192) bitwise_expression -> . expression AND expression
    (193) bitwise_expression -> . expression OR expression
    (194) bitwise_expression -> . expression XOR expression
    (195) bitwise_expression -> . expression AND_NOT expression
    (196) bitwise_expression -> . expression LSHIFT expression
    (197) bitwise_expression -> . expression RSHIFT expression
    (144) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (171) type_name -> . IDENTIFIER
    (172) type_name -> . slice_type
    (173) type_name -> . array_type
    (174) type_name -> . map_type
    (119) array_type -> . LBRACKET INT RBRACKET type

    LPAREN          shift and go to state 54
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    LNOT            shift and go to state 61
    INT             shift and go to state 62
    FLOAT64         shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 66
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    expression                     shift and go to state 140
    slice_type                     shift and go to state 53
    binary_expression              shift and go to state 55
    relational_expression          shift and go to state 56
    logical_expression             shift and go to state 57
    bitwise_expression             shift and go to state 58
    map_type                       shift and go to state 67
    type_name                      shift and go to state 68
    array_type                     shift and go to state 69

state 100

    (193) bitwise_expression -> expression OR . expression
    (57) expression -> . slice_type LBRACE expression_list RBRACE
    (58) expression -> . slice_type LBRACE RBRACE
    (61) expression -> . LPAREN expression RPAREN
    (120) expression -> . binary_expression
    (121) expression -> . relational_expression
    (122) expression -> . logical_expression
    (123) expression -> . bitwise_expression
    (124) expression -> . PLUS expression
    (125) expression -> . MINUS expression
    (126) expression -> . LNOT expression
    (127) expression -> . INT
    (128) expression -> . FLOAT64
    (129) expression -> . TRUE
    (130) expression -> . FALSE
    (131) expression -> . IDENTIFIER
    (132) expression -> . STRING
    (133) expression -> . IDENTIFIER PLUSPLUS
    (134) expression -> . IDENTIFIER MINUSMINUS
    (145) expression -> . map_type LBRACE expression_map_list RBRACE
    (146) expression -> . map_type LBRACE RBRACE
    (169) expression -> . type_name LBRACE keyed_element_list RBRACE
    (170) expression -> . type_name LBRACE RBRACE
    (56) slice_type -> . LBRACKET RBRACKET primitive_type
    (175) binary_expression -> . expression PLUS expression
    (176) binary_expression -> . expression MINUS expression
    (177) binary_expression -> . expression TIMES expression
    (178) binary_expression -> . expression DIVIDE expression
    (179) binary_expression -> . expression MODULE expression
    (184) relational_expression -> . expression EQ expression
    (185) relational_expression -> . expression NEQ expression
    (186) relational_expression -> . expression LT expression
    (187) relational_expression -> . expression LE expression
    (188) relational_expression -> . expression GT expression
    (189) relational_expression -> . expression GE expression
    (190) logical_expression -> . expression LAND expression
    (191) logical_expression -> . expression LOR expression
    (192) bitwise_expression -> . expression AND expression
    (193) bitwise_expression -> . expression OR expression
    (194) bitwise_expression -> . expression XOR expression
    (195) bitwise_expression -> . expression AND_NOT expression
    (196) bitwise_expression -> . expression LSHIFT expression
    (197) bitwise_expression -> . expression RSHIFT expression
    (144) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (171) type_name -> . IDENTIFIER
    (172) type_name -> . slice_type
    (173) type_name -> . array_type
    (174) type_name -> . map_type
    (119) array_type -> . LBRACKET INT RBRACKET type

    LPAREN          shift and go to state 54
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    LNOT            shift and go to state 61
    INT             shift and go to state 62
    FLOAT64         shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 66
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    expression                     shift and go to state 141
    slice_type                     shift and go to state 53
    binary_expression              shift and go to state 55
    relational_expression          shift and go to state 56
    logical_expression             shift and go to state 57
    bitwise_expression             shift and go to state 58
    map_type                       shift and go to state 67
    type_name                      shift and go to state 68
    array_type                     shift and go to state 69

state 101

    (194) bitwise_expression -> expression XOR . expression
    (57) expression -> . slice_type LBRACE expression_list RBRACE
    (58) expression -> . slice_type LBRACE RBRACE
    (61) expression -> . LPAREN expression RPAREN
    (120) expression -> . binary_expression
    (121) expression -> . relational_expression
    (122) expression -> . logical_expression
    (123) expression -> . bitwise_expression
    (124) expression -> . PLUS expression
    (125) expression -> . MINUS expression
    (126) expression -> . LNOT expression
    (127) expression -> . INT
    (128) expression -> . FLOAT64
    (129) expression -> . TRUE
    (130) expression -> . FALSE
    (131) expression -> . IDENTIFIER
    (132) expression -> . STRING
    (133) expression -> . IDENTIFIER PLUSPLUS
    (134) expression -> . IDENTIFIER MINUSMINUS
    (145) expression -> . map_type LBRACE expression_map_list RBRACE
    (146) expression -> . map_type LBRACE RBRACE
    (169) expression -> . type_name LBRACE keyed_element_list RBRACE
    (170) expression -> . type_name LBRACE RBRACE
    (56) slice_type -> . LBRACKET RBRACKET primitive_type
    (175) binary_expression -> . expression PLUS expression
    (176) binary_expression -> . expression MINUS expression
    (177) binary_expression -> . expression TIMES expression
    (178) binary_expression -> . expression DIVIDE expression
    (179) binary_expression -> . expression MODULE expression
    (184) relational_expression -> . expression EQ expression
    (185) relational_expression -> . expression NEQ expression
    (186) relational_expression -> . expression LT expression
    (187) relational_expression -> . expression LE expression
    (188) relational_expression -> . expression GT expression
    (189) relational_expression -> . expression GE expression
    (190) logical_expression -> . expression LAND expression
    (191) logical_expression -> . expression LOR expression
    (192) bitwise_expression -> . expression AND expression
    (193) bitwise_expression -> . expression OR expression
    (194) bitwise_expression -> . expression XOR expression
    (195) bitwise_expression -> . expression AND_NOT expression
    (196) bitwise_expression -> . expression LSHIFT expression
    (197) bitwise_expression -> . expression RSHIFT expression
    (144) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (171) type_name -> . IDENTIFIER
    (172) type_name -> . slice_type
    (173) type_name -> . array_type
    (174) type_name -> . map_type
    (119) array_type -> . LBRACKET INT RBRACKET type

    LPAREN          shift and go to state 54
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    LNOT            shift and go to state 61
    INT             shift and go to state 62
    FLOAT64         shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 66
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    expression                     shift and go to state 142
    slice_type                     shift and go to state 53
    binary_expression              shift and go to state 55
    relational_expression          shift and go to state 56
    logical_expression             shift and go to state 57
    bitwise_expression             shift and go to state 58
    map_type                       shift and go to state 67
    type_name                      shift and go to state 68
    array_type                     shift and go to state 69

state 102

    (195) bitwise_expression -> expression AND_NOT . expression
    (57) expression -> . slice_type LBRACE expression_list RBRACE
    (58) expression -> . slice_type LBRACE RBRACE
    (61) expression -> . LPAREN expression RPAREN
    (120) expression -> . binary_expression
    (121) expression -> . relational_expression
    (122) expression -> . logical_expression
    (123) expression -> . bitwise_expression
    (124) expression -> . PLUS expression
    (125) expression -> . MINUS expression
    (126) expression -> . LNOT expression
    (127) expression -> . INT
    (128) expression -> . FLOAT64
    (129) expression -> . TRUE
    (130) expression -> . FALSE
    (131) expression -> . IDENTIFIER
    (132) expression -> . STRING
    (133) expression -> . IDENTIFIER PLUSPLUS
    (134) expression -> . IDENTIFIER MINUSMINUS
    (145) expression -> . map_type LBRACE expression_map_list RBRACE
    (146) expression -> . map_type LBRACE RBRACE
    (169) expression -> . type_name LBRACE keyed_element_list RBRACE
    (170) expression -> . type_name LBRACE RBRACE
    (56) slice_type -> . LBRACKET RBRACKET primitive_type
    (175) binary_expression -> . expression PLUS expression
    (176) binary_expression -> . expression MINUS expression
    (177) binary_expression -> . expression TIMES expression
    (178) binary_expression -> . expression DIVIDE expression
    (179) binary_expression -> . expression MODULE expression
    (184) relational_expression -> . expression EQ expression
    (185) relational_expression -> . expression NEQ expression
    (186) relational_expression -> . expression LT expression
    (187) relational_expression -> . expression LE expression
    (188) relational_expression -> . expression GT expression
    (189) relational_expression -> . expression GE expression
    (190) logical_expression -> . expression LAND expression
    (191) logical_expression -> . expression LOR expression
    (192) bitwise_expression -> . expression AND expression
    (193) bitwise_expression -> . expression OR expression
    (194) bitwise_expression -> . expression XOR expression
    (195) bitwise_expression -> . expression AND_NOT expression
    (196) bitwise_expression -> . expression LSHIFT expression
    (197) bitwise_expression -> . expression RSHIFT expression
    (144) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (171) type_name -> . IDENTIFIER
    (172) type_name -> . slice_type
    (173) type_name -> . array_type
    (174) type_name -> . map_type
    (119) array_type -> . LBRACKET INT RBRACKET type

    LPAREN          shift and go to state 54
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    LNOT            shift and go to state 61
    INT             shift and go to state 62
    FLOAT64         shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 66
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    expression                     shift and go to state 143
    slice_type                     shift and go to state 53
    binary_expression              shift and go to state 55
    relational_expression          shift and go to state 56
    logical_expression             shift and go to state 57
    bitwise_expression             shift and go to state 58
    map_type                       shift and go to state 67
    type_name                      shift and go to state 68
    array_type                     shift and go to state 69

state 103

    (196) bitwise_expression -> expression LSHIFT . expression
    (57) expression -> . slice_type LBRACE expression_list RBRACE
    (58) expression -> . slice_type LBRACE RBRACE
    (61) expression -> . LPAREN expression RPAREN
    (120) expression -> . binary_expression
    (121) expression -> . relational_expression
    (122) expression -> . logical_expression
    (123) expression -> . bitwise_expression
    (124) expression -> . PLUS expression
    (125) expression -> . MINUS expression
    (126) expression -> . LNOT expression
    (127) expression -> . INT
    (128) expression -> . FLOAT64
    (129) expression -> . TRUE
    (130) expression -> . FALSE
    (131) expression -> . IDENTIFIER
    (132) expression -> . STRING
    (133) expression -> . IDENTIFIER PLUSPLUS
    (134) expression -> . IDENTIFIER MINUSMINUS
    (145) expression -> . map_type LBRACE expression_map_list RBRACE
    (146) expression -> . map_type LBRACE RBRACE
    (169) expression -> . type_name LBRACE keyed_element_list RBRACE
    (170) expression -> . type_name LBRACE RBRACE
    (56) slice_type -> . LBRACKET RBRACKET primitive_type
    (175) binary_expression -> . expression PLUS expression
    (176) binary_expression -> . expression MINUS expression
    (177) binary_expression -> . expression TIMES expression
    (178) binary_expression -> . expression DIVIDE expression
    (179) binary_expression -> . expression MODULE expression
    (184) relational_expression -> . expression EQ expression
    (185) relational_expression -> . expression NEQ expression
    (186) relational_expression -> . expression LT expression
    (187) relational_expression -> . expression LE expression
    (188) relational_expression -> . expression GT expression
    (189) relational_expression -> . expression GE expression
    (190) logical_expression -> . expression LAND expression
    (191) logical_expression -> . expression LOR expression
    (192) bitwise_expression -> . expression AND expression
    (193) bitwise_expression -> . expression OR expression
    (194) bitwise_expression -> . expression XOR expression
    (195) bitwise_expression -> . expression AND_NOT expression
    (196) bitwise_expression -> . expression LSHIFT expression
    (197) bitwise_expression -> . expression RSHIFT expression
    (144) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (171) type_name -> . IDENTIFIER
    (172) type_name -> . slice_type
    (173) type_name -> . array_type
    (174) type_name -> . map_type
    (119) array_type -> . LBRACKET INT RBRACKET type

    LPAREN          shift and go to state 54
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    LNOT            shift and go to state 61
    INT             shift and go to state 62
    FLOAT64         shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 66
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    expression                     shift and go to state 144
    slice_type                     shift and go to state 53
    binary_expression              shift and go to state 55
    relational_expression          shift and go to state 56
    logical_expression             shift and go to state 57
    bitwise_expression             shift and go to state 58
    map_type                       shift and go to state 67
    type_name                      shift and go to state 68
    array_type                     shift and go to state 69

state 104

    (197) bitwise_expression -> expression RSHIFT . expression
    (57) expression -> . slice_type LBRACE expression_list RBRACE
    (58) expression -> . slice_type LBRACE RBRACE
    (61) expression -> . LPAREN expression RPAREN
    (120) expression -> . binary_expression
    (121) expression -> . relational_expression
    (122) expression -> . logical_expression
    (123) expression -> . bitwise_expression
    (124) expression -> . PLUS expression
    (125) expression -> . MINUS expression
    (126) expression -> . LNOT expression
    (127) expression -> . INT
    (128) expression -> . FLOAT64
    (129) expression -> . TRUE
    (130) expression -> . FALSE
    (131) expression -> . IDENTIFIER
    (132) expression -> . STRING
    (133) expression -> . IDENTIFIER PLUSPLUS
    (134) expression -> . IDENTIFIER MINUSMINUS
    (145) expression -> . map_type LBRACE expression_map_list RBRACE
    (146) expression -> . map_type LBRACE RBRACE
    (169) expression -> . type_name LBRACE keyed_element_list RBRACE
    (170) expression -> . type_name LBRACE RBRACE
    (56) slice_type -> . LBRACKET RBRACKET primitive_type
    (175) binary_expression -> . expression PLUS expression
    (176) binary_expression -> . expression MINUS expression
    (177) binary_expression -> . expression TIMES expression
    (178) binary_expression -> . expression DIVIDE expression
    (179) binary_expression -> . expression MODULE expression
    (184) relational_expression -> . expression EQ expression
    (185) relational_expression -> . expression NEQ expression
    (186) relational_expression -> . expression LT expression
    (187) relational_expression -> . expression LE expression
    (188) relational_expression -> . expression GT expression
    (189) relational_expression -> . expression GE expression
    (190) logical_expression -> . expression LAND expression
    (191) logical_expression -> . expression LOR expression
    (192) bitwise_expression -> . expression AND expression
    (193) bitwise_expression -> . expression OR expression
    (194) bitwise_expression -> . expression XOR expression
    (195) bitwise_expression -> . expression AND_NOT expression
    (196) bitwise_expression -> . expression LSHIFT expression
    (197) bitwise_expression -> . expression RSHIFT expression
    (144) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (171) type_name -> . IDENTIFIER
    (172) type_name -> . slice_type
    (173) type_name -> . array_type
    (174) type_name -> . map_type
    (119) array_type -> . LBRACKET INT RBRACKET type

    LPAREN          shift and go to state 54
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    LNOT            shift and go to state 61
    INT             shift and go to state 62
    FLOAT64         shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 66
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    expression                     shift and go to state 145
    slice_type                     shift and go to state 53
    binary_expression              shift and go to state 55
    relational_expression          shift and go to state 56
    logical_expression             shift and go to state 57
    bitwise_expression             shift and go to state 58
    map_type                       shift and go to state 67
    type_name                      shift and go to state 68
    array_type                     shift and go to state 69

state 105

    (57) expression -> slice_type LBRACE . expression_list RBRACE
    (58) expression -> slice_type LBRACE . RBRACE
    (59) expression_list -> . expression
    (60) expression_list -> . expression_list COMMA expression
    (57) expression -> . slice_type LBRACE expression_list RBRACE
    (58) expression -> . slice_type LBRACE RBRACE
    (61) expression -> . LPAREN expression RPAREN
    (120) expression -> . binary_expression
    (121) expression -> . relational_expression
    (122) expression -> . logical_expression
    (123) expression -> . bitwise_expression
    (124) expression -> . PLUS expression
    (125) expression -> . MINUS expression
    (126) expression -> . LNOT expression
    (127) expression -> . INT
    (128) expression -> . FLOAT64
    (129) expression -> . TRUE
    (130) expression -> . FALSE
    (131) expression -> . IDENTIFIER
    (132) expression -> . STRING
    (133) expression -> . IDENTIFIER PLUSPLUS
    (134) expression -> . IDENTIFIER MINUSMINUS
    (145) expression -> . map_type LBRACE expression_map_list RBRACE
    (146) expression -> . map_type LBRACE RBRACE
    (169) expression -> . type_name LBRACE keyed_element_list RBRACE
    (170) expression -> . type_name LBRACE RBRACE
    (56) slice_type -> . LBRACKET RBRACKET primitive_type
    (175) binary_expression -> . expression PLUS expression
    (176) binary_expression -> . expression MINUS expression
    (177) binary_expression -> . expression TIMES expression
    (178) binary_expression -> . expression DIVIDE expression
    (179) binary_expression -> . expression MODULE expression
    (184) relational_expression -> . expression EQ expression
    (185) relational_expression -> . expression NEQ expression
    (186) relational_expression -> . expression LT expression
    (187) relational_expression -> . expression LE expression
    (188) relational_expression -> . expression GT expression
    (189) relational_expression -> . expression GE expression
    (190) logical_expression -> . expression LAND expression
    (191) logical_expression -> . expression LOR expression
    (192) bitwise_expression -> . expression AND expression
    (193) bitwise_expression -> . expression OR expression
    (194) bitwise_expression -> . expression XOR expression
    (195) bitwise_expression -> . expression AND_NOT expression
    (196) bitwise_expression -> . expression LSHIFT expression
    (197) bitwise_expression -> . expression RSHIFT expression
    (144) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (171) type_name -> . IDENTIFIER
    (172) type_name -> . slice_type
    (173) type_name -> . array_type
    (174) type_name -> . map_type
    (119) array_type -> . LBRACKET INT RBRACKET type

    RBRACE          shift and go to state 147
    LPAREN          shift and go to state 54
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    LNOT            shift and go to state 61
    INT             shift and go to state 62
    FLOAT64         shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 66
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    slice_type                     shift and go to state 53
    expression_list                shift and go to state 146
    expression                     shift and go to state 148
    binary_expression              shift and go to state 55
    relational_expression          shift and go to state 56
    logical_expression             shift and go to state 57
    bitwise_expression             shift and go to state 58
    map_type                       shift and go to state 67
    type_name                      shift and go to state 68
    array_type                     shift and go to state 69

state 106

    (61) expression -> LPAREN expression . RPAREN
    (175) binary_expression -> expression . PLUS expression
    (176) binary_expression -> expression . MINUS expression
    (177) binary_expression -> expression . TIMES expression
    (178) binary_expression -> expression . DIVIDE expression
    (179) binary_expression -> expression . MODULE expression
    (184) relational_expression -> expression . EQ expression
    (185) relational_expression -> expression . NEQ expression
    (186) relational_expression -> expression . LT expression
    (187) relational_expression -> expression . LE expression
    (188) relational_expression -> expression . GT expression
    (189) relational_expression -> expression . GE expression
    (190) logical_expression -> expression . LAND expression
    (191) logical_expression -> expression . LOR expression
    (192) bitwise_expression -> expression . AND expression
    (193) bitwise_expression -> expression . OR expression
    (194) bitwise_expression -> expression . XOR expression
    (195) bitwise_expression -> expression . AND_NOT expression
    (196) bitwise_expression -> expression . LSHIFT expression
    (197) bitwise_expression -> expression . RSHIFT expression

    RPAREN          shift and go to state 149
    PLUS            shift and go to state 86
    MINUS           shift and go to state 87
    TIMES           shift and go to state 88
    DIVIDE          shift and go to state 89
    MODULE          shift and go to state 90
    EQ              shift and go to state 91
    NEQ             shift and go to state 92
    LT              shift and go to state 93
    LE              shift and go to state 94
    GT              shift and go to state 95
    GE              shift and go to state 96
    LAND            shift and go to state 97
    LOR             shift and go to state 98
    AND             shift and go to state 99
    OR              shift and go to state 100
    XOR             shift and go to state 101
    AND_NOT         shift and go to state 102
    LSHIFT          shift and go to state 103
    RSHIFT          shift and go to state 104


state 107

    (124) expression -> PLUS expression .
    (175) binary_expression -> expression . PLUS expression
    (176) binary_expression -> expression . MINUS expression
    (177) binary_expression -> expression . TIMES expression
    (178) binary_expression -> expression . DIVIDE expression
    (179) binary_expression -> expression . MODULE expression
    (184) relational_expression -> expression . EQ expression
    (185) relational_expression -> expression . NEQ expression
    (186) relational_expression -> expression . LT expression
    (187) relational_expression -> expression . LE expression
    (188) relational_expression -> expression . GT expression
    (189) relational_expression -> expression . GE expression
    (190) logical_expression -> expression . LAND expression
    (191) logical_expression -> expression . LOR expression
    (192) bitwise_expression -> expression . AND expression
    (193) bitwise_expression -> expression . OR expression
    (194) bitwise_expression -> expression . XOR expression
    (195) bitwise_expression -> expression . AND_NOT expression
    (196) bitwise_expression -> expression . LSHIFT expression
    (197) bitwise_expression -> expression . RSHIFT expression

    AND_NOT         reduce using rule 124 (expression -> PLUS expression .)
    VAR             reduce using rule 124 (expression -> PLUS expression .)
    CONST           reduce using rule 124 (expression -> PLUS expression .)
    FUNC            reduce using rule 124 (expression -> PLUS expression .)
    TYPE            reduce using rule 124 (expression -> PLUS expression .)
    $end            reduce using rule 124 (expression -> PLUS expression .)
    RPAREN          reduce using rule 124 (expression -> PLUS expression .)
    RBRACE          reduce using rule 124 (expression -> PLUS expression .)
    COMMA           reduce using rule 124 (expression -> PLUS expression .)
    COLON           reduce using rule 124 (expression -> PLUS expression .)
    IDENTIFIER      reduce using rule 124 (expression -> PLUS expression .)
    LPAREN          reduce using rule 124 (expression -> PLUS expression .)
    LNOT            reduce using rule 124 (expression -> PLUS expression .)
    INT             reduce using rule 124 (expression -> PLUS expression .)
    FLOAT64         reduce using rule 124 (expression -> PLUS expression .)
    TRUE            reduce using rule 124 (expression -> PLUS expression .)
    FALSE           reduce using rule 124 (expression -> PLUS expression .)
    STRING          reduce using rule 124 (expression -> PLUS expression .)
    RETURN          reduce using rule 124 (expression -> PLUS expression .)
    IF              reduce using rule 124 (expression -> PLUS expression .)
    SWITCH          reduce using rule 124 (expression -> PLUS expression .)
    BREAK           reduce using rule 124 (expression -> PLUS expression .)
    CONTINUE        reduce using rule 124 (expression -> PLUS expression .)
    LBRACKET        reduce using rule 124 (expression -> PLUS expression .)
    MAP             reduce using rule 124 (expression -> PLUS expression .)
    FOR             reduce using rule 124 (expression -> PLUS expression .)
    CASE            reduce using rule 124 (expression -> PLUS expression .)
    DEFAULT         reduce using rule 124 (expression -> PLUS expression .)
    LBRACE          reduce using rule 124 (expression -> PLUS expression .)
    SEMICOLON       reduce using rule 124 (expression -> PLUS expression .)
    PLUS            shift and go to state 86
    MINUS           shift and go to state 87
    TIMES           shift and go to state 88
    DIVIDE          shift and go to state 89
    MODULE          shift and go to state 90
    EQ              shift and go to state 91
    NEQ             shift and go to state 92
    LT              shift and go to state 93
    LE              shift and go to state 94
    GT              shift and go to state 95
    GE              shift and go to state 96
    LAND            shift and go to state 97
    LOR             shift and go to state 98
    AND             shift and go to state 99
    OR              shift and go to state 100
    XOR             shift and go to state 101
    LSHIFT          shift and go to state 103
    RSHIFT          shift and go to state 104

  ! PLUS            [ reduce using rule 124 (expression -> PLUS expression .) ]
  ! MINUS           [ reduce using rule 124 (expression -> PLUS expression .) ]
  ! TIMES           [ reduce using rule 124 (expression -> PLUS expression .) ]
  ! DIVIDE          [ reduce using rule 124 (expression -> PLUS expression .) ]
  ! MODULE          [ reduce using rule 124 (expression -> PLUS expression .) ]
  ! EQ              [ reduce using rule 124 (expression -> PLUS expression .) ]
  ! NEQ             [ reduce using rule 124 (expression -> PLUS expression .) ]
  ! LT              [ reduce using rule 124 (expression -> PLUS expression .) ]
  ! LE              [ reduce using rule 124 (expression -> PLUS expression .) ]
  ! GT              [ reduce using rule 124 (expression -> PLUS expression .) ]
  ! GE              [ reduce using rule 124 (expression -> PLUS expression .) ]
  ! LAND            [ reduce using rule 124 (expression -> PLUS expression .) ]
  ! LOR             [ reduce using rule 124 (expression -> PLUS expression .) ]
  ! AND             [ reduce using rule 124 (expression -> PLUS expression .) ]
  ! OR              [ reduce using rule 124 (expression -> PLUS expression .) ]
  ! XOR             [ reduce using rule 124 (expression -> PLUS expression .) ]
  ! LSHIFT          [ reduce using rule 124 (expression -> PLUS expression .) ]
  ! RSHIFT          [ reduce using rule 124 (expression -> PLUS expression .) ]
  ! AND_NOT         [ shift and go to state 102 ]


state 108

    (125) expression -> MINUS expression .
    (175) binary_expression -> expression . PLUS expression
    (176) binary_expression -> expression . MINUS expression
    (177) binary_expression -> expression . TIMES expression
    (178) binary_expression -> expression . DIVIDE expression
    (179) binary_expression -> expression . MODULE expression
    (184) relational_expression -> expression . EQ expression
    (185) relational_expression -> expression . NEQ expression
    (186) relational_expression -> expression . LT expression
    (187) relational_expression -> expression . LE expression
    (188) relational_expression -> expression . GT expression
    (189) relational_expression -> expression . GE expression
    (190) logical_expression -> expression . LAND expression
    (191) logical_expression -> expression . LOR expression
    (192) bitwise_expression -> expression . AND expression
    (193) bitwise_expression -> expression . OR expression
    (194) bitwise_expression -> expression . XOR expression
    (195) bitwise_expression -> expression . AND_NOT expression
    (196) bitwise_expression -> expression . LSHIFT expression
    (197) bitwise_expression -> expression . RSHIFT expression

    AND_NOT         reduce using rule 125 (expression -> MINUS expression .)
    VAR             reduce using rule 125 (expression -> MINUS expression .)
    CONST           reduce using rule 125 (expression -> MINUS expression .)
    FUNC            reduce using rule 125 (expression -> MINUS expression .)
    TYPE            reduce using rule 125 (expression -> MINUS expression .)
    $end            reduce using rule 125 (expression -> MINUS expression .)
    RPAREN          reduce using rule 125 (expression -> MINUS expression .)
    RBRACE          reduce using rule 125 (expression -> MINUS expression .)
    COMMA           reduce using rule 125 (expression -> MINUS expression .)
    COLON           reduce using rule 125 (expression -> MINUS expression .)
    IDENTIFIER      reduce using rule 125 (expression -> MINUS expression .)
    LPAREN          reduce using rule 125 (expression -> MINUS expression .)
    LNOT            reduce using rule 125 (expression -> MINUS expression .)
    INT             reduce using rule 125 (expression -> MINUS expression .)
    FLOAT64         reduce using rule 125 (expression -> MINUS expression .)
    TRUE            reduce using rule 125 (expression -> MINUS expression .)
    FALSE           reduce using rule 125 (expression -> MINUS expression .)
    STRING          reduce using rule 125 (expression -> MINUS expression .)
    RETURN          reduce using rule 125 (expression -> MINUS expression .)
    IF              reduce using rule 125 (expression -> MINUS expression .)
    SWITCH          reduce using rule 125 (expression -> MINUS expression .)
    BREAK           reduce using rule 125 (expression -> MINUS expression .)
    CONTINUE        reduce using rule 125 (expression -> MINUS expression .)
    LBRACKET        reduce using rule 125 (expression -> MINUS expression .)
    MAP             reduce using rule 125 (expression -> MINUS expression .)
    FOR             reduce using rule 125 (expression -> MINUS expression .)
    CASE            reduce using rule 125 (expression -> MINUS expression .)
    DEFAULT         reduce using rule 125 (expression -> MINUS expression .)
    LBRACE          reduce using rule 125 (expression -> MINUS expression .)
    SEMICOLON       reduce using rule 125 (expression -> MINUS expression .)
    PLUS            shift and go to state 86
    MINUS           shift and go to state 87
    TIMES           shift and go to state 88
    DIVIDE          shift and go to state 89
    MODULE          shift and go to state 90
    EQ              shift and go to state 91
    NEQ             shift and go to state 92
    LT              shift and go to state 93
    LE              shift and go to state 94
    GT              shift and go to state 95
    GE              shift and go to state 96
    LAND            shift and go to state 97
    LOR             shift and go to state 98
    AND             shift and go to state 99
    OR              shift and go to state 100
    XOR             shift and go to state 101
    LSHIFT          shift and go to state 103
    RSHIFT          shift and go to state 104

  ! PLUS            [ reduce using rule 125 (expression -> MINUS expression .) ]
  ! MINUS           [ reduce using rule 125 (expression -> MINUS expression .) ]
  ! TIMES           [ reduce using rule 125 (expression -> MINUS expression .) ]
  ! DIVIDE          [ reduce using rule 125 (expression -> MINUS expression .) ]
  ! MODULE          [ reduce using rule 125 (expression -> MINUS expression .) ]
  ! EQ              [ reduce using rule 125 (expression -> MINUS expression .) ]
  ! NEQ             [ reduce using rule 125 (expression -> MINUS expression .) ]
  ! LT              [ reduce using rule 125 (expression -> MINUS expression .) ]
  ! LE              [ reduce using rule 125 (expression -> MINUS expression .) ]
  ! GT              [ reduce using rule 125 (expression -> MINUS expression .) ]
  ! GE              [ reduce using rule 125 (expression -> MINUS expression .) ]
  ! LAND            [ reduce using rule 125 (expression -> MINUS expression .) ]
  ! LOR             [ reduce using rule 125 (expression -> MINUS expression .) ]
  ! AND             [ reduce using rule 125 (expression -> MINUS expression .) ]
  ! OR              [ reduce using rule 125 (expression -> MINUS expression .) ]
  ! XOR             [ reduce using rule 125 (expression -> MINUS expression .) ]
  ! LSHIFT          [ reduce using rule 125 (expression -> MINUS expression .) ]
  ! RSHIFT          [ reduce using rule 125 (expression -> MINUS expression .) ]
  ! AND_NOT         [ shift and go to state 102 ]


state 109

    (126) expression -> LNOT expression .
    (175) binary_expression -> expression . PLUS expression
    (176) binary_expression -> expression . MINUS expression
    (177) binary_expression -> expression . TIMES expression
    (178) binary_expression -> expression . DIVIDE expression
    (179) binary_expression -> expression . MODULE expression
    (184) relational_expression -> expression . EQ expression
    (185) relational_expression -> expression . NEQ expression
    (186) relational_expression -> expression . LT expression
    (187) relational_expression -> expression . LE expression
    (188) relational_expression -> expression . GT expression
    (189) relational_expression -> expression . GE expression
    (190) logical_expression -> expression . LAND expression
    (191) logical_expression -> expression . LOR expression
    (192) bitwise_expression -> expression . AND expression
    (193) bitwise_expression -> expression . OR expression
    (194) bitwise_expression -> expression . XOR expression
    (195) bitwise_expression -> expression . AND_NOT expression
    (196) bitwise_expression -> expression . LSHIFT expression
    (197) bitwise_expression -> expression . RSHIFT expression

    AND_NOT         reduce using rule 126 (expression -> LNOT expression .)
    VAR             reduce using rule 126 (expression -> LNOT expression .)
    CONST           reduce using rule 126 (expression -> LNOT expression .)
    FUNC            reduce using rule 126 (expression -> LNOT expression .)
    TYPE            reduce using rule 126 (expression -> LNOT expression .)
    $end            reduce using rule 126 (expression -> LNOT expression .)
    RPAREN          reduce using rule 126 (expression -> LNOT expression .)
    RBRACE          reduce using rule 126 (expression -> LNOT expression .)
    COMMA           reduce using rule 126 (expression -> LNOT expression .)
    COLON           reduce using rule 126 (expression -> LNOT expression .)
    IDENTIFIER      reduce using rule 126 (expression -> LNOT expression .)
    LPAREN          reduce using rule 126 (expression -> LNOT expression .)
    LNOT            reduce using rule 126 (expression -> LNOT expression .)
    INT             reduce using rule 126 (expression -> LNOT expression .)
    FLOAT64         reduce using rule 126 (expression -> LNOT expression .)
    TRUE            reduce using rule 126 (expression -> LNOT expression .)
    FALSE           reduce using rule 126 (expression -> LNOT expression .)
    STRING          reduce using rule 126 (expression -> LNOT expression .)
    RETURN          reduce using rule 126 (expression -> LNOT expression .)
    IF              reduce using rule 126 (expression -> LNOT expression .)
    SWITCH          reduce using rule 126 (expression -> LNOT expression .)
    BREAK           reduce using rule 126 (expression -> LNOT expression .)
    CONTINUE        reduce using rule 126 (expression -> LNOT expression .)
    LBRACKET        reduce using rule 126 (expression -> LNOT expression .)
    MAP             reduce using rule 126 (expression -> LNOT expression .)
    FOR             reduce using rule 126 (expression -> LNOT expression .)
    CASE            reduce using rule 126 (expression -> LNOT expression .)
    DEFAULT         reduce using rule 126 (expression -> LNOT expression .)
    LBRACE          reduce using rule 126 (expression -> LNOT expression .)
    SEMICOLON       reduce using rule 126 (expression -> LNOT expression .)
    PLUS            shift and go to state 86
    MINUS           shift and go to state 87
    TIMES           shift and go to state 88
    DIVIDE          shift and go to state 89
    MODULE          shift and go to state 90
    EQ              shift and go to state 91
    NEQ             shift and go to state 92
    LT              shift and go to state 93
    LE              shift and go to state 94
    GT              shift and go to state 95
    GE              shift and go to state 96
    LAND            shift and go to state 97
    LOR             shift and go to state 98
    AND             shift and go to state 99
    OR              shift and go to state 100
    XOR             shift and go to state 101
    LSHIFT          shift and go to state 103
    RSHIFT          shift and go to state 104

  ! PLUS            [ reduce using rule 126 (expression -> LNOT expression .) ]
  ! MINUS           [ reduce using rule 126 (expression -> LNOT expression .) ]
  ! TIMES           [ reduce using rule 126 (expression -> LNOT expression .) ]
  ! DIVIDE          [ reduce using rule 126 (expression -> LNOT expression .) ]
  ! MODULE          [ reduce using rule 126 (expression -> LNOT expression .) ]
  ! EQ              [ reduce using rule 126 (expression -> LNOT expression .) ]
  ! NEQ             [ reduce using rule 126 (expression -> LNOT expression .) ]
  ! LT              [ reduce using rule 126 (expression -> LNOT expression .) ]
  ! LE              [ reduce using rule 126 (expression -> LNOT expression .) ]
  ! GT              [ reduce using rule 126 (expression -> LNOT expression .) ]
  ! GE              [ reduce using rule 126 (expression -> LNOT expression .) ]
  ! LAND            [ reduce using rule 126 (expression -> LNOT expression .) ]
  ! LOR             [ reduce using rule 126 (expression -> LNOT expression .) ]
  ! AND             [ reduce using rule 126 (expression -> LNOT expression .) ]
  ! OR              [ reduce using rule 126 (expression -> LNOT expression .) ]
  ! XOR             [ reduce using rule 126 (expression -> LNOT expression .) ]
  ! LSHIFT          [ reduce using rule 126 (expression -> LNOT expression .) ]
  ! RSHIFT          [ reduce using rule 126 (expression -> LNOT expression .) ]
  ! AND_NOT         [ shift and go to state 102 ]


state 110

    (145) expression -> map_type LBRACE . expression_map_list RBRACE
    (146) expression -> map_type LBRACE . RBRACE
    (147) expression_map_list -> . key_value
    (148) expression_map_list -> . expression_map_list COMMA key_value
    (149) key_value -> . expression COLON expression
    (57) expression -> . slice_type LBRACE expression_list RBRACE
    (58) expression -> . slice_type LBRACE RBRACE
    (61) expression -> . LPAREN expression RPAREN
    (120) expression -> . binary_expression
    (121) expression -> . relational_expression
    (122) expression -> . logical_expression
    (123) expression -> . bitwise_expression
    (124) expression -> . PLUS expression
    (125) expression -> . MINUS expression
    (126) expression -> . LNOT expression
    (127) expression -> . INT
    (128) expression -> . FLOAT64
    (129) expression -> . TRUE
    (130) expression -> . FALSE
    (131) expression -> . IDENTIFIER
    (132) expression -> . STRING
    (133) expression -> . IDENTIFIER PLUSPLUS
    (134) expression -> . IDENTIFIER MINUSMINUS
    (145) expression -> . map_type LBRACE expression_map_list RBRACE
    (146) expression -> . map_type LBRACE RBRACE
    (169) expression -> . type_name LBRACE keyed_element_list RBRACE
    (170) expression -> . type_name LBRACE RBRACE
    (56) slice_type -> . LBRACKET RBRACKET primitive_type
    (175) binary_expression -> . expression PLUS expression
    (176) binary_expression -> . expression MINUS expression
    (177) binary_expression -> . expression TIMES expression
    (178) binary_expression -> . expression DIVIDE expression
    (179) binary_expression -> . expression MODULE expression
    (184) relational_expression -> . expression EQ expression
    (185) relational_expression -> . expression NEQ expression
    (186) relational_expression -> . expression LT expression
    (187) relational_expression -> . expression LE expression
    (188) relational_expression -> . expression GT expression
    (189) relational_expression -> . expression GE expression
    (190) logical_expression -> . expression LAND expression
    (191) logical_expression -> . expression LOR expression
    (192) bitwise_expression -> . expression AND expression
    (193) bitwise_expression -> . expression OR expression
    (194) bitwise_expression -> . expression XOR expression
    (195) bitwise_expression -> . expression AND_NOT expression
    (196) bitwise_expression -> . expression LSHIFT expression
    (197) bitwise_expression -> . expression RSHIFT expression
    (144) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (171) type_name -> . IDENTIFIER
    (172) type_name -> . slice_type
    (173) type_name -> . array_type
    (174) type_name -> . map_type
    (119) array_type -> . LBRACKET INT RBRACKET type

    RBRACE          shift and go to state 151
    LPAREN          shift and go to state 54
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    LNOT            shift and go to state 61
    INT             shift and go to state 62
    FLOAT64         shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 66
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    map_type                       shift and go to state 67
    expression_map_list            shift and go to state 150
    key_value                      shift and go to state 152
    expression                     shift and go to state 153
    slice_type                     shift and go to state 53
    binary_expression              shift and go to state 55
    relational_expression          shift and go to state 56
    logical_expression             shift and go to state 57
    bitwise_expression             shift and go to state 58
    type_name                      shift and go to state 68
    array_type                     shift and go to state 69

state 111

    (169) expression -> type_name LBRACE . keyed_element_list RBRACE
    (170) expression -> type_name LBRACE . RBRACE
    (164) keyed_element_list -> . keyed_element
    (165) keyed_element_list -> . keyed_element_list COMMA keyed_element
    (166) keyed_element -> . IDENTIFIER COLON expression
    (167) keyed_element -> . INT COLON expression
    (168) keyed_element -> . expression
    (57) expression -> . slice_type LBRACE expression_list RBRACE
    (58) expression -> . slice_type LBRACE RBRACE
    (61) expression -> . LPAREN expression RPAREN
    (120) expression -> . binary_expression
    (121) expression -> . relational_expression
    (122) expression -> . logical_expression
    (123) expression -> . bitwise_expression
    (124) expression -> . PLUS expression
    (125) expression -> . MINUS expression
    (126) expression -> . LNOT expression
    (127) expression -> . INT
    (128) expression -> . FLOAT64
    (129) expression -> . TRUE
    (130) expression -> . FALSE
    (131) expression -> . IDENTIFIER
    (132) expression -> . STRING
    (133) expression -> . IDENTIFIER PLUSPLUS
    (134) expression -> . IDENTIFIER MINUSMINUS
    (145) expression -> . map_type LBRACE expression_map_list RBRACE
    (146) expression -> . map_type LBRACE RBRACE
    (169) expression -> . type_name LBRACE keyed_element_list RBRACE
    (170) expression -> . type_name LBRACE RBRACE
    (56) slice_type -> . LBRACKET RBRACKET primitive_type
    (175) binary_expression -> . expression PLUS expression
    (176) binary_expression -> . expression MINUS expression
    (177) binary_expression -> . expression TIMES expression
    (178) binary_expression -> . expression DIVIDE expression
    (179) binary_expression -> . expression MODULE expression
    (184) relational_expression -> . expression EQ expression
    (185) relational_expression -> . expression NEQ expression
    (186) relational_expression -> . expression LT expression
    (187) relational_expression -> . expression LE expression
    (188) relational_expression -> . expression GT expression
    (189) relational_expression -> . expression GE expression
    (190) logical_expression -> . expression LAND expression
    (191) logical_expression -> . expression LOR expression
    (192) bitwise_expression -> . expression AND expression
    (193) bitwise_expression -> . expression OR expression
    (194) bitwise_expression -> . expression XOR expression
    (195) bitwise_expression -> . expression AND_NOT expression
    (196) bitwise_expression -> . expression LSHIFT expression
    (197) bitwise_expression -> . expression RSHIFT expression
    (144) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (171) type_name -> . IDENTIFIER
    (172) type_name -> . slice_type
    (173) type_name -> . array_type
    (174) type_name -> . map_type
    (119) array_type -> . LBRACKET INT RBRACKET type

    RBRACE          shift and go to state 155
    IDENTIFIER      shift and go to state 157
    INT             shift and go to state 159
    LPAREN          shift and go to state 54
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    LNOT            shift and go to state 61
    FLOAT64         shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    STRING          shift and go to state 66
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    type_name                      shift and go to state 68
    keyed_element_list             shift and go to state 154
    keyed_element                  shift and go to state 156
    expression                     shift and go to state 158
    slice_type                     shift and go to state 53
    binary_expression              shift and go to state 55
    relational_expression          shift and go to state 56
    logical_expression             shift and go to state 57
    bitwise_expression             shift and go to state 58
    map_type                       shift and go to state 67
    array_type                     shift and go to state 69

state 112

    (56) slice_type -> LBRACKET RBRACKET primitive_type .

    ASSIGN          reduce using rule 56 (slice_type -> LBRACKET RBRACKET primitive_type .)
    VAR             reduce using rule 56 (slice_type -> LBRACKET RBRACKET primitive_type .)
    CONST           reduce using rule 56 (slice_type -> LBRACKET RBRACKET primitive_type .)
    FUNC            reduce using rule 56 (slice_type -> LBRACKET RBRACKET primitive_type .)
    TYPE            reduce using rule 56 (slice_type -> LBRACKET RBRACKET primitive_type .)
    $end            reduce using rule 56 (slice_type -> LBRACKET RBRACKET primitive_type .)
    LBRACE          reduce using rule 56 (slice_type -> LBRACKET RBRACKET primitive_type .)
    RPAREN          reduce using rule 56 (slice_type -> LBRACKET RBRACKET primitive_type .)
    COMMA           reduce using rule 56 (slice_type -> LBRACKET RBRACKET primitive_type .)
    RBRACE          reduce using rule 56 (slice_type -> LBRACKET RBRACKET primitive_type .)
    IDENTIFIER      reduce using rule 56 (slice_type -> LBRACKET RBRACKET primitive_type .)
    SEMICOLON       reduce using rule 56 (slice_type -> LBRACKET RBRACKET primitive_type .)


state 113

    (119) array_type -> LBRACKET INT RBRACKET . type
    (52) type -> . primitive_type
    (53) type -> . slice_type
    (54) type -> . array_type
    (55) type -> . map_type
    (115) primitive_type -> . INT_TYPE
    (116) primitive_type -> . FLOAT64_TYPE
    (117) primitive_type -> . STRING_TYPE
    (118) primitive_type -> . BOOL_TYPE
    (56) slice_type -> . LBRACKET RBRACKET primitive_type
    (119) array_type -> . LBRACKET INT RBRACKET type
    (144) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type

    INT_TYPE        shift and go to state 34
    FLOAT64_TYPE    shift and go to state 35
    STRING_TYPE     shift and go to state 36
    BOOL_TYPE       shift and go to state 37
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    type                           shift and go to state 160
    primitive_type                 shift and go to state 30
    slice_type                     shift and go to state 31
    array_type                     shift and go to state 32
    map_type                       shift and go to state 33

state 114

    (144) map_type -> MAP LBRACKET primitive_type . RBRACKET primitive_type

    RBRACKET        shift and go to state 161


state 115

    (33) global_const_dec -> CONST IDENTIFIER type ASSIGN expression .
    (175) binary_expression -> expression . PLUS expression
    (176) binary_expression -> expression . MINUS expression
    (177) binary_expression -> expression . TIMES expression
    (178) binary_expression -> expression . DIVIDE expression
    (179) binary_expression -> expression . MODULE expression
    (184) relational_expression -> expression . EQ expression
    (185) relational_expression -> expression . NEQ expression
    (186) relational_expression -> expression . LT expression
    (187) relational_expression -> expression . LE expression
    (188) relational_expression -> expression . GT expression
    (189) relational_expression -> expression . GE expression
    (190) logical_expression -> expression . LAND expression
    (191) logical_expression -> expression . LOR expression
    (192) bitwise_expression -> expression . AND expression
    (193) bitwise_expression -> expression . OR expression
    (194) bitwise_expression -> expression . XOR expression
    (195) bitwise_expression -> expression . AND_NOT expression
    (196) bitwise_expression -> expression . LSHIFT expression
    (197) bitwise_expression -> expression . RSHIFT expression

    VAR             reduce using rule 33 (global_const_dec -> CONST IDENTIFIER type ASSIGN expression .)
    CONST           reduce using rule 33 (global_const_dec -> CONST IDENTIFIER type ASSIGN expression .)
    FUNC            reduce using rule 33 (global_const_dec -> CONST IDENTIFIER type ASSIGN expression .)
    TYPE            reduce using rule 33 (global_const_dec -> CONST IDENTIFIER type ASSIGN expression .)
    $end            reduce using rule 33 (global_const_dec -> CONST IDENTIFIER type ASSIGN expression .)
    PLUS            shift and go to state 86
    MINUS           shift and go to state 87
    TIMES           shift and go to state 88
    DIVIDE          shift and go to state 89
    MODULE          shift and go to state 90
    EQ              shift and go to state 91
    NEQ             shift and go to state 92
    LT              shift and go to state 93
    LE              shift and go to state 94
    GT              shift and go to state 95
    GE              shift and go to state 96
    LAND            shift and go to state 97
    LOR             shift and go to state 98
    AND             shift and go to state 99
    OR              shift and go to state 100
    XOR             shift and go to state 101
    AND_NOT         shift and go to state 102
    LSHIFT          shift and go to state 103
    RSHIFT          shift and go to state 104


state 116

    (100) parameter -> IDENTIFIER type .

    RPAREN          reduce using rule 100 (parameter -> IDENTIFIER type .)
    COMMA           reduce using rule 100 (parameter -> IDENTIFIER type .)


state 117

    (101) parameter -> IDENTIFIER ELLIPSIS . primitive_type
    (115) primitive_type -> . INT_TYPE
    (116) primitive_type -> . FLOAT64_TYPE
    (117) primitive_type -> . STRING_TYPE
    (118) primitive_type -> . BOOL_TYPE

    INT_TYPE        shift and go to state 34
    FLOAT64_TYPE    shift and go to state 35
    STRING_TYPE     shift and go to state 36
    BOOL_TYPE       shift and go to state 37

    primitive_type                 shift and go to state 162

state 118

    (96) function_declaration -> FUNC IDENTIFIER LPAREN parameter_list RPAREN . return_type block
    (102) return_type -> . type
    (103) return_type -> . LPAREN type_list RPAREN
    (104) return_type -> . empty
    (52) type -> . primitive_type
    (53) type -> . slice_type
    (54) type -> . array_type
    (55) type -> . map_type
    (7) empty -> .
    (115) primitive_type -> . INT_TYPE
    (116) primitive_type -> . FLOAT64_TYPE
    (117) primitive_type -> . STRING_TYPE
    (118) primitive_type -> . BOOL_TYPE
    (56) slice_type -> . LBRACKET RBRACKET primitive_type
    (119) array_type -> . LBRACKET INT RBRACKET type
    (144) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type

    LPAREN          shift and go to state 163
    LBRACE          reduce using rule 7 (empty -> .)
    INT_TYPE        shift and go to state 34
    FLOAT64_TYPE    shift and go to state 35
    STRING_TYPE     shift and go to state 36
    BOOL_TYPE       shift and go to state 37
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    return_type                    shift and go to state 164
    type                           shift and go to state 165
    empty                          shift and go to state 166
    primitive_type                 shift and go to state 30
    slice_type                     shift and go to state 31
    array_type                     shift and go to state 32
    map_type                       shift and go to state 33

state 119

    (97) parameter_list -> parameter_list COMMA . parameter
    (100) parameter -> . IDENTIFIER type
    (101) parameter -> . IDENTIFIER ELLIPSIS primitive_type

    IDENTIFIER      shift and go to state 75

    parameter                      shift and go to state 167

state 120

    (154) method_declaration -> FUNC LPAREN receiver RPAREN IDENTIFIER . LPAREN parameter_list RPAREN return_type block

    LPAREN          shift and go to state 168


state 121

    (156) receiver -> IDENTIFIER TIMES IDENTIFIER .

    RPAREN          reduce using rule 156 (receiver -> IDENTIFIER TIMES IDENTIFIER .)


state 122

    (157) receiver -> IDENTIFIER TIMES type .

    RPAREN          reduce using rule 157 (receiver -> IDENTIFIER TIMES type .)


state 123

    (162) struct_type -> STRUCT LBRACE RBRACE .

    VAR             reduce using rule 162 (struct_type -> STRUCT LBRACE RBRACE .)
    CONST           reduce using rule 162 (struct_type -> STRUCT LBRACE RBRACE .)
    FUNC            reduce using rule 162 (struct_type -> STRUCT LBRACE RBRACE .)
    TYPE            reduce using rule 162 (struct_type -> STRUCT LBRACE RBRACE .)
    $end            reduce using rule 162 (struct_type -> STRUCT LBRACE RBRACE .)


state 124

    (163) struct_type -> STRUCT LBRACE field_list . RBRACE
    (151) field_list -> field_list . field_declaration
    (152) field_declaration -> . IDENTIFIER type
    (153) field_declaration -> . IDENTIFIER

    RBRACE          shift and go to state 169
    IDENTIFIER      shift and go to state 126

    field_declaration              shift and go to state 170

state 125

    (150) field_list -> field_declaration .

    RBRACE          reduce using rule 150 (field_list -> field_declaration .)
    IDENTIFIER      reduce using rule 150 (field_list -> field_declaration .)


state 126

    (152) field_declaration -> IDENTIFIER . type
    (153) field_declaration -> IDENTIFIER .
    (52) type -> . primitive_type
    (53) type -> . slice_type
    (54) type -> . array_type
    (55) type -> . map_type
    (115) primitive_type -> . INT_TYPE
    (116) primitive_type -> . FLOAT64_TYPE
    (117) primitive_type -> . STRING_TYPE
    (118) primitive_type -> . BOOL_TYPE
    (56) slice_type -> . LBRACKET RBRACKET primitive_type
    (119) array_type -> . LBRACKET INT RBRACKET type
    (144) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type

    RBRACE          reduce using rule 153 (field_declaration -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 153 (field_declaration -> IDENTIFIER .)
    INT_TYPE        shift and go to state 34
    FLOAT64_TYPE    shift and go to state 35
    STRING_TYPE     shift and go to state 36
    BOOL_TYPE       shift and go to state 37
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    type                           shift and go to state 171
    primitive_type                 shift and go to state 30
    slice_type                     shift and go to state 31
    array_type                     shift and go to state 32
    map_type                       shift and go to state 33

state 127

    (175) binary_expression -> expression PLUS expression .
    (175) binary_expression -> expression . PLUS expression
    (176) binary_expression -> expression . MINUS expression
    (177) binary_expression -> expression . TIMES expression
    (178) binary_expression -> expression . DIVIDE expression
    (179) binary_expression -> expression . MODULE expression
    (184) relational_expression -> expression . EQ expression
    (185) relational_expression -> expression . NEQ expression
    (186) relational_expression -> expression . LT expression
    (187) relational_expression -> expression . LE expression
    (188) relational_expression -> expression . GT expression
    (189) relational_expression -> expression . GE expression
    (190) logical_expression -> expression . LAND expression
    (191) logical_expression -> expression . LOR expression
    (192) bitwise_expression -> expression . AND expression
    (193) bitwise_expression -> expression . OR expression
    (194) bitwise_expression -> expression . XOR expression
    (195) bitwise_expression -> expression . AND_NOT expression
    (196) bitwise_expression -> expression . LSHIFT expression
    (197) bitwise_expression -> expression . RSHIFT expression

    PLUS            reduce using rule 175 (binary_expression -> expression PLUS expression .)
    MINUS           reduce using rule 175 (binary_expression -> expression PLUS expression .)
    TIMES           reduce using rule 175 (binary_expression -> expression PLUS expression .)
    DIVIDE          reduce using rule 175 (binary_expression -> expression PLUS expression .)
    MODULE          reduce using rule 175 (binary_expression -> expression PLUS expression .)
    AND_NOT         reduce using rule 175 (binary_expression -> expression PLUS expression .)
    VAR             reduce using rule 175 (binary_expression -> expression PLUS expression .)
    CONST           reduce using rule 175 (binary_expression -> expression PLUS expression .)
    FUNC            reduce using rule 175 (binary_expression -> expression PLUS expression .)
    TYPE            reduce using rule 175 (binary_expression -> expression PLUS expression .)
    $end            reduce using rule 175 (binary_expression -> expression PLUS expression .)
    RPAREN          reduce using rule 175 (binary_expression -> expression PLUS expression .)
    RBRACE          reduce using rule 175 (binary_expression -> expression PLUS expression .)
    COMMA           reduce using rule 175 (binary_expression -> expression PLUS expression .)
    COLON           reduce using rule 175 (binary_expression -> expression PLUS expression .)
    IDENTIFIER      reduce using rule 175 (binary_expression -> expression PLUS expression .)
    LPAREN          reduce using rule 175 (binary_expression -> expression PLUS expression .)
    LNOT            reduce using rule 175 (binary_expression -> expression PLUS expression .)
    INT             reduce using rule 175 (binary_expression -> expression PLUS expression .)
    FLOAT64         reduce using rule 175 (binary_expression -> expression PLUS expression .)
    TRUE            reduce using rule 175 (binary_expression -> expression PLUS expression .)
    FALSE           reduce using rule 175 (binary_expression -> expression PLUS expression .)
    STRING          reduce using rule 175 (binary_expression -> expression PLUS expression .)
    RETURN          reduce using rule 175 (binary_expression -> expression PLUS expression .)
    IF              reduce using rule 175 (binary_expression -> expression PLUS expression .)
    SWITCH          reduce using rule 175 (binary_expression -> expression PLUS expression .)
    BREAK           reduce using rule 175 (binary_expression -> expression PLUS expression .)
    CONTINUE        reduce using rule 175 (binary_expression -> expression PLUS expression .)
    LBRACKET        reduce using rule 175 (binary_expression -> expression PLUS expression .)
    MAP             reduce using rule 175 (binary_expression -> expression PLUS expression .)
    FOR             reduce using rule 175 (binary_expression -> expression PLUS expression .)
    CASE            reduce using rule 175 (binary_expression -> expression PLUS expression .)
    DEFAULT         reduce using rule 175 (binary_expression -> expression PLUS expression .)
    LBRACE          reduce using rule 175 (binary_expression -> expression PLUS expression .)
    SEMICOLON       reduce using rule 175 (binary_expression -> expression PLUS expression .)
    EQ              shift and go to state 91
    NEQ             shift and go to state 92
    LT              shift and go to state 93
    LE              shift and go to state 94
    GT              shift and go to state 95
    GE              shift and go to state 96
    LAND            shift and go to state 97
    LOR             shift and go to state 98
    AND             shift and go to state 99
    OR              shift and go to state 100
    XOR             shift and go to state 101
    LSHIFT          shift and go to state 103
    RSHIFT          shift and go to state 104

  ! EQ              [ reduce using rule 175 (binary_expression -> expression PLUS expression .) ]
  ! NEQ             [ reduce using rule 175 (binary_expression -> expression PLUS expression .) ]
  ! LT              [ reduce using rule 175 (binary_expression -> expression PLUS expression .) ]
  ! LE              [ reduce using rule 175 (binary_expression -> expression PLUS expression .) ]
  ! GT              [ reduce using rule 175 (binary_expression -> expression PLUS expression .) ]
  ! GE              [ reduce using rule 175 (binary_expression -> expression PLUS expression .) ]
  ! LAND            [ reduce using rule 175 (binary_expression -> expression PLUS expression .) ]
  ! LOR             [ reduce using rule 175 (binary_expression -> expression PLUS expression .) ]
  ! AND             [ reduce using rule 175 (binary_expression -> expression PLUS expression .) ]
  ! OR              [ reduce using rule 175 (binary_expression -> expression PLUS expression .) ]
  ! XOR             [ reduce using rule 175 (binary_expression -> expression PLUS expression .) ]
  ! LSHIFT          [ reduce using rule 175 (binary_expression -> expression PLUS expression .) ]
  ! RSHIFT          [ reduce using rule 175 (binary_expression -> expression PLUS expression .) ]
  ! PLUS            [ shift and go to state 86 ]
  ! MINUS           [ shift and go to state 87 ]
  ! TIMES           [ shift and go to state 88 ]
  ! DIVIDE          [ shift and go to state 89 ]
  ! MODULE          [ shift and go to state 90 ]
  ! AND_NOT         [ shift and go to state 102 ]


state 128

    (176) binary_expression -> expression MINUS expression .
    (175) binary_expression -> expression . PLUS expression
    (176) binary_expression -> expression . MINUS expression
    (177) binary_expression -> expression . TIMES expression
    (178) binary_expression -> expression . DIVIDE expression
    (179) binary_expression -> expression . MODULE expression
    (184) relational_expression -> expression . EQ expression
    (185) relational_expression -> expression . NEQ expression
    (186) relational_expression -> expression . LT expression
    (187) relational_expression -> expression . LE expression
    (188) relational_expression -> expression . GT expression
    (189) relational_expression -> expression . GE expression
    (190) logical_expression -> expression . LAND expression
    (191) logical_expression -> expression . LOR expression
    (192) bitwise_expression -> expression . AND expression
    (193) bitwise_expression -> expression . OR expression
    (194) bitwise_expression -> expression . XOR expression
    (195) bitwise_expression -> expression . AND_NOT expression
    (196) bitwise_expression -> expression . LSHIFT expression
    (197) bitwise_expression -> expression . RSHIFT expression

    PLUS            reduce using rule 176 (binary_expression -> expression MINUS expression .)
    MINUS           reduce using rule 176 (binary_expression -> expression MINUS expression .)
    TIMES           reduce using rule 176 (binary_expression -> expression MINUS expression .)
    DIVIDE          reduce using rule 176 (binary_expression -> expression MINUS expression .)
    MODULE          reduce using rule 176 (binary_expression -> expression MINUS expression .)
    AND_NOT         reduce using rule 176 (binary_expression -> expression MINUS expression .)
    VAR             reduce using rule 176 (binary_expression -> expression MINUS expression .)
    CONST           reduce using rule 176 (binary_expression -> expression MINUS expression .)
    FUNC            reduce using rule 176 (binary_expression -> expression MINUS expression .)
    TYPE            reduce using rule 176 (binary_expression -> expression MINUS expression .)
    $end            reduce using rule 176 (binary_expression -> expression MINUS expression .)
    RPAREN          reduce using rule 176 (binary_expression -> expression MINUS expression .)
    RBRACE          reduce using rule 176 (binary_expression -> expression MINUS expression .)
    COMMA           reduce using rule 176 (binary_expression -> expression MINUS expression .)
    COLON           reduce using rule 176 (binary_expression -> expression MINUS expression .)
    IDENTIFIER      reduce using rule 176 (binary_expression -> expression MINUS expression .)
    LPAREN          reduce using rule 176 (binary_expression -> expression MINUS expression .)
    LNOT            reduce using rule 176 (binary_expression -> expression MINUS expression .)
    INT             reduce using rule 176 (binary_expression -> expression MINUS expression .)
    FLOAT64         reduce using rule 176 (binary_expression -> expression MINUS expression .)
    TRUE            reduce using rule 176 (binary_expression -> expression MINUS expression .)
    FALSE           reduce using rule 176 (binary_expression -> expression MINUS expression .)
    STRING          reduce using rule 176 (binary_expression -> expression MINUS expression .)
    RETURN          reduce using rule 176 (binary_expression -> expression MINUS expression .)
    IF              reduce using rule 176 (binary_expression -> expression MINUS expression .)
    SWITCH          reduce using rule 176 (binary_expression -> expression MINUS expression .)
    BREAK           reduce using rule 176 (binary_expression -> expression MINUS expression .)
    CONTINUE        reduce using rule 176 (binary_expression -> expression MINUS expression .)
    LBRACKET        reduce using rule 176 (binary_expression -> expression MINUS expression .)
    MAP             reduce using rule 176 (binary_expression -> expression MINUS expression .)
    FOR             reduce using rule 176 (binary_expression -> expression MINUS expression .)
    CASE            reduce using rule 176 (binary_expression -> expression MINUS expression .)
    DEFAULT         reduce using rule 176 (binary_expression -> expression MINUS expression .)
    LBRACE          reduce using rule 176 (binary_expression -> expression MINUS expression .)
    SEMICOLON       reduce using rule 176 (binary_expression -> expression MINUS expression .)
    EQ              shift and go to state 91
    NEQ             shift and go to state 92
    LT              shift and go to state 93
    LE              shift and go to state 94
    GT              shift and go to state 95
    GE              shift and go to state 96
    LAND            shift and go to state 97
    LOR             shift and go to state 98
    AND             shift and go to state 99
    OR              shift and go to state 100
    XOR             shift and go to state 101
    LSHIFT          shift and go to state 103
    RSHIFT          shift and go to state 104

  ! EQ              [ reduce using rule 176 (binary_expression -> expression MINUS expression .) ]
  ! NEQ             [ reduce using rule 176 (binary_expression -> expression MINUS expression .) ]
  ! LT              [ reduce using rule 176 (binary_expression -> expression MINUS expression .) ]
  ! LE              [ reduce using rule 176 (binary_expression -> expression MINUS expression .) ]
  ! GT              [ reduce using rule 176 (binary_expression -> expression MINUS expression .) ]
  ! GE              [ reduce using rule 176 (binary_expression -> expression MINUS expression .) ]
  ! LAND            [ reduce using rule 176 (binary_expression -> expression MINUS expression .) ]
  ! LOR             [ reduce using rule 176 (binary_expression -> expression MINUS expression .) ]
  ! AND             [ reduce using rule 176 (binary_expression -> expression MINUS expression .) ]
  ! OR              [ reduce using rule 176 (binary_expression -> expression MINUS expression .) ]
  ! XOR             [ reduce using rule 176 (binary_expression -> expression MINUS expression .) ]
  ! LSHIFT          [ reduce using rule 176 (binary_expression -> expression MINUS expression .) ]
  ! RSHIFT          [ reduce using rule 176 (binary_expression -> expression MINUS expression .) ]
  ! PLUS            [ shift and go to state 86 ]
  ! MINUS           [ shift and go to state 87 ]
  ! TIMES           [ shift and go to state 88 ]
  ! DIVIDE          [ shift and go to state 89 ]
  ! MODULE          [ shift and go to state 90 ]
  ! AND_NOT         [ shift and go to state 102 ]


state 129

    (177) binary_expression -> expression TIMES expression .
    (175) binary_expression -> expression . PLUS expression
    (176) binary_expression -> expression . MINUS expression
    (177) binary_expression -> expression . TIMES expression
    (178) binary_expression -> expression . DIVIDE expression
    (179) binary_expression -> expression . MODULE expression
    (184) relational_expression -> expression . EQ expression
    (185) relational_expression -> expression . NEQ expression
    (186) relational_expression -> expression . LT expression
    (187) relational_expression -> expression . LE expression
    (188) relational_expression -> expression . GT expression
    (189) relational_expression -> expression . GE expression
    (190) logical_expression -> expression . LAND expression
    (191) logical_expression -> expression . LOR expression
    (192) bitwise_expression -> expression . AND expression
    (193) bitwise_expression -> expression . OR expression
    (194) bitwise_expression -> expression . XOR expression
    (195) bitwise_expression -> expression . AND_NOT expression
    (196) bitwise_expression -> expression . LSHIFT expression
    (197) bitwise_expression -> expression . RSHIFT expression

    TIMES           reduce using rule 177 (binary_expression -> expression TIMES expression .)
    DIVIDE          reduce using rule 177 (binary_expression -> expression TIMES expression .)
    MODULE          reduce using rule 177 (binary_expression -> expression TIMES expression .)
    AND_NOT         reduce using rule 177 (binary_expression -> expression TIMES expression .)
    VAR             reduce using rule 177 (binary_expression -> expression TIMES expression .)
    CONST           reduce using rule 177 (binary_expression -> expression TIMES expression .)
    FUNC            reduce using rule 177 (binary_expression -> expression TIMES expression .)
    TYPE            reduce using rule 177 (binary_expression -> expression TIMES expression .)
    $end            reduce using rule 177 (binary_expression -> expression TIMES expression .)
    RPAREN          reduce using rule 177 (binary_expression -> expression TIMES expression .)
    RBRACE          reduce using rule 177 (binary_expression -> expression TIMES expression .)
    COMMA           reduce using rule 177 (binary_expression -> expression TIMES expression .)
    COLON           reduce using rule 177 (binary_expression -> expression TIMES expression .)
    IDENTIFIER      reduce using rule 177 (binary_expression -> expression TIMES expression .)
    LPAREN          reduce using rule 177 (binary_expression -> expression TIMES expression .)
    LNOT            reduce using rule 177 (binary_expression -> expression TIMES expression .)
    INT             reduce using rule 177 (binary_expression -> expression TIMES expression .)
    FLOAT64         reduce using rule 177 (binary_expression -> expression TIMES expression .)
    TRUE            reduce using rule 177 (binary_expression -> expression TIMES expression .)
    FALSE           reduce using rule 177 (binary_expression -> expression TIMES expression .)
    STRING          reduce using rule 177 (binary_expression -> expression TIMES expression .)
    RETURN          reduce using rule 177 (binary_expression -> expression TIMES expression .)
    IF              reduce using rule 177 (binary_expression -> expression TIMES expression .)
    SWITCH          reduce using rule 177 (binary_expression -> expression TIMES expression .)
    BREAK           reduce using rule 177 (binary_expression -> expression TIMES expression .)
    CONTINUE        reduce using rule 177 (binary_expression -> expression TIMES expression .)
    LBRACKET        reduce using rule 177 (binary_expression -> expression TIMES expression .)
    MAP             reduce using rule 177 (binary_expression -> expression TIMES expression .)
    FOR             reduce using rule 177 (binary_expression -> expression TIMES expression .)
    CASE            reduce using rule 177 (binary_expression -> expression TIMES expression .)
    DEFAULT         reduce using rule 177 (binary_expression -> expression TIMES expression .)
    LBRACE          reduce using rule 177 (binary_expression -> expression TIMES expression .)
    SEMICOLON       reduce using rule 177 (binary_expression -> expression TIMES expression .)
    PLUS            shift and go to state 86
    MINUS           shift and go to state 87
    EQ              shift and go to state 91
    NEQ             shift and go to state 92
    LT              shift and go to state 93
    LE              shift and go to state 94
    GT              shift and go to state 95
    GE              shift and go to state 96
    LAND            shift and go to state 97
    LOR             shift and go to state 98
    AND             shift and go to state 99
    OR              shift and go to state 100
    XOR             shift and go to state 101
    LSHIFT          shift and go to state 103
    RSHIFT          shift and go to state 104

  ! PLUS            [ reduce using rule 177 (binary_expression -> expression TIMES expression .) ]
  ! MINUS           [ reduce using rule 177 (binary_expression -> expression TIMES expression .) ]
  ! EQ              [ reduce using rule 177 (binary_expression -> expression TIMES expression .) ]
  ! NEQ             [ reduce using rule 177 (binary_expression -> expression TIMES expression .) ]
  ! LT              [ reduce using rule 177 (binary_expression -> expression TIMES expression .) ]
  ! LE              [ reduce using rule 177 (binary_expression -> expression TIMES expression .) ]
  ! GT              [ reduce using rule 177 (binary_expression -> expression TIMES expression .) ]
  ! GE              [ reduce using rule 177 (binary_expression -> expression TIMES expression .) ]
  ! LAND            [ reduce using rule 177 (binary_expression -> expression TIMES expression .) ]
  ! LOR             [ reduce using rule 177 (binary_expression -> expression TIMES expression .) ]
  ! AND             [ reduce using rule 177 (binary_expression -> expression TIMES expression .) ]
  ! OR              [ reduce using rule 177 (binary_expression -> expression TIMES expression .) ]
  ! XOR             [ reduce using rule 177 (binary_expression -> expression TIMES expression .) ]
  ! LSHIFT          [ reduce using rule 177 (binary_expression -> expression TIMES expression .) ]
  ! RSHIFT          [ reduce using rule 177 (binary_expression -> expression TIMES expression .) ]
  ! TIMES           [ shift and go to state 88 ]
  ! DIVIDE          [ shift and go to state 89 ]
  ! MODULE          [ shift and go to state 90 ]
  ! AND_NOT         [ shift and go to state 102 ]


state 130

    (178) binary_expression -> expression DIVIDE expression .
    (175) binary_expression -> expression . PLUS expression
    (176) binary_expression -> expression . MINUS expression
    (177) binary_expression -> expression . TIMES expression
    (178) binary_expression -> expression . DIVIDE expression
    (179) binary_expression -> expression . MODULE expression
    (184) relational_expression -> expression . EQ expression
    (185) relational_expression -> expression . NEQ expression
    (186) relational_expression -> expression . LT expression
    (187) relational_expression -> expression . LE expression
    (188) relational_expression -> expression . GT expression
    (189) relational_expression -> expression . GE expression
    (190) logical_expression -> expression . LAND expression
    (191) logical_expression -> expression . LOR expression
    (192) bitwise_expression -> expression . AND expression
    (193) bitwise_expression -> expression . OR expression
    (194) bitwise_expression -> expression . XOR expression
    (195) bitwise_expression -> expression . AND_NOT expression
    (196) bitwise_expression -> expression . LSHIFT expression
    (197) bitwise_expression -> expression . RSHIFT expression

    TIMES           reduce using rule 178 (binary_expression -> expression DIVIDE expression .)
    DIVIDE          reduce using rule 178 (binary_expression -> expression DIVIDE expression .)
    MODULE          reduce using rule 178 (binary_expression -> expression DIVIDE expression .)
    AND_NOT         reduce using rule 178 (binary_expression -> expression DIVIDE expression .)
    VAR             reduce using rule 178 (binary_expression -> expression DIVIDE expression .)
    CONST           reduce using rule 178 (binary_expression -> expression DIVIDE expression .)
    FUNC            reduce using rule 178 (binary_expression -> expression DIVIDE expression .)
    TYPE            reduce using rule 178 (binary_expression -> expression DIVIDE expression .)
    $end            reduce using rule 178 (binary_expression -> expression DIVIDE expression .)
    RPAREN          reduce using rule 178 (binary_expression -> expression DIVIDE expression .)
    RBRACE          reduce using rule 178 (binary_expression -> expression DIVIDE expression .)
    COMMA           reduce using rule 178 (binary_expression -> expression DIVIDE expression .)
    COLON           reduce using rule 178 (binary_expression -> expression DIVIDE expression .)
    IDENTIFIER      reduce using rule 178 (binary_expression -> expression DIVIDE expression .)
    LPAREN          reduce using rule 178 (binary_expression -> expression DIVIDE expression .)
    LNOT            reduce using rule 178 (binary_expression -> expression DIVIDE expression .)
    INT             reduce using rule 178 (binary_expression -> expression DIVIDE expression .)
    FLOAT64         reduce using rule 178 (binary_expression -> expression DIVIDE expression .)
    TRUE            reduce using rule 178 (binary_expression -> expression DIVIDE expression .)
    FALSE           reduce using rule 178 (binary_expression -> expression DIVIDE expression .)
    STRING          reduce using rule 178 (binary_expression -> expression DIVIDE expression .)
    RETURN          reduce using rule 178 (binary_expression -> expression DIVIDE expression .)
    IF              reduce using rule 178 (binary_expression -> expression DIVIDE expression .)
    SWITCH          reduce using rule 178 (binary_expression -> expression DIVIDE expression .)
    BREAK           reduce using rule 178 (binary_expression -> expression DIVIDE expression .)
    CONTINUE        reduce using rule 178 (binary_expression -> expression DIVIDE expression .)
    LBRACKET        reduce using rule 178 (binary_expression -> expression DIVIDE expression .)
    MAP             reduce using rule 178 (binary_expression -> expression DIVIDE expression .)
    FOR             reduce using rule 178 (binary_expression -> expression DIVIDE expression .)
    CASE            reduce using rule 178 (binary_expression -> expression DIVIDE expression .)
    DEFAULT         reduce using rule 178 (binary_expression -> expression DIVIDE expression .)
    LBRACE          reduce using rule 178 (binary_expression -> expression DIVIDE expression .)
    SEMICOLON       reduce using rule 178 (binary_expression -> expression DIVIDE expression .)
    PLUS            shift and go to state 86
    MINUS           shift and go to state 87
    EQ              shift and go to state 91
    NEQ             shift and go to state 92
    LT              shift and go to state 93
    LE              shift and go to state 94
    GT              shift and go to state 95
    GE              shift and go to state 96
    LAND            shift and go to state 97
    LOR             shift and go to state 98
    AND             shift and go to state 99
    OR              shift and go to state 100
    XOR             shift and go to state 101
    LSHIFT          shift and go to state 103
    RSHIFT          shift and go to state 104

  ! PLUS            [ reduce using rule 178 (binary_expression -> expression DIVIDE expression .) ]
  ! MINUS           [ reduce using rule 178 (binary_expression -> expression DIVIDE expression .) ]
  ! EQ              [ reduce using rule 178 (binary_expression -> expression DIVIDE expression .) ]
  ! NEQ             [ reduce using rule 178 (binary_expression -> expression DIVIDE expression .) ]
  ! LT              [ reduce using rule 178 (binary_expression -> expression DIVIDE expression .) ]
  ! LE              [ reduce using rule 178 (binary_expression -> expression DIVIDE expression .) ]
  ! GT              [ reduce using rule 178 (binary_expression -> expression DIVIDE expression .) ]
  ! GE              [ reduce using rule 178 (binary_expression -> expression DIVIDE expression .) ]
  ! LAND            [ reduce using rule 178 (binary_expression -> expression DIVIDE expression .) ]
  ! LOR             [ reduce using rule 178 (binary_expression -> expression DIVIDE expression .) ]
  ! AND             [ reduce using rule 178 (binary_expression -> expression DIVIDE expression .) ]
  ! OR              [ reduce using rule 178 (binary_expression -> expression DIVIDE expression .) ]
  ! XOR             [ reduce using rule 178 (binary_expression -> expression DIVIDE expression .) ]
  ! LSHIFT          [ reduce using rule 178 (binary_expression -> expression DIVIDE expression .) ]
  ! RSHIFT          [ reduce using rule 178 (binary_expression -> expression DIVIDE expression .) ]
  ! TIMES           [ shift and go to state 88 ]
  ! DIVIDE          [ shift and go to state 89 ]
  ! MODULE          [ shift and go to state 90 ]
  ! AND_NOT         [ shift and go to state 102 ]


state 131

    (179) binary_expression -> expression MODULE expression .
    (175) binary_expression -> expression . PLUS expression
    (176) binary_expression -> expression . MINUS expression
    (177) binary_expression -> expression . TIMES expression
    (178) binary_expression -> expression . DIVIDE expression
    (179) binary_expression -> expression . MODULE expression
    (184) relational_expression -> expression . EQ expression
    (185) relational_expression -> expression . NEQ expression
    (186) relational_expression -> expression . LT expression
    (187) relational_expression -> expression . LE expression
    (188) relational_expression -> expression . GT expression
    (189) relational_expression -> expression . GE expression
    (190) logical_expression -> expression . LAND expression
    (191) logical_expression -> expression . LOR expression
    (192) bitwise_expression -> expression . AND expression
    (193) bitwise_expression -> expression . OR expression
    (194) bitwise_expression -> expression . XOR expression
    (195) bitwise_expression -> expression . AND_NOT expression
    (196) bitwise_expression -> expression . LSHIFT expression
    (197) bitwise_expression -> expression . RSHIFT expression

    TIMES           reduce using rule 179 (binary_expression -> expression MODULE expression .)
    DIVIDE          reduce using rule 179 (binary_expression -> expression MODULE expression .)
    MODULE          reduce using rule 179 (binary_expression -> expression MODULE expression .)
    AND_NOT         reduce using rule 179 (binary_expression -> expression MODULE expression .)
    VAR             reduce using rule 179 (binary_expression -> expression MODULE expression .)
    CONST           reduce using rule 179 (binary_expression -> expression MODULE expression .)
    FUNC            reduce using rule 179 (binary_expression -> expression MODULE expression .)
    TYPE            reduce using rule 179 (binary_expression -> expression MODULE expression .)
    $end            reduce using rule 179 (binary_expression -> expression MODULE expression .)
    RPAREN          reduce using rule 179 (binary_expression -> expression MODULE expression .)
    RBRACE          reduce using rule 179 (binary_expression -> expression MODULE expression .)
    COMMA           reduce using rule 179 (binary_expression -> expression MODULE expression .)
    COLON           reduce using rule 179 (binary_expression -> expression MODULE expression .)
    IDENTIFIER      reduce using rule 179 (binary_expression -> expression MODULE expression .)
    LPAREN          reduce using rule 179 (binary_expression -> expression MODULE expression .)
    LNOT            reduce using rule 179 (binary_expression -> expression MODULE expression .)
    INT             reduce using rule 179 (binary_expression -> expression MODULE expression .)
    FLOAT64         reduce using rule 179 (binary_expression -> expression MODULE expression .)
    TRUE            reduce using rule 179 (binary_expression -> expression MODULE expression .)
    FALSE           reduce using rule 179 (binary_expression -> expression MODULE expression .)
    STRING          reduce using rule 179 (binary_expression -> expression MODULE expression .)
    RETURN          reduce using rule 179 (binary_expression -> expression MODULE expression .)
    IF              reduce using rule 179 (binary_expression -> expression MODULE expression .)
    SWITCH          reduce using rule 179 (binary_expression -> expression MODULE expression .)
    BREAK           reduce using rule 179 (binary_expression -> expression MODULE expression .)
    CONTINUE        reduce using rule 179 (binary_expression -> expression MODULE expression .)
    LBRACKET        reduce using rule 179 (binary_expression -> expression MODULE expression .)
    MAP             reduce using rule 179 (binary_expression -> expression MODULE expression .)
    FOR             reduce using rule 179 (binary_expression -> expression MODULE expression .)
    CASE            reduce using rule 179 (binary_expression -> expression MODULE expression .)
    DEFAULT         reduce using rule 179 (binary_expression -> expression MODULE expression .)
    LBRACE          reduce using rule 179 (binary_expression -> expression MODULE expression .)
    SEMICOLON       reduce using rule 179 (binary_expression -> expression MODULE expression .)
    PLUS            shift and go to state 86
    MINUS           shift and go to state 87
    EQ              shift and go to state 91
    NEQ             shift and go to state 92
    LT              shift and go to state 93
    LE              shift and go to state 94
    GT              shift and go to state 95
    GE              shift and go to state 96
    LAND            shift and go to state 97
    LOR             shift and go to state 98
    AND             shift and go to state 99
    OR              shift and go to state 100
    XOR             shift and go to state 101
    LSHIFT          shift and go to state 103
    RSHIFT          shift and go to state 104

  ! PLUS            [ reduce using rule 179 (binary_expression -> expression MODULE expression .) ]
  ! MINUS           [ reduce using rule 179 (binary_expression -> expression MODULE expression .) ]
  ! EQ              [ reduce using rule 179 (binary_expression -> expression MODULE expression .) ]
  ! NEQ             [ reduce using rule 179 (binary_expression -> expression MODULE expression .) ]
  ! LT              [ reduce using rule 179 (binary_expression -> expression MODULE expression .) ]
  ! LE              [ reduce using rule 179 (binary_expression -> expression MODULE expression .) ]
  ! GT              [ reduce using rule 179 (binary_expression -> expression MODULE expression .) ]
  ! GE              [ reduce using rule 179 (binary_expression -> expression MODULE expression .) ]
  ! LAND            [ reduce using rule 179 (binary_expression -> expression MODULE expression .) ]
  ! LOR             [ reduce using rule 179 (binary_expression -> expression MODULE expression .) ]
  ! AND             [ reduce using rule 179 (binary_expression -> expression MODULE expression .) ]
  ! OR              [ reduce using rule 179 (binary_expression -> expression MODULE expression .) ]
  ! XOR             [ reduce using rule 179 (binary_expression -> expression MODULE expression .) ]
  ! LSHIFT          [ reduce using rule 179 (binary_expression -> expression MODULE expression .) ]
  ! RSHIFT          [ reduce using rule 179 (binary_expression -> expression MODULE expression .) ]
  ! TIMES           [ shift and go to state 88 ]
  ! DIVIDE          [ shift and go to state 89 ]
  ! MODULE          [ shift and go to state 90 ]
  ! AND_NOT         [ shift and go to state 102 ]


state 132

    (184) relational_expression -> expression EQ expression .
    (175) binary_expression -> expression . PLUS expression
    (176) binary_expression -> expression . MINUS expression
    (177) binary_expression -> expression . TIMES expression
    (178) binary_expression -> expression . DIVIDE expression
    (179) binary_expression -> expression . MODULE expression
    (184) relational_expression -> expression . EQ expression
    (185) relational_expression -> expression . NEQ expression
    (186) relational_expression -> expression . LT expression
    (187) relational_expression -> expression . LE expression
    (188) relational_expression -> expression . GT expression
    (189) relational_expression -> expression . GE expression
    (190) logical_expression -> expression . LAND expression
    (191) logical_expression -> expression . LOR expression
    (192) bitwise_expression -> expression . AND expression
    (193) bitwise_expression -> expression . OR expression
    (194) bitwise_expression -> expression . XOR expression
    (195) bitwise_expression -> expression . AND_NOT expression
    (196) bitwise_expression -> expression . LSHIFT expression
    (197) bitwise_expression -> expression . RSHIFT expression

    PLUS            reduce using rule 184 (relational_expression -> expression EQ expression .)
    MINUS           reduce using rule 184 (relational_expression -> expression EQ expression .)
    TIMES           reduce using rule 184 (relational_expression -> expression EQ expression .)
    DIVIDE          reduce using rule 184 (relational_expression -> expression EQ expression .)
    MODULE          reduce using rule 184 (relational_expression -> expression EQ expression .)
    EQ              reduce using rule 184 (relational_expression -> expression EQ expression .)
    NEQ             reduce using rule 184 (relational_expression -> expression EQ expression .)
    LT              reduce using rule 184 (relational_expression -> expression EQ expression .)
    LE              reduce using rule 184 (relational_expression -> expression EQ expression .)
    GT              reduce using rule 184 (relational_expression -> expression EQ expression .)
    GE              reduce using rule 184 (relational_expression -> expression EQ expression .)
    AND             reduce using rule 184 (relational_expression -> expression EQ expression .)
    OR              reduce using rule 184 (relational_expression -> expression EQ expression .)
    XOR             reduce using rule 184 (relational_expression -> expression EQ expression .)
    AND_NOT         reduce using rule 184 (relational_expression -> expression EQ expression .)
    LSHIFT          reduce using rule 184 (relational_expression -> expression EQ expression .)
    RSHIFT          reduce using rule 184 (relational_expression -> expression EQ expression .)
    VAR             reduce using rule 184 (relational_expression -> expression EQ expression .)
    CONST           reduce using rule 184 (relational_expression -> expression EQ expression .)
    FUNC            reduce using rule 184 (relational_expression -> expression EQ expression .)
    TYPE            reduce using rule 184 (relational_expression -> expression EQ expression .)
    $end            reduce using rule 184 (relational_expression -> expression EQ expression .)
    RPAREN          reduce using rule 184 (relational_expression -> expression EQ expression .)
    RBRACE          reduce using rule 184 (relational_expression -> expression EQ expression .)
    COMMA           reduce using rule 184 (relational_expression -> expression EQ expression .)
    COLON           reduce using rule 184 (relational_expression -> expression EQ expression .)
    IDENTIFIER      reduce using rule 184 (relational_expression -> expression EQ expression .)
    LPAREN          reduce using rule 184 (relational_expression -> expression EQ expression .)
    LNOT            reduce using rule 184 (relational_expression -> expression EQ expression .)
    INT             reduce using rule 184 (relational_expression -> expression EQ expression .)
    FLOAT64         reduce using rule 184 (relational_expression -> expression EQ expression .)
    TRUE            reduce using rule 184 (relational_expression -> expression EQ expression .)
    FALSE           reduce using rule 184 (relational_expression -> expression EQ expression .)
    STRING          reduce using rule 184 (relational_expression -> expression EQ expression .)
    RETURN          reduce using rule 184 (relational_expression -> expression EQ expression .)
    IF              reduce using rule 184 (relational_expression -> expression EQ expression .)
    SWITCH          reduce using rule 184 (relational_expression -> expression EQ expression .)
    BREAK           reduce using rule 184 (relational_expression -> expression EQ expression .)
    CONTINUE        reduce using rule 184 (relational_expression -> expression EQ expression .)
    LBRACKET        reduce using rule 184 (relational_expression -> expression EQ expression .)
    MAP             reduce using rule 184 (relational_expression -> expression EQ expression .)
    FOR             reduce using rule 184 (relational_expression -> expression EQ expression .)
    CASE            reduce using rule 184 (relational_expression -> expression EQ expression .)
    DEFAULT         reduce using rule 184 (relational_expression -> expression EQ expression .)
    LBRACE          reduce using rule 184 (relational_expression -> expression EQ expression .)
    SEMICOLON       reduce using rule 184 (relational_expression -> expression EQ expression .)
    LAND            shift and go to state 97
    LOR             shift and go to state 98

  ! LAND            [ reduce using rule 184 (relational_expression -> expression EQ expression .) ]
  ! LOR             [ reduce using rule 184 (relational_expression -> expression EQ expression .) ]
  ! PLUS            [ shift and go to state 86 ]
  ! MINUS           [ shift and go to state 87 ]
  ! TIMES           [ shift and go to state 88 ]
  ! DIVIDE          [ shift and go to state 89 ]
  ! MODULE          [ shift and go to state 90 ]
  ! EQ              [ shift and go to state 91 ]
  ! NEQ             [ shift and go to state 92 ]
  ! LT              [ shift and go to state 93 ]
  ! LE              [ shift and go to state 94 ]
  ! GT              [ shift and go to state 95 ]
  ! GE              [ shift and go to state 96 ]
  ! AND             [ shift and go to state 99 ]
  ! OR              [ shift and go to state 100 ]
  ! XOR             [ shift and go to state 101 ]
  ! AND_NOT         [ shift and go to state 102 ]
  ! LSHIFT          [ shift and go to state 103 ]
  ! RSHIFT          [ shift and go to state 104 ]


state 133

    (185) relational_expression -> expression NEQ expression .
    (175) binary_expression -> expression . PLUS expression
    (176) binary_expression -> expression . MINUS expression
    (177) binary_expression -> expression . TIMES expression
    (178) binary_expression -> expression . DIVIDE expression
    (179) binary_expression -> expression . MODULE expression
    (184) relational_expression -> expression . EQ expression
    (185) relational_expression -> expression . NEQ expression
    (186) relational_expression -> expression . LT expression
    (187) relational_expression -> expression . LE expression
    (188) relational_expression -> expression . GT expression
    (189) relational_expression -> expression . GE expression
    (190) logical_expression -> expression . LAND expression
    (191) logical_expression -> expression . LOR expression
    (192) bitwise_expression -> expression . AND expression
    (193) bitwise_expression -> expression . OR expression
    (194) bitwise_expression -> expression . XOR expression
    (195) bitwise_expression -> expression . AND_NOT expression
    (196) bitwise_expression -> expression . LSHIFT expression
    (197) bitwise_expression -> expression . RSHIFT expression

    PLUS            reduce using rule 185 (relational_expression -> expression NEQ expression .)
    MINUS           reduce using rule 185 (relational_expression -> expression NEQ expression .)
    TIMES           reduce using rule 185 (relational_expression -> expression NEQ expression .)
    DIVIDE          reduce using rule 185 (relational_expression -> expression NEQ expression .)
    MODULE          reduce using rule 185 (relational_expression -> expression NEQ expression .)
    EQ              reduce using rule 185 (relational_expression -> expression NEQ expression .)
    NEQ             reduce using rule 185 (relational_expression -> expression NEQ expression .)
    LT              reduce using rule 185 (relational_expression -> expression NEQ expression .)
    LE              reduce using rule 185 (relational_expression -> expression NEQ expression .)
    GT              reduce using rule 185 (relational_expression -> expression NEQ expression .)
    GE              reduce using rule 185 (relational_expression -> expression NEQ expression .)
    AND             reduce using rule 185 (relational_expression -> expression NEQ expression .)
    OR              reduce using rule 185 (relational_expression -> expression NEQ expression .)
    XOR             reduce using rule 185 (relational_expression -> expression NEQ expression .)
    AND_NOT         reduce using rule 185 (relational_expression -> expression NEQ expression .)
    LSHIFT          reduce using rule 185 (relational_expression -> expression NEQ expression .)
    RSHIFT          reduce using rule 185 (relational_expression -> expression NEQ expression .)
    VAR             reduce using rule 185 (relational_expression -> expression NEQ expression .)
    CONST           reduce using rule 185 (relational_expression -> expression NEQ expression .)
    FUNC            reduce using rule 185 (relational_expression -> expression NEQ expression .)
    TYPE            reduce using rule 185 (relational_expression -> expression NEQ expression .)
    $end            reduce using rule 185 (relational_expression -> expression NEQ expression .)
    RPAREN          reduce using rule 185 (relational_expression -> expression NEQ expression .)
    RBRACE          reduce using rule 185 (relational_expression -> expression NEQ expression .)
    COMMA           reduce using rule 185 (relational_expression -> expression NEQ expression .)
    COLON           reduce using rule 185 (relational_expression -> expression NEQ expression .)
    IDENTIFIER      reduce using rule 185 (relational_expression -> expression NEQ expression .)
    LPAREN          reduce using rule 185 (relational_expression -> expression NEQ expression .)
    LNOT            reduce using rule 185 (relational_expression -> expression NEQ expression .)
    INT             reduce using rule 185 (relational_expression -> expression NEQ expression .)
    FLOAT64         reduce using rule 185 (relational_expression -> expression NEQ expression .)
    TRUE            reduce using rule 185 (relational_expression -> expression NEQ expression .)
    FALSE           reduce using rule 185 (relational_expression -> expression NEQ expression .)
    STRING          reduce using rule 185 (relational_expression -> expression NEQ expression .)
    RETURN          reduce using rule 185 (relational_expression -> expression NEQ expression .)
    IF              reduce using rule 185 (relational_expression -> expression NEQ expression .)
    SWITCH          reduce using rule 185 (relational_expression -> expression NEQ expression .)
    BREAK           reduce using rule 185 (relational_expression -> expression NEQ expression .)
    CONTINUE        reduce using rule 185 (relational_expression -> expression NEQ expression .)
    LBRACKET        reduce using rule 185 (relational_expression -> expression NEQ expression .)
    MAP             reduce using rule 185 (relational_expression -> expression NEQ expression .)
    FOR             reduce using rule 185 (relational_expression -> expression NEQ expression .)
    CASE            reduce using rule 185 (relational_expression -> expression NEQ expression .)
    DEFAULT         reduce using rule 185 (relational_expression -> expression NEQ expression .)
    LBRACE          reduce using rule 185 (relational_expression -> expression NEQ expression .)
    SEMICOLON       reduce using rule 185 (relational_expression -> expression NEQ expression .)
    LAND            shift and go to state 97
    LOR             shift and go to state 98

  ! LAND            [ reduce using rule 185 (relational_expression -> expression NEQ expression .) ]
  ! LOR             [ reduce using rule 185 (relational_expression -> expression NEQ expression .) ]
  ! PLUS            [ shift and go to state 86 ]
  ! MINUS           [ shift and go to state 87 ]
  ! TIMES           [ shift and go to state 88 ]
  ! DIVIDE          [ shift and go to state 89 ]
  ! MODULE          [ shift and go to state 90 ]
  ! EQ              [ shift and go to state 91 ]
  ! NEQ             [ shift and go to state 92 ]
  ! LT              [ shift and go to state 93 ]
  ! LE              [ shift and go to state 94 ]
  ! GT              [ shift and go to state 95 ]
  ! GE              [ shift and go to state 96 ]
  ! AND             [ shift and go to state 99 ]
  ! OR              [ shift and go to state 100 ]
  ! XOR             [ shift and go to state 101 ]
  ! AND_NOT         [ shift and go to state 102 ]
  ! LSHIFT          [ shift and go to state 103 ]
  ! RSHIFT          [ shift and go to state 104 ]


state 134

    (186) relational_expression -> expression LT expression .
    (175) binary_expression -> expression . PLUS expression
    (176) binary_expression -> expression . MINUS expression
    (177) binary_expression -> expression . TIMES expression
    (178) binary_expression -> expression . DIVIDE expression
    (179) binary_expression -> expression . MODULE expression
    (184) relational_expression -> expression . EQ expression
    (185) relational_expression -> expression . NEQ expression
    (186) relational_expression -> expression . LT expression
    (187) relational_expression -> expression . LE expression
    (188) relational_expression -> expression . GT expression
    (189) relational_expression -> expression . GE expression
    (190) logical_expression -> expression . LAND expression
    (191) logical_expression -> expression . LOR expression
    (192) bitwise_expression -> expression . AND expression
    (193) bitwise_expression -> expression . OR expression
    (194) bitwise_expression -> expression . XOR expression
    (195) bitwise_expression -> expression . AND_NOT expression
    (196) bitwise_expression -> expression . LSHIFT expression
    (197) bitwise_expression -> expression . RSHIFT expression

    PLUS            reduce using rule 186 (relational_expression -> expression LT expression .)
    MINUS           reduce using rule 186 (relational_expression -> expression LT expression .)
    TIMES           reduce using rule 186 (relational_expression -> expression LT expression .)
    DIVIDE          reduce using rule 186 (relational_expression -> expression LT expression .)
    MODULE          reduce using rule 186 (relational_expression -> expression LT expression .)
    LT              reduce using rule 186 (relational_expression -> expression LT expression .)
    LE              reduce using rule 186 (relational_expression -> expression LT expression .)
    GT              reduce using rule 186 (relational_expression -> expression LT expression .)
    GE              reduce using rule 186 (relational_expression -> expression LT expression .)
    AND             reduce using rule 186 (relational_expression -> expression LT expression .)
    OR              reduce using rule 186 (relational_expression -> expression LT expression .)
    XOR             reduce using rule 186 (relational_expression -> expression LT expression .)
    AND_NOT         reduce using rule 186 (relational_expression -> expression LT expression .)
    LSHIFT          reduce using rule 186 (relational_expression -> expression LT expression .)
    RSHIFT          reduce using rule 186 (relational_expression -> expression LT expression .)
    VAR             reduce using rule 186 (relational_expression -> expression LT expression .)
    CONST           reduce using rule 186 (relational_expression -> expression LT expression .)
    FUNC            reduce using rule 186 (relational_expression -> expression LT expression .)
    TYPE            reduce using rule 186 (relational_expression -> expression LT expression .)
    $end            reduce using rule 186 (relational_expression -> expression LT expression .)
    RPAREN          reduce using rule 186 (relational_expression -> expression LT expression .)
    RBRACE          reduce using rule 186 (relational_expression -> expression LT expression .)
    COMMA           reduce using rule 186 (relational_expression -> expression LT expression .)
    COLON           reduce using rule 186 (relational_expression -> expression LT expression .)
    IDENTIFIER      reduce using rule 186 (relational_expression -> expression LT expression .)
    LPAREN          reduce using rule 186 (relational_expression -> expression LT expression .)
    LNOT            reduce using rule 186 (relational_expression -> expression LT expression .)
    INT             reduce using rule 186 (relational_expression -> expression LT expression .)
    FLOAT64         reduce using rule 186 (relational_expression -> expression LT expression .)
    TRUE            reduce using rule 186 (relational_expression -> expression LT expression .)
    FALSE           reduce using rule 186 (relational_expression -> expression LT expression .)
    STRING          reduce using rule 186 (relational_expression -> expression LT expression .)
    RETURN          reduce using rule 186 (relational_expression -> expression LT expression .)
    IF              reduce using rule 186 (relational_expression -> expression LT expression .)
    SWITCH          reduce using rule 186 (relational_expression -> expression LT expression .)
    BREAK           reduce using rule 186 (relational_expression -> expression LT expression .)
    CONTINUE        reduce using rule 186 (relational_expression -> expression LT expression .)
    LBRACKET        reduce using rule 186 (relational_expression -> expression LT expression .)
    MAP             reduce using rule 186 (relational_expression -> expression LT expression .)
    FOR             reduce using rule 186 (relational_expression -> expression LT expression .)
    CASE            reduce using rule 186 (relational_expression -> expression LT expression .)
    DEFAULT         reduce using rule 186 (relational_expression -> expression LT expression .)
    LBRACE          reduce using rule 186 (relational_expression -> expression LT expression .)
    SEMICOLON       reduce using rule 186 (relational_expression -> expression LT expression .)
    EQ              shift and go to state 91
    NEQ             shift and go to state 92
    LAND            shift and go to state 97
    LOR             shift and go to state 98

  ! EQ              [ reduce using rule 186 (relational_expression -> expression LT expression .) ]
  ! NEQ             [ reduce using rule 186 (relational_expression -> expression LT expression .) ]
  ! LAND            [ reduce using rule 186 (relational_expression -> expression LT expression .) ]
  ! LOR             [ reduce using rule 186 (relational_expression -> expression LT expression .) ]
  ! PLUS            [ shift and go to state 86 ]
  ! MINUS           [ shift and go to state 87 ]
  ! TIMES           [ shift and go to state 88 ]
  ! DIVIDE          [ shift and go to state 89 ]
  ! MODULE          [ shift and go to state 90 ]
  ! LT              [ shift and go to state 93 ]
  ! LE              [ shift and go to state 94 ]
  ! GT              [ shift and go to state 95 ]
  ! GE              [ shift and go to state 96 ]
  ! AND             [ shift and go to state 99 ]
  ! OR              [ shift and go to state 100 ]
  ! XOR             [ shift and go to state 101 ]
  ! AND_NOT         [ shift and go to state 102 ]
  ! LSHIFT          [ shift and go to state 103 ]
  ! RSHIFT          [ shift and go to state 104 ]


state 135

    (187) relational_expression -> expression LE expression .
    (175) binary_expression -> expression . PLUS expression
    (176) binary_expression -> expression . MINUS expression
    (177) binary_expression -> expression . TIMES expression
    (178) binary_expression -> expression . DIVIDE expression
    (179) binary_expression -> expression . MODULE expression
    (184) relational_expression -> expression . EQ expression
    (185) relational_expression -> expression . NEQ expression
    (186) relational_expression -> expression . LT expression
    (187) relational_expression -> expression . LE expression
    (188) relational_expression -> expression . GT expression
    (189) relational_expression -> expression . GE expression
    (190) logical_expression -> expression . LAND expression
    (191) logical_expression -> expression . LOR expression
    (192) bitwise_expression -> expression . AND expression
    (193) bitwise_expression -> expression . OR expression
    (194) bitwise_expression -> expression . XOR expression
    (195) bitwise_expression -> expression . AND_NOT expression
    (196) bitwise_expression -> expression . LSHIFT expression
    (197) bitwise_expression -> expression . RSHIFT expression

    PLUS            reduce using rule 187 (relational_expression -> expression LE expression .)
    MINUS           reduce using rule 187 (relational_expression -> expression LE expression .)
    TIMES           reduce using rule 187 (relational_expression -> expression LE expression .)
    DIVIDE          reduce using rule 187 (relational_expression -> expression LE expression .)
    MODULE          reduce using rule 187 (relational_expression -> expression LE expression .)
    LT              reduce using rule 187 (relational_expression -> expression LE expression .)
    LE              reduce using rule 187 (relational_expression -> expression LE expression .)
    GT              reduce using rule 187 (relational_expression -> expression LE expression .)
    GE              reduce using rule 187 (relational_expression -> expression LE expression .)
    AND             reduce using rule 187 (relational_expression -> expression LE expression .)
    OR              reduce using rule 187 (relational_expression -> expression LE expression .)
    XOR             reduce using rule 187 (relational_expression -> expression LE expression .)
    AND_NOT         reduce using rule 187 (relational_expression -> expression LE expression .)
    LSHIFT          reduce using rule 187 (relational_expression -> expression LE expression .)
    RSHIFT          reduce using rule 187 (relational_expression -> expression LE expression .)
    VAR             reduce using rule 187 (relational_expression -> expression LE expression .)
    CONST           reduce using rule 187 (relational_expression -> expression LE expression .)
    FUNC            reduce using rule 187 (relational_expression -> expression LE expression .)
    TYPE            reduce using rule 187 (relational_expression -> expression LE expression .)
    $end            reduce using rule 187 (relational_expression -> expression LE expression .)
    RPAREN          reduce using rule 187 (relational_expression -> expression LE expression .)
    RBRACE          reduce using rule 187 (relational_expression -> expression LE expression .)
    COMMA           reduce using rule 187 (relational_expression -> expression LE expression .)
    COLON           reduce using rule 187 (relational_expression -> expression LE expression .)
    IDENTIFIER      reduce using rule 187 (relational_expression -> expression LE expression .)
    LPAREN          reduce using rule 187 (relational_expression -> expression LE expression .)
    LNOT            reduce using rule 187 (relational_expression -> expression LE expression .)
    INT             reduce using rule 187 (relational_expression -> expression LE expression .)
    FLOAT64         reduce using rule 187 (relational_expression -> expression LE expression .)
    TRUE            reduce using rule 187 (relational_expression -> expression LE expression .)
    FALSE           reduce using rule 187 (relational_expression -> expression LE expression .)
    STRING          reduce using rule 187 (relational_expression -> expression LE expression .)
    RETURN          reduce using rule 187 (relational_expression -> expression LE expression .)
    IF              reduce using rule 187 (relational_expression -> expression LE expression .)
    SWITCH          reduce using rule 187 (relational_expression -> expression LE expression .)
    BREAK           reduce using rule 187 (relational_expression -> expression LE expression .)
    CONTINUE        reduce using rule 187 (relational_expression -> expression LE expression .)
    LBRACKET        reduce using rule 187 (relational_expression -> expression LE expression .)
    MAP             reduce using rule 187 (relational_expression -> expression LE expression .)
    FOR             reduce using rule 187 (relational_expression -> expression LE expression .)
    CASE            reduce using rule 187 (relational_expression -> expression LE expression .)
    DEFAULT         reduce using rule 187 (relational_expression -> expression LE expression .)
    LBRACE          reduce using rule 187 (relational_expression -> expression LE expression .)
    SEMICOLON       reduce using rule 187 (relational_expression -> expression LE expression .)
    EQ              shift and go to state 91
    NEQ             shift and go to state 92
    LAND            shift and go to state 97
    LOR             shift and go to state 98

  ! EQ              [ reduce using rule 187 (relational_expression -> expression LE expression .) ]
  ! NEQ             [ reduce using rule 187 (relational_expression -> expression LE expression .) ]
  ! LAND            [ reduce using rule 187 (relational_expression -> expression LE expression .) ]
  ! LOR             [ reduce using rule 187 (relational_expression -> expression LE expression .) ]
  ! PLUS            [ shift and go to state 86 ]
  ! MINUS           [ shift and go to state 87 ]
  ! TIMES           [ shift and go to state 88 ]
  ! DIVIDE          [ shift and go to state 89 ]
  ! MODULE          [ shift and go to state 90 ]
  ! LT              [ shift and go to state 93 ]
  ! LE              [ shift and go to state 94 ]
  ! GT              [ shift and go to state 95 ]
  ! GE              [ shift and go to state 96 ]
  ! AND             [ shift and go to state 99 ]
  ! OR              [ shift and go to state 100 ]
  ! XOR             [ shift and go to state 101 ]
  ! AND_NOT         [ shift and go to state 102 ]
  ! LSHIFT          [ shift and go to state 103 ]
  ! RSHIFT          [ shift and go to state 104 ]


state 136

    (188) relational_expression -> expression GT expression .
    (175) binary_expression -> expression . PLUS expression
    (176) binary_expression -> expression . MINUS expression
    (177) binary_expression -> expression . TIMES expression
    (178) binary_expression -> expression . DIVIDE expression
    (179) binary_expression -> expression . MODULE expression
    (184) relational_expression -> expression . EQ expression
    (185) relational_expression -> expression . NEQ expression
    (186) relational_expression -> expression . LT expression
    (187) relational_expression -> expression . LE expression
    (188) relational_expression -> expression . GT expression
    (189) relational_expression -> expression . GE expression
    (190) logical_expression -> expression . LAND expression
    (191) logical_expression -> expression . LOR expression
    (192) bitwise_expression -> expression . AND expression
    (193) bitwise_expression -> expression . OR expression
    (194) bitwise_expression -> expression . XOR expression
    (195) bitwise_expression -> expression . AND_NOT expression
    (196) bitwise_expression -> expression . LSHIFT expression
    (197) bitwise_expression -> expression . RSHIFT expression

    PLUS            reduce using rule 188 (relational_expression -> expression GT expression .)
    MINUS           reduce using rule 188 (relational_expression -> expression GT expression .)
    TIMES           reduce using rule 188 (relational_expression -> expression GT expression .)
    DIVIDE          reduce using rule 188 (relational_expression -> expression GT expression .)
    MODULE          reduce using rule 188 (relational_expression -> expression GT expression .)
    LT              reduce using rule 188 (relational_expression -> expression GT expression .)
    LE              reduce using rule 188 (relational_expression -> expression GT expression .)
    GT              reduce using rule 188 (relational_expression -> expression GT expression .)
    GE              reduce using rule 188 (relational_expression -> expression GT expression .)
    AND             reduce using rule 188 (relational_expression -> expression GT expression .)
    OR              reduce using rule 188 (relational_expression -> expression GT expression .)
    XOR             reduce using rule 188 (relational_expression -> expression GT expression .)
    AND_NOT         reduce using rule 188 (relational_expression -> expression GT expression .)
    LSHIFT          reduce using rule 188 (relational_expression -> expression GT expression .)
    RSHIFT          reduce using rule 188 (relational_expression -> expression GT expression .)
    VAR             reduce using rule 188 (relational_expression -> expression GT expression .)
    CONST           reduce using rule 188 (relational_expression -> expression GT expression .)
    FUNC            reduce using rule 188 (relational_expression -> expression GT expression .)
    TYPE            reduce using rule 188 (relational_expression -> expression GT expression .)
    $end            reduce using rule 188 (relational_expression -> expression GT expression .)
    RPAREN          reduce using rule 188 (relational_expression -> expression GT expression .)
    RBRACE          reduce using rule 188 (relational_expression -> expression GT expression .)
    COMMA           reduce using rule 188 (relational_expression -> expression GT expression .)
    COLON           reduce using rule 188 (relational_expression -> expression GT expression .)
    IDENTIFIER      reduce using rule 188 (relational_expression -> expression GT expression .)
    LPAREN          reduce using rule 188 (relational_expression -> expression GT expression .)
    LNOT            reduce using rule 188 (relational_expression -> expression GT expression .)
    INT             reduce using rule 188 (relational_expression -> expression GT expression .)
    FLOAT64         reduce using rule 188 (relational_expression -> expression GT expression .)
    TRUE            reduce using rule 188 (relational_expression -> expression GT expression .)
    FALSE           reduce using rule 188 (relational_expression -> expression GT expression .)
    STRING          reduce using rule 188 (relational_expression -> expression GT expression .)
    RETURN          reduce using rule 188 (relational_expression -> expression GT expression .)
    IF              reduce using rule 188 (relational_expression -> expression GT expression .)
    SWITCH          reduce using rule 188 (relational_expression -> expression GT expression .)
    BREAK           reduce using rule 188 (relational_expression -> expression GT expression .)
    CONTINUE        reduce using rule 188 (relational_expression -> expression GT expression .)
    LBRACKET        reduce using rule 188 (relational_expression -> expression GT expression .)
    MAP             reduce using rule 188 (relational_expression -> expression GT expression .)
    FOR             reduce using rule 188 (relational_expression -> expression GT expression .)
    CASE            reduce using rule 188 (relational_expression -> expression GT expression .)
    DEFAULT         reduce using rule 188 (relational_expression -> expression GT expression .)
    LBRACE          reduce using rule 188 (relational_expression -> expression GT expression .)
    SEMICOLON       reduce using rule 188 (relational_expression -> expression GT expression .)
    EQ              shift and go to state 91
    NEQ             shift and go to state 92
    LAND            shift and go to state 97
    LOR             shift and go to state 98

  ! EQ              [ reduce using rule 188 (relational_expression -> expression GT expression .) ]
  ! NEQ             [ reduce using rule 188 (relational_expression -> expression GT expression .) ]
  ! LAND            [ reduce using rule 188 (relational_expression -> expression GT expression .) ]
  ! LOR             [ reduce using rule 188 (relational_expression -> expression GT expression .) ]
  ! PLUS            [ shift and go to state 86 ]
  ! MINUS           [ shift and go to state 87 ]
  ! TIMES           [ shift and go to state 88 ]
  ! DIVIDE          [ shift and go to state 89 ]
  ! MODULE          [ shift and go to state 90 ]
  ! LT              [ shift and go to state 93 ]
  ! LE              [ shift and go to state 94 ]
  ! GT              [ shift and go to state 95 ]
  ! GE              [ shift and go to state 96 ]
  ! AND             [ shift and go to state 99 ]
  ! OR              [ shift and go to state 100 ]
  ! XOR             [ shift and go to state 101 ]
  ! AND_NOT         [ shift and go to state 102 ]
  ! LSHIFT          [ shift and go to state 103 ]
  ! RSHIFT          [ shift and go to state 104 ]


state 137

    (189) relational_expression -> expression GE expression .
    (175) binary_expression -> expression . PLUS expression
    (176) binary_expression -> expression . MINUS expression
    (177) binary_expression -> expression . TIMES expression
    (178) binary_expression -> expression . DIVIDE expression
    (179) binary_expression -> expression . MODULE expression
    (184) relational_expression -> expression . EQ expression
    (185) relational_expression -> expression . NEQ expression
    (186) relational_expression -> expression . LT expression
    (187) relational_expression -> expression . LE expression
    (188) relational_expression -> expression . GT expression
    (189) relational_expression -> expression . GE expression
    (190) logical_expression -> expression . LAND expression
    (191) logical_expression -> expression . LOR expression
    (192) bitwise_expression -> expression . AND expression
    (193) bitwise_expression -> expression . OR expression
    (194) bitwise_expression -> expression . XOR expression
    (195) bitwise_expression -> expression . AND_NOT expression
    (196) bitwise_expression -> expression . LSHIFT expression
    (197) bitwise_expression -> expression . RSHIFT expression

    PLUS            reduce using rule 189 (relational_expression -> expression GE expression .)
    MINUS           reduce using rule 189 (relational_expression -> expression GE expression .)
    TIMES           reduce using rule 189 (relational_expression -> expression GE expression .)
    DIVIDE          reduce using rule 189 (relational_expression -> expression GE expression .)
    MODULE          reduce using rule 189 (relational_expression -> expression GE expression .)
    LT              reduce using rule 189 (relational_expression -> expression GE expression .)
    LE              reduce using rule 189 (relational_expression -> expression GE expression .)
    GT              reduce using rule 189 (relational_expression -> expression GE expression .)
    GE              reduce using rule 189 (relational_expression -> expression GE expression .)
    AND             reduce using rule 189 (relational_expression -> expression GE expression .)
    OR              reduce using rule 189 (relational_expression -> expression GE expression .)
    XOR             reduce using rule 189 (relational_expression -> expression GE expression .)
    AND_NOT         reduce using rule 189 (relational_expression -> expression GE expression .)
    LSHIFT          reduce using rule 189 (relational_expression -> expression GE expression .)
    RSHIFT          reduce using rule 189 (relational_expression -> expression GE expression .)
    VAR             reduce using rule 189 (relational_expression -> expression GE expression .)
    CONST           reduce using rule 189 (relational_expression -> expression GE expression .)
    FUNC            reduce using rule 189 (relational_expression -> expression GE expression .)
    TYPE            reduce using rule 189 (relational_expression -> expression GE expression .)
    $end            reduce using rule 189 (relational_expression -> expression GE expression .)
    RPAREN          reduce using rule 189 (relational_expression -> expression GE expression .)
    RBRACE          reduce using rule 189 (relational_expression -> expression GE expression .)
    COMMA           reduce using rule 189 (relational_expression -> expression GE expression .)
    COLON           reduce using rule 189 (relational_expression -> expression GE expression .)
    IDENTIFIER      reduce using rule 189 (relational_expression -> expression GE expression .)
    LPAREN          reduce using rule 189 (relational_expression -> expression GE expression .)
    LNOT            reduce using rule 189 (relational_expression -> expression GE expression .)
    INT             reduce using rule 189 (relational_expression -> expression GE expression .)
    FLOAT64         reduce using rule 189 (relational_expression -> expression GE expression .)
    TRUE            reduce using rule 189 (relational_expression -> expression GE expression .)
    FALSE           reduce using rule 189 (relational_expression -> expression GE expression .)
    STRING          reduce using rule 189 (relational_expression -> expression GE expression .)
    RETURN          reduce using rule 189 (relational_expression -> expression GE expression .)
    IF              reduce using rule 189 (relational_expression -> expression GE expression .)
    SWITCH          reduce using rule 189 (relational_expression -> expression GE expression .)
    BREAK           reduce using rule 189 (relational_expression -> expression GE expression .)
    CONTINUE        reduce using rule 189 (relational_expression -> expression GE expression .)
    LBRACKET        reduce using rule 189 (relational_expression -> expression GE expression .)
    MAP             reduce using rule 189 (relational_expression -> expression GE expression .)
    FOR             reduce using rule 189 (relational_expression -> expression GE expression .)
    CASE            reduce using rule 189 (relational_expression -> expression GE expression .)
    DEFAULT         reduce using rule 189 (relational_expression -> expression GE expression .)
    LBRACE          reduce using rule 189 (relational_expression -> expression GE expression .)
    SEMICOLON       reduce using rule 189 (relational_expression -> expression GE expression .)
    EQ              shift and go to state 91
    NEQ             shift and go to state 92
    LAND            shift and go to state 97
    LOR             shift and go to state 98

  ! EQ              [ reduce using rule 189 (relational_expression -> expression GE expression .) ]
  ! NEQ             [ reduce using rule 189 (relational_expression -> expression GE expression .) ]
  ! LAND            [ reduce using rule 189 (relational_expression -> expression GE expression .) ]
  ! LOR             [ reduce using rule 189 (relational_expression -> expression GE expression .) ]
  ! PLUS            [ shift and go to state 86 ]
  ! MINUS           [ shift and go to state 87 ]
  ! TIMES           [ shift and go to state 88 ]
  ! DIVIDE          [ shift and go to state 89 ]
  ! MODULE          [ shift and go to state 90 ]
  ! LT              [ shift and go to state 93 ]
  ! LE              [ shift and go to state 94 ]
  ! GT              [ shift and go to state 95 ]
  ! GE              [ shift and go to state 96 ]
  ! AND             [ shift and go to state 99 ]
  ! OR              [ shift and go to state 100 ]
  ! XOR             [ shift and go to state 101 ]
  ! AND_NOT         [ shift and go to state 102 ]
  ! LSHIFT          [ shift and go to state 103 ]
  ! RSHIFT          [ shift and go to state 104 ]


state 138

    (190) logical_expression -> expression LAND expression .
    (175) binary_expression -> expression . PLUS expression
    (176) binary_expression -> expression . MINUS expression
    (177) binary_expression -> expression . TIMES expression
    (178) binary_expression -> expression . DIVIDE expression
    (179) binary_expression -> expression . MODULE expression
    (184) relational_expression -> expression . EQ expression
    (185) relational_expression -> expression . NEQ expression
    (186) relational_expression -> expression . LT expression
    (187) relational_expression -> expression . LE expression
    (188) relational_expression -> expression . GT expression
    (189) relational_expression -> expression . GE expression
    (190) logical_expression -> expression . LAND expression
    (191) logical_expression -> expression . LOR expression
    (192) bitwise_expression -> expression . AND expression
    (193) bitwise_expression -> expression . OR expression
    (194) bitwise_expression -> expression . XOR expression
    (195) bitwise_expression -> expression . AND_NOT expression
    (196) bitwise_expression -> expression . LSHIFT expression
    (197) bitwise_expression -> expression . RSHIFT expression

    PLUS            reduce using rule 190 (logical_expression -> expression LAND expression .)
    MINUS           reduce using rule 190 (logical_expression -> expression LAND expression .)
    TIMES           reduce using rule 190 (logical_expression -> expression LAND expression .)
    DIVIDE          reduce using rule 190 (logical_expression -> expression LAND expression .)
    MODULE          reduce using rule 190 (logical_expression -> expression LAND expression .)
    EQ              reduce using rule 190 (logical_expression -> expression LAND expression .)
    NEQ             reduce using rule 190 (logical_expression -> expression LAND expression .)
    LT              reduce using rule 190 (logical_expression -> expression LAND expression .)
    LE              reduce using rule 190 (logical_expression -> expression LAND expression .)
    GT              reduce using rule 190 (logical_expression -> expression LAND expression .)
    GE              reduce using rule 190 (logical_expression -> expression LAND expression .)
    LAND            reduce using rule 190 (logical_expression -> expression LAND expression .)
    AND             reduce using rule 190 (logical_expression -> expression LAND expression .)
    OR              reduce using rule 190 (logical_expression -> expression LAND expression .)
    XOR             reduce using rule 190 (logical_expression -> expression LAND expression .)
    AND_NOT         reduce using rule 190 (logical_expression -> expression LAND expression .)
    LSHIFT          reduce using rule 190 (logical_expression -> expression LAND expression .)
    RSHIFT          reduce using rule 190 (logical_expression -> expression LAND expression .)
    VAR             reduce using rule 190 (logical_expression -> expression LAND expression .)
    CONST           reduce using rule 190 (logical_expression -> expression LAND expression .)
    FUNC            reduce using rule 190 (logical_expression -> expression LAND expression .)
    TYPE            reduce using rule 190 (logical_expression -> expression LAND expression .)
    $end            reduce using rule 190 (logical_expression -> expression LAND expression .)
    RPAREN          reduce using rule 190 (logical_expression -> expression LAND expression .)
    RBRACE          reduce using rule 190 (logical_expression -> expression LAND expression .)
    COMMA           reduce using rule 190 (logical_expression -> expression LAND expression .)
    COLON           reduce using rule 190 (logical_expression -> expression LAND expression .)
    IDENTIFIER      reduce using rule 190 (logical_expression -> expression LAND expression .)
    LPAREN          reduce using rule 190 (logical_expression -> expression LAND expression .)
    LNOT            reduce using rule 190 (logical_expression -> expression LAND expression .)
    INT             reduce using rule 190 (logical_expression -> expression LAND expression .)
    FLOAT64         reduce using rule 190 (logical_expression -> expression LAND expression .)
    TRUE            reduce using rule 190 (logical_expression -> expression LAND expression .)
    FALSE           reduce using rule 190 (logical_expression -> expression LAND expression .)
    STRING          reduce using rule 190 (logical_expression -> expression LAND expression .)
    RETURN          reduce using rule 190 (logical_expression -> expression LAND expression .)
    IF              reduce using rule 190 (logical_expression -> expression LAND expression .)
    SWITCH          reduce using rule 190 (logical_expression -> expression LAND expression .)
    BREAK           reduce using rule 190 (logical_expression -> expression LAND expression .)
    CONTINUE        reduce using rule 190 (logical_expression -> expression LAND expression .)
    LBRACKET        reduce using rule 190 (logical_expression -> expression LAND expression .)
    MAP             reduce using rule 190 (logical_expression -> expression LAND expression .)
    FOR             reduce using rule 190 (logical_expression -> expression LAND expression .)
    CASE            reduce using rule 190 (logical_expression -> expression LAND expression .)
    DEFAULT         reduce using rule 190 (logical_expression -> expression LAND expression .)
    LBRACE          reduce using rule 190 (logical_expression -> expression LAND expression .)
    SEMICOLON       reduce using rule 190 (logical_expression -> expression LAND expression .)
    LOR             shift and go to state 98

  ! LOR             [ reduce using rule 190 (logical_expression -> expression LAND expression .) ]
  ! PLUS            [ shift and go to state 86 ]
  ! MINUS           [ shift and go to state 87 ]
  ! TIMES           [ shift and go to state 88 ]
  ! DIVIDE          [ shift and go to state 89 ]
  ! MODULE          [ shift and go to state 90 ]
  ! EQ              [ shift and go to state 91 ]
  ! NEQ             [ shift and go to state 92 ]
  ! LT              [ shift and go to state 93 ]
  ! LE              [ shift and go to state 94 ]
  ! GT              [ shift and go to state 95 ]
  ! GE              [ shift and go to state 96 ]
  ! LAND            [ shift and go to state 97 ]
  ! AND             [ shift and go to state 99 ]
  ! OR              [ shift and go to state 100 ]
  ! XOR             [ shift and go to state 101 ]
  ! AND_NOT         [ shift and go to state 102 ]
  ! LSHIFT          [ shift and go to state 103 ]
  ! RSHIFT          [ shift and go to state 104 ]


state 139

    (191) logical_expression -> expression LOR expression .
    (175) binary_expression -> expression . PLUS expression
    (176) binary_expression -> expression . MINUS expression
    (177) binary_expression -> expression . TIMES expression
    (178) binary_expression -> expression . DIVIDE expression
    (179) binary_expression -> expression . MODULE expression
    (184) relational_expression -> expression . EQ expression
    (185) relational_expression -> expression . NEQ expression
    (186) relational_expression -> expression . LT expression
    (187) relational_expression -> expression . LE expression
    (188) relational_expression -> expression . GT expression
    (189) relational_expression -> expression . GE expression
    (190) logical_expression -> expression . LAND expression
    (191) logical_expression -> expression . LOR expression
    (192) bitwise_expression -> expression . AND expression
    (193) bitwise_expression -> expression . OR expression
    (194) bitwise_expression -> expression . XOR expression
    (195) bitwise_expression -> expression . AND_NOT expression
    (196) bitwise_expression -> expression . LSHIFT expression
    (197) bitwise_expression -> expression . RSHIFT expression

    PLUS            reduce using rule 191 (logical_expression -> expression LOR expression .)
    MINUS           reduce using rule 191 (logical_expression -> expression LOR expression .)
    TIMES           reduce using rule 191 (logical_expression -> expression LOR expression .)
    DIVIDE          reduce using rule 191 (logical_expression -> expression LOR expression .)
    MODULE          reduce using rule 191 (logical_expression -> expression LOR expression .)
    EQ              reduce using rule 191 (logical_expression -> expression LOR expression .)
    NEQ             reduce using rule 191 (logical_expression -> expression LOR expression .)
    LT              reduce using rule 191 (logical_expression -> expression LOR expression .)
    LE              reduce using rule 191 (logical_expression -> expression LOR expression .)
    GT              reduce using rule 191 (logical_expression -> expression LOR expression .)
    GE              reduce using rule 191 (logical_expression -> expression LOR expression .)
    LAND            reduce using rule 191 (logical_expression -> expression LOR expression .)
    LOR             reduce using rule 191 (logical_expression -> expression LOR expression .)
    AND             reduce using rule 191 (logical_expression -> expression LOR expression .)
    OR              reduce using rule 191 (logical_expression -> expression LOR expression .)
    XOR             reduce using rule 191 (logical_expression -> expression LOR expression .)
    AND_NOT         reduce using rule 191 (logical_expression -> expression LOR expression .)
    LSHIFT          reduce using rule 191 (logical_expression -> expression LOR expression .)
    RSHIFT          reduce using rule 191 (logical_expression -> expression LOR expression .)
    VAR             reduce using rule 191 (logical_expression -> expression LOR expression .)
    CONST           reduce using rule 191 (logical_expression -> expression LOR expression .)
    FUNC            reduce using rule 191 (logical_expression -> expression LOR expression .)
    TYPE            reduce using rule 191 (logical_expression -> expression LOR expression .)
    $end            reduce using rule 191 (logical_expression -> expression LOR expression .)
    RPAREN          reduce using rule 191 (logical_expression -> expression LOR expression .)
    RBRACE          reduce using rule 191 (logical_expression -> expression LOR expression .)
    COMMA           reduce using rule 191 (logical_expression -> expression LOR expression .)
    COLON           reduce using rule 191 (logical_expression -> expression LOR expression .)
    IDENTIFIER      reduce using rule 191 (logical_expression -> expression LOR expression .)
    LPAREN          reduce using rule 191 (logical_expression -> expression LOR expression .)
    LNOT            reduce using rule 191 (logical_expression -> expression LOR expression .)
    INT             reduce using rule 191 (logical_expression -> expression LOR expression .)
    FLOAT64         reduce using rule 191 (logical_expression -> expression LOR expression .)
    TRUE            reduce using rule 191 (logical_expression -> expression LOR expression .)
    FALSE           reduce using rule 191 (logical_expression -> expression LOR expression .)
    STRING          reduce using rule 191 (logical_expression -> expression LOR expression .)
    RETURN          reduce using rule 191 (logical_expression -> expression LOR expression .)
    IF              reduce using rule 191 (logical_expression -> expression LOR expression .)
    SWITCH          reduce using rule 191 (logical_expression -> expression LOR expression .)
    BREAK           reduce using rule 191 (logical_expression -> expression LOR expression .)
    CONTINUE        reduce using rule 191 (logical_expression -> expression LOR expression .)
    LBRACKET        reduce using rule 191 (logical_expression -> expression LOR expression .)
    MAP             reduce using rule 191 (logical_expression -> expression LOR expression .)
    FOR             reduce using rule 191 (logical_expression -> expression LOR expression .)
    CASE            reduce using rule 191 (logical_expression -> expression LOR expression .)
    DEFAULT         reduce using rule 191 (logical_expression -> expression LOR expression .)
    LBRACE          reduce using rule 191 (logical_expression -> expression LOR expression .)
    SEMICOLON       reduce using rule 191 (logical_expression -> expression LOR expression .)

  ! PLUS            [ shift and go to state 86 ]
  ! MINUS           [ shift and go to state 87 ]
  ! TIMES           [ shift and go to state 88 ]
  ! DIVIDE          [ shift and go to state 89 ]
  ! MODULE          [ shift and go to state 90 ]
  ! EQ              [ shift and go to state 91 ]
  ! NEQ             [ shift and go to state 92 ]
  ! LT              [ shift and go to state 93 ]
  ! LE              [ shift and go to state 94 ]
  ! GT              [ shift and go to state 95 ]
  ! GE              [ shift and go to state 96 ]
  ! LAND            [ shift and go to state 97 ]
  ! LOR             [ shift and go to state 98 ]
  ! AND             [ shift and go to state 99 ]
  ! OR              [ shift and go to state 100 ]
  ! XOR             [ shift and go to state 101 ]
  ! AND_NOT         [ shift and go to state 102 ]
  ! LSHIFT          [ shift and go to state 103 ]
  ! RSHIFT          [ shift and go to state 104 ]


state 140

    (192) bitwise_expression -> expression AND expression .
    (175) binary_expression -> expression . PLUS expression
    (176) binary_expression -> expression . MINUS expression
    (177) binary_expression -> expression . TIMES expression
    (178) binary_expression -> expression . DIVIDE expression
    (179) binary_expression -> expression . MODULE expression
    (184) relational_expression -> expression . EQ expression
    (185) relational_expression -> expression . NEQ expression
    (186) relational_expression -> expression . LT expression
    (187) relational_expression -> expression . LE expression
    (188) relational_expression -> expression . GT expression
    (189) relational_expression -> expression . GE expression
    (190) logical_expression -> expression . LAND expression
    (191) logical_expression -> expression . LOR expression
    (192) bitwise_expression -> expression . AND expression
    (193) bitwise_expression -> expression . OR expression
    (194) bitwise_expression -> expression . XOR expression
    (195) bitwise_expression -> expression . AND_NOT expression
    (196) bitwise_expression -> expression . LSHIFT expression
    (197) bitwise_expression -> expression . RSHIFT expression

    PLUS            reduce using rule 192 (bitwise_expression -> expression AND expression .)
    MINUS           reduce using rule 192 (bitwise_expression -> expression AND expression .)
    TIMES           reduce using rule 192 (bitwise_expression -> expression AND expression .)
    DIVIDE          reduce using rule 192 (bitwise_expression -> expression AND expression .)
    MODULE          reduce using rule 192 (bitwise_expression -> expression AND expression .)
    AND             reduce using rule 192 (bitwise_expression -> expression AND expression .)
    AND_NOT         reduce using rule 192 (bitwise_expression -> expression AND expression .)
    LSHIFT          reduce using rule 192 (bitwise_expression -> expression AND expression .)
    RSHIFT          reduce using rule 192 (bitwise_expression -> expression AND expression .)
    VAR             reduce using rule 192 (bitwise_expression -> expression AND expression .)
    CONST           reduce using rule 192 (bitwise_expression -> expression AND expression .)
    FUNC            reduce using rule 192 (bitwise_expression -> expression AND expression .)
    TYPE            reduce using rule 192 (bitwise_expression -> expression AND expression .)
    $end            reduce using rule 192 (bitwise_expression -> expression AND expression .)
    RPAREN          reduce using rule 192 (bitwise_expression -> expression AND expression .)
    RBRACE          reduce using rule 192 (bitwise_expression -> expression AND expression .)
    COMMA           reduce using rule 192 (bitwise_expression -> expression AND expression .)
    COLON           reduce using rule 192 (bitwise_expression -> expression AND expression .)
    IDENTIFIER      reduce using rule 192 (bitwise_expression -> expression AND expression .)
    LPAREN          reduce using rule 192 (bitwise_expression -> expression AND expression .)
    LNOT            reduce using rule 192 (bitwise_expression -> expression AND expression .)
    INT             reduce using rule 192 (bitwise_expression -> expression AND expression .)
    FLOAT64         reduce using rule 192 (bitwise_expression -> expression AND expression .)
    TRUE            reduce using rule 192 (bitwise_expression -> expression AND expression .)
    FALSE           reduce using rule 192 (bitwise_expression -> expression AND expression .)
    STRING          reduce using rule 192 (bitwise_expression -> expression AND expression .)
    RETURN          reduce using rule 192 (bitwise_expression -> expression AND expression .)
    IF              reduce using rule 192 (bitwise_expression -> expression AND expression .)
    SWITCH          reduce using rule 192 (bitwise_expression -> expression AND expression .)
    BREAK           reduce using rule 192 (bitwise_expression -> expression AND expression .)
    CONTINUE        reduce using rule 192 (bitwise_expression -> expression AND expression .)
    LBRACKET        reduce using rule 192 (bitwise_expression -> expression AND expression .)
    MAP             reduce using rule 192 (bitwise_expression -> expression AND expression .)
    FOR             reduce using rule 192 (bitwise_expression -> expression AND expression .)
    CASE            reduce using rule 192 (bitwise_expression -> expression AND expression .)
    DEFAULT         reduce using rule 192 (bitwise_expression -> expression AND expression .)
    LBRACE          reduce using rule 192 (bitwise_expression -> expression AND expression .)
    SEMICOLON       reduce using rule 192 (bitwise_expression -> expression AND expression .)
    EQ              shift and go to state 91
    NEQ             shift and go to state 92
    LT              shift and go to state 93
    LE              shift and go to state 94
    GT              shift and go to state 95
    GE              shift and go to state 96
    LAND            shift and go to state 97
    LOR             shift and go to state 98
    OR              shift and go to state 100
    XOR             shift and go to state 101

  ! EQ              [ reduce using rule 192 (bitwise_expression -> expression AND expression .) ]
  ! NEQ             [ reduce using rule 192 (bitwise_expression -> expression AND expression .) ]
  ! LT              [ reduce using rule 192 (bitwise_expression -> expression AND expression .) ]
  ! LE              [ reduce using rule 192 (bitwise_expression -> expression AND expression .) ]
  ! GT              [ reduce using rule 192 (bitwise_expression -> expression AND expression .) ]
  ! GE              [ reduce using rule 192 (bitwise_expression -> expression AND expression .) ]
  ! LAND            [ reduce using rule 192 (bitwise_expression -> expression AND expression .) ]
  ! LOR             [ reduce using rule 192 (bitwise_expression -> expression AND expression .) ]
  ! OR              [ reduce using rule 192 (bitwise_expression -> expression AND expression .) ]
  ! XOR             [ reduce using rule 192 (bitwise_expression -> expression AND expression .) ]
  ! PLUS            [ shift and go to state 86 ]
  ! MINUS           [ shift and go to state 87 ]
  ! TIMES           [ shift and go to state 88 ]
  ! DIVIDE          [ shift and go to state 89 ]
  ! MODULE          [ shift and go to state 90 ]
  ! AND             [ shift and go to state 99 ]
  ! AND_NOT         [ shift and go to state 102 ]
  ! LSHIFT          [ shift and go to state 103 ]
  ! RSHIFT          [ shift and go to state 104 ]


state 141

    (193) bitwise_expression -> expression OR expression .
    (175) binary_expression -> expression . PLUS expression
    (176) binary_expression -> expression . MINUS expression
    (177) binary_expression -> expression . TIMES expression
    (178) binary_expression -> expression . DIVIDE expression
    (179) binary_expression -> expression . MODULE expression
    (184) relational_expression -> expression . EQ expression
    (185) relational_expression -> expression . NEQ expression
    (186) relational_expression -> expression . LT expression
    (187) relational_expression -> expression . LE expression
    (188) relational_expression -> expression . GT expression
    (189) relational_expression -> expression . GE expression
    (190) logical_expression -> expression . LAND expression
    (191) logical_expression -> expression . LOR expression
    (192) bitwise_expression -> expression . AND expression
    (193) bitwise_expression -> expression . OR expression
    (194) bitwise_expression -> expression . XOR expression
    (195) bitwise_expression -> expression . AND_NOT expression
    (196) bitwise_expression -> expression . LSHIFT expression
    (197) bitwise_expression -> expression . RSHIFT expression

    PLUS            reduce using rule 193 (bitwise_expression -> expression OR expression .)
    MINUS           reduce using rule 193 (bitwise_expression -> expression OR expression .)
    TIMES           reduce using rule 193 (bitwise_expression -> expression OR expression .)
    DIVIDE          reduce using rule 193 (bitwise_expression -> expression OR expression .)
    MODULE          reduce using rule 193 (bitwise_expression -> expression OR expression .)
    AND             reduce using rule 193 (bitwise_expression -> expression OR expression .)
    OR              reduce using rule 193 (bitwise_expression -> expression OR expression .)
    XOR             reduce using rule 193 (bitwise_expression -> expression OR expression .)
    AND_NOT         reduce using rule 193 (bitwise_expression -> expression OR expression .)
    LSHIFT          reduce using rule 193 (bitwise_expression -> expression OR expression .)
    RSHIFT          reduce using rule 193 (bitwise_expression -> expression OR expression .)
    VAR             reduce using rule 193 (bitwise_expression -> expression OR expression .)
    CONST           reduce using rule 193 (bitwise_expression -> expression OR expression .)
    FUNC            reduce using rule 193 (bitwise_expression -> expression OR expression .)
    TYPE            reduce using rule 193 (bitwise_expression -> expression OR expression .)
    $end            reduce using rule 193 (bitwise_expression -> expression OR expression .)
    RPAREN          reduce using rule 193 (bitwise_expression -> expression OR expression .)
    RBRACE          reduce using rule 193 (bitwise_expression -> expression OR expression .)
    COMMA           reduce using rule 193 (bitwise_expression -> expression OR expression .)
    COLON           reduce using rule 193 (bitwise_expression -> expression OR expression .)
    IDENTIFIER      reduce using rule 193 (bitwise_expression -> expression OR expression .)
    LPAREN          reduce using rule 193 (bitwise_expression -> expression OR expression .)
    LNOT            reduce using rule 193 (bitwise_expression -> expression OR expression .)
    INT             reduce using rule 193 (bitwise_expression -> expression OR expression .)
    FLOAT64         reduce using rule 193 (bitwise_expression -> expression OR expression .)
    TRUE            reduce using rule 193 (bitwise_expression -> expression OR expression .)
    FALSE           reduce using rule 193 (bitwise_expression -> expression OR expression .)
    STRING          reduce using rule 193 (bitwise_expression -> expression OR expression .)
    RETURN          reduce using rule 193 (bitwise_expression -> expression OR expression .)
    IF              reduce using rule 193 (bitwise_expression -> expression OR expression .)
    SWITCH          reduce using rule 193 (bitwise_expression -> expression OR expression .)
    BREAK           reduce using rule 193 (bitwise_expression -> expression OR expression .)
    CONTINUE        reduce using rule 193 (bitwise_expression -> expression OR expression .)
    LBRACKET        reduce using rule 193 (bitwise_expression -> expression OR expression .)
    MAP             reduce using rule 193 (bitwise_expression -> expression OR expression .)
    FOR             reduce using rule 193 (bitwise_expression -> expression OR expression .)
    CASE            reduce using rule 193 (bitwise_expression -> expression OR expression .)
    DEFAULT         reduce using rule 193 (bitwise_expression -> expression OR expression .)
    LBRACE          reduce using rule 193 (bitwise_expression -> expression OR expression .)
    SEMICOLON       reduce using rule 193 (bitwise_expression -> expression OR expression .)
    EQ              shift and go to state 91
    NEQ             shift and go to state 92
    LT              shift and go to state 93
    LE              shift and go to state 94
    GT              shift and go to state 95
    GE              shift and go to state 96
    LAND            shift and go to state 97
    LOR             shift and go to state 98

  ! EQ              [ reduce using rule 193 (bitwise_expression -> expression OR expression .) ]
  ! NEQ             [ reduce using rule 193 (bitwise_expression -> expression OR expression .) ]
  ! LT              [ reduce using rule 193 (bitwise_expression -> expression OR expression .) ]
  ! LE              [ reduce using rule 193 (bitwise_expression -> expression OR expression .) ]
  ! GT              [ reduce using rule 193 (bitwise_expression -> expression OR expression .) ]
  ! GE              [ reduce using rule 193 (bitwise_expression -> expression OR expression .) ]
  ! LAND            [ reduce using rule 193 (bitwise_expression -> expression OR expression .) ]
  ! LOR             [ reduce using rule 193 (bitwise_expression -> expression OR expression .) ]
  ! PLUS            [ shift and go to state 86 ]
  ! MINUS           [ shift and go to state 87 ]
  ! TIMES           [ shift and go to state 88 ]
  ! DIVIDE          [ shift and go to state 89 ]
  ! MODULE          [ shift and go to state 90 ]
  ! AND             [ shift and go to state 99 ]
  ! OR              [ shift and go to state 100 ]
  ! XOR             [ shift and go to state 101 ]
  ! AND_NOT         [ shift and go to state 102 ]
  ! LSHIFT          [ shift and go to state 103 ]
  ! RSHIFT          [ shift and go to state 104 ]


state 142

    (194) bitwise_expression -> expression XOR expression .
    (175) binary_expression -> expression . PLUS expression
    (176) binary_expression -> expression . MINUS expression
    (177) binary_expression -> expression . TIMES expression
    (178) binary_expression -> expression . DIVIDE expression
    (179) binary_expression -> expression . MODULE expression
    (184) relational_expression -> expression . EQ expression
    (185) relational_expression -> expression . NEQ expression
    (186) relational_expression -> expression . LT expression
    (187) relational_expression -> expression . LE expression
    (188) relational_expression -> expression . GT expression
    (189) relational_expression -> expression . GE expression
    (190) logical_expression -> expression . LAND expression
    (191) logical_expression -> expression . LOR expression
    (192) bitwise_expression -> expression . AND expression
    (193) bitwise_expression -> expression . OR expression
    (194) bitwise_expression -> expression . XOR expression
    (195) bitwise_expression -> expression . AND_NOT expression
    (196) bitwise_expression -> expression . LSHIFT expression
    (197) bitwise_expression -> expression . RSHIFT expression

    PLUS            reduce using rule 194 (bitwise_expression -> expression XOR expression .)
    MINUS           reduce using rule 194 (bitwise_expression -> expression XOR expression .)
    TIMES           reduce using rule 194 (bitwise_expression -> expression XOR expression .)
    DIVIDE          reduce using rule 194 (bitwise_expression -> expression XOR expression .)
    MODULE          reduce using rule 194 (bitwise_expression -> expression XOR expression .)
    AND             reduce using rule 194 (bitwise_expression -> expression XOR expression .)
    XOR             reduce using rule 194 (bitwise_expression -> expression XOR expression .)
    AND_NOT         reduce using rule 194 (bitwise_expression -> expression XOR expression .)
    LSHIFT          reduce using rule 194 (bitwise_expression -> expression XOR expression .)
    RSHIFT          reduce using rule 194 (bitwise_expression -> expression XOR expression .)
    VAR             reduce using rule 194 (bitwise_expression -> expression XOR expression .)
    CONST           reduce using rule 194 (bitwise_expression -> expression XOR expression .)
    FUNC            reduce using rule 194 (bitwise_expression -> expression XOR expression .)
    TYPE            reduce using rule 194 (bitwise_expression -> expression XOR expression .)
    $end            reduce using rule 194 (bitwise_expression -> expression XOR expression .)
    RPAREN          reduce using rule 194 (bitwise_expression -> expression XOR expression .)
    RBRACE          reduce using rule 194 (bitwise_expression -> expression XOR expression .)
    COMMA           reduce using rule 194 (bitwise_expression -> expression XOR expression .)
    COLON           reduce using rule 194 (bitwise_expression -> expression XOR expression .)
    IDENTIFIER      reduce using rule 194 (bitwise_expression -> expression XOR expression .)
    LPAREN          reduce using rule 194 (bitwise_expression -> expression XOR expression .)
    LNOT            reduce using rule 194 (bitwise_expression -> expression XOR expression .)
    INT             reduce using rule 194 (bitwise_expression -> expression XOR expression .)
    FLOAT64         reduce using rule 194 (bitwise_expression -> expression XOR expression .)
    TRUE            reduce using rule 194 (bitwise_expression -> expression XOR expression .)
    FALSE           reduce using rule 194 (bitwise_expression -> expression XOR expression .)
    STRING          reduce using rule 194 (bitwise_expression -> expression XOR expression .)
    RETURN          reduce using rule 194 (bitwise_expression -> expression XOR expression .)
    IF              reduce using rule 194 (bitwise_expression -> expression XOR expression .)
    SWITCH          reduce using rule 194 (bitwise_expression -> expression XOR expression .)
    BREAK           reduce using rule 194 (bitwise_expression -> expression XOR expression .)
    CONTINUE        reduce using rule 194 (bitwise_expression -> expression XOR expression .)
    LBRACKET        reduce using rule 194 (bitwise_expression -> expression XOR expression .)
    MAP             reduce using rule 194 (bitwise_expression -> expression XOR expression .)
    FOR             reduce using rule 194 (bitwise_expression -> expression XOR expression .)
    CASE            reduce using rule 194 (bitwise_expression -> expression XOR expression .)
    DEFAULT         reduce using rule 194 (bitwise_expression -> expression XOR expression .)
    LBRACE          reduce using rule 194 (bitwise_expression -> expression XOR expression .)
    SEMICOLON       reduce using rule 194 (bitwise_expression -> expression XOR expression .)
    EQ              shift and go to state 91
    NEQ             shift and go to state 92
    LT              shift and go to state 93
    LE              shift and go to state 94
    GT              shift and go to state 95
    GE              shift and go to state 96
    LAND            shift and go to state 97
    LOR             shift and go to state 98
    OR              shift and go to state 100

  ! EQ              [ reduce using rule 194 (bitwise_expression -> expression XOR expression .) ]
  ! NEQ             [ reduce using rule 194 (bitwise_expression -> expression XOR expression .) ]
  ! LT              [ reduce using rule 194 (bitwise_expression -> expression XOR expression .) ]
  ! LE              [ reduce using rule 194 (bitwise_expression -> expression XOR expression .) ]
  ! GT              [ reduce using rule 194 (bitwise_expression -> expression XOR expression .) ]
  ! GE              [ reduce using rule 194 (bitwise_expression -> expression XOR expression .) ]
  ! LAND            [ reduce using rule 194 (bitwise_expression -> expression XOR expression .) ]
  ! LOR             [ reduce using rule 194 (bitwise_expression -> expression XOR expression .) ]
  ! OR              [ reduce using rule 194 (bitwise_expression -> expression XOR expression .) ]
  ! PLUS            [ shift and go to state 86 ]
  ! MINUS           [ shift and go to state 87 ]
  ! TIMES           [ shift and go to state 88 ]
  ! DIVIDE          [ shift and go to state 89 ]
  ! MODULE          [ shift and go to state 90 ]
  ! AND             [ shift and go to state 99 ]
  ! XOR             [ shift and go to state 101 ]
  ! AND_NOT         [ shift and go to state 102 ]
  ! LSHIFT          [ shift and go to state 103 ]
  ! RSHIFT          [ shift and go to state 104 ]


state 143

    (195) bitwise_expression -> expression AND_NOT expression .
    (175) binary_expression -> expression . PLUS expression
    (176) binary_expression -> expression . MINUS expression
    (177) binary_expression -> expression . TIMES expression
    (178) binary_expression -> expression . DIVIDE expression
    (179) binary_expression -> expression . MODULE expression
    (184) relational_expression -> expression . EQ expression
    (185) relational_expression -> expression . NEQ expression
    (186) relational_expression -> expression . LT expression
    (187) relational_expression -> expression . LE expression
    (188) relational_expression -> expression . GT expression
    (189) relational_expression -> expression . GE expression
    (190) logical_expression -> expression . LAND expression
    (191) logical_expression -> expression . LOR expression
    (192) bitwise_expression -> expression . AND expression
    (193) bitwise_expression -> expression . OR expression
    (194) bitwise_expression -> expression . XOR expression
    (195) bitwise_expression -> expression . AND_NOT expression
    (196) bitwise_expression -> expression . LSHIFT expression
    (197) bitwise_expression -> expression . RSHIFT expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NEQ resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for LAND resolved as shift
  ! shift/reduce conflict for LOR resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for XOR resolved as shift
  ! shift/reduce conflict for AND_NOT resolved as shift
  ! shift/reduce conflict for LSHIFT resolved as shift
  ! shift/reduce conflict for RSHIFT resolved as shift
    VAR             reduce using rule 195 (bitwise_expression -> expression AND_NOT expression .)
    CONST           reduce using rule 195 (bitwise_expression -> expression AND_NOT expression .)
    FUNC            reduce using rule 195 (bitwise_expression -> expression AND_NOT expression .)
    TYPE            reduce using rule 195 (bitwise_expression -> expression AND_NOT expression .)
    $end            reduce using rule 195 (bitwise_expression -> expression AND_NOT expression .)
    RPAREN          reduce using rule 195 (bitwise_expression -> expression AND_NOT expression .)
    RBRACE          reduce using rule 195 (bitwise_expression -> expression AND_NOT expression .)
    COMMA           reduce using rule 195 (bitwise_expression -> expression AND_NOT expression .)
    COLON           reduce using rule 195 (bitwise_expression -> expression AND_NOT expression .)
    IDENTIFIER      reduce using rule 195 (bitwise_expression -> expression AND_NOT expression .)
    LPAREN          reduce using rule 195 (bitwise_expression -> expression AND_NOT expression .)
    LNOT            reduce using rule 195 (bitwise_expression -> expression AND_NOT expression .)
    INT             reduce using rule 195 (bitwise_expression -> expression AND_NOT expression .)
    FLOAT64         reduce using rule 195 (bitwise_expression -> expression AND_NOT expression .)
    TRUE            reduce using rule 195 (bitwise_expression -> expression AND_NOT expression .)
    FALSE           reduce using rule 195 (bitwise_expression -> expression AND_NOT expression .)
    STRING          reduce using rule 195 (bitwise_expression -> expression AND_NOT expression .)
    RETURN          reduce using rule 195 (bitwise_expression -> expression AND_NOT expression .)
    IF              reduce using rule 195 (bitwise_expression -> expression AND_NOT expression .)
    SWITCH          reduce using rule 195 (bitwise_expression -> expression AND_NOT expression .)
    BREAK           reduce using rule 195 (bitwise_expression -> expression AND_NOT expression .)
    CONTINUE        reduce using rule 195 (bitwise_expression -> expression AND_NOT expression .)
    LBRACKET        reduce using rule 195 (bitwise_expression -> expression AND_NOT expression .)
    MAP             reduce using rule 195 (bitwise_expression -> expression AND_NOT expression .)
    FOR             reduce using rule 195 (bitwise_expression -> expression AND_NOT expression .)
    CASE            reduce using rule 195 (bitwise_expression -> expression AND_NOT expression .)
    DEFAULT         reduce using rule 195 (bitwise_expression -> expression AND_NOT expression .)
    LBRACE          reduce using rule 195 (bitwise_expression -> expression AND_NOT expression .)
    SEMICOLON       reduce using rule 195 (bitwise_expression -> expression AND_NOT expression .)
    PLUS            shift and go to state 86
    MINUS           shift and go to state 87
    TIMES           shift and go to state 88
    DIVIDE          shift and go to state 89
    MODULE          shift and go to state 90
    EQ              shift and go to state 91
    NEQ             shift and go to state 92
    LT              shift and go to state 93
    LE              shift and go to state 94
    GT              shift and go to state 95
    GE              shift and go to state 96
    LAND            shift and go to state 97
    LOR             shift and go to state 98
    AND             shift and go to state 99
    OR              shift and go to state 100
    XOR             shift and go to state 101
    AND_NOT         shift and go to state 102
    LSHIFT          shift and go to state 103
    RSHIFT          shift and go to state 104

  ! PLUS            [ reduce using rule 195 (bitwise_expression -> expression AND_NOT expression .) ]
  ! MINUS           [ reduce using rule 195 (bitwise_expression -> expression AND_NOT expression .) ]
  ! TIMES           [ reduce using rule 195 (bitwise_expression -> expression AND_NOT expression .) ]
  ! DIVIDE          [ reduce using rule 195 (bitwise_expression -> expression AND_NOT expression .) ]
  ! MODULE          [ reduce using rule 195 (bitwise_expression -> expression AND_NOT expression .) ]
  ! EQ              [ reduce using rule 195 (bitwise_expression -> expression AND_NOT expression .) ]
  ! NEQ             [ reduce using rule 195 (bitwise_expression -> expression AND_NOT expression .) ]
  ! LT              [ reduce using rule 195 (bitwise_expression -> expression AND_NOT expression .) ]
  ! LE              [ reduce using rule 195 (bitwise_expression -> expression AND_NOT expression .) ]
  ! GT              [ reduce using rule 195 (bitwise_expression -> expression AND_NOT expression .) ]
  ! GE              [ reduce using rule 195 (bitwise_expression -> expression AND_NOT expression .) ]
  ! LAND            [ reduce using rule 195 (bitwise_expression -> expression AND_NOT expression .) ]
  ! LOR             [ reduce using rule 195 (bitwise_expression -> expression AND_NOT expression .) ]
  ! AND             [ reduce using rule 195 (bitwise_expression -> expression AND_NOT expression .) ]
  ! OR              [ reduce using rule 195 (bitwise_expression -> expression AND_NOT expression .) ]
  ! XOR             [ reduce using rule 195 (bitwise_expression -> expression AND_NOT expression .) ]
  ! AND_NOT         [ reduce using rule 195 (bitwise_expression -> expression AND_NOT expression .) ]
  ! LSHIFT          [ reduce using rule 195 (bitwise_expression -> expression AND_NOT expression .) ]
  ! RSHIFT          [ reduce using rule 195 (bitwise_expression -> expression AND_NOT expression .) ]


state 144

    (196) bitwise_expression -> expression LSHIFT expression .
    (175) binary_expression -> expression . PLUS expression
    (176) binary_expression -> expression . MINUS expression
    (177) binary_expression -> expression . TIMES expression
    (178) binary_expression -> expression . DIVIDE expression
    (179) binary_expression -> expression . MODULE expression
    (184) relational_expression -> expression . EQ expression
    (185) relational_expression -> expression . NEQ expression
    (186) relational_expression -> expression . LT expression
    (187) relational_expression -> expression . LE expression
    (188) relational_expression -> expression . GT expression
    (189) relational_expression -> expression . GE expression
    (190) logical_expression -> expression . LAND expression
    (191) logical_expression -> expression . LOR expression
    (192) bitwise_expression -> expression . AND expression
    (193) bitwise_expression -> expression . OR expression
    (194) bitwise_expression -> expression . XOR expression
    (195) bitwise_expression -> expression . AND_NOT expression
    (196) bitwise_expression -> expression . LSHIFT expression
    (197) bitwise_expression -> expression . RSHIFT expression

    PLUS            reduce using rule 196 (bitwise_expression -> expression LSHIFT expression .)
    MINUS           reduce using rule 196 (bitwise_expression -> expression LSHIFT expression .)
    TIMES           reduce using rule 196 (bitwise_expression -> expression LSHIFT expression .)
    DIVIDE          reduce using rule 196 (bitwise_expression -> expression LSHIFT expression .)
    MODULE          reduce using rule 196 (bitwise_expression -> expression LSHIFT expression .)
    AND_NOT         reduce using rule 196 (bitwise_expression -> expression LSHIFT expression .)
    LSHIFT          reduce using rule 196 (bitwise_expression -> expression LSHIFT expression .)
    RSHIFT          reduce using rule 196 (bitwise_expression -> expression LSHIFT expression .)
    VAR             reduce using rule 196 (bitwise_expression -> expression LSHIFT expression .)
    CONST           reduce using rule 196 (bitwise_expression -> expression LSHIFT expression .)
    FUNC            reduce using rule 196 (bitwise_expression -> expression LSHIFT expression .)
    TYPE            reduce using rule 196 (bitwise_expression -> expression LSHIFT expression .)
    $end            reduce using rule 196 (bitwise_expression -> expression LSHIFT expression .)
    RPAREN          reduce using rule 196 (bitwise_expression -> expression LSHIFT expression .)
    RBRACE          reduce using rule 196 (bitwise_expression -> expression LSHIFT expression .)
    COMMA           reduce using rule 196 (bitwise_expression -> expression LSHIFT expression .)
    COLON           reduce using rule 196 (bitwise_expression -> expression LSHIFT expression .)
    IDENTIFIER      reduce using rule 196 (bitwise_expression -> expression LSHIFT expression .)
    LPAREN          reduce using rule 196 (bitwise_expression -> expression LSHIFT expression .)
    LNOT            reduce using rule 196 (bitwise_expression -> expression LSHIFT expression .)
    INT             reduce using rule 196 (bitwise_expression -> expression LSHIFT expression .)
    FLOAT64         reduce using rule 196 (bitwise_expression -> expression LSHIFT expression .)
    TRUE            reduce using rule 196 (bitwise_expression -> expression LSHIFT expression .)
    FALSE           reduce using rule 196 (bitwise_expression -> expression LSHIFT expression .)
    STRING          reduce using rule 196 (bitwise_expression -> expression LSHIFT expression .)
    RETURN          reduce using rule 196 (bitwise_expression -> expression LSHIFT expression .)
    IF              reduce using rule 196 (bitwise_expression -> expression LSHIFT expression .)
    SWITCH          reduce using rule 196 (bitwise_expression -> expression LSHIFT expression .)
    BREAK           reduce using rule 196 (bitwise_expression -> expression LSHIFT expression .)
    CONTINUE        reduce using rule 196 (bitwise_expression -> expression LSHIFT expression .)
    LBRACKET        reduce using rule 196 (bitwise_expression -> expression LSHIFT expression .)
    MAP             reduce using rule 196 (bitwise_expression -> expression LSHIFT expression .)
    FOR             reduce using rule 196 (bitwise_expression -> expression LSHIFT expression .)
    CASE            reduce using rule 196 (bitwise_expression -> expression LSHIFT expression .)
    DEFAULT         reduce using rule 196 (bitwise_expression -> expression LSHIFT expression .)
    LBRACE          reduce using rule 196 (bitwise_expression -> expression LSHIFT expression .)
    SEMICOLON       reduce using rule 196 (bitwise_expression -> expression LSHIFT expression .)
    EQ              shift and go to state 91
    NEQ             shift and go to state 92
    LT              shift and go to state 93
    LE              shift and go to state 94
    GT              shift and go to state 95
    GE              shift and go to state 96
    LAND            shift and go to state 97
    LOR             shift and go to state 98
    AND             shift and go to state 99
    OR              shift and go to state 100
    XOR             shift and go to state 101

  ! EQ              [ reduce using rule 196 (bitwise_expression -> expression LSHIFT expression .) ]
  ! NEQ             [ reduce using rule 196 (bitwise_expression -> expression LSHIFT expression .) ]
  ! LT              [ reduce using rule 196 (bitwise_expression -> expression LSHIFT expression .) ]
  ! LE              [ reduce using rule 196 (bitwise_expression -> expression LSHIFT expression .) ]
  ! GT              [ reduce using rule 196 (bitwise_expression -> expression LSHIFT expression .) ]
  ! GE              [ reduce using rule 196 (bitwise_expression -> expression LSHIFT expression .) ]
  ! LAND            [ reduce using rule 196 (bitwise_expression -> expression LSHIFT expression .) ]
  ! LOR             [ reduce using rule 196 (bitwise_expression -> expression LSHIFT expression .) ]
  ! AND             [ reduce using rule 196 (bitwise_expression -> expression LSHIFT expression .) ]
  ! OR              [ reduce using rule 196 (bitwise_expression -> expression LSHIFT expression .) ]
  ! XOR             [ reduce using rule 196 (bitwise_expression -> expression LSHIFT expression .) ]
  ! PLUS            [ shift and go to state 86 ]
  ! MINUS           [ shift and go to state 87 ]
  ! TIMES           [ shift and go to state 88 ]
  ! DIVIDE          [ shift and go to state 89 ]
  ! MODULE          [ shift and go to state 90 ]
  ! AND_NOT         [ shift and go to state 102 ]
  ! LSHIFT          [ shift and go to state 103 ]
  ! RSHIFT          [ shift and go to state 104 ]


state 145

    (197) bitwise_expression -> expression RSHIFT expression .
    (175) binary_expression -> expression . PLUS expression
    (176) binary_expression -> expression . MINUS expression
    (177) binary_expression -> expression . TIMES expression
    (178) binary_expression -> expression . DIVIDE expression
    (179) binary_expression -> expression . MODULE expression
    (184) relational_expression -> expression . EQ expression
    (185) relational_expression -> expression . NEQ expression
    (186) relational_expression -> expression . LT expression
    (187) relational_expression -> expression . LE expression
    (188) relational_expression -> expression . GT expression
    (189) relational_expression -> expression . GE expression
    (190) logical_expression -> expression . LAND expression
    (191) logical_expression -> expression . LOR expression
    (192) bitwise_expression -> expression . AND expression
    (193) bitwise_expression -> expression . OR expression
    (194) bitwise_expression -> expression . XOR expression
    (195) bitwise_expression -> expression . AND_NOT expression
    (196) bitwise_expression -> expression . LSHIFT expression
    (197) bitwise_expression -> expression . RSHIFT expression

    PLUS            reduce using rule 197 (bitwise_expression -> expression RSHIFT expression .)
    MINUS           reduce using rule 197 (bitwise_expression -> expression RSHIFT expression .)
    TIMES           reduce using rule 197 (bitwise_expression -> expression RSHIFT expression .)
    DIVIDE          reduce using rule 197 (bitwise_expression -> expression RSHIFT expression .)
    MODULE          reduce using rule 197 (bitwise_expression -> expression RSHIFT expression .)
    AND_NOT         reduce using rule 197 (bitwise_expression -> expression RSHIFT expression .)
    LSHIFT          reduce using rule 197 (bitwise_expression -> expression RSHIFT expression .)
    RSHIFT          reduce using rule 197 (bitwise_expression -> expression RSHIFT expression .)
    VAR             reduce using rule 197 (bitwise_expression -> expression RSHIFT expression .)
    CONST           reduce using rule 197 (bitwise_expression -> expression RSHIFT expression .)
    FUNC            reduce using rule 197 (bitwise_expression -> expression RSHIFT expression .)
    TYPE            reduce using rule 197 (bitwise_expression -> expression RSHIFT expression .)
    $end            reduce using rule 197 (bitwise_expression -> expression RSHIFT expression .)
    RPAREN          reduce using rule 197 (bitwise_expression -> expression RSHIFT expression .)
    RBRACE          reduce using rule 197 (bitwise_expression -> expression RSHIFT expression .)
    COMMA           reduce using rule 197 (bitwise_expression -> expression RSHIFT expression .)
    COLON           reduce using rule 197 (bitwise_expression -> expression RSHIFT expression .)
    IDENTIFIER      reduce using rule 197 (bitwise_expression -> expression RSHIFT expression .)
    LPAREN          reduce using rule 197 (bitwise_expression -> expression RSHIFT expression .)
    LNOT            reduce using rule 197 (bitwise_expression -> expression RSHIFT expression .)
    INT             reduce using rule 197 (bitwise_expression -> expression RSHIFT expression .)
    FLOAT64         reduce using rule 197 (bitwise_expression -> expression RSHIFT expression .)
    TRUE            reduce using rule 197 (bitwise_expression -> expression RSHIFT expression .)
    FALSE           reduce using rule 197 (bitwise_expression -> expression RSHIFT expression .)
    STRING          reduce using rule 197 (bitwise_expression -> expression RSHIFT expression .)
    RETURN          reduce using rule 197 (bitwise_expression -> expression RSHIFT expression .)
    IF              reduce using rule 197 (bitwise_expression -> expression RSHIFT expression .)
    SWITCH          reduce using rule 197 (bitwise_expression -> expression RSHIFT expression .)
    BREAK           reduce using rule 197 (bitwise_expression -> expression RSHIFT expression .)
    CONTINUE        reduce using rule 197 (bitwise_expression -> expression RSHIFT expression .)
    LBRACKET        reduce using rule 197 (bitwise_expression -> expression RSHIFT expression .)
    MAP             reduce using rule 197 (bitwise_expression -> expression RSHIFT expression .)
    FOR             reduce using rule 197 (bitwise_expression -> expression RSHIFT expression .)
    CASE            reduce using rule 197 (bitwise_expression -> expression RSHIFT expression .)
    DEFAULT         reduce using rule 197 (bitwise_expression -> expression RSHIFT expression .)
    LBRACE          reduce using rule 197 (bitwise_expression -> expression RSHIFT expression .)
    SEMICOLON       reduce using rule 197 (bitwise_expression -> expression RSHIFT expression .)
    EQ              shift and go to state 91
    NEQ             shift and go to state 92
    LT              shift and go to state 93
    LE              shift and go to state 94
    GT              shift and go to state 95
    GE              shift and go to state 96
    LAND            shift and go to state 97
    LOR             shift and go to state 98
    AND             shift and go to state 99
    OR              shift and go to state 100
    XOR             shift and go to state 101

  ! EQ              [ reduce using rule 197 (bitwise_expression -> expression RSHIFT expression .) ]
  ! NEQ             [ reduce using rule 197 (bitwise_expression -> expression RSHIFT expression .) ]
  ! LT              [ reduce using rule 197 (bitwise_expression -> expression RSHIFT expression .) ]
  ! LE              [ reduce using rule 197 (bitwise_expression -> expression RSHIFT expression .) ]
  ! GT              [ reduce using rule 197 (bitwise_expression -> expression RSHIFT expression .) ]
  ! GE              [ reduce using rule 197 (bitwise_expression -> expression RSHIFT expression .) ]
  ! LAND            [ reduce using rule 197 (bitwise_expression -> expression RSHIFT expression .) ]
  ! LOR             [ reduce using rule 197 (bitwise_expression -> expression RSHIFT expression .) ]
  ! AND             [ reduce using rule 197 (bitwise_expression -> expression RSHIFT expression .) ]
  ! OR              [ reduce using rule 197 (bitwise_expression -> expression RSHIFT expression .) ]
  ! XOR             [ reduce using rule 197 (bitwise_expression -> expression RSHIFT expression .) ]
  ! PLUS            [ shift and go to state 86 ]
  ! MINUS           [ shift and go to state 87 ]
  ! TIMES           [ shift and go to state 88 ]
  ! DIVIDE          [ shift and go to state 89 ]
  ! MODULE          [ shift and go to state 90 ]
  ! AND_NOT         [ shift and go to state 102 ]
  ! LSHIFT          [ shift and go to state 103 ]
  ! RSHIFT          [ shift and go to state 104 ]


state 146

    (57) expression -> slice_type LBRACE expression_list . RBRACE
    (60) expression_list -> expression_list . COMMA expression

    RBRACE          shift and go to state 172
    COMMA           shift and go to state 173


state 147

    (58) expression -> slice_type LBRACE RBRACE .

    PLUS            reduce using rule 58 (expression -> slice_type LBRACE RBRACE .)
    MINUS           reduce using rule 58 (expression -> slice_type LBRACE RBRACE .)
    TIMES           reduce using rule 58 (expression -> slice_type LBRACE RBRACE .)
    DIVIDE          reduce using rule 58 (expression -> slice_type LBRACE RBRACE .)
    MODULE          reduce using rule 58 (expression -> slice_type LBRACE RBRACE .)
    EQ              reduce using rule 58 (expression -> slice_type LBRACE RBRACE .)
    NEQ             reduce using rule 58 (expression -> slice_type LBRACE RBRACE .)
    LT              reduce using rule 58 (expression -> slice_type LBRACE RBRACE .)
    LE              reduce using rule 58 (expression -> slice_type LBRACE RBRACE .)
    GT              reduce using rule 58 (expression -> slice_type LBRACE RBRACE .)
    GE              reduce using rule 58 (expression -> slice_type LBRACE RBRACE .)
    LAND            reduce using rule 58 (expression -> slice_type LBRACE RBRACE .)
    LOR             reduce using rule 58 (expression -> slice_type LBRACE RBRACE .)
    AND             reduce using rule 58 (expression -> slice_type LBRACE RBRACE .)
    OR              reduce using rule 58 (expression -> slice_type LBRACE RBRACE .)
    XOR             reduce using rule 58 (expression -> slice_type LBRACE RBRACE .)
    AND_NOT         reduce using rule 58 (expression -> slice_type LBRACE RBRACE .)
    LSHIFT          reduce using rule 58 (expression -> slice_type LBRACE RBRACE .)
    RSHIFT          reduce using rule 58 (expression -> slice_type LBRACE RBRACE .)
    VAR             reduce using rule 58 (expression -> slice_type LBRACE RBRACE .)
    CONST           reduce using rule 58 (expression -> slice_type LBRACE RBRACE .)
    FUNC            reduce using rule 58 (expression -> slice_type LBRACE RBRACE .)
    TYPE            reduce using rule 58 (expression -> slice_type LBRACE RBRACE .)
    $end            reduce using rule 58 (expression -> slice_type LBRACE RBRACE .)
    RPAREN          reduce using rule 58 (expression -> slice_type LBRACE RBRACE .)
    RBRACE          reduce using rule 58 (expression -> slice_type LBRACE RBRACE .)
    COMMA           reduce using rule 58 (expression -> slice_type LBRACE RBRACE .)
    COLON           reduce using rule 58 (expression -> slice_type LBRACE RBRACE .)
    IDENTIFIER      reduce using rule 58 (expression -> slice_type LBRACE RBRACE .)
    LPAREN          reduce using rule 58 (expression -> slice_type LBRACE RBRACE .)
    LNOT            reduce using rule 58 (expression -> slice_type LBRACE RBRACE .)
    INT             reduce using rule 58 (expression -> slice_type LBRACE RBRACE .)
    FLOAT64         reduce using rule 58 (expression -> slice_type LBRACE RBRACE .)
    TRUE            reduce using rule 58 (expression -> slice_type LBRACE RBRACE .)
    FALSE           reduce using rule 58 (expression -> slice_type LBRACE RBRACE .)
    STRING          reduce using rule 58 (expression -> slice_type LBRACE RBRACE .)
    RETURN          reduce using rule 58 (expression -> slice_type LBRACE RBRACE .)
    IF              reduce using rule 58 (expression -> slice_type LBRACE RBRACE .)
    SWITCH          reduce using rule 58 (expression -> slice_type LBRACE RBRACE .)
    BREAK           reduce using rule 58 (expression -> slice_type LBRACE RBRACE .)
    CONTINUE        reduce using rule 58 (expression -> slice_type LBRACE RBRACE .)
    LBRACKET        reduce using rule 58 (expression -> slice_type LBRACE RBRACE .)
    MAP             reduce using rule 58 (expression -> slice_type LBRACE RBRACE .)
    FOR             reduce using rule 58 (expression -> slice_type LBRACE RBRACE .)
    CASE            reduce using rule 58 (expression -> slice_type LBRACE RBRACE .)
    DEFAULT         reduce using rule 58 (expression -> slice_type LBRACE RBRACE .)
    LBRACE          reduce using rule 58 (expression -> slice_type LBRACE RBRACE .)
    SEMICOLON       reduce using rule 58 (expression -> slice_type LBRACE RBRACE .)


state 148

    (59) expression_list -> expression .
    (175) binary_expression -> expression . PLUS expression
    (176) binary_expression -> expression . MINUS expression
    (177) binary_expression -> expression . TIMES expression
    (178) binary_expression -> expression . DIVIDE expression
    (179) binary_expression -> expression . MODULE expression
    (184) relational_expression -> expression . EQ expression
    (185) relational_expression -> expression . NEQ expression
    (186) relational_expression -> expression . LT expression
    (187) relational_expression -> expression . LE expression
    (188) relational_expression -> expression . GT expression
    (189) relational_expression -> expression . GE expression
    (190) logical_expression -> expression . LAND expression
    (191) logical_expression -> expression . LOR expression
    (192) bitwise_expression -> expression . AND expression
    (193) bitwise_expression -> expression . OR expression
    (194) bitwise_expression -> expression . XOR expression
    (195) bitwise_expression -> expression . AND_NOT expression
    (196) bitwise_expression -> expression . LSHIFT expression
    (197) bitwise_expression -> expression . RSHIFT expression

    RBRACE          reduce using rule 59 (expression_list -> expression .)
    COMMA           reduce using rule 59 (expression_list -> expression .)
    RPAREN          reduce using rule 59 (expression_list -> expression .)
    PLUS            shift and go to state 86
    MINUS           shift and go to state 87
    TIMES           shift and go to state 88
    DIVIDE          shift and go to state 89
    MODULE          shift and go to state 90
    EQ              shift and go to state 91
    NEQ             shift and go to state 92
    LT              shift and go to state 93
    LE              shift and go to state 94
    GT              shift and go to state 95
    GE              shift and go to state 96
    LAND            shift and go to state 97
    LOR             shift and go to state 98
    AND             shift and go to state 99
    OR              shift and go to state 100
    XOR             shift and go to state 101
    AND_NOT         shift and go to state 102
    LSHIFT          shift and go to state 103
    RSHIFT          shift and go to state 104


state 149

    (61) expression -> LPAREN expression RPAREN .

    PLUS            reduce using rule 61 (expression -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 61 (expression -> LPAREN expression RPAREN .)
    TIMES           reduce using rule 61 (expression -> LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 61 (expression -> LPAREN expression RPAREN .)
    MODULE          reduce using rule 61 (expression -> LPAREN expression RPAREN .)
    EQ              reduce using rule 61 (expression -> LPAREN expression RPAREN .)
    NEQ             reduce using rule 61 (expression -> LPAREN expression RPAREN .)
    LT              reduce using rule 61 (expression -> LPAREN expression RPAREN .)
    LE              reduce using rule 61 (expression -> LPAREN expression RPAREN .)
    GT              reduce using rule 61 (expression -> LPAREN expression RPAREN .)
    GE              reduce using rule 61 (expression -> LPAREN expression RPAREN .)
    LAND            reduce using rule 61 (expression -> LPAREN expression RPAREN .)
    LOR             reduce using rule 61 (expression -> LPAREN expression RPAREN .)
    AND             reduce using rule 61 (expression -> LPAREN expression RPAREN .)
    OR              reduce using rule 61 (expression -> LPAREN expression RPAREN .)
    XOR             reduce using rule 61 (expression -> LPAREN expression RPAREN .)
    AND_NOT         reduce using rule 61 (expression -> LPAREN expression RPAREN .)
    LSHIFT          reduce using rule 61 (expression -> LPAREN expression RPAREN .)
    RSHIFT          reduce using rule 61 (expression -> LPAREN expression RPAREN .)
    VAR             reduce using rule 61 (expression -> LPAREN expression RPAREN .)
    CONST           reduce using rule 61 (expression -> LPAREN expression RPAREN .)
    FUNC            reduce using rule 61 (expression -> LPAREN expression RPAREN .)
    TYPE            reduce using rule 61 (expression -> LPAREN expression RPAREN .)
    $end            reduce using rule 61 (expression -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 61 (expression -> LPAREN expression RPAREN .)
    RBRACE          reduce using rule 61 (expression -> LPAREN expression RPAREN .)
    COMMA           reduce using rule 61 (expression -> LPAREN expression RPAREN .)
    COLON           reduce using rule 61 (expression -> LPAREN expression RPAREN .)
    IDENTIFIER      reduce using rule 61 (expression -> LPAREN expression RPAREN .)
    LPAREN          reduce using rule 61 (expression -> LPAREN expression RPAREN .)
    LNOT            reduce using rule 61 (expression -> LPAREN expression RPAREN .)
    INT             reduce using rule 61 (expression -> LPAREN expression RPAREN .)
    FLOAT64         reduce using rule 61 (expression -> LPAREN expression RPAREN .)
    TRUE            reduce using rule 61 (expression -> LPAREN expression RPAREN .)
    FALSE           reduce using rule 61 (expression -> LPAREN expression RPAREN .)
    STRING          reduce using rule 61 (expression -> LPAREN expression RPAREN .)
    RETURN          reduce using rule 61 (expression -> LPAREN expression RPAREN .)
    IF              reduce using rule 61 (expression -> LPAREN expression RPAREN .)
    SWITCH          reduce using rule 61 (expression -> LPAREN expression RPAREN .)
    BREAK           reduce using rule 61 (expression -> LPAREN expression RPAREN .)
    CONTINUE        reduce using rule 61 (expression -> LPAREN expression RPAREN .)
    LBRACKET        reduce using rule 61 (expression -> LPAREN expression RPAREN .)
    MAP             reduce using rule 61 (expression -> LPAREN expression RPAREN .)
    FOR             reduce using rule 61 (expression -> LPAREN expression RPAREN .)
    CASE            reduce using rule 61 (expression -> LPAREN expression RPAREN .)
    DEFAULT         reduce using rule 61 (expression -> LPAREN expression RPAREN .)
    LBRACE          reduce using rule 61 (expression -> LPAREN expression RPAREN .)
    SEMICOLON       reduce using rule 61 (expression -> LPAREN expression RPAREN .)


state 150

    (145) expression -> map_type LBRACE expression_map_list . RBRACE
    (148) expression_map_list -> expression_map_list . COMMA key_value

    RBRACE          shift and go to state 174
    COMMA           shift and go to state 175


state 151

    (146) expression -> map_type LBRACE RBRACE .

    PLUS            reduce using rule 146 (expression -> map_type LBRACE RBRACE .)
    MINUS           reduce using rule 146 (expression -> map_type LBRACE RBRACE .)
    TIMES           reduce using rule 146 (expression -> map_type LBRACE RBRACE .)
    DIVIDE          reduce using rule 146 (expression -> map_type LBRACE RBRACE .)
    MODULE          reduce using rule 146 (expression -> map_type LBRACE RBRACE .)
    EQ              reduce using rule 146 (expression -> map_type LBRACE RBRACE .)
    NEQ             reduce using rule 146 (expression -> map_type LBRACE RBRACE .)
    LT              reduce using rule 146 (expression -> map_type LBRACE RBRACE .)
    LE              reduce using rule 146 (expression -> map_type LBRACE RBRACE .)
    GT              reduce using rule 146 (expression -> map_type LBRACE RBRACE .)
    GE              reduce using rule 146 (expression -> map_type LBRACE RBRACE .)
    LAND            reduce using rule 146 (expression -> map_type LBRACE RBRACE .)
    LOR             reduce using rule 146 (expression -> map_type LBRACE RBRACE .)
    AND             reduce using rule 146 (expression -> map_type LBRACE RBRACE .)
    OR              reduce using rule 146 (expression -> map_type LBRACE RBRACE .)
    XOR             reduce using rule 146 (expression -> map_type LBRACE RBRACE .)
    AND_NOT         reduce using rule 146 (expression -> map_type LBRACE RBRACE .)
    LSHIFT          reduce using rule 146 (expression -> map_type LBRACE RBRACE .)
    RSHIFT          reduce using rule 146 (expression -> map_type LBRACE RBRACE .)
    VAR             reduce using rule 146 (expression -> map_type LBRACE RBRACE .)
    CONST           reduce using rule 146 (expression -> map_type LBRACE RBRACE .)
    FUNC            reduce using rule 146 (expression -> map_type LBRACE RBRACE .)
    TYPE            reduce using rule 146 (expression -> map_type LBRACE RBRACE .)
    $end            reduce using rule 146 (expression -> map_type LBRACE RBRACE .)
    RPAREN          reduce using rule 146 (expression -> map_type LBRACE RBRACE .)
    RBRACE          reduce using rule 146 (expression -> map_type LBRACE RBRACE .)
    COMMA           reduce using rule 146 (expression -> map_type LBRACE RBRACE .)
    COLON           reduce using rule 146 (expression -> map_type LBRACE RBRACE .)
    IDENTIFIER      reduce using rule 146 (expression -> map_type LBRACE RBRACE .)
    LPAREN          reduce using rule 146 (expression -> map_type LBRACE RBRACE .)
    LNOT            reduce using rule 146 (expression -> map_type LBRACE RBRACE .)
    INT             reduce using rule 146 (expression -> map_type LBRACE RBRACE .)
    FLOAT64         reduce using rule 146 (expression -> map_type LBRACE RBRACE .)
    TRUE            reduce using rule 146 (expression -> map_type LBRACE RBRACE .)
    FALSE           reduce using rule 146 (expression -> map_type LBRACE RBRACE .)
    STRING          reduce using rule 146 (expression -> map_type LBRACE RBRACE .)
    RETURN          reduce using rule 146 (expression -> map_type LBRACE RBRACE .)
    IF              reduce using rule 146 (expression -> map_type LBRACE RBRACE .)
    SWITCH          reduce using rule 146 (expression -> map_type LBRACE RBRACE .)
    BREAK           reduce using rule 146 (expression -> map_type LBRACE RBRACE .)
    CONTINUE        reduce using rule 146 (expression -> map_type LBRACE RBRACE .)
    LBRACKET        reduce using rule 146 (expression -> map_type LBRACE RBRACE .)
    MAP             reduce using rule 146 (expression -> map_type LBRACE RBRACE .)
    FOR             reduce using rule 146 (expression -> map_type LBRACE RBRACE .)
    CASE            reduce using rule 146 (expression -> map_type LBRACE RBRACE .)
    DEFAULT         reduce using rule 146 (expression -> map_type LBRACE RBRACE .)
    LBRACE          reduce using rule 146 (expression -> map_type LBRACE RBRACE .)
    SEMICOLON       reduce using rule 146 (expression -> map_type LBRACE RBRACE .)


state 152

    (147) expression_map_list -> key_value .

    RBRACE          reduce using rule 147 (expression_map_list -> key_value .)
    COMMA           reduce using rule 147 (expression_map_list -> key_value .)


state 153

    (149) key_value -> expression . COLON expression
    (175) binary_expression -> expression . PLUS expression
    (176) binary_expression -> expression . MINUS expression
    (177) binary_expression -> expression . TIMES expression
    (178) binary_expression -> expression . DIVIDE expression
    (179) binary_expression -> expression . MODULE expression
    (184) relational_expression -> expression . EQ expression
    (185) relational_expression -> expression . NEQ expression
    (186) relational_expression -> expression . LT expression
    (187) relational_expression -> expression . LE expression
    (188) relational_expression -> expression . GT expression
    (189) relational_expression -> expression . GE expression
    (190) logical_expression -> expression . LAND expression
    (191) logical_expression -> expression . LOR expression
    (192) bitwise_expression -> expression . AND expression
    (193) bitwise_expression -> expression . OR expression
    (194) bitwise_expression -> expression . XOR expression
    (195) bitwise_expression -> expression . AND_NOT expression
    (196) bitwise_expression -> expression . LSHIFT expression
    (197) bitwise_expression -> expression . RSHIFT expression

    COLON           shift and go to state 176
    PLUS            shift and go to state 86
    MINUS           shift and go to state 87
    TIMES           shift and go to state 88
    DIVIDE          shift and go to state 89
    MODULE          shift and go to state 90
    EQ              shift and go to state 91
    NEQ             shift and go to state 92
    LT              shift and go to state 93
    LE              shift and go to state 94
    GT              shift and go to state 95
    GE              shift and go to state 96
    LAND            shift and go to state 97
    LOR             shift and go to state 98
    AND             shift and go to state 99
    OR              shift and go to state 100
    XOR             shift and go to state 101
    AND_NOT         shift and go to state 102
    LSHIFT          shift and go to state 103
    RSHIFT          shift and go to state 104


state 154

    (169) expression -> type_name LBRACE keyed_element_list . RBRACE
    (165) keyed_element_list -> keyed_element_list . COMMA keyed_element

    RBRACE          shift and go to state 177
    COMMA           shift and go to state 178


state 155

    (170) expression -> type_name LBRACE RBRACE .

    PLUS            reduce using rule 170 (expression -> type_name LBRACE RBRACE .)
    MINUS           reduce using rule 170 (expression -> type_name LBRACE RBRACE .)
    TIMES           reduce using rule 170 (expression -> type_name LBRACE RBRACE .)
    DIVIDE          reduce using rule 170 (expression -> type_name LBRACE RBRACE .)
    MODULE          reduce using rule 170 (expression -> type_name LBRACE RBRACE .)
    EQ              reduce using rule 170 (expression -> type_name LBRACE RBRACE .)
    NEQ             reduce using rule 170 (expression -> type_name LBRACE RBRACE .)
    LT              reduce using rule 170 (expression -> type_name LBRACE RBRACE .)
    LE              reduce using rule 170 (expression -> type_name LBRACE RBRACE .)
    GT              reduce using rule 170 (expression -> type_name LBRACE RBRACE .)
    GE              reduce using rule 170 (expression -> type_name LBRACE RBRACE .)
    LAND            reduce using rule 170 (expression -> type_name LBRACE RBRACE .)
    LOR             reduce using rule 170 (expression -> type_name LBRACE RBRACE .)
    AND             reduce using rule 170 (expression -> type_name LBRACE RBRACE .)
    OR              reduce using rule 170 (expression -> type_name LBRACE RBRACE .)
    XOR             reduce using rule 170 (expression -> type_name LBRACE RBRACE .)
    AND_NOT         reduce using rule 170 (expression -> type_name LBRACE RBRACE .)
    LSHIFT          reduce using rule 170 (expression -> type_name LBRACE RBRACE .)
    RSHIFT          reduce using rule 170 (expression -> type_name LBRACE RBRACE .)
    VAR             reduce using rule 170 (expression -> type_name LBRACE RBRACE .)
    CONST           reduce using rule 170 (expression -> type_name LBRACE RBRACE .)
    FUNC            reduce using rule 170 (expression -> type_name LBRACE RBRACE .)
    TYPE            reduce using rule 170 (expression -> type_name LBRACE RBRACE .)
    $end            reduce using rule 170 (expression -> type_name LBRACE RBRACE .)
    RPAREN          reduce using rule 170 (expression -> type_name LBRACE RBRACE .)
    RBRACE          reduce using rule 170 (expression -> type_name LBRACE RBRACE .)
    COMMA           reduce using rule 170 (expression -> type_name LBRACE RBRACE .)
    COLON           reduce using rule 170 (expression -> type_name LBRACE RBRACE .)
    IDENTIFIER      reduce using rule 170 (expression -> type_name LBRACE RBRACE .)
    LPAREN          reduce using rule 170 (expression -> type_name LBRACE RBRACE .)
    LNOT            reduce using rule 170 (expression -> type_name LBRACE RBRACE .)
    INT             reduce using rule 170 (expression -> type_name LBRACE RBRACE .)
    FLOAT64         reduce using rule 170 (expression -> type_name LBRACE RBRACE .)
    TRUE            reduce using rule 170 (expression -> type_name LBRACE RBRACE .)
    FALSE           reduce using rule 170 (expression -> type_name LBRACE RBRACE .)
    STRING          reduce using rule 170 (expression -> type_name LBRACE RBRACE .)
    RETURN          reduce using rule 170 (expression -> type_name LBRACE RBRACE .)
    IF              reduce using rule 170 (expression -> type_name LBRACE RBRACE .)
    SWITCH          reduce using rule 170 (expression -> type_name LBRACE RBRACE .)
    BREAK           reduce using rule 170 (expression -> type_name LBRACE RBRACE .)
    CONTINUE        reduce using rule 170 (expression -> type_name LBRACE RBRACE .)
    LBRACKET        reduce using rule 170 (expression -> type_name LBRACE RBRACE .)
    MAP             reduce using rule 170 (expression -> type_name LBRACE RBRACE .)
    FOR             reduce using rule 170 (expression -> type_name LBRACE RBRACE .)
    CASE            reduce using rule 170 (expression -> type_name LBRACE RBRACE .)
    DEFAULT         reduce using rule 170 (expression -> type_name LBRACE RBRACE .)
    LBRACE          reduce using rule 170 (expression -> type_name LBRACE RBRACE .)
    SEMICOLON       reduce using rule 170 (expression -> type_name LBRACE RBRACE .)


state 156

    (164) keyed_element_list -> keyed_element .

    RBRACE          reduce using rule 164 (keyed_element_list -> keyed_element .)
    COMMA           reduce using rule 164 (keyed_element_list -> keyed_element .)


state 157

    (166) keyed_element -> IDENTIFIER . COLON expression
    (131) expression -> IDENTIFIER .
    (133) expression -> IDENTIFIER . PLUSPLUS
    (134) expression -> IDENTIFIER . MINUSMINUS
    (171) type_name -> IDENTIFIER .

    COLON           shift and go to state 179
    PLUS            reduce using rule 131 (expression -> IDENTIFIER .)
    MINUS           reduce using rule 131 (expression -> IDENTIFIER .)
    TIMES           reduce using rule 131 (expression -> IDENTIFIER .)
    DIVIDE          reduce using rule 131 (expression -> IDENTIFIER .)
    MODULE          reduce using rule 131 (expression -> IDENTIFIER .)
    EQ              reduce using rule 131 (expression -> IDENTIFIER .)
    NEQ             reduce using rule 131 (expression -> IDENTIFIER .)
    LT              reduce using rule 131 (expression -> IDENTIFIER .)
    LE              reduce using rule 131 (expression -> IDENTIFIER .)
    GT              reduce using rule 131 (expression -> IDENTIFIER .)
    GE              reduce using rule 131 (expression -> IDENTIFIER .)
    LAND            reduce using rule 131 (expression -> IDENTIFIER .)
    LOR             reduce using rule 131 (expression -> IDENTIFIER .)
    AND             reduce using rule 131 (expression -> IDENTIFIER .)
    OR              reduce using rule 131 (expression -> IDENTIFIER .)
    XOR             reduce using rule 131 (expression -> IDENTIFIER .)
    AND_NOT         reduce using rule 131 (expression -> IDENTIFIER .)
    LSHIFT          reduce using rule 131 (expression -> IDENTIFIER .)
    RSHIFT          reduce using rule 131 (expression -> IDENTIFIER .)
    RBRACE          reduce using rule 131 (expression -> IDENTIFIER .)
    COMMA           reduce using rule 131 (expression -> IDENTIFIER .)
    PLUSPLUS        shift and go to state 84
    MINUSMINUS      shift and go to state 85
    LBRACE          reduce using rule 171 (type_name -> IDENTIFIER .)


state 158

    (168) keyed_element -> expression .
    (175) binary_expression -> expression . PLUS expression
    (176) binary_expression -> expression . MINUS expression
    (177) binary_expression -> expression . TIMES expression
    (178) binary_expression -> expression . DIVIDE expression
    (179) binary_expression -> expression . MODULE expression
    (184) relational_expression -> expression . EQ expression
    (185) relational_expression -> expression . NEQ expression
    (186) relational_expression -> expression . LT expression
    (187) relational_expression -> expression . LE expression
    (188) relational_expression -> expression . GT expression
    (189) relational_expression -> expression . GE expression
    (190) logical_expression -> expression . LAND expression
    (191) logical_expression -> expression . LOR expression
    (192) bitwise_expression -> expression . AND expression
    (193) bitwise_expression -> expression . OR expression
    (194) bitwise_expression -> expression . XOR expression
    (195) bitwise_expression -> expression . AND_NOT expression
    (196) bitwise_expression -> expression . LSHIFT expression
    (197) bitwise_expression -> expression . RSHIFT expression

    RBRACE          reduce using rule 168 (keyed_element -> expression .)
    COMMA           reduce using rule 168 (keyed_element -> expression .)
    PLUS            shift and go to state 86
    MINUS           shift and go to state 87
    TIMES           shift and go to state 88
    DIVIDE          shift and go to state 89
    MODULE          shift and go to state 90
    EQ              shift and go to state 91
    NEQ             shift and go to state 92
    LT              shift and go to state 93
    LE              shift and go to state 94
    GT              shift and go to state 95
    GE              shift and go to state 96
    LAND            shift and go to state 97
    LOR             shift and go to state 98
    AND             shift and go to state 99
    OR              shift and go to state 100
    XOR             shift and go to state 101
    AND_NOT         shift and go to state 102
    LSHIFT          shift and go to state 103
    RSHIFT          shift and go to state 104


state 159

    (167) keyed_element -> INT . COLON expression
    (127) expression -> INT .

    COLON           shift and go to state 180
    PLUS            reduce using rule 127 (expression -> INT .)
    MINUS           reduce using rule 127 (expression -> INT .)
    TIMES           reduce using rule 127 (expression -> INT .)
    DIVIDE          reduce using rule 127 (expression -> INT .)
    MODULE          reduce using rule 127 (expression -> INT .)
    EQ              reduce using rule 127 (expression -> INT .)
    NEQ             reduce using rule 127 (expression -> INT .)
    LT              reduce using rule 127 (expression -> INT .)
    LE              reduce using rule 127 (expression -> INT .)
    GT              reduce using rule 127 (expression -> INT .)
    GE              reduce using rule 127 (expression -> INT .)
    LAND            reduce using rule 127 (expression -> INT .)
    LOR             reduce using rule 127 (expression -> INT .)
    AND             reduce using rule 127 (expression -> INT .)
    OR              reduce using rule 127 (expression -> INT .)
    XOR             reduce using rule 127 (expression -> INT .)
    AND_NOT         reduce using rule 127 (expression -> INT .)
    LSHIFT          reduce using rule 127 (expression -> INT .)
    RSHIFT          reduce using rule 127 (expression -> INT .)
    RBRACE          reduce using rule 127 (expression -> INT .)
    COMMA           reduce using rule 127 (expression -> INT .)


state 160

    (119) array_type -> LBRACKET INT RBRACKET type .

    ASSIGN          reduce using rule 119 (array_type -> LBRACKET INT RBRACKET type .)
    VAR             reduce using rule 119 (array_type -> LBRACKET INT RBRACKET type .)
    CONST           reduce using rule 119 (array_type -> LBRACKET INT RBRACKET type .)
    FUNC            reduce using rule 119 (array_type -> LBRACKET INT RBRACKET type .)
    TYPE            reduce using rule 119 (array_type -> LBRACKET INT RBRACKET type .)
    $end            reduce using rule 119 (array_type -> LBRACKET INT RBRACKET type .)
    LBRACE          reduce using rule 119 (array_type -> LBRACKET INT RBRACKET type .)
    RPAREN          reduce using rule 119 (array_type -> LBRACKET INT RBRACKET type .)
    COMMA           reduce using rule 119 (array_type -> LBRACKET INT RBRACKET type .)
    RBRACE          reduce using rule 119 (array_type -> LBRACKET INT RBRACKET type .)
    IDENTIFIER      reduce using rule 119 (array_type -> LBRACKET INT RBRACKET type .)
    SEMICOLON       reduce using rule 119 (array_type -> LBRACKET INT RBRACKET type .)


state 161

    (144) map_type -> MAP LBRACKET primitive_type RBRACKET . primitive_type
    (115) primitive_type -> . INT_TYPE
    (116) primitive_type -> . FLOAT64_TYPE
    (117) primitive_type -> . STRING_TYPE
    (118) primitive_type -> . BOOL_TYPE

    INT_TYPE        shift and go to state 34
    FLOAT64_TYPE    shift and go to state 35
    STRING_TYPE     shift and go to state 36
    BOOL_TYPE       shift and go to state 37

    primitive_type                 shift and go to state 181

state 162

    (101) parameter -> IDENTIFIER ELLIPSIS primitive_type .

    RPAREN          reduce using rule 101 (parameter -> IDENTIFIER ELLIPSIS primitive_type .)
    COMMA           reduce using rule 101 (parameter -> IDENTIFIER ELLIPSIS primitive_type .)


state 163

    (103) return_type -> LPAREN . type_list RPAREN
    (107) type_list -> . type_list COMMA type
    (108) type_list -> . type
    (52) type -> . primitive_type
    (53) type -> . slice_type
    (54) type -> . array_type
    (55) type -> . map_type
    (115) primitive_type -> . INT_TYPE
    (116) primitive_type -> . FLOAT64_TYPE
    (117) primitive_type -> . STRING_TYPE
    (118) primitive_type -> . BOOL_TYPE
    (56) slice_type -> . LBRACKET RBRACKET primitive_type
    (119) array_type -> . LBRACKET INT RBRACKET type
    (144) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type

    INT_TYPE        shift and go to state 34
    FLOAT64_TYPE    shift and go to state 35
    STRING_TYPE     shift and go to state 36
    BOOL_TYPE       shift and go to state 37
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    type_list                      shift and go to state 182
    type                           shift and go to state 183
    primitive_type                 shift and go to state 30
    slice_type                     shift and go to state 31
    array_type                     shift and go to state 32
    map_type                       shift and go to state 33

state 164

    (96) function_declaration -> FUNC IDENTIFIER LPAREN parameter_list RPAREN return_type . block
    (15) block -> . LBRACE enter_block exit_block RBRACE
    (16) block -> . LBRACE enter_block statement_list exit_block RBRACE

    LBRACE          shift and go to state 185

    block                          shift and go to state 184

state 165

    (102) return_type -> type .

    LBRACE          reduce using rule 102 (return_type -> type .)


state 166

    (104) return_type -> empty .

    LBRACE          reduce using rule 104 (return_type -> empty .)


state 167

    (97) parameter_list -> parameter_list COMMA parameter .

    RPAREN          reduce using rule 97 (parameter_list -> parameter_list COMMA parameter .)
    COMMA           reduce using rule 97 (parameter_list -> parameter_list COMMA parameter .)


state 168

    (154) method_declaration -> FUNC LPAREN receiver RPAREN IDENTIFIER LPAREN . parameter_list RPAREN return_type block
    (97) parameter_list -> . parameter_list COMMA parameter
    (98) parameter_list -> . parameter
    (99) parameter_list -> . empty
    (100) parameter -> . IDENTIFIER type
    (101) parameter -> . IDENTIFIER ELLIPSIS primitive_type
    (7) empty -> .

    IDENTIFIER      shift and go to state 75
    RPAREN          reduce using rule 7 (empty -> .)
    COMMA           reduce using rule 7 (empty -> .)

    parameter_list                 shift and go to state 186
    parameter                      shift and go to state 77
    empty                          shift and go to state 78

state 169

    (163) struct_type -> STRUCT LBRACE field_list RBRACE .

    VAR             reduce using rule 163 (struct_type -> STRUCT LBRACE field_list RBRACE .)
    CONST           reduce using rule 163 (struct_type -> STRUCT LBRACE field_list RBRACE .)
    FUNC            reduce using rule 163 (struct_type -> STRUCT LBRACE field_list RBRACE .)
    TYPE            reduce using rule 163 (struct_type -> STRUCT LBRACE field_list RBRACE .)
    $end            reduce using rule 163 (struct_type -> STRUCT LBRACE field_list RBRACE .)


state 170

    (151) field_list -> field_list field_declaration .

    RBRACE          reduce using rule 151 (field_list -> field_list field_declaration .)
    IDENTIFIER      reduce using rule 151 (field_list -> field_list field_declaration .)


state 171

    (152) field_declaration -> IDENTIFIER type .

    RBRACE          reduce using rule 152 (field_declaration -> IDENTIFIER type .)
    IDENTIFIER      reduce using rule 152 (field_declaration -> IDENTIFIER type .)


state 172

    (57) expression -> slice_type LBRACE expression_list RBRACE .

    PLUS            reduce using rule 57 (expression -> slice_type LBRACE expression_list RBRACE .)
    MINUS           reduce using rule 57 (expression -> slice_type LBRACE expression_list RBRACE .)
    TIMES           reduce using rule 57 (expression -> slice_type LBRACE expression_list RBRACE .)
    DIVIDE          reduce using rule 57 (expression -> slice_type LBRACE expression_list RBRACE .)
    MODULE          reduce using rule 57 (expression -> slice_type LBRACE expression_list RBRACE .)
    EQ              reduce using rule 57 (expression -> slice_type LBRACE expression_list RBRACE .)
    NEQ             reduce using rule 57 (expression -> slice_type LBRACE expression_list RBRACE .)
    LT              reduce using rule 57 (expression -> slice_type LBRACE expression_list RBRACE .)
    LE              reduce using rule 57 (expression -> slice_type LBRACE expression_list RBRACE .)
    GT              reduce using rule 57 (expression -> slice_type LBRACE expression_list RBRACE .)
    GE              reduce using rule 57 (expression -> slice_type LBRACE expression_list RBRACE .)
    LAND            reduce using rule 57 (expression -> slice_type LBRACE expression_list RBRACE .)
    LOR             reduce using rule 57 (expression -> slice_type LBRACE expression_list RBRACE .)
    AND             reduce using rule 57 (expression -> slice_type LBRACE expression_list RBRACE .)
    OR              reduce using rule 57 (expression -> slice_type LBRACE expression_list RBRACE .)
    XOR             reduce using rule 57 (expression -> slice_type LBRACE expression_list RBRACE .)
    AND_NOT         reduce using rule 57 (expression -> slice_type LBRACE expression_list RBRACE .)
    LSHIFT          reduce using rule 57 (expression -> slice_type LBRACE expression_list RBRACE .)
    RSHIFT          reduce using rule 57 (expression -> slice_type LBRACE expression_list RBRACE .)
    VAR             reduce using rule 57 (expression -> slice_type LBRACE expression_list RBRACE .)
    CONST           reduce using rule 57 (expression -> slice_type LBRACE expression_list RBRACE .)
    FUNC            reduce using rule 57 (expression -> slice_type LBRACE expression_list RBRACE .)
    TYPE            reduce using rule 57 (expression -> slice_type LBRACE expression_list RBRACE .)
    $end            reduce using rule 57 (expression -> slice_type LBRACE expression_list RBRACE .)
    RPAREN          reduce using rule 57 (expression -> slice_type LBRACE expression_list RBRACE .)
    RBRACE          reduce using rule 57 (expression -> slice_type LBRACE expression_list RBRACE .)
    COMMA           reduce using rule 57 (expression -> slice_type LBRACE expression_list RBRACE .)
    COLON           reduce using rule 57 (expression -> slice_type LBRACE expression_list RBRACE .)
    IDENTIFIER      reduce using rule 57 (expression -> slice_type LBRACE expression_list RBRACE .)
    LPAREN          reduce using rule 57 (expression -> slice_type LBRACE expression_list RBRACE .)
    LNOT            reduce using rule 57 (expression -> slice_type LBRACE expression_list RBRACE .)
    INT             reduce using rule 57 (expression -> slice_type LBRACE expression_list RBRACE .)
    FLOAT64         reduce using rule 57 (expression -> slice_type LBRACE expression_list RBRACE .)
    TRUE            reduce using rule 57 (expression -> slice_type LBRACE expression_list RBRACE .)
    FALSE           reduce using rule 57 (expression -> slice_type LBRACE expression_list RBRACE .)
    STRING          reduce using rule 57 (expression -> slice_type LBRACE expression_list RBRACE .)
    RETURN          reduce using rule 57 (expression -> slice_type LBRACE expression_list RBRACE .)
    IF              reduce using rule 57 (expression -> slice_type LBRACE expression_list RBRACE .)
    SWITCH          reduce using rule 57 (expression -> slice_type LBRACE expression_list RBRACE .)
    BREAK           reduce using rule 57 (expression -> slice_type LBRACE expression_list RBRACE .)
    CONTINUE        reduce using rule 57 (expression -> slice_type LBRACE expression_list RBRACE .)
    LBRACKET        reduce using rule 57 (expression -> slice_type LBRACE expression_list RBRACE .)
    MAP             reduce using rule 57 (expression -> slice_type LBRACE expression_list RBRACE .)
    FOR             reduce using rule 57 (expression -> slice_type LBRACE expression_list RBRACE .)
    CASE            reduce using rule 57 (expression -> slice_type LBRACE expression_list RBRACE .)
    DEFAULT         reduce using rule 57 (expression -> slice_type LBRACE expression_list RBRACE .)
    LBRACE          reduce using rule 57 (expression -> slice_type LBRACE expression_list RBRACE .)
    SEMICOLON       reduce using rule 57 (expression -> slice_type LBRACE expression_list RBRACE .)


state 173

    (60) expression_list -> expression_list COMMA . expression
    (57) expression -> . slice_type LBRACE expression_list RBRACE
    (58) expression -> . slice_type LBRACE RBRACE
    (61) expression -> . LPAREN expression RPAREN
    (120) expression -> . binary_expression
    (121) expression -> . relational_expression
    (122) expression -> . logical_expression
    (123) expression -> . bitwise_expression
    (124) expression -> . PLUS expression
    (125) expression -> . MINUS expression
    (126) expression -> . LNOT expression
    (127) expression -> . INT
    (128) expression -> . FLOAT64
    (129) expression -> . TRUE
    (130) expression -> . FALSE
    (131) expression -> . IDENTIFIER
    (132) expression -> . STRING
    (133) expression -> . IDENTIFIER PLUSPLUS
    (134) expression -> . IDENTIFIER MINUSMINUS
    (145) expression -> . map_type LBRACE expression_map_list RBRACE
    (146) expression -> . map_type LBRACE RBRACE
    (169) expression -> . type_name LBRACE keyed_element_list RBRACE
    (170) expression -> . type_name LBRACE RBRACE
    (56) slice_type -> . LBRACKET RBRACKET primitive_type
    (175) binary_expression -> . expression PLUS expression
    (176) binary_expression -> . expression MINUS expression
    (177) binary_expression -> . expression TIMES expression
    (178) binary_expression -> . expression DIVIDE expression
    (179) binary_expression -> . expression MODULE expression
    (184) relational_expression -> . expression EQ expression
    (185) relational_expression -> . expression NEQ expression
    (186) relational_expression -> . expression LT expression
    (187) relational_expression -> . expression LE expression
    (188) relational_expression -> . expression GT expression
    (189) relational_expression -> . expression GE expression
    (190) logical_expression -> . expression LAND expression
    (191) logical_expression -> . expression LOR expression
    (192) bitwise_expression -> . expression AND expression
    (193) bitwise_expression -> . expression OR expression
    (194) bitwise_expression -> . expression XOR expression
    (195) bitwise_expression -> . expression AND_NOT expression
    (196) bitwise_expression -> . expression LSHIFT expression
    (197) bitwise_expression -> . expression RSHIFT expression
    (144) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (171) type_name -> . IDENTIFIER
    (172) type_name -> . slice_type
    (173) type_name -> . array_type
    (174) type_name -> . map_type
    (119) array_type -> . LBRACKET INT RBRACKET type

    LPAREN          shift and go to state 54
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    LNOT            shift and go to state 61
    INT             shift and go to state 62
    FLOAT64         shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 66
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    expression                     shift and go to state 187
    slice_type                     shift and go to state 53
    binary_expression              shift and go to state 55
    relational_expression          shift and go to state 56
    logical_expression             shift and go to state 57
    bitwise_expression             shift and go to state 58
    map_type                       shift and go to state 67
    type_name                      shift and go to state 68
    array_type                     shift and go to state 69

state 174

    (145) expression -> map_type LBRACE expression_map_list RBRACE .

    PLUS            reduce using rule 145 (expression -> map_type LBRACE expression_map_list RBRACE .)
    MINUS           reduce using rule 145 (expression -> map_type LBRACE expression_map_list RBRACE .)
    TIMES           reduce using rule 145 (expression -> map_type LBRACE expression_map_list RBRACE .)
    DIVIDE          reduce using rule 145 (expression -> map_type LBRACE expression_map_list RBRACE .)
    MODULE          reduce using rule 145 (expression -> map_type LBRACE expression_map_list RBRACE .)
    EQ              reduce using rule 145 (expression -> map_type LBRACE expression_map_list RBRACE .)
    NEQ             reduce using rule 145 (expression -> map_type LBRACE expression_map_list RBRACE .)
    LT              reduce using rule 145 (expression -> map_type LBRACE expression_map_list RBRACE .)
    LE              reduce using rule 145 (expression -> map_type LBRACE expression_map_list RBRACE .)
    GT              reduce using rule 145 (expression -> map_type LBRACE expression_map_list RBRACE .)
    GE              reduce using rule 145 (expression -> map_type LBRACE expression_map_list RBRACE .)
    LAND            reduce using rule 145 (expression -> map_type LBRACE expression_map_list RBRACE .)
    LOR             reduce using rule 145 (expression -> map_type LBRACE expression_map_list RBRACE .)
    AND             reduce using rule 145 (expression -> map_type LBRACE expression_map_list RBRACE .)
    OR              reduce using rule 145 (expression -> map_type LBRACE expression_map_list RBRACE .)
    XOR             reduce using rule 145 (expression -> map_type LBRACE expression_map_list RBRACE .)
    AND_NOT         reduce using rule 145 (expression -> map_type LBRACE expression_map_list RBRACE .)
    LSHIFT          reduce using rule 145 (expression -> map_type LBRACE expression_map_list RBRACE .)
    RSHIFT          reduce using rule 145 (expression -> map_type LBRACE expression_map_list RBRACE .)
    VAR             reduce using rule 145 (expression -> map_type LBRACE expression_map_list RBRACE .)
    CONST           reduce using rule 145 (expression -> map_type LBRACE expression_map_list RBRACE .)
    FUNC            reduce using rule 145 (expression -> map_type LBRACE expression_map_list RBRACE .)
    TYPE            reduce using rule 145 (expression -> map_type LBRACE expression_map_list RBRACE .)
    $end            reduce using rule 145 (expression -> map_type LBRACE expression_map_list RBRACE .)
    RPAREN          reduce using rule 145 (expression -> map_type LBRACE expression_map_list RBRACE .)
    RBRACE          reduce using rule 145 (expression -> map_type LBRACE expression_map_list RBRACE .)
    COMMA           reduce using rule 145 (expression -> map_type LBRACE expression_map_list RBRACE .)
    COLON           reduce using rule 145 (expression -> map_type LBRACE expression_map_list RBRACE .)
    IDENTIFIER      reduce using rule 145 (expression -> map_type LBRACE expression_map_list RBRACE .)
    LPAREN          reduce using rule 145 (expression -> map_type LBRACE expression_map_list RBRACE .)
    LNOT            reduce using rule 145 (expression -> map_type LBRACE expression_map_list RBRACE .)
    INT             reduce using rule 145 (expression -> map_type LBRACE expression_map_list RBRACE .)
    FLOAT64         reduce using rule 145 (expression -> map_type LBRACE expression_map_list RBRACE .)
    TRUE            reduce using rule 145 (expression -> map_type LBRACE expression_map_list RBRACE .)
    FALSE           reduce using rule 145 (expression -> map_type LBRACE expression_map_list RBRACE .)
    STRING          reduce using rule 145 (expression -> map_type LBRACE expression_map_list RBRACE .)
    RETURN          reduce using rule 145 (expression -> map_type LBRACE expression_map_list RBRACE .)
    IF              reduce using rule 145 (expression -> map_type LBRACE expression_map_list RBRACE .)
    SWITCH          reduce using rule 145 (expression -> map_type LBRACE expression_map_list RBRACE .)
    BREAK           reduce using rule 145 (expression -> map_type LBRACE expression_map_list RBRACE .)
    CONTINUE        reduce using rule 145 (expression -> map_type LBRACE expression_map_list RBRACE .)
    LBRACKET        reduce using rule 145 (expression -> map_type LBRACE expression_map_list RBRACE .)
    MAP             reduce using rule 145 (expression -> map_type LBRACE expression_map_list RBRACE .)
    FOR             reduce using rule 145 (expression -> map_type LBRACE expression_map_list RBRACE .)
    CASE            reduce using rule 145 (expression -> map_type LBRACE expression_map_list RBRACE .)
    DEFAULT         reduce using rule 145 (expression -> map_type LBRACE expression_map_list RBRACE .)
    LBRACE          reduce using rule 145 (expression -> map_type LBRACE expression_map_list RBRACE .)
    SEMICOLON       reduce using rule 145 (expression -> map_type LBRACE expression_map_list RBRACE .)


state 175

    (148) expression_map_list -> expression_map_list COMMA . key_value
    (149) key_value -> . expression COLON expression
    (57) expression -> . slice_type LBRACE expression_list RBRACE
    (58) expression -> . slice_type LBRACE RBRACE
    (61) expression -> . LPAREN expression RPAREN
    (120) expression -> . binary_expression
    (121) expression -> . relational_expression
    (122) expression -> . logical_expression
    (123) expression -> . bitwise_expression
    (124) expression -> . PLUS expression
    (125) expression -> . MINUS expression
    (126) expression -> . LNOT expression
    (127) expression -> . INT
    (128) expression -> . FLOAT64
    (129) expression -> . TRUE
    (130) expression -> . FALSE
    (131) expression -> . IDENTIFIER
    (132) expression -> . STRING
    (133) expression -> . IDENTIFIER PLUSPLUS
    (134) expression -> . IDENTIFIER MINUSMINUS
    (145) expression -> . map_type LBRACE expression_map_list RBRACE
    (146) expression -> . map_type LBRACE RBRACE
    (169) expression -> . type_name LBRACE keyed_element_list RBRACE
    (170) expression -> . type_name LBRACE RBRACE
    (56) slice_type -> . LBRACKET RBRACKET primitive_type
    (175) binary_expression -> . expression PLUS expression
    (176) binary_expression -> . expression MINUS expression
    (177) binary_expression -> . expression TIMES expression
    (178) binary_expression -> . expression DIVIDE expression
    (179) binary_expression -> . expression MODULE expression
    (184) relational_expression -> . expression EQ expression
    (185) relational_expression -> . expression NEQ expression
    (186) relational_expression -> . expression LT expression
    (187) relational_expression -> . expression LE expression
    (188) relational_expression -> . expression GT expression
    (189) relational_expression -> . expression GE expression
    (190) logical_expression -> . expression LAND expression
    (191) logical_expression -> . expression LOR expression
    (192) bitwise_expression -> . expression AND expression
    (193) bitwise_expression -> . expression OR expression
    (194) bitwise_expression -> . expression XOR expression
    (195) bitwise_expression -> . expression AND_NOT expression
    (196) bitwise_expression -> . expression LSHIFT expression
    (197) bitwise_expression -> . expression RSHIFT expression
    (144) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (171) type_name -> . IDENTIFIER
    (172) type_name -> . slice_type
    (173) type_name -> . array_type
    (174) type_name -> . map_type
    (119) array_type -> . LBRACKET INT RBRACKET type

    LPAREN          shift and go to state 54
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    LNOT            shift and go to state 61
    INT             shift and go to state 62
    FLOAT64         shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 66
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    key_value                      shift and go to state 188
    expression                     shift and go to state 153
    slice_type                     shift and go to state 53
    binary_expression              shift and go to state 55
    relational_expression          shift and go to state 56
    logical_expression             shift and go to state 57
    bitwise_expression             shift and go to state 58
    map_type                       shift and go to state 67
    type_name                      shift and go to state 68
    array_type                     shift and go to state 69

state 176

    (149) key_value -> expression COLON . expression
    (57) expression -> . slice_type LBRACE expression_list RBRACE
    (58) expression -> . slice_type LBRACE RBRACE
    (61) expression -> . LPAREN expression RPAREN
    (120) expression -> . binary_expression
    (121) expression -> . relational_expression
    (122) expression -> . logical_expression
    (123) expression -> . bitwise_expression
    (124) expression -> . PLUS expression
    (125) expression -> . MINUS expression
    (126) expression -> . LNOT expression
    (127) expression -> . INT
    (128) expression -> . FLOAT64
    (129) expression -> . TRUE
    (130) expression -> . FALSE
    (131) expression -> . IDENTIFIER
    (132) expression -> . STRING
    (133) expression -> . IDENTIFIER PLUSPLUS
    (134) expression -> . IDENTIFIER MINUSMINUS
    (145) expression -> . map_type LBRACE expression_map_list RBRACE
    (146) expression -> . map_type LBRACE RBRACE
    (169) expression -> . type_name LBRACE keyed_element_list RBRACE
    (170) expression -> . type_name LBRACE RBRACE
    (56) slice_type -> . LBRACKET RBRACKET primitive_type
    (175) binary_expression -> . expression PLUS expression
    (176) binary_expression -> . expression MINUS expression
    (177) binary_expression -> . expression TIMES expression
    (178) binary_expression -> . expression DIVIDE expression
    (179) binary_expression -> . expression MODULE expression
    (184) relational_expression -> . expression EQ expression
    (185) relational_expression -> . expression NEQ expression
    (186) relational_expression -> . expression LT expression
    (187) relational_expression -> . expression LE expression
    (188) relational_expression -> . expression GT expression
    (189) relational_expression -> . expression GE expression
    (190) logical_expression -> . expression LAND expression
    (191) logical_expression -> . expression LOR expression
    (192) bitwise_expression -> . expression AND expression
    (193) bitwise_expression -> . expression OR expression
    (194) bitwise_expression -> . expression XOR expression
    (195) bitwise_expression -> . expression AND_NOT expression
    (196) bitwise_expression -> . expression LSHIFT expression
    (197) bitwise_expression -> . expression RSHIFT expression
    (144) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (171) type_name -> . IDENTIFIER
    (172) type_name -> . slice_type
    (173) type_name -> . array_type
    (174) type_name -> . map_type
    (119) array_type -> . LBRACKET INT RBRACKET type

    LPAREN          shift and go to state 54
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    LNOT            shift and go to state 61
    INT             shift and go to state 62
    FLOAT64         shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 66
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    expression                     shift and go to state 189
    slice_type                     shift and go to state 53
    binary_expression              shift and go to state 55
    relational_expression          shift and go to state 56
    logical_expression             shift and go to state 57
    bitwise_expression             shift and go to state 58
    map_type                       shift and go to state 67
    type_name                      shift and go to state 68
    array_type                     shift and go to state 69

state 177

    (169) expression -> type_name LBRACE keyed_element_list RBRACE .

    PLUS            reduce using rule 169 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    MINUS           reduce using rule 169 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    TIMES           reduce using rule 169 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    DIVIDE          reduce using rule 169 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    MODULE          reduce using rule 169 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    EQ              reduce using rule 169 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    NEQ             reduce using rule 169 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    LT              reduce using rule 169 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    LE              reduce using rule 169 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    GT              reduce using rule 169 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    GE              reduce using rule 169 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    LAND            reduce using rule 169 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    LOR             reduce using rule 169 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    AND             reduce using rule 169 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    OR              reduce using rule 169 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    XOR             reduce using rule 169 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    AND_NOT         reduce using rule 169 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    LSHIFT          reduce using rule 169 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    RSHIFT          reduce using rule 169 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    VAR             reduce using rule 169 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    CONST           reduce using rule 169 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    FUNC            reduce using rule 169 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    TYPE            reduce using rule 169 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    $end            reduce using rule 169 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    RPAREN          reduce using rule 169 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    RBRACE          reduce using rule 169 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    COMMA           reduce using rule 169 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    COLON           reduce using rule 169 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    IDENTIFIER      reduce using rule 169 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    LPAREN          reduce using rule 169 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    LNOT            reduce using rule 169 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    INT             reduce using rule 169 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    FLOAT64         reduce using rule 169 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    TRUE            reduce using rule 169 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    FALSE           reduce using rule 169 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    STRING          reduce using rule 169 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    RETURN          reduce using rule 169 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    IF              reduce using rule 169 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    SWITCH          reduce using rule 169 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    BREAK           reduce using rule 169 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    CONTINUE        reduce using rule 169 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    LBRACKET        reduce using rule 169 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    MAP             reduce using rule 169 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    FOR             reduce using rule 169 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    CASE            reduce using rule 169 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    DEFAULT         reduce using rule 169 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    LBRACE          reduce using rule 169 (expression -> type_name LBRACE keyed_element_list RBRACE .)
    SEMICOLON       reduce using rule 169 (expression -> type_name LBRACE keyed_element_list RBRACE .)


state 178

    (165) keyed_element_list -> keyed_element_list COMMA . keyed_element
    (166) keyed_element -> . IDENTIFIER COLON expression
    (167) keyed_element -> . INT COLON expression
    (168) keyed_element -> . expression
    (57) expression -> . slice_type LBRACE expression_list RBRACE
    (58) expression -> . slice_type LBRACE RBRACE
    (61) expression -> . LPAREN expression RPAREN
    (120) expression -> . binary_expression
    (121) expression -> . relational_expression
    (122) expression -> . logical_expression
    (123) expression -> . bitwise_expression
    (124) expression -> . PLUS expression
    (125) expression -> . MINUS expression
    (126) expression -> . LNOT expression
    (127) expression -> . INT
    (128) expression -> . FLOAT64
    (129) expression -> . TRUE
    (130) expression -> . FALSE
    (131) expression -> . IDENTIFIER
    (132) expression -> . STRING
    (133) expression -> . IDENTIFIER PLUSPLUS
    (134) expression -> . IDENTIFIER MINUSMINUS
    (145) expression -> . map_type LBRACE expression_map_list RBRACE
    (146) expression -> . map_type LBRACE RBRACE
    (169) expression -> . type_name LBRACE keyed_element_list RBRACE
    (170) expression -> . type_name LBRACE RBRACE
    (56) slice_type -> . LBRACKET RBRACKET primitive_type
    (175) binary_expression -> . expression PLUS expression
    (176) binary_expression -> . expression MINUS expression
    (177) binary_expression -> . expression TIMES expression
    (178) binary_expression -> . expression DIVIDE expression
    (179) binary_expression -> . expression MODULE expression
    (184) relational_expression -> . expression EQ expression
    (185) relational_expression -> . expression NEQ expression
    (186) relational_expression -> . expression LT expression
    (187) relational_expression -> . expression LE expression
    (188) relational_expression -> . expression GT expression
    (189) relational_expression -> . expression GE expression
    (190) logical_expression -> . expression LAND expression
    (191) logical_expression -> . expression LOR expression
    (192) bitwise_expression -> . expression AND expression
    (193) bitwise_expression -> . expression OR expression
    (194) bitwise_expression -> . expression XOR expression
    (195) bitwise_expression -> . expression AND_NOT expression
    (196) bitwise_expression -> . expression LSHIFT expression
    (197) bitwise_expression -> . expression RSHIFT expression
    (144) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (171) type_name -> . IDENTIFIER
    (172) type_name -> . slice_type
    (173) type_name -> . array_type
    (174) type_name -> . map_type
    (119) array_type -> . LBRACKET INT RBRACKET type

    IDENTIFIER      shift and go to state 157
    INT             shift and go to state 159
    LPAREN          shift and go to state 54
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    LNOT            shift and go to state 61
    FLOAT64         shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    STRING          shift and go to state 66
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    keyed_element                  shift and go to state 190
    expression                     shift and go to state 158
    slice_type                     shift and go to state 53
    binary_expression              shift and go to state 55
    relational_expression          shift and go to state 56
    logical_expression             shift and go to state 57
    bitwise_expression             shift and go to state 58
    map_type                       shift and go to state 67
    type_name                      shift and go to state 68
    array_type                     shift and go to state 69

state 179

    (166) keyed_element -> IDENTIFIER COLON . expression
    (57) expression -> . slice_type LBRACE expression_list RBRACE
    (58) expression -> . slice_type LBRACE RBRACE
    (61) expression -> . LPAREN expression RPAREN
    (120) expression -> . binary_expression
    (121) expression -> . relational_expression
    (122) expression -> . logical_expression
    (123) expression -> . bitwise_expression
    (124) expression -> . PLUS expression
    (125) expression -> . MINUS expression
    (126) expression -> . LNOT expression
    (127) expression -> . INT
    (128) expression -> . FLOAT64
    (129) expression -> . TRUE
    (130) expression -> . FALSE
    (131) expression -> . IDENTIFIER
    (132) expression -> . STRING
    (133) expression -> . IDENTIFIER PLUSPLUS
    (134) expression -> . IDENTIFIER MINUSMINUS
    (145) expression -> . map_type LBRACE expression_map_list RBRACE
    (146) expression -> . map_type LBRACE RBRACE
    (169) expression -> . type_name LBRACE keyed_element_list RBRACE
    (170) expression -> . type_name LBRACE RBRACE
    (56) slice_type -> . LBRACKET RBRACKET primitive_type
    (175) binary_expression -> . expression PLUS expression
    (176) binary_expression -> . expression MINUS expression
    (177) binary_expression -> . expression TIMES expression
    (178) binary_expression -> . expression DIVIDE expression
    (179) binary_expression -> . expression MODULE expression
    (184) relational_expression -> . expression EQ expression
    (185) relational_expression -> . expression NEQ expression
    (186) relational_expression -> . expression LT expression
    (187) relational_expression -> . expression LE expression
    (188) relational_expression -> . expression GT expression
    (189) relational_expression -> . expression GE expression
    (190) logical_expression -> . expression LAND expression
    (191) logical_expression -> . expression LOR expression
    (192) bitwise_expression -> . expression AND expression
    (193) bitwise_expression -> . expression OR expression
    (194) bitwise_expression -> . expression XOR expression
    (195) bitwise_expression -> . expression AND_NOT expression
    (196) bitwise_expression -> . expression LSHIFT expression
    (197) bitwise_expression -> . expression RSHIFT expression
    (144) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (171) type_name -> . IDENTIFIER
    (172) type_name -> . slice_type
    (173) type_name -> . array_type
    (174) type_name -> . map_type
    (119) array_type -> . LBRACKET INT RBRACKET type

    LPAREN          shift and go to state 54
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    LNOT            shift and go to state 61
    INT             shift and go to state 62
    FLOAT64         shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 66
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    expression                     shift and go to state 191
    slice_type                     shift and go to state 53
    binary_expression              shift and go to state 55
    relational_expression          shift and go to state 56
    logical_expression             shift and go to state 57
    bitwise_expression             shift and go to state 58
    map_type                       shift and go to state 67
    type_name                      shift and go to state 68
    array_type                     shift and go to state 69

state 180

    (167) keyed_element -> INT COLON . expression
    (57) expression -> . slice_type LBRACE expression_list RBRACE
    (58) expression -> . slice_type LBRACE RBRACE
    (61) expression -> . LPAREN expression RPAREN
    (120) expression -> . binary_expression
    (121) expression -> . relational_expression
    (122) expression -> . logical_expression
    (123) expression -> . bitwise_expression
    (124) expression -> . PLUS expression
    (125) expression -> . MINUS expression
    (126) expression -> . LNOT expression
    (127) expression -> . INT
    (128) expression -> . FLOAT64
    (129) expression -> . TRUE
    (130) expression -> . FALSE
    (131) expression -> . IDENTIFIER
    (132) expression -> . STRING
    (133) expression -> . IDENTIFIER PLUSPLUS
    (134) expression -> . IDENTIFIER MINUSMINUS
    (145) expression -> . map_type LBRACE expression_map_list RBRACE
    (146) expression -> . map_type LBRACE RBRACE
    (169) expression -> . type_name LBRACE keyed_element_list RBRACE
    (170) expression -> . type_name LBRACE RBRACE
    (56) slice_type -> . LBRACKET RBRACKET primitive_type
    (175) binary_expression -> . expression PLUS expression
    (176) binary_expression -> . expression MINUS expression
    (177) binary_expression -> . expression TIMES expression
    (178) binary_expression -> . expression DIVIDE expression
    (179) binary_expression -> . expression MODULE expression
    (184) relational_expression -> . expression EQ expression
    (185) relational_expression -> . expression NEQ expression
    (186) relational_expression -> . expression LT expression
    (187) relational_expression -> . expression LE expression
    (188) relational_expression -> . expression GT expression
    (189) relational_expression -> . expression GE expression
    (190) logical_expression -> . expression LAND expression
    (191) logical_expression -> . expression LOR expression
    (192) bitwise_expression -> . expression AND expression
    (193) bitwise_expression -> . expression OR expression
    (194) bitwise_expression -> . expression XOR expression
    (195) bitwise_expression -> . expression AND_NOT expression
    (196) bitwise_expression -> . expression LSHIFT expression
    (197) bitwise_expression -> . expression RSHIFT expression
    (144) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (171) type_name -> . IDENTIFIER
    (172) type_name -> . slice_type
    (173) type_name -> . array_type
    (174) type_name -> . map_type
    (119) array_type -> . LBRACKET INT RBRACKET type

    LPAREN          shift and go to state 54
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    LNOT            shift and go to state 61
    INT             shift and go to state 62
    FLOAT64         shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 66
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    expression                     shift and go to state 192
    slice_type                     shift and go to state 53
    binary_expression              shift and go to state 55
    relational_expression          shift and go to state 56
    logical_expression             shift and go to state 57
    bitwise_expression             shift and go to state 58
    map_type                       shift and go to state 67
    type_name                      shift and go to state 68
    array_type                     shift and go to state 69

state 181

    (144) map_type -> MAP LBRACKET primitive_type RBRACKET primitive_type .

    ASSIGN          reduce using rule 144 (map_type -> MAP LBRACKET primitive_type RBRACKET primitive_type .)
    VAR             reduce using rule 144 (map_type -> MAP LBRACKET primitive_type RBRACKET primitive_type .)
    CONST           reduce using rule 144 (map_type -> MAP LBRACKET primitive_type RBRACKET primitive_type .)
    FUNC            reduce using rule 144 (map_type -> MAP LBRACKET primitive_type RBRACKET primitive_type .)
    TYPE            reduce using rule 144 (map_type -> MAP LBRACKET primitive_type RBRACKET primitive_type .)
    $end            reduce using rule 144 (map_type -> MAP LBRACKET primitive_type RBRACKET primitive_type .)
    LBRACE          reduce using rule 144 (map_type -> MAP LBRACKET primitive_type RBRACKET primitive_type .)
    RPAREN          reduce using rule 144 (map_type -> MAP LBRACKET primitive_type RBRACKET primitive_type .)
    COMMA           reduce using rule 144 (map_type -> MAP LBRACKET primitive_type RBRACKET primitive_type .)
    RBRACE          reduce using rule 144 (map_type -> MAP LBRACKET primitive_type RBRACKET primitive_type .)
    IDENTIFIER      reduce using rule 144 (map_type -> MAP LBRACKET primitive_type RBRACKET primitive_type .)
    SEMICOLON       reduce using rule 144 (map_type -> MAP LBRACKET primitive_type RBRACKET primitive_type .)


state 182

    (103) return_type -> LPAREN type_list . RPAREN
    (107) type_list -> type_list . COMMA type

    RPAREN          shift and go to state 193
    COMMA           shift and go to state 194


state 183

    (108) type_list -> type .

    RPAREN          reduce using rule 108 (type_list -> type .)
    COMMA           reduce using rule 108 (type_list -> type .)


state 184

    (96) function_declaration -> FUNC IDENTIFIER LPAREN parameter_list RPAREN return_type block .

    VAR             reduce using rule 96 (function_declaration -> FUNC IDENTIFIER LPAREN parameter_list RPAREN return_type block .)
    CONST           reduce using rule 96 (function_declaration -> FUNC IDENTIFIER LPAREN parameter_list RPAREN return_type block .)
    FUNC            reduce using rule 96 (function_declaration -> FUNC IDENTIFIER LPAREN parameter_list RPAREN return_type block .)
    TYPE            reduce using rule 96 (function_declaration -> FUNC IDENTIFIER LPAREN parameter_list RPAREN return_type block .)
    $end            reduce using rule 96 (function_declaration -> FUNC IDENTIFIER LPAREN parameter_list RPAREN return_type block .)


state 185

    (15) block -> LBRACE . enter_block exit_block RBRACE
    (16) block -> LBRACE . enter_block statement_list exit_block RBRACE
    (207) enter_block -> .

    IDENTIFIER      reduce using rule 207 (enter_block -> .)
    VAR             reduce using rule 207 (enter_block -> .)
    CONST           reduce using rule 207 (enter_block -> .)
    LPAREN          reduce using rule 207 (enter_block -> .)
    PLUS            reduce using rule 207 (enter_block -> .)
    MINUS           reduce using rule 207 (enter_block -> .)
    LNOT            reduce using rule 207 (enter_block -> .)
    INT             reduce using rule 207 (enter_block -> .)
    FLOAT64         reduce using rule 207 (enter_block -> .)
    TRUE            reduce using rule 207 (enter_block -> .)
    FALSE           reduce using rule 207 (enter_block -> .)
    STRING          reduce using rule 207 (enter_block -> .)
    RETURN          reduce using rule 207 (enter_block -> .)
    IF              reduce using rule 207 (enter_block -> .)
    SWITCH          reduce using rule 207 (enter_block -> .)
    BREAK           reduce using rule 207 (enter_block -> .)
    CONTINUE        reduce using rule 207 (enter_block -> .)
    LBRACKET        reduce using rule 207 (enter_block -> .)
    MAP             reduce using rule 207 (enter_block -> .)
    FOR             reduce using rule 207 (enter_block -> .)
    RBRACE          reduce using rule 207 (enter_block -> .)

    enter_block                    shift and go to state 195

state 186

    (154) method_declaration -> FUNC LPAREN receiver RPAREN IDENTIFIER LPAREN parameter_list . RPAREN return_type block
    (97) parameter_list -> parameter_list . COMMA parameter

    RPAREN          shift and go to state 196
    COMMA           shift and go to state 119


state 187

    (60) expression_list -> expression_list COMMA expression .
    (175) binary_expression -> expression . PLUS expression
    (176) binary_expression -> expression . MINUS expression
    (177) binary_expression -> expression . TIMES expression
    (178) binary_expression -> expression . DIVIDE expression
    (179) binary_expression -> expression . MODULE expression
    (184) relational_expression -> expression . EQ expression
    (185) relational_expression -> expression . NEQ expression
    (186) relational_expression -> expression . LT expression
    (187) relational_expression -> expression . LE expression
    (188) relational_expression -> expression . GT expression
    (189) relational_expression -> expression . GE expression
    (190) logical_expression -> expression . LAND expression
    (191) logical_expression -> expression . LOR expression
    (192) bitwise_expression -> expression . AND expression
    (193) bitwise_expression -> expression . OR expression
    (194) bitwise_expression -> expression . XOR expression
    (195) bitwise_expression -> expression . AND_NOT expression
    (196) bitwise_expression -> expression . LSHIFT expression
    (197) bitwise_expression -> expression . RSHIFT expression

    RBRACE          reduce using rule 60 (expression_list -> expression_list COMMA expression .)
    COMMA           reduce using rule 60 (expression_list -> expression_list COMMA expression .)
    RPAREN          reduce using rule 60 (expression_list -> expression_list COMMA expression .)
    PLUS            shift and go to state 86
    MINUS           shift and go to state 87
    TIMES           shift and go to state 88
    DIVIDE          shift and go to state 89
    MODULE          shift and go to state 90
    EQ              shift and go to state 91
    NEQ             shift and go to state 92
    LT              shift and go to state 93
    LE              shift and go to state 94
    GT              shift and go to state 95
    GE              shift and go to state 96
    LAND            shift and go to state 97
    LOR             shift and go to state 98
    AND             shift and go to state 99
    OR              shift and go to state 100
    XOR             shift and go to state 101
    AND_NOT         shift and go to state 102
    LSHIFT          shift and go to state 103
    RSHIFT          shift and go to state 104


state 188

    (148) expression_map_list -> expression_map_list COMMA key_value .

    RBRACE          reduce using rule 148 (expression_map_list -> expression_map_list COMMA key_value .)
    COMMA           reduce using rule 148 (expression_map_list -> expression_map_list COMMA key_value .)


state 189

    (149) key_value -> expression COLON expression .
    (175) binary_expression -> expression . PLUS expression
    (176) binary_expression -> expression . MINUS expression
    (177) binary_expression -> expression . TIMES expression
    (178) binary_expression -> expression . DIVIDE expression
    (179) binary_expression -> expression . MODULE expression
    (184) relational_expression -> expression . EQ expression
    (185) relational_expression -> expression . NEQ expression
    (186) relational_expression -> expression . LT expression
    (187) relational_expression -> expression . LE expression
    (188) relational_expression -> expression . GT expression
    (189) relational_expression -> expression . GE expression
    (190) logical_expression -> expression . LAND expression
    (191) logical_expression -> expression . LOR expression
    (192) bitwise_expression -> expression . AND expression
    (193) bitwise_expression -> expression . OR expression
    (194) bitwise_expression -> expression . XOR expression
    (195) bitwise_expression -> expression . AND_NOT expression
    (196) bitwise_expression -> expression . LSHIFT expression
    (197) bitwise_expression -> expression . RSHIFT expression

    RBRACE          reduce using rule 149 (key_value -> expression COLON expression .)
    COMMA           reduce using rule 149 (key_value -> expression COLON expression .)
    PLUS            shift and go to state 86
    MINUS           shift and go to state 87
    TIMES           shift and go to state 88
    DIVIDE          shift and go to state 89
    MODULE          shift and go to state 90
    EQ              shift and go to state 91
    NEQ             shift and go to state 92
    LT              shift and go to state 93
    LE              shift and go to state 94
    GT              shift and go to state 95
    GE              shift and go to state 96
    LAND            shift and go to state 97
    LOR             shift and go to state 98
    AND             shift and go to state 99
    OR              shift and go to state 100
    XOR             shift and go to state 101
    AND_NOT         shift and go to state 102
    LSHIFT          shift and go to state 103
    RSHIFT          shift and go to state 104


state 190

    (165) keyed_element_list -> keyed_element_list COMMA keyed_element .

    RBRACE          reduce using rule 165 (keyed_element_list -> keyed_element_list COMMA keyed_element .)
    COMMA           reduce using rule 165 (keyed_element_list -> keyed_element_list COMMA keyed_element .)


state 191

    (166) keyed_element -> IDENTIFIER COLON expression .
    (175) binary_expression -> expression . PLUS expression
    (176) binary_expression -> expression . MINUS expression
    (177) binary_expression -> expression . TIMES expression
    (178) binary_expression -> expression . DIVIDE expression
    (179) binary_expression -> expression . MODULE expression
    (184) relational_expression -> expression . EQ expression
    (185) relational_expression -> expression . NEQ expression
    (186) relational_expression -> expression . LT expression
    (187) relational_expression -> expression . LE expression
    (188) relational_expression -> expression . GT expression
    (189) relational_expression -> expression . GE expression
    (190) logical_expression -> expression . LAND expression
    (191) logical_expression -> expression . LOR expression
    (192) bitwise_expression -> expression . AND expression
    (193) bitwise_expression -> expression . OR expression
    (194) bitwise_expression -> expression . XOR expression
    (195) bitwise_expression -> expression . AND_NOT expression
    (196) bitwise_expression -> expression . LSHIFT expression
    (197) bitwise_expression -> expression . RSHIFT expression

    RBRACE          reduce using rule 166 (keyed_element -> IDENTIFIER COLON expression .)
    COMMA           reduce using rule 166 (keyed_element -> IDENTIFIER COLON expression .)
    PLUS            shift and go to state 86
    MINUS           shift and go to state 87
    TIMES           shift and go to state 88
    DIVIDE          shift and go to state 89
    MODULE          shift and go to state 90
    EQ              shift and go to state 91
    NEQ             shift and go to state 92
    LT              shift and go to state 93
    LE              shift and go to state 94
    GT              shift and go to state 95
    GE              shift and go to state 96
    LAND            shift and go to state 97
    LOR             shift and go to state 98
    AND             shift and go to state 99
    OR              shift and go to state 100
    XOR             shift and go to state 101
    AND_NOT         shift and go to state 102
    LSHIFT          shift and go to state 103
    RSHIFT          shift and go to state 104


state 192

    (167) keyed_element -> INT COLON expression .
    (175) binary_expression -> expression . PLUS expression
    (176) binary_expression -> expression . MINUS expression
    (177) binary_expression -> expression . TIMES expression
    (178) binary_expression -> expression . DIVIDE expression
    (179) binary_expression -> expression . MODULE expression
    (184) relational_expression -> expression . EQ expression
    (185) relational_expression -> expression . NEQ expression
    (186) relational_expression -> expression . LT expression
    (187) relational_expression -> expression . LE expression
    (188) relational_expression -> expression . GT expression
    (189) relational_expression -> expression . GE expression
    (190) logical_expression -> expression . LAND expression
    (191) logical_expression -> expression . LOR expression
    (192) bitwise_expression -> expression . AND expression
    (193) bitwise_expression -> expression . OR expression
    (194) bitwise_expression -> expression . XOR expression
    (195) bitwise_expression -> expression . AND_NOT expression
    (196) bitwise_expression -> expression . LSHIFT expression
    (197) bitwise_expression -> expression . RSHIFT expression

    RBRACE          reduce using rule 167 (keyed_element -> INT COLON expression .)
    COMMA           reduce using rule 167 (keyed_element -> INT COLON expression .)
    PLUS            shift and go to state 86
    MINUS           shift and go to state 87
    TIMES           shift and go to state 88
    DIVIDE          shift and go to state 89
    MODULE          shift and go to state 90
    EQ              shift and go to state 91
    NEQ             shift and go to state 92
    LT              shift and go to state 93
    LE              shift and go to state 94
    GT              shift and go to state 95
    GE              shift and go to state 96
    LAND            shift and go to state 97
    LOR             shift and go to state 98
    AND             shift and go to state 99
    OR              shift and go to state 100
    XOR             shift and go to state 101
    AND_NOT         shift and go to state 102
    LSHIFT          shift and go to state 103
    RSHIFT          shift and go to state 104


state 193

    (103) return_type -> LPAREN type_list RPAREN .

    LBRACE          reduce using rule 103 (return_type -> LPAREN type_list RPAREN .)


state 194

    (107) type_list -> type_list COMMA . type
    (52) type -> . primitive_type
    (53) type -> . slice_type
    (54) type -> . array_type
    (55) type -> . map_type
    (115) primitive_type -> . INT_TYPE
    (116) primitive_type -> . FLOAT64_TYPE
    (117) primitive_type -> . STRING_TYPE
    (118) primitive_type -> . BOOL_TYPE
    (56) slice_type -> . LBRACKET RBRACKET primitive_type
    (119) array_type -> . LBRACKET INT RBRACKET type
    (144) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type

    INT_TYPE        shift and go to state 34
    FLOAT64_TYPE    shift and go to state 35
    STRING_TYPE     shift and go to state 36
    BOOL_TYPE       shift and go to state 37
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    type                           shift and go to state 197
    primitive_type                 shift and go to state 30
    slice_type                     shift and go to state 31
    array_type                     shift and go to state 32
    map_type                       shift and go to state 33

state 195

    (15) block -> LBRACE enter_block . exit_block RBRACE
    (16) block -> LBRACE enter_block . statement_list exit_block RBRACE
    (208) exit_block -> .
    (17) statement_list -> . statement
    (18) statement_list -> . statement_list statement
    (19) statement -> . assignment
    (20) statement -> . assignment_compound
    (21) statement -> . variable_declaration
    (22) statement -> . expression
    (23) statement -> . return_statement
    (24) statement -> . for_statement
    (25) statement -> . if_statement
    (26) statement -> . switch_statement
    (27) statement -> . break_statement
    (28) statement -> . continue_statement
    (29) statement -> . call_expression
    (109) assignment -> . IDENTIFIER ASSIGN expression
    (110) assignment -> . IDENTIFIER SHORT_ASSIGN expression
    (40) assignment_compound -> . IDENTIFIER operator_assign expression
    (111) variable_declaration -> . VAR IDENTIFIER type ASSIGN expression
    (112) variable_declaration -> . CONST IDENTIFIER type ASSIGN expression
    (113) variable_declaration -> . VAR IDENTIFIER ASSIGN expression
    (114) variable_declaration -> . CONST IDENTIFIER ASSIGN expression
    (57) expression -> . slice_type LBRACE expression_list RBRACE
    (58) expression -> . slice_type LBRACE RBRACE
    (61) expression -> . LPAREN expression RPAREN
    (120) expression -> . binary_expression
    (121) expression -> . relational_expression
    (122) expression -> . logical_expression
    (123) expression -> . bitwise_expression
    (124) expression -> . PLUS expression
    (125) expression -> . MINUS expression
    (126) expression -> . LNOT expression
    (127) expression -> . INT
    (128) expression -> . FLOAT64
    (129) expression -> . TRUE
    (130) expression -> . FALSE
    (131) expression -> . IDENTIFIER
    (132) expression -> . STRING
    (133) expression -> . IDENTIFIER PLUSPLUS
    (134) expression -> . IDENTIFIER MINUSMINUS
    (145) expression -> . map_type LBRACE expression_map_list RBRACE
    (146) expression -> . map_type LBRACE RBRACE
    (169) expression -> . type_name LBRACE keyed_element_list RBRACE
    (170) expression -> . type_name LBRACE RBRACE
    (105) return_statement -> . RETURN
    (106) return_statement -> . RETURN return_list
    (78) for_statement -> . for_classic
    (79) for_statement -> . for_condition
    (80) for_statement -> . for_infinite
    (135) if_statement -> . IF expression block
    (136) if_statement -> . IF expression block ELSE block
    (137) if_statement -> . IF expression block ELSE if_statement
    (138) if_statement -> . IF if_assignment SEMICOLON expression block
    (139) if_statement -> . IF if_assignment SEMICOLON expression block ELSE block
    (140) if_statement -> . IF if_assignment SEMICOLON expression block ELSE if_statement
    (228) switch_statement -> . SWITCH enter_block switch_header LBRACE case_clauses RBRACE exit_block
    (74) break_statement -> . BREAK
    (75) continue_statement -> . CONTINUE
    (202) call_expression -> . print_expression
    (203) call_expression -> . input_expression
    (204) call_expression -> . func_call_expression
    (56) slice_type -> . LBRACKET RBRACKET primitive_type
    (175) binary_expression -> . expression PLUS expression
    (176) binary_expression -> . expression MINUS expression
    (177) binary_expression -> . expression TIMES expression
    (178) binary_expression -> . expression DIVIDE expression
    (179) binary_expression -> . expression MODULE expression
    (184) relational_expression -> . expression EQ expression
    (185) relational_expression -> . expression NEQ expression
    (186) relational_expression -> . expression LT expression
    (187) relational_expression -> . expression LE expression
    (188) relational_expression -> . expression GT expression
    (189) relational_expression -> . expression GE expression
    (190) logical_expression -> . expression LAND expression
    (191) logical_expression -> . expression LOR expression
    (192) bitwise_expression -> . expression AND expression
    (193) bitwise_expression -> . expression OR expression
    (194) bitwise_expression -> . expression XOR expression
    (195) bitwise_expression -> . expression AND_NOT expression
    (196) bitwise_expression -> . expression LSHIFT expression
    (197) bitwise_expression -> . expression RSHIFT expression
    (144) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (171) type_name -> . IDENTIFIER
    (172) type_name -> . slice_type
    (173) type_name -> . array_type
    (174) type_name -> . map_type
    (81) for_classic -> . FOR for_init SEMICOLON for_cond SEMICOLON for_post block
    (82) for_condition -> . FOR expression block
    (83) for_infinite -> . FOR block
    (229) print_expression -> . IDENTIFIER DOT IDENTIFIER LPAREN argument_list RPAREN
    (230) input_expression -> . IDENTIFIER DOT IDENTIFIER LPAREN AND IDENTIFIER COMMA argument_list RPAREN
    (201) func_call_expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (119) array_type -> . LBRACKET INT RBRACKET type

    RBRACE          reduce using rule 208 (exit_block -> .)
    IDENTIFIER      shift and go to state 212
    VAR             shift and go to state 213
    CONST           shift and go to state 214
    LPAREN          shift and go to state 54
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    LNOT            shift and go to state 61
    INT             shift and go to state 62
    FLOAT64         shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    STRING          shift and go to state 66
    RETURN          shift and go to state 215
    IF              shift and go to state 219
    SWITCH          shift and go to state 220
    BREAK           shift and go to state 221
    CONTINUE        shift and go to state 222
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39
    FOR             shift and go to state 226

    exit_block                     shift and go to state 198
    statement_list                 shift and go to state 199
    statement                      shift and go to state 200
    assignment                     shift and go to state 201
    assignment_compound            shift and go to state 202
    variable_declaration           shift and go to state 203
    expression                     shift and go to state 204
    return_statement               shift and go to state 205
    for_statement                  shift and go to state 206
    if_statement                   shift and go to state 207
    switch_statement               shift and go to state 208
    break_statement                shift and go to state 209
    continue_statement             shift and go to state 210
    call_expression                shift and go to state 211
    slice_type                     shift and go to state 53
    binary_expression              shift and go to state 55
    relational_expression          shift and go to state 56
    logical_expression             shift and go to state 57
    bitwise_expression             shift and go to state 58
    map_type                       shift and go to state 67
    type_name                      shift and go to state 68
    for_classic                    shift and go to state 216
    for_condition                  shift and go to state 217
    for_infinite                   shift and go to state 218
    print_expression               shift and go to state 223
    input_expression               shift and go to state 224
    func_call_expression           shift and go to state 225
    array_type                     shift and go to state 69

state 196

    (154) method_declaration -> FUNC LPAREN receiver RPAREN IDENTIFIER LPAREN parameter_list RPAREN . return_type block
    (102) return_type -> . type
    (103) return_type -> . LPAREN type_list RPAREN
    (104) return_type -> . empty
    (52) type -> . primitive_type
    (53) type -> . slice_type
    (54) type -> . array_type
    (55) type -> . map_type
    (7) empty -> .
    (115) primitive_type -> . INT_TYPE
    (116) primitive_type -> . FLOAT64_TYPE
    (117) primitive_type -> . STRING_TYPE
    (118) primitive_type -> . BOOL_TYPE
    (56) slice_type -> . LBRACKET RBRACKET primitive_type
    (119) array_type -> . LBRACKET INT RBRACKET type
    (144) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type

    LPAREN          shift and go to state 163
    LBRACE          reduce using rule 7 (empty -> .)
    INT_TYPE        shift and go to state 34
    FLOAT64_TYPE    shift and go to state 35
    STRING_TYPE     shift and go to state 36
    BOOL_TYPE       shift and go to state 37
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    return_type                    shift and go to state 227
    type                           shift and go to state 165
    empty                          shift and go to state 166
    primitive_type                 shift and go to state 30
    slice_type                     shift and go to state 31
    array_type                     shift and go to state 32
    map_type                       shift and go to state 33

state 197

    (107) type_list -> type_list COMMA type .

    RPAREN          reduce using rule 107 (type_list -> type_list COMMA type .)
    COMMA           reduce using rule 107 (type_list -> type_list COMMA type .)


state 198

    (15) block -> LBRACE enter_block exit_block . RBRACE

    RBRACE          shift and go to state 228


state 199

    (16) block -> LBRACE enter_block statement_list . exit_block RBRACE
    (18) statement_list -> statement_list . statement
    (208) exit_block -> .
    (19) statement -> . assignment
    (20) statement -> . assignment_compound
    (21) statement -> . variable_declaration
    (22) statement -> . expression
    (23) statement -> . return_statement
    (24) statement -> . for_statement
    (25) statement -> . if_statement
    (26) statement -> . switch_statement
    (27) statement -> . break_statement
    (28) statement -> . continue_statement
    (29) statement -> . call_expression
    (109) assignment -> . IDENTIFIER ASSIGN expression
    (110) assignment -> . IDENTIFIER SHORT_ASSIGN expression
    (40) assignment_compound -> . IDENTIFIER operator_assign expression
    (111) variable_declaration -> . VAR IDENTIFIER type ASSIGN expression
    (112) variable_declaration -> . CONST IDENTIFIER type ASSIGN expression
    (113) variable_declaration -> . VAR IDENTIFIER ASSIGN expression
    (114) variable_declaration -> . CONST IDENTIFIER ASSIGN expression
    (57) expression -> . slice_type LBRACE expression_list RBRACE
    (58) expression -> . slice_type LBRACE RBRACE
    (61) expression -> . LPAREN expression RPAREN
    (120) expression -> . binary_expression
    (121) expression -> . relational_expression
    (122) expression -> . logical_expression
    (123) expression -> . bitwise_expression
    (124) expression -> . PLUS expression
    (125) expression -> . MINUS expression
    (126) expression -> . LNOT expression
    (127) expression -> . INT
    (128) expression -> . FLOAT64
    (129) expression -> . TRUE
    (130) expression -> . FALSE
    (131) expression -> . IDENTIFIER
    (132) expression -> . STRING
    (133) expression -> . IDENTIFIER PLUSPLUS
    (134) expression -> . IDENTIFIER MINUSMINUS
    (145) expression -> . map_type LBRACE expression_map_list RBRACE
    (146) expression -> . map_type LBRACE RBRACE
    (169) expression -> . type_name LBRACE keyed_element_list RBRACE
    (170) expression -> . type_name LBRACE RBRACE
    (105) return_statement -> . RETURN
    (106) return_statement -> . RETURN return_list
    (78) for_statement -> . for_classic
    (79) for_statement -> . for_condition
    (80) for_statement -> . for_infinite
    (135) if_statement -> . IF expression block
    (136) if_statement -> . IF expression block ELSE block
    (137) if_statement -> . IF expression block ELSE if_statement
    (138) if_statement -> . IF if_assignment SEMICOLON expression block
    (139) if_statement -> . IF if_assignment SEMICOLON expression block ELSE block
    (140) if_statement -> . IF if_assignment SEMICOLON expression block ELSE if_statement
    (228) switch_statement -> . SWITCH enter_block switch_header LBRACE case_clauses RBRACE exit_block
    (74) break_statement -> . BREAK
    (75) continue_statement -> . CONTINUE
    (202) call_expression -> . print_expression
    (203) call_expression -> . input_expression
    (204) call_expression -> . func_call_expression
    (56) slice_type -> . LBRACKET RBRACKET primitive_type
    (175) binary_expression -> . expression PLUS expression
    (176) binary_expression -> . expression MINUS expression
    (177) binary_expression -> . expression TIMES expression
    (178) binary_expression -> . expression DIVIDE expression
    (179) binary_expression -> . expression MODULE expression
    (184) relational_expression -> . expression EQ expression
    (185) relational_expression -> . expression NEQ expression
    (186) relational_expression -> . expression LT expression
    (187) relational_expression -> . expression LE expression
    (188) relational_expression -> . expression GT expression
    (189) relational_expression -> . expression GE expression
    (190) logical_expression -> . expression LAND expression
    (191) logical_expression -> . expression LOR expression
    (192) bitwise_expression -> . expression AND expression
    (193) bitwise_expression -> . expression OR expression
    (194) bitwise_expression -> . expression XOR expression
    (195) bitwise_expression -> . expression AND_NOT expression
    (196) bitwise_expression -> . expression LSHIFT expression
    (197) bitwise_expression -> . expression RSHIFT expression
    (144) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (171) type_name -> . IDENTIFIER
    (172) type_name -> . slice_type
    (173) type_name -> . array_type
    (174) type_name -> . map_type
    (81) for_classic -> . FOR for_init SEMICOLON for_cond SEMICOLON for_post block
    (82) for_condition -> . FOR expression block
    (83) for_infinite -> . FOR block
    (229) print_expression -> . IDENTIFIER DOT IDENTIFIER LPAREN argument_list RPAREN
    (230) input_expression -> . IDENTIFIER DOT IDENTIFIER LPAREN AND IDENTIFIER COMMA argument_list RPAREN
    (201) func_call_expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (119) array_type -> . LBRACKET INT RBRACKET type

    RBRACE          reduce using rule 208 (exit_block -> .)
    IDENTIFIER      shift and go to state 212
    VAR             shift and go to state 213
    CONST           shift and go to state 214
    LPAREN          shift and go to state 54
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    LNOT            shift and go to state 61
    INT             shift and go to state 62
    FLOAT64         shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    STRING          shift and go to state 66
    RETURN          shift and go to state 215
    IF              shift and go to state 219
    SWITCH          shift and go to state 220
    BREAK           shift and go to state 221
    CONTINUE        shift and go to state 222
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39
    FOR             shift and go to state 226

    exit_block                     shift and go to state 229
    statement                      shift and go to state 230
    assignment                     shift and go to state 201
    assignment_compound            shift and go to state 202
    variable_declaration           shift and go to state 203
    expression                     shift and go to state 204
    return_statement               shift and go to state 205
    for_statement                  shift and go to state 206
    if_statement                   shift and go to state 207
    switch_statement               shift and go to state 208
    break_statement                shift and go to state 209
    continue_statement             shift and go to state 210
    call_expression                shift and go to state 211
    slice_type                     shift and go to state 53
    binary_expression              shift and go to state 55
    relational_expression          shift and go to state 56
    logical_expression             shift and go to state 57
    bitwise_expression             shift and go to state 58
    map_type                       shift and go to state 67
    type_name                      shift and go to state 68
    for_classic                    shift and go to state 216
    for_condition                  shift and go to state 217
    for_infinite                   shift and go to state 218
    print_expression               shift and go to state 223
    input_expression               shift and go to state 224
    func_call_expression           shift and go to state 225
    array_type                     shift and go to state 69

state 200

    (17) statement_list -> statement .

    IDENTIFIER      reduce using rule 17 (statement_list -> statement .)
    VAR             reduce using rule 17 (statement_list -> statement .)
    CONST           reduce using rule 17 (statement_list -> statement .)
    LPAREN          reduce using rule 17 (statement_list -> statement .)
    PLUS            reduce using rule 17 (statement_list -> statement .)
    MINUS           reduce using rule 17 (statement_list -> statement .)
    LNOT            reduce using rule 17 (statement_list -> statement .)
    INT             reduce using rule 17 (statement_list -> statement .)
    FLOAT64         reduce using rule 17 (statement_list -> statement .)
    TRUE            reduce using rule 17 (statement_list -> statement .)
    FALSE           reduce using rule 17 (statement_list -> statement .)
    STRING          reduce using rule 17 (statement_list -> statement .)
    RETURN          reduce using rule 17 (statement_list -> statement .)
    IF              reduce using rule 17 (statement_list -> statement .)
    SWITCH          reduce using rule 17 (statement_list -> statement .)
    BREAK           reduce using rule 17 (statement_list -> statement .)
    CONTINUE        reduce using rule 17 (statement_list -> statement .)
    LBRACKET        reduce using rule 17 (statement_list -> statement .)
    MAP             reduce using rule 17 (statement_list -> statement .)
    FOR             reduce using rule 17 (statement_list -> statement .)
    RBRACE          reduce using rule 17 (statement_list -> statement .)
    CASE            reduce using rule 17 (statement_list -> statement .)
    DEFAULT         reduce using rule 17 (statement_list -> statement .)


state 201

    (19) statement -> assignment .

    IDENTIFIER      reduce using rule 19 (statement -> assignment .)
    VAR             reduce using rule 19 (statement -> assignment .)
    CONST           reduce using rule 19 (statement -> assignment .)
    LPAREN          reduce using rule 19 (statement -> assignment .)
    PLUS            reduce using rule 19 (statement -> assignment .)
    MINUS           reduce using rule 19 (statement -> assignment .)
    LNOT            reduce using rule 19 (statement -> assignment .)
    INT             reduce using rule 19 (statement -> assignment .)
    FLOAT64         reduce using rule 19 (statement -> assignment .)
    TRUE            reduce using rule 19 (statement -> assignment .)
    FALSE           reduce using rule 19 (statement -> assignment .)
    STRING          reduce using rule 19 (statement -> assignment .)
    RETURN          reduce using rule 19 (statement -> assignment .)
    IF              reduce using rule 19 (statement -> assignment .)
    SWITCH          reduce using rule 19 (statement -> assignment .)
    BREAK           reduce using rule 19 (statement -> assignment .)
    CONTINUE        reduce using rule 19 (statement -> assignment .)
    LBRACKET        reduce using rule 19 (statement -> assignment .)
    MAP             reduce using rule 19 (statement -> assignment .)
    FOR             reduce using rule 19 (statement -> assignment .)
    RBRACE          reduce using rule 19 (statement -> assignment .)
    CASE            reduce using rule 19 (statement -> assignment .)
    DEFAULT         reduce using rule 19 (statement -> assignment .)


state 202

    (20) statement -> assignment_compound .

    IDENTIFIER      reduce using rule 20 (statement -> assignment_compound .)
    VAR             reduce using rule 20 (statement -> assignment_compound .)
    CONST           reduce using rule 20 (statement -> assignment_compound .)
    LPAREN          reduce using rule 20 (statement -> assignment_compound .)
    PLUS            reduce using rule 20 (statement -> assignment_compound .)
    MINUS           reduce using rule 20 (statement -> assignment_compound .)
    LNOT            reduce using rule 20 (statement -> assignment_compound .)
    INT             reduce using rule 20 (statement -> assignment_compound .)
    FLOAT64         reduce using rule 20 (statement -> assignment_compound .)
    TRUE            reduce using rule 20 (statement -> assignment_compound .)
    FALSE           reduce using rule 20 (statement -> assignment_compound .)
    STRING          reduce using rule 20 (statement -> assignment_compound .)
    RETURN          reduce using rule 20 (statement -> assignment_compound .)
    IF              reduce using rule 20 (statement -> assignment_compound .)
    SWITCH          reduce using rule 20 (statement -> assignment_compound .)
    BREAK           reduce using rule 20 (statement -> assignment_compound .)
    CONTINUE        reduce using rule 20 (statement -> assignment_compound .)
    LBRACKET        reduce using rule 20 (statement -> assignment_compound .)
    MAP             reduce using rule 20 (statement -> assignment_compound .)
    FOR             reduce using rule 20 (statement -> assignment_compound .)
    RBRACE          reduce using rule 20 (statement -> assignment_compound .)
    CASE            reduce using rule 20 (statement -> assignment_compound .)
    DEFAULT         reduce using rule 20 (statement -> assignment_compound .)


state 203

    (21) statement -> variable_declaration .

    IDENTIFIER      reduce using rule 21 (statement -> variable_declaration .)
    VAR             reduce using rule 21 (statement -> variable_declaration .)
    CONST           reduce using rule 21 (statement -> variable_declaration .)
    LPAREN          reduce using rule 21 (statement -> variable_declaration .)
    PLUS            reduce using rule 21 (statement -> variable_declaration .)
    MINUS           reduce using rule 21 (statement -> variable_declaration .)
    LNOT            reduce using rule 21 (statement -> variable_declaration .)
    INT             reduce using rule 21 (statement -> variable_declaration .)
    FLOAT64         reduce using rule 21 (statement -> variable_declaration .)
    TRUE            reduce using rule 21 (statement -> variable_declaration .)
    FALSE           reduce using rule 21 (statement -> variable_declaration .)
    STRING          reduce using rule 21 (statement -> variable_declaration .)
    RETURN          reduce using rule 21 (statement -> variable_declaration .)
    IF              reduce using rule 21 (statement -> variable_declaration .)
    SWITCH          reduce using rule 21 (statement -> variable_declaration .)
    BREAK           reduce using rule 21 (statement -> variable_declaration .)
    CONTINUE        reduce using rule 21 (statement -> variable_declaration .)
    LBRACKET        reduce using rule 21 (statement -> variable_declaration .)
    MAP             reduce using rule 21 (statement -> variable_declaration .)
    FOR             reduce using rule 21 (statement -> variable_declaration .)
    RBRACE          reduce using rule 21 (statement -> variable_declaration .)
    CASE            reduce using rule 21 (statement -> variable_declaration .)
    DEFAULT         reduce using rule 21 (statement -> variable_declaration .)


state 204

    (22) statement -> expression .
    (175) binary_expression -> expression . PLUS expression
    (176) binary_expression -> expression . MINUS expression
    (177) binary_expression -> expression . TIMES expression
    (178) binary_expression -> expression . DIVIDE expression
    (179) binary_expression -> expression . MODULE expression
    (184) relational_expression -> expression . EQ expression
    (185) relational_expression -> expression . NEQ expression
    (186) relational_expression -> expression . LT expression
    (187) relational_expression -> expression . LE expression
    (188) relational_expression -> expression . GT expression
    (189) relational_expression -> expression . GE expression
    (190) logical_expression -> expression . LAND expression
    (191) logical_expression -> expression . LOR expression
    (192) bitwise_expression -> expression . AND expression
    (193) bitwise_expression -> expression . OR expression
    (194) bitwise_expression -> expression . XOR expression
    (195) bitwise_expression -> expression . AND_NOT expression
    (196) bitwise_expression -> expression . LSHIFT expression
    (197) bitwise_expression -> expression . RSHIFT expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    IDENTIFIER      reduce using rule 22 (statement -> expression .)
    VAR             reduce using rule 22 (statement -> expression .)
    CONST           reduce using rule 22 (statement -> expression .)
    LPAREN          reduce using rule 22 (statement -> expression .)
    LNOT            reduce using rule 22 (statement -> expression .)
    INT             reduce using rule 22 (statement -> expression .)
    FLOAT64         reduce using rule 22 (statement -> expression .)
    TRUE            reduce using rule 22 (statement -> expression .)
    FALSE           reduce using rule 22 (statement -> expression .)
    STRING          reduce using rule 22 (statement -> expression .)
    RETURN          reduce using rule 22 (statement -> expression .)
    IF              reduce using rule 22 (statement -> expression .)
    SWITCH          reduce using rule 22 (statement -> expression .)
    BREAK           reduce using rule 22 (statement -> expression .)
    CONTINUE        reduce using rule 22 (statement -> expression .)
    LBRACKET        reduce using rule 22 (statement -> expression .)
    MAP             reduce using rule 22 (statement -> expression .)
    FOR             reduce using rule 22 (statement -> expression .)
    RBRACE          reduce using rule 22 (statement -> expression .)
    CASE            reduce using rule 22 (statement -> expression .)
    DEFAULT         reduce using rule 22 (statement -> expression .)
    PLUS            shift and go to state 86
    MINUS           shift and go to state 87
    TIMES           shift and go to state 88
    DIVIDE          shift and go to state 89
    MODULE          shift and go to state 90
    EQ              shift and go to state 91
    NEQ             shift and go to state 92
    LT              shift and go to state 93
    LE              shift and go to state 94
    GT              shift and go to state 95
    GE              shift and go to state 96
    LAND            shift and go to state 97
    LOR             shift and go to state 98
    AND             shift and go to state 99
    OR              shift and go to state 100
    XOR             shift and go to state 101
    AND_NOT         shift and go to state 102
    LSHIFT          shift and go to state 103
    RSHIFT          shift and go to state 104

  ! PLUS            [ reduce using rule 22 (statement -> expression .) ]
  ! MINUS           [ reduce using rule 22 (statement -> expression .) ]


state 205

    (23) statement -> return_statement .

    IDENTIFIER      reduce using rule 23 (statement -> return_statement .)
    VAR             reduce using rule 23 (statement -> return_statement .)
    CONST           reduce using rule 23 (statement -> return_statement .)
    LPAREN          reduce using rule 23 (statement -> return_statement .)
    PLUS            reduce using rule 23 (statement -> return_statement .)
    MINUS           reduce using rule 23 (statement -> return_statement .)
    LNOT            reduce using rule 23 (statement -> return_statement .)
    INT             reduce using rule 23 (statement -> return_statement .)
    FLOAT64         reduce using rule 23 (statement -> return_statement .)
    TRUE            reduce using rule 23 (statement -> return_statement .)
    FALSE           reduce using rule 23 (statement -> return_statement .)
    STRING          reduce using rule 23 (statement -> return_statement .)
    RETURN          reduce using rule 23 (statement -> return_statement .)
    IF              reduce using rule 23 (statement -> return_statement .)
    SWITCH          reduce using rule 23 (statement -> return_statement .)
    BREAK           reduce using rule 23 (statement -> return_statement .)
    CONTINUE        reduce using rule 23 (statement -> return_statement .)
    LBRACKET        reduce using rule 23 (statement -> return_statement .)
    MAP             reduce using rule 23 (statement -> return_statement .)
    FOR             reduce using rule 23 (statement -> return_statement .)
    RBRACE          reduce using rule 23 (statement -> return_statement .)
    CASE            reduce using rule 23 (statement -> return_statement .)
    DEFAULT         reduce using rule 23 (statement -> return_statement .)


state 206

    (24) statement -> for_statement .

    IDENTIFIER      reduce using rule 24 (statement -> for_statement .)
    VAR             reduce using rule 24 (statement -> for_statement .)
    CONST           reduce using rule 24 (statement -> for_statement .)
    LPAREN          reduce using rule 24 (statement -> for_statement .)
    PLUS            reduce using rule 24 (statement -> for_statement .)
    MINUS           reduce using rule 24 (statement -> for_statement .)
    LNOT            reduce using rule 24 (statement -> for_statement .)
    INT             reduce using rule 24 (statement -> for_statement .)
    FLOAT64         reduce using rule 24 (statement -> for_statement .)
    TRUE            reduce using rule 24 (statement -> for_statement .)
    FALSE           reduce using rule 24 (statement -> for_statement .)
    STRING          reduce using rule 24 (statement -> for_statement .)
    RETURN          reduce using rule 24 (statement -> for_statement .)
    IF              reduce using rule 24 (statement -> for_statement .)
    SWITCH          reduce using rule 24 (statement -> for_statement .)
    BREAK           reduce using rule 24 (statement -> for_statement .)
    CONTINUE        reduce using rule 24 (statement -> for_statement .)
    LBRACKET        reduce using rule 24 (statement -> for_statement .)
    MAP             reduce using rule 24 (statement -> for_statement .)
    FOR             reduce using rule 24 (statement -> for_statement .)
    RBRACE          reduce using rule 24 (statement -> for_statement .)
    CASE            reduce using rule 24 (statement -> for_statement .)
    DEFAULT         reduce using rule 24 (statement -> for_statement .)


state 207

    (25) statement -> if_statement .

    IDENTIFIER      reduce using rule 25 (statement -> if_statement .)
    VAR             reduce using rule 25 (statement -> if_statement .)
    CONST           reduce using rule 25 (statement -> if_statement .)
    LPAREN          reduce using rule 25 (statement -> if_statement .)
    PLUS            reduce using rule 25 (statement -> if_statement .)
    MINUS           reduce using rule 25 (statement -> if_statement .)
    LNOT            reduce using rule 25 (statement -> if_statement .)
    INT             reduce using rule 25 (statement -> if_statement .)
    FLOAT64         reduce using rule 25 (statement -> if_statement .)
    TRUE            reduce using rule 25 (statement -> if_statement .)
    FALSE           reduce using rule 25 (statement -> if_statement .)
    STRING          reduce using rule 25 (statement -> if_statement .)
    RETURN          reduce using rule 25 (statement -> if_statement .)
    IF              reduce using rule 25 (statement -> if_statement .)
    SWITCH          reduce using rule 25 (statement -> if_statement .)
    BREAK           reduce using rule 25 (statement -> if_statement .)
    CONTINUE        reduce using rule 25 (statement -> if_statement .)
    LBRACKET        reduce using rule 25 (statement -> if_statement .)
    MAP             reduce using rule 25 (statement -> if_statement .)
    FOR             reduce using rule 25 (statement -> if_statement .)
    RBRACE          reduce using rule 25 (statement -> if_statement .)
    CASE            reduce using rule 25 (statement -> if_statement .)
    DEFAULT         reduce using rule 25 (statement -> if_statement .)


state 208

    (26) statement -> switch_statement .

    IDENTIFIER      reduce using rule 26 (statement -> switch_statement .)
    VAR             reduce using rule 26 (statement -> switch_statement .)
    CONST           reduce using rule 26 (statement -> switch_statement .)
    LPAREN          reduce using rule 26 (statement -> switch_statement .)
    PLUS            reduce using rule 26 (statement -> switch_statement .)
    MINUS           reduce using rule 26 (statement -> switch_statement .)
    LNOT            reduce using rule 26 (statement -> switch_statement .)
    INT             reduce using rule 26 (statement -> switch_statement .)
    FLOAT64         reduce using rule 26 (statement -> switch_statement .)
    TRUE            reduce using rule 26 (statement -> switch_statement .)
    FALSE           reduce using rule 26 (statement -> switch_statement .)
    STRING          reduce using rule 26 (statement -> switch_statement .)
    RETURN          reduce using rule 26 (statement -> switch_statement .)
    IF              reduce using rule 26 (statement -> switch_statement .)
    SWITCH          reduce using rule 26 (statement -> switch_statement .)
    BREAK           reduce using rule 26 (statement -> switch_statement .)
    CONTINUE        reduce using rule 26 (statement -> switch_statement .)
    LBRACKET        reduce using rule 26 (statement -> switch_statement .)
    MAP             reduce using rule 26 (statement -> switch_statement .)
    FOR             reduce using rule 26 (statement -> switch_statement .)
    RBRACE          reduce using rule 26 (statement -> switch_statement .)
    CASE            reduce using rule 26 (statement -> switch_statement .)
    DEFAULT         reduce using rule 26 (statement -> switch_statement .)


state 209

    (27) statement -> break_statement .

    IDENTIFIER      reduce using rule 27 (statement -> break_statement .)
    VAR             reduce using rule 27 (statement -> break_statement .)
    CONST           reduce using rule 27 (statement -> break_statement .)
    LPAREN          reduce using rule 27 (statement -> break_statement .)
    PLUS            reduce using rule 27 (statement -> break_statement .)
    MINUS           reduce using rule 27 (statement -> break_statement .)
    LNOT            reduce using rule 27 (statement -> break_statement .)
    INT             reduce using rule 27 (statement -> break_statement .)
    FLOAT64         reduce using rule 27 (statement -> break_statement .)
    TRUE            reduce using rule 27 (statement -> break_statement .)
    FALSE           reduce using rule 27 (statement -> break_statement .)
    STRING          reduce using rule 27 (statement -> break_statement .)
    RETURN          reduce using rule 27 (statement -> break_statement .)
    IF              reduce using rule 27 (statement -> break_statement .)
    SWITCH          reduce using rule 27 (statement -> break_statement .)
    BREAK           reduce using rule 27 (statement -> break_statement .)
    CONTINUE        reduce using rule 27 (statement -> break_statement .)
    LBRACKET        reduce using rule 27 (statement -> break_statement .)
    MAP             reduce using rule 27 (statement -> break_statement .)
    FOR             reduce using rule 27 (statement -> break_statement .)
    RBRACE          reduce using rule 27 (statement -> break_statement .)
    CASE            reduce using rule 27 (statement -> break_statement .)
    DEFAULT         reduce using rule 27 (statement -> break_statement .)


state 210

    (28) statement -> continue_statement .

    IDENTIFIER      reduce using rule 28 (statement -> continue_statement .)
    VAR             reduce using rule 28 (statement -> continue_statement .)
    CONST           reduce using rule 28 (statement -> continue_statement .)
    LPAREN          reduce using rule 28 (statement -> continue_statement .)
    PLUS            reduce using rule 28 (statement -> continue_statement .)
    MINUS           reduce using rule 28 (statement -> continue_statement .)
    LNOT            reduce using rule 28 (statement -> continue_statement .)
    INT             reduce using rule 28 (statement -> continue_statement .)
    FLOAT64         reduce using rule 28 (statement -> continue_statement .)
    TRUE            reduce using rule 28 (statement -> continue_statement .)
    FALSE           reduce using rule 28 (statement -> continue_statement .)
    STRING          reduce using rule 28 (statement -> continue_statement .)
    RETURN          reduce using rule 28 (statement -> continue_statement .)
    IF              reduce using rule 28 (statement -> continue_statement .)
    SWITCH          reduce using rule 28 (statement -> continue_statement .)
    BREAK           reduce using rule 28 (statement -> continue_statement .)
    CONTINUE        reduce using rule 28 (statement -> continue_statement .)
    LBRACKET        reduce using rule 28 (statement -> continue_statement .)
    MAP             reduce using rule 28 (statement -> continue_statement .)
    FOR             reduce using rule 28 (statement -> continue_statement .)
    RBRACE          reduce using rule 28 (statement -> continue_statement .)
    CASE            reduce using rule 28 (statement -> continue_statement .)
    DEFAULT         reduce using rule 28 (statement -> continue_statement .)


state 211

    (29) statement -> call_expression .

    IDENTIFIER      reduce using rule 29 (statement -> call_expression .)
    VAR             reduce using rule 29 (statement -> call_expression .)
    CONST           reduce using rule 29 (statement -> call_expression .)
    LPAREN          reduce using rule 29 (statement -> call_expression .)
    PLUS            reduce using rule 29 (statement -> call_expression .)
    MINUS           reduce using rule 29 (statement -> call_expression .)
    LNOT            reduce using rule 29 (statement -> call_expression .)
    INT             reduce using rule 29 (statement -> call_expression .)
    FLOAT64         reduce using rule 29 (statement -> call_expression .)
    TRUE            reduce using rule 29 (statement -> call_expression .)
    FALSE           reduce using rule 29 (statement -> call_expression .)
    STRING          reduce using rule 29 (statement -> call_expression .)
    RETURN          reduce using rule 29 (statement -> call_expression .)
    IF              reduce using rule 29 (statement -> call_expression .)
    SWITCH          reduce using rule 29 (statement -> call_expression .)
    BREAK           reduce using rule 29 (statement -> call_expression .)
    CONTINUE        reduce using rule 29 (statement -> call_expression .)
    LBRACKET        reduce using rule 29 (statement -> call_expression .)
    MAP             reduce using rule 29 (statement -> call_expression .)
    FOR             reduce using rule 29 (statement -> call_expression .)
    RBRACE          reduce using rule 29 (statement -> call_expression .)
    CASE            reduce using rule 29 (statement -> call_expression .)
    DEFAULT         reduce using rule 29 (statement -> call_expression .)


state 212

    (109) assignment -> IDENTIFIER . ASSIGN expression
    (110) assignment -> IDENTIFIER . SHORT_ASSIGN expression
    (40) assignment_compound -> IDENTIFIER . operator_assign expression
    (131) expression -> IDENTIFIER .
    (133) expression -> IDENTIFIER . PLUSPLUS
    (134) expression -> IDENTIFIER . MINUSMINUS
    (171) type_name -> IDENTIFIER .
    (229) print_expression -> IDENTIFIER . DOT IDENTIFIER LPAREN argument_list RPAREN
    (230) input_expression -> IDENTIFIER . DOT IDENTIFIER LPAREN AND IDENTIFIER COMMA argument_list RPAREN
    (201) func_call_expression -> IDENTIFIER . LPAREN argument_list RPAREN
    (41) operator_assign -> . PLUS_ASSIGN
    (42) operator_assign -> . MINUS_ASSIGN
    (43) operator_assign -> . MULT_ASSIGN
    (44) operator_assign -> . DIV_ASSIGN
    (45) operator_assign -> . MOD_ASSIGN
    (46) operator_assign -> . AND_ASSIGN
    (47) operator_assign -> . OR_ASSIGN
    (48) operator_assign -> . XOR_ASSIGN
    (49) operator_assign -> . LSHIFT_ASSIGN
    (50) operator_assign -> . RSHIFT_ASSIGN

  ! shift/reduce conflict for LPAREN resolved as shift
    ASSIGN          shift and go to state 231
    SHORT_ASSIGN    shift and go to state 232
    PLUS            reduce using rule 131 (expression -> IDENTIFIER .)
    MINUS           reduce using rule 131 (expression -> IDENTIFIER .)
    TIMES           reduce using rule 131 (expression -> IDENTIFIER .)
    DIVIDE          reduce using rule 131 (expression -> IDENTIFIER .)
    MODULE          reduce using rule 131 (expression -> IDENTIFIER .)
    EQ              reduce using rule 131 (expression -> IDENTIFIER .)
    NEQ             reduce using rule 131 (expression -> IDENTIFIER .)
    LT              reduce using rule 131 (expression -> IDENTIFIER .)
    LE              reduce using rule 131 (expression -> IDENTIFIER .)
    GT              reduce using rule 131 (expression -> IDENTIFIER .)
    GE              reduce using rule 131 (expression -> IDENTIFIER .)
    LAND            reduce using rule 131 (expression -> IDENTIFIER .)
    LOR             reduce using rule 131 (expression -> IDENTIFIER .)
    AND             reduce using rule 131 (expression -> IDENTIFIER .)
    OR              reduce using rule 131 (expression -> IDENTIFIER .)
    XOR             reduce using rule 131 (expression -> IDENTIFIER .)
    AND_NOT         reduce using rule 131 (expression -> IDENTIFIER .)
    LSHIFT          reduce using rule 131 (expression -> IDENTIFIER .)
    RSHIFT          reduce using rule 131 (expression -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 131 (expression -> IDENTIFIER .)
    VAR             reduce using rule 131 (expression -> IDENTIFIER .)
    CONST           reduce using rule 131 (expression -> IDENTIFIER .)
    LNOT            reduce using rule 131 (expression -> IDENTIFIER .)
    INT             reduce using rule 131 (expression -> IDENTIFIER .)
    FLOAT64         reduce using rule 131 (expression -> IDENTIFIER .)
    TRUE            reduce using rule 131 (expression -> IDENTIFIER .)
    FALSE           reduce using rule 131 (expression -> IDENTIFIER .)
    STRING          reduce using rule 131 (expression -> IDENTIFIER .)
    RETURN          reduce using rule 131 (expression -> IDENTIFIER .)
    IF              reduce using rule 131 (expression -> IDENTIFIER .)
    SWITCH          reduce using rule 131 (expression -> IDENTIFIER .)
    BREAK           reduce using rule 131 (expression -> IDENTIFIER .)
    CONTINUE        reduce using rule 131 (expression -> IDENTIFIER .)
    LBRACKET        reduce using rule 131 (expression -> IDENTIFIER .)
    MAP             reduce using rule 131 (expression -> IDENTIFIER .)
    FOR             reduce using rule 131 (expression -> IDENTIFIER .)
    RBRACE          reduce using rule 131 (expression -> IDENTIFIER .)
    CASE            reduce using rule 131 (expression -> IDENTIFIER .)
    DEFAULT         reduce using rule 131 (expression -> IDENTIFIER .)
    PLUSPLUS        shift and go to state 84
    MINUSMINUS      shift and go to state 85
    LBRACE          reduce using rule 171 (type_name -> IDENTIFIER .)
    DOT             shift and go to state 234
    LPAREN          shift and go to state 235
    PLUS_ASSIGN     shift and go to state 236
    MINUS_ASSIGN    shift and go to state 237
    MULT_ASSIGN     shift and go to state 238
    DIV_ASSIGN      shift and go to state 239
    MOD_ASSIGN      shift and go to state 240
    AND_ASSIGN      shift and go to state 241
    OR_ASSIGN       shift and go to state 242
    XOR_ASSIGN      shift and go to state 243
    LSHIFT_ASSIGN   shift and go to state 244
    RSHIFT_ASSIGN   shift and go to state 245

  ! LPAREN          [ reduce using rule 131 (expression -> IDENTIFIER .) ]

    operator_assign                shift and go to state 233

state 213

    (111) variable_declaration -> VAR . IDENTIFIER type ASSIGN expression
    (113) variable_declaration -> VAR . IDENTIFIER ASSIGN expression

    IDENTIFIER      shift and go to state 246


state 214

    (112) variable_declaration -> CONST . IDENTIFIER type ASSIGN expression
    (114) variable_declaration -> CONST . IDENTIFIER ASSIGN expression

    IDENTIFIER      shift and go to state 247


state 215

    (105) return_statement -> RETURN .
    (106) return_statement -> RETURN . return_list
    (94) return_list -> . expression
    (95) return_list -> . return_list COMMA expression
    (57) expression -> . slice_type LBRACE expression_list RBRACE
    (58) expression -> . slice_type LBRACE RBRACE
    (61) expression -> . LPAREN expression RPAREN
    (120) expression -> . binary_expression
    (121) expression -> . relational_expression
    (122) expression -> . logical_expression
    (123) expression -> . bitwise_expression
    (124) expression -> . PLUS expression
    (125) expression -> . MINUS expression
    (126) expression -> . LNOT expression
    (127) expression -> . INT
    (128) expression -> . FLOAT64
    (129) expression -> . TRUE
    (130) expression -> . FALSE
    (131) expression -> . IDENTIFIER
    (132) expression -> . STRING
    (133) expression -> . IDENTIFIER PLUSPLUS
    (134) expression -> . IDENTIFIER MINUSMINUS
    (145) expression -> . map_type LBRACE expression_map_list RBRACE
    (146) expression -> . map_type LBRACE RBRACE
    (169) expression -> . type_name LBRACE keyed_element_list RBRACE
    (170) expression -> . type_name LBRACE RBRACE
    (56) slice_type -> . LBRACKET RBRACKET primitive_type
    (175) binary_expression -> . expression PLUS expression
    (176) binary_expression -> . expression MINUS expression
    (177) binary_expression -> . expression TIMES expression
    (178) binary_expression -> . expression DIVIDE expression
    (179) binary_expression -> . expression MODULE expression
    (184) relational_expression -> . expression EQ expression
    (185) relational_expression -> . expression NEQ expression
    (186) relational_expression -> . expression LT expression
    (187) relational_expression -> . expression LE expression
    (188) relational_expression -> . expression GT expression
    (189) relational_expression -> . expression GE expression
    (190) logical_expression -> . expression LAND expression
    (191) logical_expression -> . expression LOR expression
    (192) bitwise_expression -> . expression AND expression
    (193) bitwise_expression -> . expression OR expression
    (194) bitwise_expression -> . expression XOR expression
    (195) bitwise_expression -> . expression AND_NOT expression
    (196) bitwise_expression -> . expression LSHIFT expression
    (197) bitwise_expression -> . expression RSHIFT expression
    (144) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (171) type_name -> . IDENTIFIER
    (172) type_name -> . slice_type
    (173) type_name -> . array_type
    (174) type_name -> . map_type
    (119) array_type -> . LBRACKET INT RBRACKET type

  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for LNOT resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT64 resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for MAP resolved as shift
    VAR             reduce using rule 105 (return_statement -> RETURN .)
    CONST           reduce using rule 105 (return_statement -> RETURN .)
    RETURN          reduce using rule 105 (return_statement -> RETURN .)
    IF              reduce using rule 105 (return_statement -> RETURN .)
    SWITCH          reduce using rule 105 (return_statement -> RETURN .)
    BREAK           reduce using rule 105 (return_statement -> RETURN .)
    CONTINUE        reduce using rule 105 (return_statement -> RETURN .)
    FOR             reduce using rule 105 (return_statement -> RETURN .)
    RBRACE          reduce using rule 105 (return_statement -> RETURN .)
    CASE            reduce using rule 105 (return_statement -> RETURN .)
    DEFAULT         reduce using rule 105 (return_statement -> RETURN .)
    LPAREN          shift and go to state 54
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    LNOT            shift and go to state 61
    INT             shift and go to state 62
    FLOAT64         shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 66
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

  ! IDENTIFIER      [ reduce using rule 105 (return_statement -> RETURN .) ]
  ! LPAREN          [ reduce using rule 105 (return_statement -> RETURN .) ]
  ! PLUS            [ reduce using rule 105 (return_statement -> RETURN .) ]
  ! MINUS           [ reduce using rule 105 (return_statement -> RETURN .) ]
  ! LNOT            [ reduce using rule 105 (return_statement -> RETURN .) ]
  ! INT             [ reduce using rule 105 (return_statement -> RETURN .) ]
  ! FLOAT64         [ reduce using rule 105 (return_statement -> RETURN .) ]
  ! TRUE            [ reduce using rule 105 (return_statement -> RETURN .) ]
  ! FALSE           [ reduce using rule 105 (return_statement -> RETURN .) ]
  ! STRING          [ reduce using rule 105 (return_statement -> RETURN .) ]
  ! LBRACKET        [ reduce using rule 105 (return_statement -> RETURN .) ]
  ! MAP             [ reduce using rule 105 (return_statement -> RETURN .) ]

    return_list                    shift and go to state 248
    expression                     shift and go to state 249
    slice_type                     shift and go to state 53
    binary_expression              shift and go to state 55
    relational_expression          shift and go to state 56
    logical_expression             shift and go to state 57
    bitwise_expression             shift and go to state 58
    map_type                       shift and go to state 67
    type_name                      shift and go to state 68
    array_type                     shift and go to state 69

state 216

    (78) for_statement -> for_classic .

    IDENTIFIER      reduce using rule 78 (for_statement -> for_classic .)
    VAR             reduce using rule 78 (for_statement -> for_classic .)
    CONST           reduce using rule 78 (for_statement -> for_classic .)
    LPAREN          reduce using rule 78 (for_statement -> for_classic .)
    PLUS            reduce using rule 78 (for_statement -> for_classic .)
    MINUS           reduce using rule 78 (for_statement -> for_classic .)
    LNOT            reduce using rule 78 (for_statement -> for_classic .)
    INT             reduce using rule 78 (for_statement -> for_classic .)
    FLOAT64         reduce using rule 78 (for_statement -> for_classic .)
    TRUE            reduce using rule 78 (for_statement -> for_classic .)
    FALSE           reduce using rule 78 (for_statement -> for_classic .)
    STRING          reduce using rule 78 (for_statement -> for_classic .)
    RETURN          reduce using rule 78 (for_statement -> for_classic .)
    IF              reduce using rule 78 (for_statement -> for_classic .)
    SWITCH          reduce using rule 78 (for_statement -> for_classic .)
    BREAK           reduce using rule 78 (for_statement -> for_classic .)
    CONTINUE        reduce using rule 78 (for_statement -> for_classic .)
    LBRACKET        reduce using rule 78 (for_statement -> for_classic .)
    MAP             reduce using rule 78 (for_statement -> for_classic .)
    FOR             reduce using rule 78 (for_statement -> for_classic .)
    RBRACE          reduce using rule 78 (for_statement -> for_classic .)
    CASE            reduce using rule 78 (for_statement -> for_classic .)
    DEFAULT         reduce using rule 78 (for_statement -> for_classic .)


state 217

    (79) for_statement -> for_condition .

    IDENTIFIER      reduce using rule 79 (for_statement -> for_condition .)
    VAR             reduce using rule 79 (for_statement -> for_condition .)
    CONST           reduce using rule 79 (for_statement -> for_condition .)
    LPAREN          reduce using rule 79 (for_statement -> for_condition .)
    PLUS            reduce using rule 79 (for_statement -> for_condition .)
    MINUS           reduce using rule 79 (for_statement -> for_condition .)
    LNOT            reduce using rule 79 (for_statement -> for_condition .)
    INT             reduce using rule 79 (for_statement -> for_condition .)
    FLOAT64         reduce using rule 79 (for_statement -> for_condition .)
    TRUE            reduce using rule 79 (for_statement -> for_condition .)
    FALSE           reduce using rule 79 (for_statement -> for_condition .)
    STRING          reduce using rule 79 (for_statement -> for_condition .)
    RETURN          reduce using rule 79 (for_statement -> for_condition .)
    IF              reduce using rule 79 (for_statement -> for_condition .)
    SWITCH          reduce using rule 79 (for_statement -> for_condition .)
    BREAK           reduce using rule 79 (for_statement -> for_condition .)
    CONTINUE        reduce using rule 79 (for_statement -> for_condition .)
    LBRACKET        reduce using rule 79 (for_statement -> for_condition .)
    MAP             reduce using rule 79 (for_statement -> for_condition .)
    FOR             reduce using rule 79 (for_statement -> for_condition .)
    RBRACE          reduce using rule 79 (for_statement -> for_condition .)
    CASE            reduce using rule 79 (for_statement -> for_condition .)
    DEFAULT         reduce using rule 79 (for_statement -> for_condition .)


state 218

    (80) for_statement -> for_infinite .

    IDENTIFIER      reduce using rule 80 (for_statement -> for_infinite .)
    VAR             reduce using rule 80 (for_statement -> for_infinite .)
    CONST           reduce using rule 80 (for_statement -> for_infinite .)
    LPAREN          reduce using rule 80 (for_statement -> for_infinite .)
    PLUS            reduce using rule 80 (for_statement -> for_infinite .)
    MINUS           reduce using rule 80 (for_statement -> for_infinite .)
    LNOT            reduce using rule 80 (for_statement -> for_infinite .)
    INT             reduce using rule 80 (for_statement -> for_infinite .)
    FLOAT64         reduce using rule 80 (for_statement -> for_infinite .)
    TRUE            reduce using rule 80 (for_statement -> for_infinite .)
    FALSE           reduce using rule 80 (for_statement -> for_infinite .)
    STRING          reduce using rule 80 (for_statement -> for_infinite .)
    RETURN          reduce using rule 80 (for_statement -> for_infinite .)
    IF              reduce using rule 80 (for_statement -> for_infinite .)
    SWITCH          reduce using rule 80 (for_statement -> for_infinite .)
    BREAK           reduce using rule 80 (for_statement -> for_infinite .)
    CONTINUE        reduce using rule 80 (for_statement -> for_infinite .)
    LBRACKET        reduce using rule 80 (for_statement -> for_infinite .)
    MAP             reduce using rule 80 (for_statement -> for_infinite .)
    FOR             reduce using rule 80 (for_statement -> for_infinite .)
    RBRACE          reduce using rule 80 (for_statement -> for_infinite .)
    CASE            reduce using rule 80 (for_statement -> for_infinite .)
    DEFAULT         reduce using rule 80 (for_statement -> for_infinite .)


state 219

    (135) if_statement -> IF . expression block
    (136) if_statement -> IF . expression block ELSE block
    (137) if_statement -> IF . expression block ELSE if_statement
    (138) if_statement -> IF . if_assignment SEMICOLON expression block
    (139) if_statement -> IF . if_assignment SEMICOLON expression block ELSE block
    (140) if_statement -> IF . if_assignment SEMICOLON expression block ELSE if_statement
    (57) expression -> . slice_type LBRACE expression_list RBRACE
    (58) expression -> . slice_type LBRACE RBRACE
    (61) expression -> . LPAREN expression RPAREN
    (120) expression -> . binary_expression
    (121) expression -> . relational_expression
    (122) expression -> . logical_expression
    (123) expression -> . bitwise_expression
    (124) expression -> . PLUS expression
    (125) expression -> . MINUS expression
    (126) expression -> . LNOT expression
    (127) expression -> . INT
    (128) expression -> . FLOAT64
    (129) expression -> . TRUE
    (130) expression -> . FALSE
    (131) expression -> . IDENTIFIER
    (132) expression -> . STRING
    (133) expression -> . IDENTIFIER PLUSPLUS
    (134) expression -> . IDENTIFIER MINUSMINUS
    (145) expression -> . map_type LBRACE expression_map_list RBRACE
    (146) expression -> . map_type LBRACE RBRACE
    (169) expression -> . type_name LBRACE keyed_element_list RBRACE
    (170) expression -> . type_name LBRACE RBRACE
    (141) if_assignment -> . simple_assignment
    (142) if_assignment -> . short_assignment
    (143) if_assignment -> . local_var_dec
    (56) slice_type -> . LBRACKET RBRACKET primitive_type
    (175) binary_expression -> . expression PLUS expression
    (176) binary_expression -> . expression MINUS expression
    (177) binary_expression -> . expression TIMES expression
    (178) binary_expression -> . expression DIVIDE expression
    (179) binary_expression -> . expression MODULE expression
    (184) relational_expression -> . expression EQ expression
    (185) relational_expression -> . expression NEQ expression
    (186) relational_expression -> . expression LT expression
    (187) relational_expression -> . expression LE expression
    (188) relational_expression -> . expression GT expression
    (189) relational_expression -> . expression GE expression
    (190) logical_expression -> . expression LAND expression
    (191) logical_expression -> . expression LOR expression
    (192) bitwise_expression -> . expression AND expression
    (193) bitwise_expression -> . expression OR expression
    (194) bitwise_expression -> . expression XOR expression
    (195) bitwise_expression -> . expression AND_NOT expression
    (196) bitwise_expression -> . expression LSHIFT expression
    (197) bitwise_expression -> . expression RSHIFT expression
    (144) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (171) type_name -> . IDENTIFIER
    (172) type_name -> . slice_type
    (173) type_name -> . array_type
    (174) type_name -> . map_type
    (51) simple_assignment -> . IDENTIFIER ASSIGN expression
    (62) short_assignment -> . IDENTIFIER SHORT_ASSIGN expression
    (35) local_var_dec -> . VAR IDENTIFIER type
    (36) local_var_dec -> . VAR IDENTIFIER type ASSIGN expression
    (37) local_var_dec -> . VAR IDENTIFIER ASSIGN expression
    (119) array_type -> . LBRACKET INT RBRACKET type

    LPAREN          shift and go to state 54
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    LNOT            shift and go to state 61
    INT             shift and go to state 62
    FLOAT64         shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    IDENTIFIER      shift and go to state 252
    STRING          shift and go to state 66
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39
    VAR             shift and go to state 256

    expression                     shift and go to state 250
    if_assignment                  shift and go to state 251
    slice_type                     shift and go to state 53
    binary_expression              shift and go to state 55
    relational_expression          shift and go to state 56
    logical_expression             shift and go to state 57
    bitwise_expression             shift and go to state 58
    map_type                       shift and go to state 67
    type_name                      shift and go to state 68
    simple_assignment              shift and go to state 253
    short_assignment               shift and go to state 254
    local_var_dec                  shift and go to state 255
    array_type                     shift and go to state 69

state 220

    (228) switch_statement -> SWITCH . enter_block switch_header LBRACE case_clauses RBRACE exit_block
    (207) enter_block -> .

    IDENTIFIER      reduce using rule 207 (enter_block -> .)
    INT             reduce using rule 207 (enter_block -> .)
    FLOAT64         reduce using rule 207 (enter_block -> .)
    STRING          reduce using rule 207 (enter_block -> .)
    TRUE            reduce using rule 207 (enter_block -> .)
    FALSE           reduce using rule 207 (enter_block -> .)
    LBRACE          reduce using rule 207 (enter_block -> .)

    enter_block                    shift and go to state 257

state 221

    (74) break_statement -> BREAK .

    IDENTIFIER      reduce using rule 74 (break_statement -> BREAK .)
    VAR             reduce using rule 74 (break_statement -> BREAK .)
    CONST           reduce using rule 74 (break_statement -> BREAK .)
    LPAREN          reduce using rule 74 (break_statement -> BREAK .)
    PLUS            reduce using rule 74 (break_statement -> BREAK .)
    MINUS           reduce using rule 74 (break_statement -> BREAK .)
    LNOT            reduce using rule 74 (break_statement -> BREAK .)
    INT             reduce using rule 74 (break_statement -> BREAK .)
    FLOAT64         reduce using rule 74 (break_statement -> BREAK .)
    TRUE            reduce using rule 74 (break_statement -> BREAK .)
    FALSE           reduce using rule 74 (break_statement -> BREAK .)
    STRING          reduce using rule 74 (break_statement -> BREAK .)
    RETURN          reduce using rule 74 (break_statement -> BREAK .)
    IF              reduce using rule 74 (break_statement -> BREAK .)
    SWITCH          reduce using rule 74 (break_statement -> BREAK .)
    BREAK           reduce using rule 74 (break_statement -> BREAK .)
    CONTINUE        reduce using rule 74 (break_statement -> BREAK .)
    LBRACKET        reduce using rule 74 (break_statement -> BREAK .)
    MAP             reduce using rule 74 (break_statement -> BREAK .)
    FOR             reduce using rule 74 (break_statement -> BREAK .)
    RBRACE          reduce using rule 74 (break_statement -> BREAK .)
    CASE            reduce using rule 74 (break_statement -> BREAK .)
    DEFAULT         reduce using rule 74 (break_statement -> BREAK .)


state 222

    (75) continue_statement -> CONTINUE .

    IDENTIFIER      reduce using rule 75 (continue_statement -> CONTINUE .)
    VAR             reduce using rule 75 (continue_statement -> CONTINUE .)
    CONST           reduce using rule 75 (continue_statement -> CONTINUE .)
    LPAREN          reduce using rule 75 (continue_statement -> CONTINUE .)
    PLUS            reduce using rule 75 (continue_statement -> CONTINUE .)
    MINUS           reduce using rule 75 (continue_statement -> CONTINUE .)
    LNOT            reduce using rule 75 (continue_statement -> CONTINUE .)
    INT             reduce using rule 75 (continue_statement -> CONTINUE .)
    FLOAT64         reduce using rule 75 (continue_statement -> CONTINUE .)
    TRUE            reduce using rule 75 (continue_statement -> CONTINUE .)
    FALSE           reduce using rule 75 (continue_statement -> CONTINUE .)
    STRING          reduce using rule 75 (continue_statement -> CONTINUE .)
    RETURN          reduce using rule 75 (continue_statement -> CONTINUE .)
    IF              reduce using rule 75 (continue_statement -> CONTINUE .)
    SWITCH          reduce using rule 75 (continue_statement -> CONTINUE .)
    BREAK           reduce using rule 75 (continue_statement -> CONTINUE .)
    CONTINUE        reduce using rule 75 (continue_statement -> CONTINUE .)
    LBRACKET        reduce using rule 75 (continue_statement -> CONTINUE .)
    MAP             reduce using rule 75 (continue_statement -> CONTINUE .)
    FOR             reduce using rule 75 (continue_statement -> CONTINUE .)
    RBRACE          reduce using rule 75 (continue_statement -> CONTINUE .)
    CASE            reduce using rule 75 (continue_statement -> CONTINUE .)
    DEFAULT         reduce using rule 75 (continue_statement -> CONTINUE .)


state 223

    (202) call_expression -> print_expression .

    IDENTIFIER      reduce using rule 202 (call_expression -> print_expression .)
    VAR             reduce using rule 202 (call_expression -> print_expression .)
    CONST           reduce using rule 202 (call_expression -> print_expression .)
    LPAREN          reduce using rule 202 (call_expression -> print_expression .)
    PLUS            reduce using rule 202 (call_expression -> print_expression .)
    MINUS           reduce using rule 202 (call_expression -> print_expression .)
    LNOT            reduce using rule 202 (call_expression -> print_expression .)
    INT             reduce using rule 202 (call_expression -> print_expression .)
    FLOAT64         reduce using rule 202 (call_expression -> print_expression .)
    TRUE            reduce using rule 202 (call_expression -> print_expression .)
    FALSE           reduce using rule 202 (call_expression -> print_expression .)
    STRING          reduce using rule 202 (call_expression -> print_expression .)
    RETURN          reduce using rule 202 (call_expression -> print_expression .)
    IF              reduce using rule 202 (call_expression -> print_expression .)
    SWITCH          reduce using rule 202 (call_expression -> print_expression .)
    BREAK           reduce using rule 202 (call_expression -> print_expression .)
    CONTINUE        reduce using rule 202 (call_expression -> print_expression .)
    LBRACKET        reduce using rule 202 (call_expression -> print_expression .)
    MAP             reduce using rule 202 (call_expression -> print_expression .)
    FOR             reduce using rule 202 (call_expression -> print_expression .)
    RBRACE          reduce using rule 202 (call_expression -> print_expression .)
    CASE            reduce using rule 202 (call_expression -> print_expression .)
    DEFAULT         reduce using rule 202 (call_expression -> print_expression .)


state 224

    (203) call_expression -> input_expression .

    IDENTIFIER      reduce using rule 203 (call_expression -> input_expression .)
    VAR             reduce using rule 203 (call_expression -> input_expression .)
    CONST           reduce using rule 203 (call_expression -> input_expression .)
    LPAREN          reduce using rule 203 (call_expression -> input_expression .)
    PLUS            reduce using rule 203 (call_expression -> input_expression .)
    MINUS           reduce using rule 203 (call_expression -> input_expression .)
    LNOT            reduce using rule 203 (call_expression -> input_expression .)
    INT             reduce using rule 203 (call_expression -> input_expression .)
    FLOAT64         reduce using rule 203 (call_expression -> input_expression .)
    TRUE            reduce using rule 203 (call_expression -> input_expression .)
    FALSE           reduce using rule 203 (call_expression -> input_expression .)
    STRING          reduce using rule 203 (call_expression -> input_expression .)
    RETURN          reduce using rule 203 (call_expression -> input_expression .)
    IF              reduce using rule 203 (call_expression -> input_expression .)
    SWITCH          reduce using rule 203 (call_expression -> input_expression .)
    BREAK           reduce using rule 203 (call_expression -> input_expression .)
    CONTINUE        reduce using rule 203 (call_expression -> input_expression .)
    LBRACKET        reduce using rule 203 (call_expression -> input_expression .)
    MAP             reduce using rule 203 (call_expression -> input_expression .)
    FOR             reduce using rule 203 (call_expression -> input_expression .)
    RBRACE          reduce using rule 203 (call_expression -> input_expression .)
    CASE            reduce using rule 203 (call_expression -> input_expression .)
    DEFAULT         reduce using rule 203 (call_expression -> input_expression .)


state 225

    (204) call_expression -> func_call_expression .

    IDENTIFIER      reduce using rule 204 (call_expression -> func_call_expression .)
    VAR             reduce using rule 204 (call_expression -> func_call_expression .)
    CONST           reduce using rule 204 (call_expression -> func_call_expression .)
    LPAREN          reduce using rule 204 (call_expression -> func_call_expression .)
    PLUS            reduce using rule 204 (call_expression -> func_call_expression .)
    MINUS           reduce using rule 204 (call_expression -> func_call_expression .)
    LNOT            reduce using rule 204 (call_expression -> func_call_expression .)
    INT             reduce using rule 204 (call_expression -> func_call_expression .)
    FLOAT64         reduce using rule 204 (call_expression -> func_call_expression .)
    TRUE            reduce using rule 204 (call_expression -> func_call_expression .)
    FALSE           reduce using rule 204 (call_expression -> func_call_expression .)
    STRING          reduce using rule 204 (call_expression -> func_call_expression .)
    RETURN          reduce using rule 204 (call_expression -> func_call_expression .)
    IF              reduce using rule 204 (call_expression -> func_call_expression .)
    SWITCH          reduce using rule 204 (call_expression -> func_call_expression .)
    BREAK           reduce using rule 204 (call_expression -> func_call_expression .)
    CONTINUE        reduce using rule 204 (call_expression -> func_call_expression .)
    LBRACKET        reduce using rule 204 (call_expression -> func_call_expression .)
    MAP             reduce using rule 204 (call_expression -> func_call_expression .)
    FOR             reduce using rule 204 (call_expression -> func_call_expression .)
    RBRACE          reduce using rule 204 (call_expression -> func_call_expression .)
    CASE            reduce using rule 204 (call_expression -> func_call_expression .)
    DEFAULT         reduce using rule 204 (call_expression -> func_call_expression .)


state 226

    (81) for_classic -> FOR . for_init SEMICOLON for_cond SEMICOLON for_post block
    (82) for_condition -> FOR . expression block
    (83) for_infinite -> FOR . block
    (84) for_init -> . simple_assignment
    (85) for_init -> . short_assignment
    (86) for_init -> . local_var_dec
    (87) for_init -> . empty
    (57) expression -> . slice_type LBRACE expression_list RBRACE
    (58) expression -> . slice_type LBRACE RBRACE
    (61) expression -> . LPAREN expression RPAREN
    (120) expression -> . binary_expression
    (121) expression -> . relational_expression
    (122) expression -> . logical_expression
    (123) expression -> . bitwise_expression
    (124) expression -> . PLUS expression
    (125) expression -> . MINUS expression
    (126) expression -> . LNOT expression
    (127) expression -> . INT
    (128) expression -> . FLOAT64
    (129) expression -> . TRUE
    (130) expression -> . FALSE
    (131) expression -> . IDENTIFIER
    (132) expression -> . STRING
    (133) expression -> . IDENTIFIER PLUSPLUS
    (134) expression -> . IDENTIFIER MINUSMINUS
    (145) expression -> . map_type LBRACE expression_map_list RBRACE
    (146) expression -> . map_type LBRACE RBRACE
    (169) expression -> . type_name LBRACE keyed_element_list RBRACE
    (170) expression -> . type_name LBRACE RBRACE
    (15) block -> . LBRACE enter_block exit_block RBRACE
    (16) block -> . LBRACE enter_block statement_list exit_block RBRACE
    (51) simple_assignment -> . IDENTIFIER ASSIGN expression
    (62) short_assignment -> . IDENTIFIER SHORT_ASSIGN expression
    (35) local_var_dec -> . VAR IDENTIFIER type
    (36) local_var_dec -> . VAR IDENTIFIER type ASSIGN expression
    (37) local_var_dec -> . VAR IDENTIFIER ASSIGN expression
    (7) empty -> .
    (56) slice_type -> . LBRACKET RBRACKET primitive_type
    (175) binary_expression -> . expression PLUS expression
    (176) binary_expression -> . expression MINUS expression
    (177) binary_expression -> . expression TIMES expression
    (178) binary_expression -> . expression DIVIDE expression
    (179) binary_expression -> . expression MODULE expression
    (184) relational_expression -> . expression EQ expression
    (185) relational_expression -> . expression NEQ expression
    (186) relational_expression -> . expression LT expression
    (187) relational_expression -> . expression LE expression
    (188) relational_expression -> . expression GT expression
    (189) relational_expression -> . expression GE expression
    (190) logical_expression -> . expression LAND expression
    (191) logical_expression -> . expression LOR expression
    (192) bitwise_expression -> . expression AND expression
    (193) bitwise_expression -> . expression OR expression
    (194) bitwise_expression -> . expression XOR expression
    (195) bitwise_expression -> . expression AND_NOT expression
    (196) bitwise_expression -> . expression LSHIFT expression
    (197) bitwise_expression -> . expression RSHIFT expression
    (144) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (171) type_name -> . IDENTIFIER
    (172) type_name -> . slice_type
    (173) type_name -> . array_type
    (174) type_name -> . map_type
    (119) array_type -> . LBRACKET INT RBRACKET type

    LPAREN          shift and go to state 54
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    LNOT            shift and go to state 61
    INT             shift and go to state 62
    FLOAT64         shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    IDENTIFIER      shift and go to state 265
    STRING          shift and go to state 66
    LBRACE          shift and go to state 185
    VAR             shift and go to state 256
    SEMICOLON       reduce using rule 7 (empty -> .)
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    for_init                       shift and go to state 258
    block                          shift and go to state 259
    expression                     shift and go to state 260
    simple_assignment              shift and go to state 261
    short_assignment               shift and go to state 262
    local_var_dec                  shift and go to state 263
    empty                          shift and go to state 264
    slice_type                     shift and go to state 53
    binary_expression              shift and go to state 55
    relational_expression          shift and go to state 56
    logical_expression             shift and go to state 57
    bitwise_expression             shift and go to state 58
    map_type                       shift and go to state 67
    type_name                      shift and go to state 68
    array_type                     shift and go to state 69

state 227

    (154) method_declaration -> FUNC LPAREN receiver RPAREN IDENTIFIER LPAREN parameter_list RPAREN return_type . block
    (15) block -> . LBRACE enter_block exit_block RBRACE
    (16) block -> . LBRACE enter_block statement_list exit_block RBRACE

    LBRACE          shift and go to state 185

    block                          shift and go to state 266

state 228

    (15) block -> LBRACE enter_block exit_block RBRACE .

    VAR             reduce using rule 15 (block -> LBRACE enter_block exit_block RBRACE .)
    CONST           reduce using rule 15 (block -> LBRACE enter_block exit_block RBRACE .)
    FUNC            reduce using rule 15 (block -> LBRACE enter_block exit_block RBRACE .)
    TYPE            reduce using rule 15 (block -> LBRACE enter_block exit_block RBRACE .)
    $end            reduce using rule 15 (block -> LBRACE enter_block exit_block RBRACE .)
    IDENTIFIER      reduce using rule 15 (block -> LBRACE enter_block exit_block RBRACE .)
    LPAREN          reduce using rule 15 (block -> LBRACE enter_block exit_block RBRACE .)
    PLUS            reduce using rule 15 (block -> LBRACE enter_block exit_block RBRACE .)
    MINUS           reduce using rule 15 (block -> LBRACE enter_block exit_block RBRACE .)
    LNOT            reduce using rule 15 (block -> LBRACE enter_block exit_block RBRACE .)
    INT             reduce using rule 15 (block -> LBRACE enter_block exit_block RBRACE .)
    FLOAT64         reduce using rule 15 (block -> LBRACE enter_block exit_block RBRACE .)
    TRUE            reduce using rule 15 (block -> LBRACE enter_block exit_block RBRACE .)
    FALSE           reduce using rule 15 (block -> LBRACE enter_block exit_block RBRACE .)
    STRING          reduce using rule 15 (block -> LBRACE enter_block exit_block RBRACE .)
    RETURN          reduce using rule 15 (block -> LBRACE enter_block exit_block RBRACE .)
    IF              reduce using rule 15 (block -> LBRACE enter_block exit_block RBRACE .)
    SWITCH          reduce using rule 15 (block -> LBRACE enter_block exit_block RBRACE .)
    BREAK           reduce using rule 15 (block -> LBRACE enter_block exit_block RBRACE .)
    CONTINUE        reduce using rule 15 (block -> LBRACE enter_block exit_block RBRACE .)
    LBRACKET        reduce using rule 15 (block -> LBRACE enter_block exit_block RBRACE .)
    MAP             reduce using rule 15 (block -> LBRACE enter_block exit_block RBRACE .)
    FOR             reduce using rule 15 (block -> LBRACE enter_block exit_block RBRACE .)
    RBRACE          reduce using rule 15 (block -> LBRACE enter_block exit_block RBRACE .)
    CASE            reduce using rule 15 (block -> LBRACE enter_block exit_block RBRACE .)
    DEFAULT         reduce using rule 15 (block -> LBRACE enter_block exit_block RBRACE .)
    ELSE            reduce using rule 15 (block -> LBRACE enter_block exit_block RBRACE .)


state 229

    (16) block -> LBRACE enter_block statement_list exit_block . RBRACE

    RBRACE          shift and go to state 267


state 230

    (18) statement_list -> statement_list statement .

    IDENTIFIER      reduce using rule 18 (statement_list -> statement_list statement .)
    VAR             reduce using rule 18 (statement_list -> statement_list statement .)
    CONST           reduce using rule 18 (statement_list -> statement_list statement .)
    LPAREN          reduce using rule 18 (statement_list -> statement_list statement .)
    PLUS            reduce using rule 18 (statement_list -> statement_list statement .)
    MINUS           reduce using rule 18 (statement_list -> statement_list statement .)
    LNOT            reduce using rule 18 (statement_list -> statement_list statement .)
    INT             reduce using rule 18 (statement_list -> statement_list statement .)
    FLOAT64         reduce using rule 18 (statement_list -> statement_list statement .)
    TRUE            reduce using rule 18 (statement_list -> statement_list statement .)
    FALSE           reduce using rule 18 (statement_list -> statement_list statement .)
    STRING          reduce using rule 18 (statement_list -> statement_list statement .)
    RETURN          reduce using rule 18 (statement_list -> statement_list statement .)
    IF              reduce using rule 18 (statement_list -> statement_list statement .)
    SWITCH          reduce using rule 18 (statement_list -> statement_list statement .)
    BREAK           reduce using rule 18 (statement_list -> statement_list statement .)
    CONTINUE        reduce using rule 18 (statement_list -> statement_list statement .)
    LBRACKET        reduce using rule 18 (statement_list -> statement_list statement .)
    MAP             reduce using rule 18 (statement_list -> statement_list statement .)
    FOR             reduce using rule 18 (statement_list -> statement_list statement .)
    RBRACE          reduce using rule 18 (statement_list -> statement_list statement .)
    CASE            reduce using rule 18 (statement_list -> statement_list statement .)
    DEFAULT         reduce using rule 18 (statement_list -> statement_list statement .)


state 231

    (109) assignment -> IDENTIFIER ASSIGN . expression
    (57) expression -> . slice_type LBRACE expression_list RBRACE
    (58) expression -> . slice_type LBRACE RBRACE
    (61) expression -> . LPAREN expression RPAREN
    (120) expression -> . binary_expression
    (121) expression -> . relational_expression
    (122) expression -> . logical_expression
    (123) expression -> . bitwise_expression
    (124) expression -> . PLUS expression
    (125) expression -> . MINUS expression
    (126) expression -> . LNOT expression
    (127) expression -> . INT
    (128) expression -> . FLOAT64
    (129) expression -> . TRUE
    (130) expression -> . FALSE
    (131) expression -> . IDENTIFIER
    (132) expression -> . STRING
    (133) expression -> . IDENTIFIER PLUSPLUS
    (134) expression -> . IDENTIFIER MINUSMINUS
    (145) expression -> . map_type LBRACE expression_map_list RBRACE
    (146) expression -> . map_type LBRACE RBRACE
    (169) expression -> . type_name LBRACE keyed_element_list RBRACE
    (170) expression -> . type_name LBRACE RBRACE
    (56) slice_type -> . LBRACKET RBRACKET primitive_type
    (175) binary_expression -> . expression PLUS expression
    (176) binary_expression -> . expression MINUS expression
    (177) binary_expression -> . expression TIMES expression
    (178) binary_expression -> . expression DIVIDE expression
    (179) binary_expression -> . expression MODULE expression
    (184) relational_expression -> . expression EQ expression
    (185) relational_expression -> . expression NEQ expression
    (186) relational_expression -> . expression LT expression
    (187) relational_expression -> . expression LE expression
    (188) relational_expression -> . expression GT expression
    (189) relational_expression -> . expression GE expression
    (190) logical_expression -> . expression LAND expression
    (191) logical_expression -> . expression LOR expression
    (192) bitwise_expression -> . expression AND expression
    (193) bitwise_expression -> . expression OR expression
    (194) bitwise_expression -> . expression XOR expression
    (195) bitwise_expression -> . expression AND_NOT expression
    (196) bitwise_expression -> . expression LSHIFT expression
    (197) bitwise_expression -> . expression RSHIFT expression
    (144) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (171) type_name -> . IDENTIFIER
    (172) type_name -> . slice_type
    (173) type_name -> . array_type
    (174) type_name -> . map_type
    (119) array_type -> . LBRACKET INT RBRACKET type

    LPAREN          shift and go to state 54
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    LNOT            shift and go to state 61
    INT             shift and go to state 62
    FLOAT64         shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 66
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    expression                     shift and go to state 268
    slice_type                     shift and go to state 53
    binary_expression              shift and go to state 55
    relational_expression          shift and go to state 56
    logical_expression             shift and go to state 57
    bitwise_expression             shift and go to state 58
    map_type                       shift and go to state 67
    type_name                      shift and go to state 68
    array_type                     shift and go to state 69

state 232

    (110) assignment -> IDENTIFIER SHORT_ASSIGN . expression
    (57) expression -> . slice_type LBRACE expression_list RBRACE
    (58) expression -> . slice_type LBRACE RBRACE
    (61) expression -> . LPAREN expression RPAREN
    (120) expression -> . binary_expression
    (121) expression -> . relational_expression
    (122) expression -> . logical_expression
    (123) expression -> . bitwise_expression
    (124) expression -> . PLUS expression
    (125) expression -> . MINUS expression
    (126) expression -> . LNOT expression
    (127) expression -> . INT
    (128) expression -> . FLOAT64
    (129) expression -> . TRUE
    (130) expression -> . FALSE
    (131) expression -> . IDENTIFIER
    (132) expression -> . STRING
    (133) expression -> . IDENTIFIER PLUSPLUS
    (134) expression -> . IDENTIFIER MINUSMINUS
    (145) expression -> . map_type LBRACE expression_map_list RBRACE
    (146) expression -> . map_type LBRACE RBRACE
    (169) expression -> . type_name LBRACE keyed_element_list RBRACE
    (170) expression -> . type_name LBRACE RBRACE
    (56) slice_type -> . LBRACKET RBRACKET primitive_type
    (175) binary_expression -> . expression PLUS expression
    (176) binary_expression -> . expression MINUS expression
    (177) binary_expression -> . expression TIMES expression
    (178) binary_expression -> . expression DIVIDE expression
    (179) binary_expression -> . expression MODULE expression
    (184) relational_expression -> . expression EQ expression
    (185) relational_expression -> . expression NEQ expression
    (186) relational_expression -> . expression LT expression
    (187) relational_expression -> . expression LE expression
    (188) relational_expression -> . expression GT expression
    (189) relational_expression -> . expression GE expression
    (190) logical_expression -> . expression LAND expression
    (191) logical_expression -> . expression LOR expression
    (192) bitwise_expression -> . expression AND expression
    (193) bitwise_expression -> . expression OR expression
    (194) bitwise_expression -> . expression XOR expression
    (195) bitwise_expression -> . expression AND_NOT expression
    (196) bitwise_expression -> . expression LSHIFT expression
    (197) bitwise_expression -> . expression RSHIFT expression
    (144) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (171) type_name -> . IDENTIFIER
    (172) type_name -> . slice_type
    (173) type_name -> . array_type
    (174) type_name -> . map_type
    (119) array_type -> . LBRACKET INT RBRACKET type

    LPAREN          shift and go to state 54
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    LNOT            shift and go to state 61
    INT             shift and go to state 62
    FLOAT64         shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 66
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    expression                     shift and go to state 269
    slice_type                     shift and go to state 53
    binary_expression              shift and go to state 55
    relational_expression          shift and go to state 56
    logical_expression             shift and go to state 57
    bitwise_expression             shift and go to state 58
    map_type                       shift and go to state 67
    type_name                      shift and go to state 68
    array_type                     shift and go to state 69

state 233

    (40) assignment_compound -> IDENTIFIER operator_assign . expression
    (57) expression -> . slice_type LBRACE expression_list RBRACE
    (58) expression -> . slice_type LBRACE RBRACE
    (61) expression -> . LPAREN expression RPAREN
    (120) expression -> . binary_expression
    (121) expression -> . relational_expression
    (122) expression -> . logical_expression
    (123) expression -> . bitwise_expression
    (124) expression -> . PLUS expression
    (125) expression -> . MINUS expression
    (126) expression -> . LNOT expression
    (127) expression -> . INT
    (128) expression -> . FLOAT64
    (129) expression -> . TRUE
    (130) expression -> . FALSE
    (131) expression -> . IDENTIFIER
    (132) expression -> . STRING
    (133) expression -> . IDENTIFIER PLUSPLUS
    (134) expression -> . IDENTIFIER MINUSMINUS
    (145) expression -> . map_type LBRACE expression_map_list RBRACE
    (146) expression -> . map_type LBRACE RBRACE
    (169) expression -> . type_name LBRACE keyed_element_list RBRACE
    (170) expression -> . type_name LBRACE RBRACE
    (56) slice_type -> . LBRACKET RBRACKET primitive_type
    (175) binary_expression -> . expression PLUS expression
    (176) binary_expression -> . expression MINUS expression
    (177) binary_expression -> . expression TIMES expression
    (178) binary_expression -> . expression DIVIDE expression
    (179) binary_expression -> . expression MODULE expression
    (184) relational_expression -> . expression EQ expression
    (185) relational_expression -> . expression NEQ expression
    (186) relational_expression -> . expression LT expression
    (187) relational_expression -> . expression LE expression
    (188) relational_expression -> . expression GT expression
    (189) relational_expression -> . expression GE expression
    (190) logical_expression -> . expression LAND expression
    (191) logical_expression -> . expression LOR expression
    (192) bitwise_expression -> . expression AND expression
    (193) bitwise_expression -> . expression OR expression
    (194) bitwise_expression -> . expression XOR expression
    (195) bitwise_expression -> . expression AND_NOT expression
    (196) bitwise_expression -> . expression LSHIFT expression
    (197) bitwise_expression -> . expression RSHIFT expression
    (144) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (171) type_name -> . IDENTIFIER
    (172) type_name -> . slice_type
    (173) type_name -> . array_type
    (174) type_name -> . map_type
    (119) array_type -> . LBRACKET INT RBRACKET type

    LPAREN          shift and go to state 54
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    LNOT            shift and go to state 61
    INT             shift and go to state 62
    FLOAT64         shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 66
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    expression                     shift and go to state 270
    slice_type                     shift and go to state 53
    binary_expression              shift and go to state 55
    relational_expression          shift and go to state 56
    logical_expression             shift and go to state 57
    bitwise_expression             shift and go to state 58
    map_type                       shift and go to state 67
    type_name                      shift and go to state 68
    array_type                     shift and go to state 69

state 234

    (229) print_expression -> IDENTIFIER DOT . IDENTIFIER LPAREN argument_list RPAREN
    (230) input_expression -> IDENTIFIER DOT . IDENTIFIER LPAREN AND IDENTIFIER COMMA argument_list RPAREN

    IDENTIFIER      shift and go to state 271


state 235

    (201) func_call_expression -> IDENTIFIER LPAREN . argument_list RPAREN
    (231) argument_list -> . expression_list
    (232) argument_list -> . empty
    (59) expression_list -> . expression
    (60) expression_list -> . expression_list COMMA expression
    (7) empty -> .
    (57) expression -> . slice_type LBRACE expression_list RBRACE
    (58) expression -> . slice_type LBRACE RBRACE
    (61) expression -> . LPAREN expression RPAREN
    (120) expression -> . binary_expression
    (121) expression -> . relational_expression
    (122) expression -> . logical_expression
    (123) expression -> . bitwise_expression
    (124) expression -> . PLUS expression
    (125) expression -> . MINUS expression
    (126) expression -> . LNOT expression
    (127) expression -> . INT
    (128) expression -> . FLOAT64
    (129) expression -> . TRUE
    (130) expression -> . FALSE
    (131) expression -> . IDENTIFIER
    (132) expression -> . STRING
    (133) expression -> . IDENTIFIER PLUSPLUS
    (134) expression -> . IDENTIFIER MINUSMINUS
    (145) expression -> . map_type LBRACE expression_map_list RBRACE
    (146) expression -> . map_type LBRACE RBRACE
    (169) expression -> . type_name LBRACE keyed_element_list RBRACE
    (170) expression -> . type_name LBRACE RBRACE
    (56) slice_type -> . LBRACKET RBRACKET primitive_type
    (175) binary_expression -> . expression PLUS expression
    (176) binary_expression -> . expression MINUS expression
    (177) binary_expression -> . expression TIMES expression
    (178) binary_expression -> . expression DIVIDE expression
    (179) binary_expression -> . expression MODULE expression
    (184) relational_expression -> . expression EQ expression
    (185) relational_expression -> . expression NEQ expression
    (186) relational_expression -> . expression LT expression
    (187) relational_expression -> . expression LE expression
    (188) relational_expression -> . expression GT expression
    (189) relational_expression -> . expression GE expression
    (190) logical_expression -> . expression LAND expression
    (191) logical_expression -> . expression LOR expression
    (192) bitwise_expression -> . expression AND expression
    (193) bitwise_expression -> . expression OR expression
    (194) bitwise_expression -> . expression XOR expression
    (195) bitwise_expression -> . expression AND_NOT expression
    (196) bitwise_expression -> . expression LSHIFT expression
    (197) bitwise_expression -> . expression RSHIFT expression
    (144) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (171) type_name -> . IDENTIFIER
    (172) type_name -> . slice_type
    (173) type_name -> . array_type
    (174) type_name -> . map_type
    (119) array_type -> . LBRACKET INT RBRACKET type

    RPAREN          reduce using rule 7 (empty -> .)
    LPAREN          shift and go to state 54
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    LNOT            shift and go to state 61
    INT             shift and go to state 62
    FLOAT64         shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 66
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    argument_list                  shift and go to state 272
    expression_list                shift and go to state 273
    empty                          shift and go to state 274
    expression                     shift and go to state 148
    slice_type                     shift and go to state 53
    binary_expression              shift and go to state 55
    relational_expression          shift and go to state 56
    logical_expression             shift and go to state 57
    bitwise_expression             shift and go to state 58
    map_type                       shift and go to state 67
    type_name                      shift and go to state 68
    array_type                     shift and go to state 69

state 236

    (41) operator_assign -> PLUS_ASSIGN .

    LPAREN          reduce using rule 41 (operator_assign -> PLUS_ASSIGN .)
    PLUS            reduce using rule 41 (operator_assign -> PLUS_ASSIGN .)
    MINUS           reduce using rule 41 (operator_assign -> PLUS_ASSIGN .)
    LNOT            reduce using rule 41 (operator_assign -> PLUS_ASSIGN .)
    INT             reduce using rule 41 (operator_assign -> PLUS_ASSIGN .)
    FLOAT64         reduce using rule 41 (operator_assign -> PLUS_ASSIGN .)
    TRUE            reduce using rule 41 (operator_assign -> PLUS_ASSIGN .)
    FALSE           reduce using rule 41 (operator_assign -> PLUS_ASSIGN .)
    IDENTIFIER      reduce using rule 41 (operator_assign -> PLUS_ASSIGN .)
    STRING          reduce using rule 41 (operator_assign -> PLUS_ASSIGN .)
    LBRACKET        reduce using rule 41 (operator_assign -> PLUS_ASSIGN .)
    MAP             reduce using rule 41 (operator_assign -> PLUS_ASSIGN .)


state 237

    (42) operator_assign -> MINUS_ASSIGN .

    LPAREN          reduce using rule 42 (operator_assign -> MINUS_ASSIGN .)
    PLUS            reduce using rule 42 (operator_assign -> MINUS_ASSIGN .)
    MINUS           reduce using rule 42 (operator_assign -> MINUS_ASSIGN .)
    LNOT            reduce using rule 42 (operator_assign -> MINUS_ASSIGN .)
    INT             reduce using rule 42 (operator_assign -> MINUS_ASSIGN .)
    FLOAT64         reduce using rule 42 (operator_assign -> MINUS_ASSIGN .)
    TRUE            reduce using rule 42 (operator_assign -> MINUS_ASSIGN .)
    FALSE           reduce using rule 42 (operator_assign -> MINUS_ASSIGN .)
    IDENTIFIER      reduce using rule 42 (operator_assign -> MINUS_ASSIGN .)
    STRING          reduce using rule 42 (operator_assign -> MINUS_ASSIGN .)
    LBRACKET        reduce using rule 42 (operator_assign -> MINUS_ASSIGN .)
    MAP             reduce using rule 42 (operator_assign -> MINUS_ASSIGN .)


state 238

    (43) operator_assign -> MULT_ASSIGN .

    LPAREN          reduce using rule 43 (operator_assign -> MULT_ASSIGN .)
    PLUS            reduce using rule 43 (operator_assign -> MULT_ASSIGN .)
    MINUS           reduce using rule 43 (operator_assign -> MULT_ASSIGN .)
    LNOT            reduce using rule 43 (operator_assign -> MULT_ASSIGN .)
    INT             reduce using rule 43 (operator_assign -> MULT_ASSIGN .)
    FLOAT64         reduce using rule 43 (operator_assign -> MULT_ASSIGN .)
    TRUE            reduce using rule 43 (operator_assign -> MULT_ASSIGN .)
    FALSE           reduce using rule 43 (operator_assign -> MULT_ASSIGN .)
    IDENTIFIER      reduce using rule 43 (operator_assign -> MULT_ASSIGN .)
    STRING          reduce using rule 43 (operator_assign -> MULT_ASSIGN .)
    LBRACKET        reduce using rule 43 (operator_assign -> MULT_ASSIGN .)
    MAP             reduce using rule 43 (operator_assign -> MULT_ASSIGN .)


state 239

    (44) operator_assign -> DIV_ASSIGN .

    LPAREN          reduce using rule 44 (operator_assign -> DIV_ASSIGN .)
    PLUS            reduce using rule 44 (operator_assign -> DIV_ASSIGN .)
    MINUS           reduce using rule 44 (operator_assign -> DIV_ASSIGN .)
    LNOT            reduce using rule 44 (operator_assign -> DIV_ASSIGN .)
    INT             reduce using rule 44 (operator_assign -> DIV_ASSIGN .)
    FLOAT64         reduce using rule 44 (operator_assign -> DIV_ASSIGN .)
    TRUE            reduce using rule 44 (operator_assign -> DIV_ASSIGN .)
    FALSE           reduce using rule 44 (operator_assign -> DIV_ASSIGN .)
    IDENTIFIER      reduce using rule 44 (operator_assign -> DIV_ASSIGN .)
    STRING          reduce using rule 44 (operator_assign -> DIV_ASSIGN .)
    LBRACKET        reduce using rule 44 (operator_assign -> DIV_ASSIGN .)
    MAP             reduce using rule 44 (operator_assign -> DIV_ASSIGN .)


state 240

    (45) operator_assign -> MOD_ASSIGN .

    LPAREN          reduce using rule 45 (operator_assign -> MOD_ASSIGN .)
    PLUS            reduce using rule 45 (operator_assign -> MOD_ASSIGN .)
    MINUS           reduce using rule 45 (operator_assign -> MOD_ASSIGN .)
    LNOT            reduce using rule 45 (operator_assign -> MOD_ASSIGN .)
    INT             reduce using rule 45 (operator_assign -> MOD_ASSIGN .)
    FLOAT64         reduce using rule 45 (operator_assign -> MOD_ASSIGN .)
    TRUE            reduce using rule 45 (operator_assign -> MOD_ASSIGN .)
    FALSE           reduce using rule 45 (operator_assign -> MOD_ASSIGN .)
    IDENTIFIER      reduce using rule 45 (operator_assign -> MOD_ASSIGN .)
    STRING          reduce using rule 45 (operator_assign -> MOD_ASSIGN .)
    LBRACKET        reduce using rule 45 (operator_assign -> MOD_ASSIGN .)
    MAP             reduce using rule 45 (operator_assign -> MOD_ASSIGN .)


state 241

    (46) operator_assign -> AND_ASSIGN .

    LPAREN          reduce using rule 46 (operator_assign -> AND_ASSIGN .)
    PLUS            reduce using rule 46 (operator_assign -> AND_ASSIGN .)
    MINUS           reduce using rule 46 (operator_assign -> AND_ASSIGN .)
    LNOT            reduce using rule 46 (operator_assign -> AND_ASSIGN .)
    INT             reduce using rule 46 (operator_assign -> AND_ASSIGN .)
    FLOAT64         reduce using rule 46 (operator_assign -> AND_ASSIGN .)
    TRUE            reduce using rule 46 (operator_assign -> AND_ASSIGN .)
    FALSE           reduce using rule 46 (operator_assign -> AND_ASSIGN .)
    IDENTIFIER      reduce using rule 46 (operator_assign -> AND_ASSIGN .)
    STRING          reduce using rule 46 (operator_assign -> AND_ASSIGN .)
    LBRACKET        reduce using rule 46 (operator_assign -> AND_ASSIGN .)
    MAP             reduce using rule 46 (operator_assign -> AND_ASSIGN .)


state 242

    (47) operator_assign -> OR_ASSIGN .

    LPAREN          reduce using rule 47 (operator_assign -> OR_ASSIGN .)
    PLUS            reduce using rule 47 (operator_assign -> OR_ASSIGN .)
    MINUS           reduce using rule 47 (operator_assign -> OR_ASSIGN .)
    LNOT            reduce using rule 47 (operator_assign -> OR_ASSIGN .)
    INT             reduce using rule 47 (operator_assign -> OR_ASSIGN .)
    FLOAT64         reduce using rule 47 (operator_assign -> OR_ASSIGN .)
    TRUE            reduce using rule 47 (operator_assign -> OR_ASSIGN .)
    FALSE           reduce using rule 47 (operator_assign -> OR_ASSIGN .)
    IDENTIFIER      reduce using rule 47 (operator_assign -> OR_ASSIGN .)
    STRING          reduce using rule 47 (operator_assign -> OR_ASSIGN .)
    LBRACKET        reduce using rule 47 (operator_assign -> OR_ASSIGN .)
    MAP             reduce using rule 47 (operator_assign -> OR_ASSIGN .)


state 243

    (48) operator_assign -> XOR_ASSIGN .

    LPAREN          reduce using rule 48 (operator_assign -> XOR_ASSIGN .)
    PLUS            reduce using rule 48 (operator_assign -> XOR_ASSIGN .)
    MINUS           reduce using rule 48 (operator_assign -> XOR_ASSIGN .)
    LNOT            reduce using rule 48 (operator_assign -> XOR_ASSIGN .)
    INT             reduce using rule 48 (operator_assign -> XOR_ASSIGN .)
    FLOAT64         reduce using rule 48 (operator_assign -> XOR_ASSIGN .)
    TRUE            reduce using rule 48 (operator_assign -> XOR_ASSIGN .)
    FALSE           reduce using rule 48 (operator_assign -> XOR_ASSIGN .)
    IDENTIFIER      reduce using rule 48 (operator_assign -> XOR_ASSIGN .)
    STRING          reduce using rule 48 (operator_assign -> XOR_ASSIGN .)
    LBRACKET        reduce using rule 48 (operator_assign -> XOR_ASSIGN .)
    MAP             reduce using rule 48 (operator_assign -> XOR_ASSIGN .)


state 244

    (49) operator_assign -> LSHIFT_ASSIGN .

    LPAREN          reduce using rule 49 (operator_assign -> LSHIFT_ASSIGN .)
    PLUS            reduce using rule 49 (operator_assign -> LSHIFT_ASSIGN .)
    MINUS           reduce using rule 49 (operator_assign -> LSHIFT_ASSIGN .)
    LNOT            reduce using rule 49 (operator_assign -> LSHIFT_ASSIGN .)
    INT             reduce using rule 49 (operator_assign -> LSHIFT_ASSIGN .)
    FLOAT64         reduce using rule 49 (operator_assign -> LSHIFT_ASSIGN .)
    TRUE            reduce using rule 49 (operator_assign -> LSHIFT_ASSIGN .)
    FALSE           reduce using rule 49 (operator_assign -> LSHIFT_ASSIGN .)
    IDENTIFIER      reduce using rule 49 (operator_assign -> LSHIFT_ASSIGN .)
    STRING          reduce using rule 49 (operator_assign -> LSHIFT_ASSIGN .)
    LBRACKET        reduce using rule 49 (operator_assign -> LSHIFT_ASSIGN .)
    MAP             reduce using rule 49 (operator_assign -> LSHIFT_ASSIGN .)


state 245

    (50) operator_assign -> RSHIFT_ASSIGN .

    LPAREN          reduce using rule 50 (operator_assign -> RSHIFT_ASSIGN .)
    PLUS            reduce using rule 50 (operator_assign -> RSHIFT_ASSIGN .)
    MINUS           reduce using rule 50 (operator_assign -> RSHIFT_ASSIGN .)
    LNOT            reduce using rule 50 (operator_assign -> RSHIFT_ASSIGN .)
    INT             reduce using rule 50 (operator_assign -> RSHIFT_ASSIGN .)
    FLOAT64         reduce using rule 50 (operator_assign -> RSHIFT_ASSIGN .)
    TRUE            reduce using rule 50 (operator_assign -> RSHIFT_ASSIGN .)
    FALSE           reduce using rule 50 (operator_assign -> RSHIFT_ASSIGN .)
    IDENTIFIER      reduce using rule 50 (operator_assign -> RSHIFT_ASSIGN .)
    STRING          reduce using rule 50 (operator_assign -> RSHIFT_ASSIGN .)
    LBRACKET        reduce using rule 50 (operator_assign -> RSHIFT_ASSIGN .)
    MAP             reduce using rule 50 (operator_assign -> RSHIFT_ASSIGN .)


state 246

    (111) variable_declaration -> VAR IDENTIFIER . type ASSIGN expression
    (113) variable_declaration -> VAR IDENTIFIER . ASSIGN expression
    (52) type -> . primitive_type
    (53) type -> . slice_type
    (54) type -> . array_type
    (55) type -> . map_type
    (115) primitive_type -> . INT_TYPE
    (116) primitive_type -> . FLOAT64_TYPE
    (117) primitive_type -> . STRING_TYPE
    (118) primitive_type -> . BOOL_TYPE
    (56) slice_type -> . LBRACKET RBRACKET primitive_type
    (119) array_type -> . LBRACKET INT RBRACKET type
    (144) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type

    ASSIGN          shift and go to state 276
    INT_TYPE        shift and go to state 34
    FLOAT64_TYPE    shift and go to state 35
    STRING_TYPE     shift and go to state 36
    BOOL_TYPE       shift and go to state 37
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    type                           shift and go to state 275
    primitive_type                 shift and go to state 30
    slice_type                     shift and go to state 31
    array_type                     shift and go to state 32
    map_type                       shift and go to state 33

state 247

    (112) variable_declaration -> CONST IDENTIFIER . type ASSIGN expression
    (114) variable_declaration -> CONST IDENTIFIER . ASSIGN expression
    (52) type -> . primitive_type
    (53) type -> . slice_type
    (54) type -> . array_type
    (55) type -> . map_type
    (115) primitive_type -> . INT_TYPE
    (116) primitive_type -> . FLOAT64_TYPE
    (117) primitive_type -> . STRING_TYPE
    (118) primitive_type -> . BOOL_TYPE
    (56) slice_type -> . LBRACKET RBRACKET primitive_type
    (119) array_type -> . LBRACKET INT RBRACKET type
    (144) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type

    ASSIGN          shift and go to state 278
    INT_TYPE        shift and go to state 34
    FLOAT64_TYPE    shift and go to state 35
    STRING_TYPE     shift and go to state 36
    BOOL_TYPE       shift and go to state 37
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    type                           shift and go to state 277
    primitive_type                 shift and go to state 30
    slice_type                     shift and go to state 31
    array_type                     shift and go to state 32
    map_type                       shift and go to state 33

state 248

    (106) return_statement -> RETURN return_list .
    (95) return_list -> return_list . COMMA expression

    IDENTIFIER      reduce using rule 106 (return_statement -> RETURN return_list .)
    VAR             reduce using rule 106 (return_statement -> RETURN return_list .)
    CONST           reduce using rule 106 (return_statement -> RETURN return_list .)
    LPAREN          reduce using rule 106 (return_statement -> RETURN return_list .)
    PLUS            reduce using rule 106 (return_statement -> RETURN return_list .)
    MINUS           reduce using rule 106 (return_statement -> RETURN return_list .)
    LNOT            reduce using rule 106 (return_statement -> RETURN return_list .)
    INT             reduce using rule 106 (return_statement -> RETURN return_list .)
    FLOAT64         reduce using rule 106 (return_statement -> RETURN return_list .)
    TRUE            reduce using rule 106 (return_statement -> RETURN return_list .)
    FALSE           reduce using rule 106 (return_statement -> RETURN return_list .)
    STRING          reduce using rule 106 (return_statement -> RETURN return_list .)
    RETURN          reduce using rule 106 (return_statement -> RETURN return_list .)
    IF              reduce using rule 106 (return_statement -> RETURN return_list .)
    SWITCH          reduce using rule 106 (return_statement -> RETURN return_list .)
    BREAK           reduce using rule 106 (return_statement -> RETURN return_list .)
    CONTINUE        reduce using rule 106 (return_statement -> RETURN return_list .)
    LBRACKET        reduce using rule 106 (return_statement -> RETURN return_list .)
    MAP             reduce using rule 106 (return_statement -> RETURN return_list .)
    FOR             reduce using rule 106 (return_statement -> RETURN return_list .)
    RBRACE          reduce using rule 106 (return_statement -> RETURN return_list .)
    CASE            reduce using rule 106 (return_statement -> RETURN return_list .)
    DEFAULT         reduce using rule 106 (return_statement -> RETURN return_list .)
    COMMA           shift and go to state 279


state 249

    (94) return_list -> expression .
    (175) binary_expression -> expression . PLUS expression
    (176) binary_expression -> expression . MINUS expression
    (177) binary_expression -> expression . TIMES expression
    (178) binary_expression -> expression . DIVIDE expression
    (179) binary_expression -> expression . MODULE expression
    (184) relational_expression -> expression . EQ expression
    (185) relational_expression -> expression . NEQ expression
    (186) relational_expression -> expression . LT expression
    (187) relational_expression -> expression . LE expression
    (188) relational_expression -> expression . GT expression
    (189) relational_expression -> expression . GE expression
    (190) logical_expression -> expression . LAND expression
    (191) logical_expression -> expression . LOR expression
    (192) bitwise_expression -> expression . AND expression
    (193) bitwise_expression -> expression . OR expression
    (194) bitwise_expression -> expression . XOR expression
    (195) bitwise_expression -> expression . AND_NOT expression
    (196) bitwise_expression -> expression . LSHIFT expression
    (197) bitwise_expression -> expression . RSHIFT expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    COMMA           reduce using rule 94 (return_list -> expression .)
    IDENTIFIER      reduce using rule 94 (return_list -> expression .)
    VAR             reduce using rule 94 (return_list -> expression .)
    CONST           reduce using rule 94 (return_list -> expression .)
    LPAREN          reduce using rule 94 (return_list -> expression .)
    LNOT            reduce using rule 94 (return_list -> expression .)
    INT             reduce using rule 94 (return_list -> expression .)
    FLOAT64         reduce using rule 94 (return_list -> expression .)
    TRUE            reduce using rule 94 (return_list -> expression .)
    FALSE           reduce using rule 94 (return_list -> expression .)
    STRING          reduce using rule 94 (return_list -> expression .)
    RETURN          reduce using rule 94 (return_list -> expression .)
    IF              reduce using rule 94 (return_list -> expression .)
    SWITCH          reduce using rule 94 (return_list -> expression .)
    BREAK           reduce using rule 94 (return_list -> expression .)
    CONTINUE        reduce using rule 94 (return_list -> expression .)
    LBRACKET        reduce using rule 94 (return_list -> expression .)
    MAP             reduce using rule 94 (return_list -> expression .)
    FOR             reduce using rule 94 (return_list -> expression .)
    RBRACE          reduce using rule 94 (return_list -> expression .)
    CASE            reduce using rule 94 (return_list -> expression .)
    DEFAULT         reduce using rule 94 (return_list -> expression .)
    PLUS            shift and go to state 86
    MINUS           shift and go to state 87
    TIMES           shift and go to state 88
    DIVIDE          shift and go to state 89
    MODULE          shift and go to state 90
    EQ              shift and go to state 91
    NEQ             shift and go to state 92
    LT              shift and go to state 93
    LE              shift and go to state 94
    GT              shift and go to state 95
    GE              shift and go to state 96
    LAND            shift and go to state 97
    LOR             shift and go to state 98
    AND             shift and go to state 99
    OR              shift and go to state 100
    XOR             shift and go to state 101
    AND_NOT         shift and go to state 102
    LSHIFT          shift and go to state 103
    RSHIFT          shift and go to state 104

  ! PLUS            [ reduce using rule 94 (return_list -> expression .) ]
  ! MINUS           [ reduce using rule 94 (return_list -> expression .) ]


state 250

    (135) if_statement -> IF expression . block
    (136) if_statement -> IF expression . block ELSE block
    (137) if_statement -> IF expression . block ELSE if_statement
    (175) binary_expression -> expression . PLUS expression
    (176) binary_expression -> expression . MINUS expression
    (177) binary_expression -> expression . TIMES expression
    (178) binary_expression -> expression . DIVIDE expression
    (179) binary_expression -> expression . MODULE expression
    (184) relational_expression -> expression . EQ expression
    (185) relational_expression -> expression . NEQ expression
    (186) relational_expression -> expression . LT expression
    (187) relational_expression -> expression . LE expression
    (188) relational_expression -> expression . GT expression
    (189) relational_expression -> expression . GE expression
    (190) logical_expression -> expression . LAND expression
    (191) logical_expression -> expression . LOR expression
    (192) bitwise_expression -> expression . AND expression
    (193) bitwise_expression -> expression . OR expression
    (194) bitwise_expression -> expression . XOR expression
    (195) bitwise_expression -> expression . AND_NOT expression
    (196) bitwise_expression -> expression . LSHIFT expression
    (197) bitwise_expression -> expression . RSHIFT expression
    (15) block -> . LBRACE enter_block exit_block RBRACE
    (16) block -> . LBRACE enter_block statement_list exit_block RBRACE

    PLUS            shift and go to state 86
    MINUS           shift and go to state 87
    TIMES           shift and go to state 88
    DIVIDE          shift and go to state 89
    MODULE          shift and go to state 90
    EQ              shift and go to state 91
    NEQ             shift and go to state 92
    LT              shift and go to state 93
    LE              shift and go to state 94
    GT              shift and go to state 95
    GE              shift and go to state 96
    LAND            shift and go to state 97
    LOR             shift and go to state 98
    AND             shift and go to state 99
    OR              shift and go to state 100
    XOR             shift and go to state 101
    AND_NOT         shift and go to state 102
    LSHIFT          shift and go to state 103
    RSHIFT          shift and go to state 104
    LBRACE          shift and go to state 185

    block                          shift and go to state 280

state 251

    (138) if_statement -> IF if_assignment . SEMICOLON expression block
    (139) if_statement -> IF if_assignment . SEMICOLON expression block ELSE block
    (140) if_statement -> IF if_assignment . SEMICOLON expression block ELSE if_statement

    SEMICOLON       shift and go to state 281


state 252

    (131) expression -> IDENTIFIER .
    (133) expression -> IDENTIFIER . PLUSPLUS
    (134) expression -> IDENTIFIER . MINUSMINUS
    (171) type_name -> IDENTIFIER .
    (51) simple_assignment -> IDENTIFIER . ASSIGN expression
    (62) short_assignment -> IDENTIFIER . SHORT_ASSIGN expression

  ! reduce/reduce conflict for LBRACE resolved using rule 131 (expression -> IDENTIFIER .)
    PLUS            reduce using rule 131 (expression -> IDENTIFIER .)
    MINUS           reduce using rule 131 (expression -> IDENTIFIER .)
    TIMES           reduce using rule 131 (expression -> IDENTIFIER .)
    DIVIDE          reduce using rule 131 (expression -> IDENTIFIER .)
    MODULE          reduce using rule 131 (expression -> IDENTIFIER .)
    EQ              reduce using rule 131 (expression -> IDENTIFIER .)
    NEQ             reduce using rule 131 (expression -> IDENTIFIER .)
    LT              reduce using rule 131 (expression -> IDENTIFIER .)
    LE              reduce using rule 131 (expression -> IDENTIFIER .)
    GT              reduce using rule 131 (expression -> IDENTIFIER .)
    GE              reduce using rule 131 (expression -> IDENTIFIER .)
    LAND            reduce using rule 131 (expression -> IDENTIFIER .)
    LOR             reduce using rule 131 (expression -> IDENTIFIER .)
    AND             reduce using rule 131 (expression -> IDENTIFIER .)
    OR              reduce using rule 131 (expression -> IDENTIFIER .)
    XOR             reduce using rule 131 (expression -> IDENTIFIER .)
    AND_NOT         reduce using rule 131 (expression -> IDENTIFIER .)
    LSHIFT          reduce using rule 131 (expression -> IDENTIFIER .)
    RSHIFT          reduce using rule 131 (expression -> IDENTIFIER .)
    LBRACE          reduce using rule 131 (expression -> IDENTIFIER .)
    PLUSPLUS        shift and go to state 84
    MINUSMINUS      shift and go to state 85
    ASSIGN          shift and go to state 282
    SHORT_ASSIGN    shift and go to state 283

  ! LBRACE          [ reduce using rule 171 (type_name -> IDENTIFIER .) ]


state 253

    (141) if_assignment -> simple_assignment .

    SEMICOLON       reduce using rule 141 (if_assignment -> simple_assignment .)


state 254

    (142) if_assignment -> short_assignment .

    SEMICOLON       reduce using rule 142 (if_assignment -> short_assignment .)


state 255

    (143) if_assignment -> local_var_dec .

    SEMICOLON       reduce using rule 143 (if_assignment -> local_var_dec .)


state 256

    (35) local_var_dec -> VAR . IDENTIFIER type
    (36) local_var_dec -> VAR . IDENTIFIER type ASSIGN expression
    (37) local_var_dec -> VAR . IDENTIFIER ASSIGN expression

    IDENTIFIER      shift and go to state 284


state 257

    (228) switch_statement -> SWITCH enter_block . switch_header LBRACE case_clauses RBRACE exit_block
    (226) switch_header -> . switch_expression
    (227) switch_header -> . switch_init
    (224) switch_expression -> . switch_primary
    (225) switch_expression -> . empty
    (223) switch_init -> . assignment SEMICOLON switch_expression
    (217) switch_primary -> . IDENTIFIER
    (218) switch_primary -> . INT
    (219) switch_primary -> . FLOAT64
    (220) switch_primary -> . STRING
    (221) switch_primary -> . TRUE
    (222) switch_primary -> . FALSE
    (7) empty -> .
    (109) assignment -> . IDENTIFIER ASSIGN expression
    (110) assignment -> . IDENTIFIER SHORT_ASSIGN expression

    IDENTIFIER      shift and go to state 291
    INT             shift and go to state 292
    FLOAT64         shift and go to state 293
    STRING          shift and go to state 294
    TRUE            shift and go to state 295
    FALSE           shift and go to state 296
    LBRACE          reduce using rule 7 (empty -> .)

    switch_header                  shift and go to state 285
    switch_expression              shift and go to state 286
    switch_init                    shift and go to state 287
    switch_primary                 shift and go to state 288
    empty                          shift and go to state 289
    assignment                     shift and go to state 290

state 258

    (81) for_classic -> FOR for_init . SEMICOLON for_cond SEMICOLON for_post block

    SEMICOLON       shift and go to state 297


state 259

    (83) for_infinite -> FOR block .

    IDENTIFIER      reduce using rule 83 (for_infinite -> FOR block .)
    VAR             reduce using rule 83 (for_infinite -> FOR block .)
    CONST           reduce using rule 83 (for_infinite -> FOR block .)
    LPAREN          reduce using rule 83 (for_infinite -> FOR block .)
    PLUS            reduce using rule 83 (for_infinite -> FOR block .)
    MINUS           reduce using rule 83 (for_infinite -> FOR block .)
    LNOT            reduce using rule 83 (for_infinite -> FOR block .)
    INT             reduce using rule 83 (for_infinite -> FOR block .)
    FLOAT64         reduce using rule 83 (for_infinite -> FOR block .)
    TRUE            reduce using rule 83 (for_infinite -> FOR block .)
    FALSE           reduce using rule 83 (for_infinite -> FOR block .)
    STRING          reduce using rule 83 (for_infinite -> FOR block .)
    RETURN          reduce using rule 83 (for_infinite -> FOR block .)
    IF              reduce using rule 83 (for_infinite -> FOR block .)
    SWITCH          reduce using rule 83 (for_infinite -> FOR block .)
    BREAK           reduce using rule 83 (for_infinite -> FOR block .)
    CONTINUE        reduce using rule 83 (for_infinite -> FOR block .)
    LBRACKET        reduce using rule 83 (for_infinite -> FOR block .)
    MAP             reduce using rule 83 (for_infinite -> FOR block .)
    FOR             reduce using rule 83 (for_infinite -> FOR block .)
    RBRACE          reduce using rule 83 (for_infinite -> FOR block .)
    CASE            reduce using rule 83 (for_infinite -> FOR block .)
    DEFAULT         reduce using rule 83 (for_infinite -> FOR block .)


state 260

    (82) for_condition -> FOR expression . block
    (175) binary_expression -> expression . PLUS expression
    (176) binary_expression -> expression . MINUS expression
    (177) binary_expression -> expression . TIMES expression
    (178) binary_expression -> expression . DIVIDE expression
    (179) binary_expression -> expression . MODULE expression
    (184) relational_expression -> expression . EQ expression
    (185) relational_expression -> expression . NEQ expression
    (186) relational_expression -> expression . LT expression
    (187) relational_expression -> expression . LE expression
    (188) relational_expression -> expression . GT expression
    (189) relational_expression -> expression . GE expression
    (190) logical_expression -> expression . LAND expression
    (191) logical_expression -> expression . LOR expression
    (192) bitwise_expression -> expression . AND expression
    (193) bitwise_expression -> expression . OR expression
    (194) bitwise_expression -> expression . XOR expression
    (195) bitwise_expression -> expression . AND_NOT expression
    (196) bitwise_expression -> expression . LSHIFT expression
    (197) bitwise_expression -> expression . RSHIFT expression
    (15) block -> . LBRACE enter_block exit_block RBRACE
    (16) block -> . LBRACE enter_block statement_list exit_block RBRACE

    PLUS            shift and go to state 86
    MINUS           shift and go to state 87
    TIMES           shift and go to state 88
    DIVIDE          shift and go to state 89
    MODULE          shift and go to state 90
    EQ              shift and go to state 91
    NEQ             shift and go to state 92
    LT              shift and go to state 93
    LE              shift and go to state 94
    GT              shift and go to state 95
    GE              shift and go to state 96
    LAND            shift and go to state 97
    LOR             shift and go to state 98
    AND             shift and go to state 99
    OR              shift and go to state 100
    XOR             shift and go to state 101
    AND_NOT         shift and go to state 102
    LSHIFT          shift and go to state 103
    RSHIFT          shift and go to state 104
    LBRACE          shift and go to state 185

    block                          shift and go to state 298

state 261

    (84) for_init -> simple_assignment .

    SEMICOLON       reduce using rule 84 (for_init -> simple_assignment .)


state 262

    (85) for_init -> short_assignment .

    SEMICOLON       reduce using rule 85 (for_init -> short_assignment .)


state 263

    (86) for_init -> local_var_dec .

    SEMICOLON       reduce using rule 86 (for_init -> local_var_dec .)


state 264

    (87) for_init -> empty .

    SEMICOLON       reduce using rule 87 (for_init -> empty .)


state 265

    (131) expression -> IDENTIFIER .
    (133) expression -> IDENTIFIER . PLUSPLUS
    (134) expression -> IDENTIFIER . MINUSMINUS
    (51) simple_assignment -> IDENTIFIER . ASSIGN expression
    (62) short_assignment -> IDENTIFIER . SHORT_ASSIGN expression
    (171) type_name -> IDENTIFIER .

  ! reduce/reduce conflict for LBRACE resolved using rule 131 (expression -> IDENTIFIER .)
    PLUS            reduce using rule 131 (expression -> IDENTIFIER .)
    MINUS           reduce using rule 131 (expression -> IDENTIFIER .)
    TIMES           reduce using rule 131 (expression -> IDENTIFIER .)
    DIVIDE          reduce using rule 131 (expression -> IDENTIFIER .)
    MODULE          reduce using rule 131 (expression -> IDENTIFIER .)
    EQ              reduce using rule 131 (expression -> IDENTIFIER .)
    NEQ             reduce using rule 131 (expression -> IDENTIFIER .)
    LT              reduce using rule 131 (expression -> IDENTIFIER .)
    LE              reduce using rule 131 (expression -> IDENTIFIER .)
    GT              reduce using rule 131 (expression -> IDENTIFIER .)
    GE              reduce using rule 131 (expression -> IDENTIFIER .)
    LAND            reduce using rule 131 (expression -> IDENTIFIER .)
    LOR             reduce using rule 131 (expression -> IDENTIFIER .)
    AND             reduce using rule 131 (expression -> IDENTIFIER .)
    OR              reduce using rule 131 (expression -> IDENTIFIER .)
    XOR             reduce using rule 131 (expression -> IDENTIFIER .)
    AND_NOT         reduce using rule 131 (expression -> IDENTIFIER .)
    LSHIFT          reduce using rule 131 (expression -> IDENTIFIER .)
    RSHIFT          reduce using rule 131 (expression -> IDENTIFIER .)
    LBRACE          reduce using rule 131 (expression -> IDENTIFIER .)
    PLUSPLUS        shift and go to state 84
    MINUSMINUS      shift and go to state 85
    ASSIGN          shift and go to state 282
    SHORT_ASSIGN    shift and go to state 283

  ! LBRACE          [ reduce using rule 171 (type_name -> IDENTIFIER .) ]


state 266

    (154) method_declaration -> FUNC LPAREN receiver RPAREN IDENTIFIER LPAREN parameter_list RPAREN return_type block .

    VAR             reduce using rule 154 (method_declaration -> FUNC LPAREN receiver RPAREN IDENTIFIER LPAREN parameter_list RPAREN return_type block .)
    CONST           reduce using rule 154 (method_declaration -> FUNC LPAREN receiver RPAREN IDENTIFIER LPAREN parameter_list RPAREN return_type block .)
    FUNC            reduce using rule 154 (method_declaration -> FUNC LPAREN receiver RPAREN IDENTIFIER LPAREN parameter_list RPAREN return_type block .)
    TYPE            reduce using rule 154 (method_declaration -> FUNC LPAREN receiver RPAREN IDENTIFIER LPAREN parameter_list RPAREN return_type block .)
    $end            reduce using rule 154 (method_declaration -> FUNC LPAREN receiver RPAREN IDENTIFIER LPAREN parameter_list RPAREN return_type block .)


state 267

    (16) block -> LBRACE enter_block statement_list exit_block RBRACE .

    VAR             reduce using rule 16 (block -> LBRACE enter_block statement_list exit_block RBRACE .)
    CONST           reduce using rule 16 (block -> LBRACE enter_block statement_list exit_block RBRACE .)
    FUNC            reduce using rule 16 (block -> LBRACE enter_block statement_list exit_block RBRACE .)
    TYPE            reduce using rule 16 (block -> LBRACE enter_block statement_list exit_block RBRACE .)
    $end            reduce using rule 16 (block -> LBRACE enter_block statement_list exit_block RBRACE .)
    IDENTIFIER      reduce using rule 16 (block -> LBRACE enter_block statement_list exit_block RBRACE .)
    LPAREN          reduce using rule 16 (block -> LBRACE enter_block statement_list exit_block RBRACE .)
    PLUS            reduce using rule 16 (block -> LBRACE enter_block statement_list exit_block RBRACE .)
    MINUS           reduce using rule 16 (block -> LBRACE enter_block statement_list exit_block RBRACE .)
    LNOT            reduce using rule 16 (block -> LBRACE enter_block statement_list exit_block RBRACE .)
    INT             reduce using rule 16 (block -> LBRACE enter_block statement_list exit_block RBRACE .)
    FLOAT64         reduce using rule 16 (block -> LBRACE enter_block statement_list exit_block RBRACE .)
    TRUE            reduce using rule 16 (block -> LBRACE enter_block statement_list exit_block RBRACE .)
    FALSE           reduce using rule 16 (block -> LBRACE enter_block statement_list exit_block RBRACE .)
    STRING          reduce using rule 16 (block -> LBRACE enter_block statement_list exit_block RBRACE .)
    RETURN          reduce using rule 16 (block -> LBRACE enter_block statement_list exit_block RBRACE .)
    IF              reduce using rule 16 (block -> LBRACE enter_block statement_list exit_block RBRACE .)
    SWITCH          reduce using rule 16 (block -> LBRACE enter_block statement_list exit_block RBRACE .)
    BREAK           reduce using rule 16 (block -> LBRACE enter_block statement_list exit_block RBRACE .)
    CONTINUE        reduce using rule 16 (block -> LBRACE enter_block statement_list exit_block RBRACE .)
    LBRACKET        reduce using rule 16 (block -> LBRACE enter_block statement_list exit_block RBRACE .)
    MAP             reduce using rule 16 (block -> LBRACE enter_block statement_list exit_block RBRACE .)
    FOR             reduce using rule 16 (block -> LBRACE enter_block statement_list exit_block RBRACE .)
    RBRACE          reduce using rule 16 (block -> LBRACE enter_block statement_list exit_block RBRACE .)
    CASE            reduce using rule 16 (block -> LBRACE enter_block statement_list exit_block RBRACE .)
    DEFAULT         reduce using rule 16 (block -> LBRACE enter_block statement_list exit_block RBRACE .)
    ELSE            reduce using rule 16 (block -> LBRACE enter_block statement_list exit_block RBRACE .)


state 268

    (109) assignment -> IDENTIFIER ASSIGN expression .
    (175) binary_expression -> expression . PLUS expression
    (176) binary_expression -> expression . MINUS expression
    (177) binary_expression -> expression . TIMES expression
    (178) binary_expression -> expression . DIVIDE expression
    (179) binary_expression -> expression . MODULE expression
    (184) relational_expression -> expression . EQ expression
    (185) relational_expression -> expression . NEQ expression
    (186) relational_expression -> expression . LT expression
    (187) relational_expression -> expression . LE expression
    (188) relational_expression -> expression . GT expression
    (189) relational_expression -> expression . GE expression
    (190) logical_expression -> expression . LAND expression
    (191) logical_expression -> expression . LOR expression
    (192) bitwise_expression -> expression . AND expression
    (193) bitwise_expression -> expression . OR expression
    (194) bitwise_expression -> expression . XOR expression
    (195) bitwise_expression -> expression . AND_NOT expression
    (196) bitwise_expression -> expression . LSHIFT expression
    (197) bitwise_expression -> expression . RSHIFT expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    IDENTIFIER      reduce using rule 109 (assignment -> IDENTIFIER ASSIGN expression .)
    VAR             reduce using rule 109 (assignment -> IDENTIFIER ASSIGN expression .)
    CONST           reduce using rule 109 (assignment -> IDENTIFIER ASSIGN expression .)
    LPAREN          reduce using rule 109 (assignment -> IDENTIFIER ASSIGN expression .)
    LNOT            reduce using rule 109 (assignment -> IDENTIFIER ASSIGN expression .)
    INT             reduce using rule 109 (assignment -> IDENTIFIER ASSIGN expression .)
    FLOAT64         reduce using rule 109 (assignment -> IDENTIFIER ASSIGN expression .)
    TRUE            reduce using rule 109 (assignment -> IDENTIFIER ASSIGN expression .)
    FALSE           reduce using rule 109 (assignment -> IDENTIFIER ASSIGN expression .)
    STRING          reduce using rule 109 (assignment -> IDENTIFIER ASSIGN expression .)
    RETURN          reduce using rule 109 (assignment -> IDENTIFIER ASSIGN expression .)
    IF              reduce using rule 109 (assignment -> IDENTIFIER ASSIGN expression .)
    SWITCH          reduce using rule 109 (assignment -> IDENTIFIER ASSIGN expression .)
    BREAK           reduce using rule 109 (assignment -> IDENTIFIER ASSIGN expression .)
    CONTINUE        reduce using rule 109 (assignment -> IDENTIFIER ASSIGN expression .)
    LBRACKET        reduce using rule 109 (assignment -> IDENTIFIER ASSIGN expression .)
    MAP             reduce using rule 109 (assignment -> IDENTIFIER ASSIGN expression .)
    FOR             reduce using rule 109 (assignment -> IDENTIFIER ASSIGN expression .)
    RBRACE          reduce using rule 109 (assignment -> IDENTIFIER ASSIGN expression .)
    SEMICOLON       reduce using rule 109 (assignment -> IDENTIFIER ASSIGN expression .)
    CASE            reduce using rule 109 (assignment -> IDENTIFIER ASSIGN expression .)
    DEFAULT         reduce using rule 109 (assignment -> IDENTIFIER ASSIGN expression .)
    PLUS            shift and go to state 86
    MINUS           shift and go to state 87
    TIMES           shift and go to state 88
    DIVIDE          shift and go to state 89
    MODULE          shift and go to state 90
    EQ              shift and go to state 91
    NEQ             shift and go to state 92
    LT              shift and go to state 93
    LE              shift and go to state 94
    GT              shift and go to state 95
    GE              shift and go to state 96
    LAND            shift and go to state 97
    LOR             shift and go to state 98
    AND             shift and go to state 99
    OR              shift and go to state 100
    XOR             shift and go to state 101
    AND_NOT         shift and go to state 102
    LSHIFT          shift and go to state 103
    RSHIFT          shift and go to state 104

  ! PLUS            [ reduce using rule 109 (assignment -> IDENTIFIER ASSIGN expression .) ]
  ! MINUS           [ reduce using rule 109 (assignment -> IDENTIFIER ASSIGN expression .) ]


state 269

    (110) assignment -> IDENTIFIER SHORT_ASSIGN expression .
    (175) binary_expression -> expression . PLUS expression
    (176) binary_expression -> expression . MINUS expression
    (177) binary_expression -> expression . TIMES expression
    (178) binary_expression -> expression . DIVIDE expression
    (179) binary_expression -> expression . MODULE expression
    (184) relational_expression -> expression . EQ expression
    (185) relational_expression -> expression . NEQ expression
    (186) relational_expression -> expression . LT expression
    (187) relational_expression -> expression . LE expression
    (188) relational_expression -> expression . GT expression
    (189) relational_expression -> expression . GE expression
    (190) logical_expression -> expression . LAND expression
    (191) logical_expression -> expression . LOR expression
    (192) bitwise_expression -> expression . AND expression
    (193) bitwise_expression -> expression . OR expression
    (194) bitwise_expression -> expression . XOR expression
    (195) bitwise_expression -> expression . AND_NOT expression
    (196) bitwise_expression -> expression . LSHIFT expression
    (197) bitwise_expression -> expression . RSHIFT expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    IDENTIFIER      reduce using rule 110 (assignment -> IDENTIFIER SHORT_ASSIGN expression .)
    VAR             reduce using rule 110 (assignment -> IDENTIFIER SHORT_ASSIGN expression .)
    CONST           reduce using rule 110 (assignment -> IDENTIFIER SHORT_ASSIGN expression .)
    LPAREN          reduce using rule 110 (assignment -> IDENTIFIER SHORT_ASSIGN expression .)
    LNOT            reduce using rule 110 (assignment -> IDENTIFIER SHORT_ASSIGN expression .)
    INT             reduce using rule 110 (assignment -> IDENTIFIER SHORT_ASSIGN expression .)
    FLOAT64         reduce using rule 110 (assignment -> IDENTIFIER SHORT_ASSIGN expression .)
    TRUE            reduce using rule 110 (assignment -> IDENTIFIER SHORT_ASSIGN expression .)
    FALSE           reduce using rule 110 (assignment -> IDENTIFIER SHORT_ASSIGN expression .)
    STRING          reduce using rule 110 (assignment -> IDENTIFIER SHORT_ASSIGN expression .)
    RETURN          reduce using rule 110 (assignment -> IDENTIFIER SHORT_ASSIGN expression .)
    IF              reduce using rule 110 (assignment -> IDENTIFIER SHORT_ASSIGN expression .)
    SWITCH          reduce using rule 110 (assignment -> IDENTIFIER SHORT_ASSIGN expression .)
    BREAK           reduce using rule 110 (assignment -> IDENTIFIER SHORT_ASSIGN expression .)
    CONTINUE        reduce using rule 110 (assignment -> IDENTIFIER SHORT_ASSIGN expression .)
    LBRACKET        reduce using rule 110 (assignment -> IDENTIFIER SHORT_ASSIGN expression .)
    MAP             reduce using rule 110 (assignment -> IDENTIFIER SHORT_ASSIGN expression .)
    FOR             reduce using rule 110 (assignment -> IDENTIFIER SHORT_ASSIGN expression .)
    RBRACE          reduce using rule 110 (assignment -> IDENTIFIER SHORT_ASSIGN expression .)
    SEMICOLON       reduce using rule 110 (assignment -> IDENTIFIER SHORT_ASSIGN expression .)
    CASE            reduce using rule 110 (assignment -> IDENTIFIER SHORT_ASSIGN expression .)
    DEFAULT         reduce using rule 110 (assignment -> IDENTIFIER SHORT_ASSIGN expression .)
    PLUS            shift and go to state 86
    MINUS           shift and go to state 87
    TIMES           shift and go to state 88
    DIVIDE          shift and go to state 89
    MODULE          shift and go to state 90
    EQ              shift and go to state 91
    NEQ             shift and go to state 92
    LT              shift and go to state 93
    LE              shift and go to state 94
    GT              shift and go to state 95
    GE              shift and go to state 96
    LAND            shift and go to state 97
    LOR             shift and go to state 98
    AND             shift and go to state 99
    OR              shift and go to state 100
    XOR             shift and go to state 101
    AND_NOT         shift and go to state 102
    LSHIFT          shift and go to state 103
    RSHIFT          shift and go to state 104

  ! PLUS            [ reduce using rule 110 (assignment -> IDENTIFIER SHORT_ASSIGN expression .) ]
  ! MINUS           [ reduce using rule 110 (assignment -> IDENTIFIER SHORT_ASSIGN expression .) ]


state 270

    (40) assignment_compound -> IDENTIFIER operator_assign expression .
    (175) binary_expression -> expression . PLUS expression
    (176) binary_expression -> expression . MINUS expression
    (177) binary_expression -> expression . TIMES expression
    (178) binary_expression -> expression . DIVIDE expression
    (179) binary_expression -> expression . MODULE expression
    (184) relational_expression -> expression . EQ expression
    (185) relational_expression -> expression . NEQ expression
    (186) relational_expression -> expression . LT expression
    (187) relational_expression -> expression . LE expression
    (188) relational_expression -> expression . GT expression
    (189) relational_expression -> expression . GE expression
    (190) logical_expression -> expression . LAND expression
    (191) logical_expression -> expression . LOR expression
    (192) bitwise_expression -> expression . AND expression
    (193) bitwise_expression -> expression . OR expression
    (194) bitwise_expression -> expression . XOR expression
    (195) bitwise_expression -> expression . AND_NOT expression
    (196) bitwise_expression -> expression . LSHIFT expression
    (197) bitwise_expression -> expression . RSHIFT expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    IDENTIFIER      reduce using rule 40 (assignment_compound -> IDENTIFIER operator_assign expression .)
    VAR             reduce using rule 40 (assignment_compound -> IDENTIFIER operator_assign expression .)
    CONST           reduce using rule 40 (assignment_compound -> IDENTIFIER operator_assign expression .)
    LPAREN          reduce using rule 40 (assignment_compound -> IDENTIFIER operator_assign expression .)
    LNOT            reduce using rule 40 (assignment_compound -> IDENTIFIER operator_assign expression .)
    INT             reduce using rule 40 (assignment_compound -> IDENTIFIER operator_assign expression .)
    FLOAT64         reduce using rule 40 (assignment_compound -> IDENTIFIER operator_assign expression .)
    TRUE            reduce using rule 40 (assignment_compound -> IDENTIFIER operator_assign expression .)
    FALSE           reduce using rule 40 (assignment_compound -> IDENTIFIER operator_assign expression .)
    STRING          reduce using rule 40 (assignment_compound -> IDENTIFIER operator_assign expression .)
    RETURN          reduce using rule 40 (assignment_compound -> IDENTIFIER operator_assign expression .)
    IF              reduce using rule 40 (assignment_compound -> IDENTIFIER operator_assign expression .)
    SWITCH          reduce using rule 40 (assignment_compound -> IDENTIFIER operator_assign expression .)
    BREAK           reduce using rule 40 (assignment_compound -> IDENTIFIER operator_assign expression .)
    CONTINUE        reduce using rule 40 (assignment_compound -> IDENTIFIER operator_assign expression .)
    LBRACKET        reduce using rule 40 (assignment_compound -> IDENTIFIER operator_assign expression .)
    MAP             reduce using rule 40 (assignment_compound -> IDENTIFIER operator_assign expression .)
    FOR             reduce using rule 40 (assignment_compound -> IDENTIFIER operator_assign expression .)
    RBRACE          reduce using rule 40 (assignment_compound -> IDENTIFIER operator_assign expression .)
    LBRACE          reduce using rule 40 (assignment_compound -> IDENTIFIER operator_assign expression .)
    CASE            reduce using rule 40 (assignment_compound -> IDENTIFIER operator_assign expression .)
    DEFAULT         reduce using rule 40 (assignment_compound -> IDENTIFIER operator_assign expression .)
    PLUS            shift and go to state 86
    MINUS           shift and go to state 87
    TIMES           shift and go to state 88
    DIVIDE          shift and go to state 89
    MODULE          shift and go to state 90
    EQ              shift and go to state 91
    NEQ             shift and go to state 92
    LT              shift and go to state 93
    LE              shift and go to state 94
    GT              shift and go to state 95
    GE              shift and go to state 96
    LAND            shift and go to state 97
    LOR             shift and go to state 98
    AND             shift and go to state 99
    OR              shift and go to state 100
    XOR             shift and go to state 101
    AND_NOT         shift and go to state 102
    LSHIFT          shift and go to state 103
    RSHIFT          shift and go to state 104

  ! PLUS            [ reduce using rule 40 (assignment_compound -> IDENTIFIER operator_assign expression .) ]
  ! MINUS           [ reduce using rule 40 (assignment_compound -> IDENTIFIER operator_assign expression .) ]


state 271

    (229) print_expression -> IDENTIFIER DOT IDENTIFIER . LPAREN argument_list RPAREN
    (230) input_expression -> IDENTIFIER DOT IDENTIFIER . LPAREN AND IDENTIFIER COMMA argument_list RPAREN

    LPAREN          shift and go to state 299


state 272

    (201) func_call_expression -> IDENTIFIER LPAREN argument_list . RPAREN

    RPAREN          shift and go to state 300


state 273

    (231) argument_list -> expression_list .
    (60) expression_list -> expression_list . COMMA expression

    RPAREN          reduce using rule 231 (argument_list -> expression_list .)
    COMMA           shift and go to state 173


state 274

    (232) argument_list -> empty .

    RPAREN          reduce using rule 232 (argument_list -> empty .)


state 275

    (111) variable_declaration -> VAR IDENTIFIER type . ASSIGN expression

    ASSIGN          shift and go to state 301


state 276

    (113) variable_declaration -> VAR IDENTIFIER ASSIGN . expression
    (57) expression -> . slice_type LBRACE expression_list RBRACE
    (58) expression -> . slice_type LBRACE RBRACE
    (61) expression -> . LPAREN expression RPAREN
    (120) expression -> . binary_expression
    (121) expression -> . relational_expression
    (122) expression -> . logical_expression
    (123) expression -> . bitwise_expression
    (124) expression -> . PLUS expression
    (125) expression -> . MINUS expression
    (126) expression -> . LNOT expression
    (127) expression -> . INT
    (128) expression -> . FLOAT64
    (129) expression -> . TRUE
    (130) expression -> . FALSE
    (131) expression -> . IDENTIFIER
    (132) expression -> . STRING
    (133) expression -> . IDENTIFIER PLUSPLUS
    (134) expression -> . IDENTIFIER MINUSMINUS
    (145) expression -> . map_type LBRACE expression_map_list RBRACE
    (146) expression -> . map_type LBRACE RBRACE
    (169) expression -> . type_name LBRACE keyed_element_list RBRACE
    (170) expression -> . type_name LBRACE RBRACE
    (56) slice_type -> . LBRACKET RBRACKET primitive_type
    (175) binary_expression -> . expression PLUS expression
    (176) binary_expression -> . expression MINUS expression
    (177) binary_expression -> . expression TIMES expression
    (178) binary_expression -> . expression DIVIDE expression
    (179) binary_expression -> . expression MODULE expression
    (184) relational_expression -> . expression EQ expression
    (185) relational_expression -> . expression NEQ expression
    (186) relational_expression -> . expression LT expression
    (187) relational_expression -> . expression LE expression
    (188) relational_expression -> . expression GT expression
    (189) relational_expression -> . expression GE expression
    (190) logical_expression -> . expression LAND expression
    (191) logical_expression -> . expression LOR expression
    (192) bitwise_expression -> . expression AND expression
    (193) bitwise_expression -> . expression OR expression
    (194) bitwise_expression -> . expression XOR expression
    (195) bitwise_expression -> . expression AND_NOT expression
    (196) bitwise_expression -> . expression LSHIFT expression
    (197) bitwise_expression -> . expression RSHIFT expression
    (144) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (171) type_name -> . IDENTIFIER
    (172) type_name -> . slice_type
    (173) type_name -> . array_type
    (174) type_name -> . map_type
    (119) array_type -> . LBRACKET INT RBRACKET type

    LPAREN          shift and go to state 54
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    LNOT            shift and go to state 61
    INT             shift and go to state 62
    FLOAT64         shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 66
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    expression                     shift and go to state 302
    slice_type                     shift and go to state 53
    binary_expression              shift and go to state 55
    relational_expression          shift and go to state 56
    logical_expression             shift and go to state 57
    bitwise_expression             shift and go to state 58
    map_type                       shift and go to state 67
    type_name                      shift and go to state 68
    array_type                     shift and go to state 69

state 277

    (112) variable_declaration -> CONST IDENTIFIER type . ASSIGN expression

    ASSIGN          shift and go to state 303


state 278

    (114) variable_declaration -> CONST IDENTIFIER ASSIGN . expression
    (57) expression -> . slice_type LBRACE expression_list RBRACE
    (58) expression -> . slice_type LBRACE RBRACE
    (61) expression -> . LPAREN expression RPAREN
    (120) expression -> . binary_expression
    (121) expression -> . relational_expression
    (122) expression -> . logical_expression
    (123) expression -> . bitwise_expression
    (124) expression -> . PLUS expression
    (125) expression -> . MINUS expression
    (126) expression -> . LNOT expression
    (127) expression -> . INT
    (128) expression -> . FLOAT64
    (129) expression -> . TRUE
    (130) expression -> . FALSE
    (131) expression -> . IDENTIFIER
    (132) expression -> . STRING
    (133) expression -> . IDENTIFIER PLUSPLUS
    (134) expression -> . IDENTIFIER MINUSMINUS
    (145) expression -> . map_type LBRACE expression_map_list RBRACE
    (146) expression -> . map_type LBRACE RBRACE
    (169) expression -> . type_name LBRACE keyed_element_list RBRACE
    (170) expression -> . type_name LBRACE RBRACE
    (56) slice_type -> . LBRACKET RBRACKET primitive_type
    (175) binary_expression -> . expression PLUS expression
    (176) binary_expression -> . expression MINUS expression
    (177) binary_expression -> . expression TIMES expression
    (178) binary_expression -> . expression DIVIDE expression
    (179) binary_expression -> . expression MODULE expression
    (184) relational_expression -> . expression EQ expression
    (185) relational_expression -> . expression NEQ expression
    (186) relational_expression -> . expression LT expression
    (187) relational_expression -> . expression LE expression
    (188) relational_expression -> . expression GT expression
    (189) relational_expression -> . expression GE expression
    (190) logical_expression -> . expression LAND expression
    (191) logical_expression -> . expression LOR expression
    (192) bitwise_expression -> . expression AND expression
    (193) bitwise_expression -> . expression OR expression
    (194) bitwise_expression -> . expression XOR expression
    (195) bitwise_expression -> . expression AND_NOT expression
    (196) bitwise_expression -> . expression LSHIFT expression
    (197) bitwise_expression -> . expression RSHIFT expression
    (144) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (171) type_name -> . IDENTIFIER
    (172) type_name -> . slice_type
    (173) type_name -> . array_type
    (174) type_name -> . map_type
    (119) array_type -> . LBRACKET INT RBRACKET type

    LPAREN          shift and go to state 54
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    LNOT            shift and go to state 61
    INT             shift and go to state 62
    FLOAT64         shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 66
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    expression                     shift and go to state 304
    slice_type                     shift and go to state 53
    binary_expression              shift and go to state 55
    relational_expression          shift and go to state 56
    logical_expression             shift and go to state 57
    bitwise_expression             shift and go to state 58
    map_type                       shift and go to state 67
    type_name                      shift and go to state 68
    array_type                     shift and go to state 69

state 279

    (95) return_list -> return_list COMMA . expression
    (57) expression -> . slice_type LBRACE expression_list RBRACE
    (58) expression -> . slice_type LBRACE RBRACE
    (61) expression -> . LPAREN expression RPAREN
    (120) expression -> . binary_expression
    (121) expression -> . relational_expression
    (122) expression -> . logical_expression
    (123) expression -> . bitwise_expression
    (124) expression -> . PLUS expression
    (125) expression -> . MINUS expression
    (126) expression -> . LNOT expression
    (127) expression -> . INT
    (128) expression -> . FLOAT64
    (129) expression -> . TRUE
    (130) expression -> . FALSE
    (131) expression -> . IDENTIFIER
    (132) expression -> . STRING
    (133) expression -> . IDENTIFIER PLUSPLUS
    (134) expression -> . IDENTIFIER MINUSMINUS
    (145) expression -> . map_type LBRACE expression_map_list RBRACE
    (146) expression -> . map_type LBRACE RBRACE
    (169) expression -> . type_name LBRACE keyed_element_list RBRACE
    (170) expression -> . type_name LBRACE RBRACE
    (56) slice_type -> . LBRACKET RBRACKET primitive_type
    (175) binary_expression -> . expression PLUS expression
    (176) binary_expression -> . expression MINUS expression
    (177) binary_expression -> . expression TIMES expression
    (178) binary_expression -> . expression DIVIDE expression
    (179) binary_expression -> . expression MODULE expression
    (184) relational_expression -> . expression EQ expression
    (185) relational_expression -> . expression NEQ expression
    (186) relational_expression -> . expression LT expression
    (187) relational_expression -> . expression LE expression
    (188) relational_expression -> . expression GT expression
    (189) relational_expression -> . expression GE expression
    (190) logical_expression -> . expression LAND expression
    (191) logical_expression -> . expression LOR expression
    (192) bitwise_expression -> . expression AND expression
    (193) bitwise_expression -> . expression OR expression
    (194) bitwise_expression -> . expression XOR expression
    (195) bitwise_expression -> . expression AND_NOT expression
    (196) bitwise_expression -> . expression LSHIFT expression
    (197) bitwise_expression -> . expression RSHIFT expression
    (144) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (171) type_name -> . IDENTIFIER
    (172) type_name -> . slice_type
    (173) type_name -> . array_type
    (174) type_name -> . map_type
    (119) array_type -> . LBRACKET INT RBRACKET type

    LPAREN          shift and go to state 54
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    LNOT            shift and go to state 61
    INT             shift and go to state 62
    FLOAT64         shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 66
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    expression                     shift and go to state 305
    slice_type                     shift and go to state 53
    binary_expression              shift and go to state 55
    relational_expression          shift and go to state 56
    logical_expression             shift and go to state 57
    bitwise_expression             shift and go to state 58
    map_type                       shift and go to state 67
    type_name                      shift and go to state 68
    array_type                     shift and go to state 69

state 280

    (135) if_statement -> IF expression block .
    (136) if_statement -> IF expression block . ELSE block
    (137) if_statement -> IF expression block . ELSE if_statement

    IDENTIFIER      reduce using rule 135 (if_statement -> IF expression block .)
    VAR             reduce using rule 135 (if_statement -> IF expression block .)
    CONST           reduce using rule 135 (if_statement -> IF expression block .)
    LPAREN          reduce using rule 135 (if_statement -> IF expression block .)
    PLUS            reduce using rule 135 (if_statement -> IF expression block .)
    MINUS           reduce using rule 135 (if_statement -> IF expression block .)
    LNOT            reduce using rule 135 (if_statement -> IF expression block .)
    INT             reduce using rule 135 (if_statement -> IF expression block .)
    FLOAT64         reduce using rule 135 (if_statement -> IF expression block .)
    TRUE            reduce using rule 135 (if_statement -> IF expression block .)
    FALSE           reduce using rule 135 (if_statement -> IF expression block .)
    STRING          reduce using rule 135 (if_statement -> IF expression block .)
    RETURN          reduce using rule 135 (if_statement -> IF expression block .)
    IF              reduce using rule 135 (if_statement -> IF expression block .)
    SWITCH          reduce using rule 135 (if_statement -> IF expression block .)
    BREAK           reduce using rule 135 (if_statement -> IF expression block .)
    CONTINUE        reduce using rule 135 (if_statement -> IF expression block .)
    LBRACKET        reduce using rule 135 (if_statement -> IF expression block .)
    MAP             reduce using rule 135 (if_statement -> IF expression block .)
    FOR             reduce using rule 135 (if_statement -> IF expression block .)
    RBRACE          reduce using rule 135 (if_statement -> IF expression block .)
    CASE            reduce using rule 135 (if_statement -> IF expression block .)
    DEFAULT         reduce using rule 135 (if_statement -> IF expression block .)
    ELSE            shift and go to state 306


state 281

    (138) if_statement -> IF if_assignment SEMICOLON . expression block
    (139) if_statement -> IF if_assignment SEMICOLON . expression block ELSE block
    (140) if_statement -> IF if_assignment SEMICOLON . expression block ELSE if_statement
    (57) expression -> . slice_type LBRACE expression_list RBRACE
    (58) expression -> . slice_type LBRACE RBRACE
    (61) expression -> . LPAREN expression RPAREN
    (120) expression -> . binary_expression
    (121) expression -> . relational_expression
    (122) expression -> . logical_expression
    (123) expression -> . bitwise_expression
    (124) expression -> . PLUS expression
    (125) expression -> . MINUS expression
    (126) expression -> . LNOT expression
    (127) expression -> . INT
    (128) expression -> . FLOAT64
    (129) expression -> . TRUE
    (130) expression -> . FALSE
    (131) expression -> . IDENTIFIER
    (132) expression -> . STRING
    (133) expression -> . IDENTIFIER PLUSPLUS
    (134) expression -> . IDENTIFIER MINUSMINUS
    (145) expression -> . map_type LBRACE expression_map_list RBRACE
    (146) expression -> . map_type LBRACE RBRACE
    (169) expression -> . type_name LBRACE keyed_element_list RBRACE
    (170) expression -> . type_name LBRACE RBRACE
    (56) slice_type -> . LBRACKET RBRACKET primitive_type
    (175) binary_expression -> . expression PLUS expression
    (176) binary_expression -> . expression MINUS expression
    (177) binary_expression -> . expression TIMES expression
    (178) binary_expression -> . expression DIVIDE expression
    (179) binary_expression -> . expression MODULE expression
    (184) relational_expression -> . expression EQ expression
    (185) relational_expression -> . expression NEQ expression
    (186) relational_expression -> . expression LT expression
    (187) relational_expression -> . expression LE expression
    (188) relational_expression -> . expression GT expression
    (189) relational_expression -> . expression GE expression
    (190) logical_expression -> . expression LAND expression
    (191) logical_expression -> . expression LOR expression
    (192) bitwise_expression -> . expression AND expression
    (193) bitwise_expression -> . expression OR expression
    (194) bitwise_expression -> . expression XOR expression
    (195) bitwise_expression -> . expression AND_NOT expression
    (196) bitwise_expression -> . expression LSHIFT expression
    (197) bitwise_expression -> . expression RSHIFT expression
    (144) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (171) type_name -> . IDENTIFIER
    (172) type_name -> . slice_type
    (173) type_name -> . array_type
    (174) type_name -> . map_type
    (119) array_type -> . LBRACKET INT RBRACKET type

    LPAREN          shift and go to state 54
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    LNOT            shift and go to state 61
    INT             shift and go to state 62
    FLOAT64         shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 66
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    expression                     shift and go to state 307
    slice_type                     shift and go to state 53
    binary_expression              shift and go to state 55
    relational_expression          shift and go to state 56
    logical_expression             shift and go to state 57
    bitwise_expression             shift and go to state 58
    map_type                       shift and go to state 67
    type_name                      shift and go to state 68
    array_type                     shift and go to state 69

state 282

    (51) simple_assignment -> IDENTIFIER ASSIGN . expression
    (57) expression -> . slice_type LBRACE expression_list RBRACE
    (58) expression -> . slice_type LBRACE RBRACE
    (61) expression -> . LPAREN expression RPAREN
    (120) expression -> . binary_expression
    (121) expression -> . relational_expression
    (122) expression -> . logical_expression
    (123) expression -> . bitwise_expression
    (124) expression -> . PLUS expression
    (125) expression -> . MINUS expression
    (126) expression -> . LNOT expression
    (127) expression -> . INT
    (128) expression -> . FLOAT64
    (129) expression -> . TRUE
    (130) expression -> . FALSE
    (131) expression -> . IDENTIFIER
    (132) expression -> . STRING
    (133) expression -> . IDENTIFIER PLUSPLUS
    (134) expression -> . IDENTIFIER MINUSMINUS
    (145) expression -> . map_type LBRACE expression_map_list RBRACE
    (146) expression -> . map_type LBRACE RBRACE
    (169) expression -> . type_name LBRACE keyed_element_list RBRACE
    (170) expression -> . type_name LBRACE RBRACE
    (56) slice_type -> . LBRACKET RBRACKET primitive_type
    (175) binary_expression -> . expression PLUS expression
    (176) binary_expression -> . expression MINUS expression
    (177) binary_expression -> . expression TIMES expression
    (178) binary_expression -> . expression DIVIDE expression
    (179) binary_expression -> . expression MODULE expression
    (184) relational_expression -> . expression EQ expression
    (185) relational_expression -> . expression NEQ expression
    (186) relational_expression -> . expression LT expression
    (187) relational_expression -> . expression LE expression
    (188) relational_expression -> . expression GT expression
    (189) relational_expression -> . expression GE expression
    (190) logical_expression -> . expression LAND expression
    (191) logical_expression -> . expression LOR expression
    (192) bitwise_expression -> . expression AND expression
    (193) bitwise_expression -> . expression OR expression
    (194) bitwise_expression -> . expression XOR expression
    (195) bitwise_expression -> . expression AND_NOT expression
    (196) bitwise_expression -> . expression LSHIFT expression
    (197) bitwise_expression -> . expression RSHIFT expression
    (144) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (171) type_name -> . IDENTIFIER
    (172) type_name -> . slice_type
    (173) type_name -> . array_type
    (174) type_name -> . map_type
    (119) array_type -> . LBRACKET INT RBRACKET type

    LPAREN          shift and go to state 54
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    LNOT            shift and go to state 61
    INT             shift and go to state 62
    FLOAT64         shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 66
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    expression                     shift and go to state 308
    slice_type                     shift and go to state 53
    binary_expression              shift and go to state 55
    relational_expression          shift and go to state 56
    logical_expression             shift and go to state 57
    bitwise_expression             shift and go to state 58
    map_type                       shift and go to state 67
    type_name                      shift and go to state 68
    array_type                     shift and go to state 69

state 283

    (62) short_assignment -> IDENTIFIER SHORT_ASSIGN . expression
    (57) expression -> . slice_type LBRACE expression_list RBRACE
    (58) expression -> . slice_type LBRACE RBRACE
    (61) expression -> . LPAREN expression RPAREN
    (120) expression -> . binary_expression
    (121) expression -> . relational_expression
    (122) expression -> . logical_expression
    (123) expression -> . bitwise_expression
    (124) expression -> . PLUS expression
    (125) expression -> . MINUS expression
    (126) expression -> . LNOT expression
    (127) expression -> . INT
    (128) expression -> . FLOAT64
    (129) expression -> . TRUE
    (130) expression -> . FALSE
    (131) expression -> . IDENTIFIER
    (132) expression -> . STRING
    (133) expression -> . IDENTIFIER PLUSPLUS
    (134) expression -> . IDENTIFIER MINUSMINUS
    (145) expression -> . map_type LBRACE expression_map_list RBRACE
    (146) expression -> . map_type LBRACE RBRACE
    (169) expression -> . type_name LBRACE keyed_element_list RBRACE
    (170) expression -> . type_name LBRACE RBRACE
    (56) slice_type -> . LBRACKET RBRACKET primitive_type
    (175) binary_expression -> . expression PLUS expression
    (176) binary_expression -> . expression MINUS expression
    (177) binary_expression -> . expression TIMES expression
    (178) binary_expression -> . expression DIVIDE expression
    (179) binary_expression -> . expression MODULE expression
    (184) relational_expression -> . expression EQ expression
    (185) relational_expression -> . expression NEQ expression
    (186) relational_expression -> . expression LT expression
    (187) relational_expression -> . expression LE expression
    (188) relational_expression -> . expression GT expression
    (189) relational_expression -> . expression GE expression
    (190) logical_expression -> . expression LAND expression
    (191) logical_expression -> . expression LOR expression
    (192) bitwise_expression -> . expression AND expression
    (193) bitwise_expression -> . expression OR expression
    (194) bitwise_expression -> . expression XOR expression
    (195) bitwise_expression -> . expression AND_NOT expression
    (196) bitwise_expression -> . expression LSHIFT expression
    (197) bitwise_expression -> . expression RSHIFT expression
    (144) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (171) type_name -> . IDENTIFIER
    (172) type_name -> . slice_type
    (173) type_name -> . array_type
    (174) type_name -> . map_type
    (119) array_type -> . LBRACKET INT RBRACKET type

    LPAREN          shift and go to state 54
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    LNOT            shift and go to state 61
    INT             shift and go to state 62
    FLOAT64         shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 66
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    expression                     shift and go to state 309
    slice_type                     shift and go to state 53
    binary_expression              shift and go to state 55
    relational_expression          shift and go to state 56
    logical_expression             shift and go to state 57
    bitwise_expression             shift and go to state 58
    map_type                       shift and go to state 67
    type_name                      shift and go to state 68
    array_type                     shift and go to state 69

state 284

    (35) local_var_dec -> VAR IDENTIFIER . type
    (36) local_var_dec -> VAR IDENTIFIER . type ASSIGN expression
    (37) local_var_dec -> VAR IDENTIFIER . ASSIGN expression
    (52) type -> . primitive_type
    (53) type -> . slice_type
    (54) type -> . array_type
    (55) type -> . map_type
    (115) primitive_type -> . INT_TYPE
    (116) primitive_type -> . FLOAT64_TYPE
    (117) primitive_type -> . STRING_TYPE
    (118) primitive_type -> . BOOL_TYPE
    (56) slice_type -> . LBRACKET RBRACKET primitive_type
    (119) array_type -> . LBRACKET INT RBRACKET type
    (144) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type

    ASSIGN          shift and go to state 311
    INT_TYPE        shift and go to state 34
    FLOAT64_TYPE    shift and go to state 35
    STRING_TYPE     shift and go to state 36
    BOOL_TYPE       shift and go to state 37
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    type                           shift and go to state 310
    primitive_type                 shift and go to state 30
    slice_type                     shift and go to state 31
    array_type                     shift and go to state 32
    map_type                       shift and go to state 33

state 285

    (228) switch_statement -> SWITCH enter_block switch_header . LBRACE case_clauses RBRACE exit_block

    LBRACE          shift and go to state 312


state 286

    (226) switch_header -> switch_expression .

    LBRACE          reduce using rule 226 (switch_header -> switch_expression .)


state 287

    (227) switch_header -> switch_init .

    LBRACE          reduce using rule 227 (switch_header -> switch_init .)


state 288

    (224) switch_expression -> switch_primary .

    LBRACE          reduce using rule 224 (switch_expression -> switch_primary .)


state 289

    (225) switch_expression -> empty .

    LBRACE          reduce using rule 225 (switch_expression -> empty .)


state 290

    (223) switch_init -> assignment . SEMICOLON switch_expression

    SEMICOLON       shift and go to state 313


state 291

    (217) switch_primary -> IDENTIFIER .
    (109) assignment -> IDENTIFIER . ASSIGN expression
    (110) assignment -> IDENTIFIER . SHORT_ASSIGN expression

    LBRACE          reduce using rule 217 (switch_primary -> IDENTIFIER .)
    ASSIGN          shift and go to state 231
    SHORT_ASSIGN    shift and go to state 232


state 292

    (218) switch_primary -> INT .

    LBRACE          reduce using rule 218 (switch_primary -> INT .)


state 293

    (219) switch_primary -> FLOAT64 .

    LBRACE          reduce using rule 219 (switch_primary -> FLOAT64 .)


state 294

    (220) switch_primary -> STRING .

    LBRACE          reduce using rule 220 (switch_primary -> STRING .)


state 295

    (221) switch_primary -> TRUE .

    LBRACE          reduce using rule 221 (switch_primary -> TRUE .)


state 296

    (222) switch_primary -> FALSE .

    LBRACE          reduce using rule 222 (switch_primary -> FALSE .)


state 297

    (81) for_classic -> FOR for_init SEMICOLON . for_cond SEMICOLON for_post block
    (88) for_cond -> . expression
    (89) for_cond -> . empty
    (57) expression -> . slice_type LBRACE expression_list RBRACE
    (58) expression -> . slice_type LBRACE RBRACE
    (61) expression -> . LPAREN expression RPAREN
    (120) expression -> . binary_expression
    (121) expression -> . relational_expression
    (122) expression -> . logical_expression
    (123) expression -> . bitwise_expression
    (124) expression -> . PLUS expression
    (125) expression -> . MINUS expression
    (126) expression -> . LNOT expression
    (127) expression -> . INT
    (128) expression -> . FLOAT64
    (129) expression -> . TRUE
    (130) expression -> . FALSE
    (131) expression -> . IDENTIFIER
    (132) expression -> . STRING
    (133) expression -> . IDENTIFIER PLUSPLUS
    (134) expression -> . IDENTIFIER MINUSMINUS
    (145) expression -> . map_type LBRACE expression_map_list RBRACE
    (146) expression -> . map_type LBRACE RBRACE
    (169) expression -> . type_name LBRACE keyed_element_list RBRACE
    (170) expression -> . type_name LBRACE RBRACE
    (7) empty -> .
    (56) slice_type -> . LBRACKET RBRACKET primitive_type
    (175) binary_expression -> . expression PLUS expression
    (176) binary_expression -> . expression MINUS expression
    (177) binary_expression -> . expression TIMES expression
    (178) binary_expression -> . expression DIVIDE expression
    (179) binary_expression -> . expression MODULE expression
    (184) relational_expression -> . expression EQ expression
    (185) relational_expression -> . expression NEQ expression
    (186) relational_expression -> . expression LT expression
    (187) relational_expression -> . expression LE expression
    (188) relational_expression -> . expression GT expression
    (189) relational_expression -> . expression GE expression
    (190) logical_expression -> . expression LAND expression
    (191) logical_expression -> . expression LOR expression
    (192) bitwise_expression -> . expression AND expression
    (193) bitwise_expression -> . expression OR expression
    (194) bitwise_expression -> . expression XOR expression
    (195) bitwise_expression -> . expression AND_NOT expression
    (196) bitwise_expression -> . expression LSHIFT expression
    (197) bitwise_expression -> . expression RSHIFT expression
    (144) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (171) type_name -> . IDENTIFIER
    (172) type_name -> . slice_type
    (173) type_name -> . array_type
    (174) type_name -> . map_type
    (119) array_type -> . LBRACKET INT RBRACKET type

    LPAREN          shift and go to state 54
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    LNOT            shift and go to state 61
    INT             shift and go to state 62
    FLOAT64         shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 66
    SEMICOLON       reduce using rule 7 (empty -> .)
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    for_cond                       shift and go to state 314
    expression                     shift and go to state 315
    empty                          shift and go to state 316
    slice_type                     shift and go to state 53
    binary_expression              shift and go to state 55
    relational_expression          shift and go to state 56
    logical_expression             shift and go to state 57
    bitwise_expression             shift and go to state 58
    map_type                       shift and go to state 67
    type_name                      shift and go to state 68
    array_type                     shift and go to state 69

state 298

    (82) for_condition -> FOR expression block .

    IDENTIFIER      reduce using rule 82 (for_condition -> FOR expression block .)
    VAR             reduce using rule 82 (for_condition -> FOR expression block .)
    CONST           reduce using rule 82 (for_condition -> FOR expression block .)
    LPAREN          reduce using rule 82 (for_condition -> FOR expression block .)
    PLUS            reduce using rule 82 (for_condition -> FOR expression block .)
    MINUS           reduce using rule 82 (for_condition -> FOR expression block .)
    LNOT            reduce using rule 82 (for_condition -> FOR expression block .)
    INT             reduce using rule 82 (for_condition -> FOR expression block .)
    FLOAT64         reduce using rule 82 (for_condition -> FOR expression block .)
    TRUE            reduce using rule 82 (for_condition -> FOR expression block .)
    FALSE           reduce using rule 82 (for_condition -> FOR expression block .)
    STRING          reduce using rule 82 (for_condition -> FOR expression block .)
    RETURN          reduce using rule 82 (for_condition -> FOR expression block .)
    IF              reduce using rule 82 (for_condition -> FOR expression block .)
    SWITCH          reduce using rule 82 (for_condition -> FOR expression block .)
    BREAK           reduce using rule 82 (for_condition -> FOR expression block .)
    CONTINUE        reduce using rule 82 (for_condition -> FOR expression block .)
    LBRACKET        reduce using rule 82 (for_condition -> FOR expression block .)
    MAP             reduce using rule 82 (for_condition -> FOR expression block .)
    FOR             reduce using rule 82 (for_condition -> FOR expression block .)
    RBRACE          reduce using rule 82 (for_condition -> FOR expression block .)
    CASE            reduce using rule 82 (for_condition -> FOR expression block .)
    DEFAULT         reduce using rule 82 (for_condition -> FOR expression block .)


state 299

    (229) print_expression -> IDENTIFIER DOT IDENTIFIER LPAREN . argument_list RPAREN
    (230) input_expression -> IDENTIFIER DOT IDENTIFIER LPAREN . AND IDENTIFIER COMMA argument_list RPAREN
    (231) argument_list -> . expression_list
    (232) argument_list -> . empty
    (59) expression_list -> . expression
    (60) expression_list -> . expression_list COMMA expression
    (7) empty -> .
    (57) expression -> . slice_type LBRACE expression_list RBRACE
    (58) expression -> . slice_type LBRACE RBRACE
    (61) expression -> . LPAREN expression RPAREN
    (120) expression -> . binary_expression
    (121) expression -> . relational_expression
    (122) expression -> . logical_expression
    (123) expression -> . bitwise_expression
    (124) expression -> . PLUS expression
    (125) expression -> . MINUS expression
    (126) expression -> . LNOT expression
    (127) expression -> . INT
    (128) expression -> . FLOAT64
    (129) expression -> . TRUE
    (130) expression -> . FALSE
    (131) expression -> . IDENTIFIER
    (132) expression -> . STRING
    (133) expression -> . IDENTIFIER PLUSPLUS
    (134) expression -> . IDENTIFIER MINUSMINUS
    (145) expression -> . map_type LBRACE expression_map_list RBRACE
    (146) expression -> . map_type LBRACE RBRACE
    (169) expression -> . type_name LBRACE keyed_element_list RBRACE
    (170) expression -> . type_name LBRACE RBRACE
    (56) slice_type -> . LBRACKET RBRACKET primitive_type
    (175) binary_expression -> . expression PLUS expression
    (176) binary_expression -> . expression MINUS expression
    (177) binary_expression -> . expression TIMES expression
    (178) binary_expression -> . expression DIVIDE expression
    (179) binary_expression -> . expression MODULE expression
    (184) relational_expression -> . expression EQ expression
    (185) relational_expression -> . expression NEQ expression
    (186) relational_expression -> . expression LT expression
    (187) relational_expression -> . expression LE expression
    (188) relational_expression -> . expression GT expression
    (189) relational_expression -> . expression GE expression
    (190) logical_expression -> . expression LAND expression
    (191) logical_expression -> . expression LOR expression
    (192) bitwise_expression -> . expression AND expression
    (193) bitwise_expression -> . expression OR expression
    (194) bitwise_expression -> . expression XOR expression
    (195) bitwise_expression -> . expression AND_NOT expression
    (196) bitwise_expression -> . expression LSHIFT expression
    (197) bitwise_expression -> . expression RSHIFT expression
    (144) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (171) type_name -> . IDENTIFIER
    (172) type_name -> . slice_type
    (173) type_name -> . array_type
    (174) type_name -> . map_type
    (119) array_type -> . LBRACKET INT RBRACKET type

    AND             shift and go to state 318
    RPAREN          reduce using rule 7 (empty -> .)
    LPAREN          shift and go to state 54
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    LNOT            shift and go to state 61
    INT             shift and go to state 62
    FLOAT64         shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 66
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    argument_list                  shift and go to state 317
    expression_list                shift and go to state 273
    empty                          shift and go to state 274
    expression                     shift and go to state 148
    slice_type                     shift and go to state 53
    binary_expression              shift and go to state 55
    relational_expression          shift and go to state 56
    logical_expression             shift and go to state 57
    bitwise_expression             shift and go to state 58
    map_type                       shift and go to state 67
    type_name                      shift and go to state 68
    array_type                     shift and go to state 69

state 300

    (201) func_call_expression -> IDENTIFIER LPAREN argument_list RPAREN .

    IDENTIFIER      reduce using rule 201 (func_call_expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    VAR             reduce using rule 201 (func_call_expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    CONST           reduce using rule 201 (func_call_expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    LPAREN          reduce using rule 201 (func_call_expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    PLUS            reduce using rule 201 (func_call_expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    MINUS           reduce using rule 201 (func_call_expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    LNOT            reduce using rule 201 (func_call_expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    INT             reduce using rule 201 (func_call_expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    FLOAT64         reduce using rule 201 (func_call_expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    TRUE            reduce using rule 201 (func_call_expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    FALSE           reduce using rule 201 (func_call_expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    STRING          reduce using rule 201 (func_call_expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    RETURN          reduce using rule 201 (func_call_expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    IF              reduce using rule 201 (func_call_expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    SWITCH          reduce using rule 201 (func_call_expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    BREAK           reduce using rule 201 (func_call_expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    CONTINUE        reduce using rule 201 (func_call_expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    LBRACKET        reduce using rule 201 (func_call_expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    MAP             reduce using rule 201 (func_call_expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    FOR             reduce using rule 201 (func_call_expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    RBRACE          reduce using rule 201 (func_call_expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    CASE            reduce using rule 201 (func_call_expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    DEFAULT         reduce using rule 201 (func_call_expression -> IDENTIFIER LPAREN argument_list RPAREN .)


state 301

    (111) variable_declaration -> VAR IDENTIFIER type ASSIGN . expression
    (57) expression -> . slice_type LBRACE expression_list RBRACE
    (58) expression -> . slice_type LBRACE RBRACE
    (61) expression -> . LPAREN expression RPAREN
    (120) expression -> . binary_expression
    (121) expression -> . relational_expression
    (122) expression -> . logical_expression
    (123) expression -> . bitwise_expression
    (124) expression -> . PLUS expression
    (125) expression -> . MINUS expression
    (126) expression -> . LNOT expression
    (127) expression -> . INT
    (128) expression -> . FLOAT64
    (129) expression -> . TRUE
    (130) expression -> . FALSE
    (131) expression -> . IDENTIFIER
    (132) expression -> . STRING
    (133) expression -> . IDENTIFIER PLUSPLUS
    (134) expression -> . IDENTIFIER MINUSMINUS
    (145) expression -> . map_type LBRACE expression_map_list RBRACE
    (146) expression -> . map_type LBRACE RBRACE
    (169) expression -> . type_name LBRACE keyed_element_list RBRACE
    (170) expression -> . type_name LBRACE RBRACE
    (56) slice_type -> . LBRACKET RBRACKET primitive_type
    (175) binary_expression -> . expression PLUS expression
    (176) binary_expression -> . expression MINUS expression
    (177) binary_expression -> . expression TIMES expression
    (178) binary_expression -> . expression DIVIDE expression
    (179) binary_expression -> . expression MODULE expression
    (184) relational_expression -> . expression EQ expression
    (185) relational_expression -> . expression NEQ expression
    (186) relational_expression -> . expression LT expression
    (187) relational_expression -> . expression LE expression
    (188) relational_expression -> . expression GT expression
    (189) relational_expression -> . expression GE expression
    (190) logical_expression -> . expression LAND expression
    (191) logical_expression -> . expression LOR expression
    (192) bitwise_expression -> . expression AND expression
    (193) bitwise_expression -> . expression OR expression
    (194) bitwise_expression -> . expression XOR expression
    (195) bitwise_expression -> . expression AND_NOT expression
    (196) bitwise_expression -> . expression LSHIFT expression
    (197) bitwise_expression -> . expression RSHIFT expression
    (144) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (171) type_name -> . IDENTIFIER
    (172) type_name -> . slice_type
    (173) type_name -> . array_type
    (174) type_name -> . map_type
    (119) array_type -> . LBRACKET INT RBRACKET type

    LPAREN          shift and go to state 54
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    LNOT            shift and go to state 61
    INT             shift and go to state 62
    FLOAT64         shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 66
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    expression                     shift and go to state 319
    slice_type                     shift and go to state 53
    binary_expression              shift and go to state 55
    relational_expression          shift and go to state 56
    logical_expression             shift and go to state 57
    bitwise_expression             shift and go to state 58
    map_type                       shift and go to state 67
    type_name                      shift and go to state 68
    array_type                     shift and go to state 69

state 302

    (113) variable_declaration -> VAR IDENTIFIER ASSIGN expression .
    (175) binary_expression -> expression . PLUS expression
    (176) binary_expression -> expression . MINUS expression
    (177) binary_expression -> expression . TIMES expression
    (178) binary_expression -> expression . DIVIDE expression
    (179) binary_expression -> expression . MODULE expression
    (184) relational_expression -> expression . EQ expression
    (185) relational_expression -> expression . NEQ expression
    (186) relational_expression -> expression . LT expression
    (187) relational_expression -> expression . LE expression
    (188) relational_expression -> expression . GT expression
    (189) relational_expression -> expression . GE expression
    (190) logical_expression -> expression . LAND expression
    (191) logical_expression -> expression . LOR expression
    (192) bitwise_expression -> expression . AND expression
    (193) bitwise_expression -> expression . OR expression
    (194) bitwise_expression -> expression . XOR expression
    (195) bitwise_expression -> expression . AND_NOT expression
    (196) bitwise_expression -> expression . LSHIFT expression
    (197) bitwise_expression -> expression . RSHIFT expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    IDENTIFIER      reduce using rule 113 (variable_declaration -> VAR IDENTIFIER ASSIGN expression .)
    VAR             reduce using rule 113 (variable_declaration -> VAR IDENTIFIER ASSIGN expression .)
    CONST           reduce using rule 113 (variable_declaration -> VAR IDENTIFIER ASSIGN expression .)
    LPAREN          reduce using rule 113 (variable_declaration -> VAR IDENTIFIER ASSIGN expression .)
    LNOT            reduce using rule 113 (variable_declaration -> VAR IDENTIFIER ASSIGN expression .)
    INT             reduce using rule 113 (variable_declaration -> VAR IDENTIFIER ASSIGN expression .)
    FLOAT64         reduce using rule 113 (variable_declaration -> VAR IDENTIFIER ASSIGN expression .)
    TRUE            reduce using rule 113 (variable_declaration -> VAR IDENTIFIER ASSIGN expression .)
    FALSE           reduce using rule 113 (variable_declaration -> VAR IDENTIFIER ASSIGN expression .)
    STRING          reduce using rule 113 (variable_declaration -> VAR IDENTIFIER ASSIGN expression .)
    RETURN          reduce using rule 113 (variable_declaration -> VAR IDENTIFIER ASSIGN expression .)
    IF              reduce using rule 113 (variable_declaration -> VAR IDENTIFIER ASSIGN expression .)
    SWITCH          reduce using rule 113 (variable_declaration -> VAR IDENTIFIER ASSIGN expression .)
    BREAK           reduce using rule 113 (variable_declaration -> VAR IDENTIFIER ASSIGN expression .)
    CONTINUE        reduce using rule 113 (variable_declaration -> VAR IDENTIFIER ASSIGN expression .)
    LBRACKET        reduce using rule 113 (variable_declaration -> VAR IDENTIFIER ASSIGN expression .)
    MAP             reduce using rule 113 (variable_declaration -> VAR IDENTIFIER ASSIGN expression .)
    FOR             reduce using rule 113 (variable_declaration -> VAR IDENTIFIER ASSIGN expression .)
    RBRACE          reduce using rule 113 (variable_declaration -> VAR IDENTIFIER ASSIGN expression .)
    CASE            reduce using rule 113 (variable_declaration -> VAR IDENTIFIER ASSIGN expression .)
    DEFAULT         reduce using rule 113 (variable_declaration -> VAR IDENTIFIER ASSIGN expression .)
    PLUS            shift and go to state 86
    MINUS           shift and go to state 87
    TIMES           shift and go to state 88
    DIVIDE          shift and go to state 89
    MODULE          shift and go to state 90
    EQ              shift and go to state 91
    NEQ             shift and go to state 92
    LT              shift and go to state 93
    LE              shift and go to state 94
    GT              shift and go to state 95
    GE              shift and go to state 96
    LAND            shift and go to state 97
    LOR             shift and go to state 98
    AND             shift and go to state 99
    OR              shift and go to state 100
    XOR             shift and go to state 101
    AND_NOT         shift and go to state 102
    LSHIFT          shift and go to state 103
    RSHIFT          shift and go to state 104

  ! PLUS            [ reduce using rule 113 (variable_declaration -> VAR IDENTIFIER ASSIGN expression .) ]
  ! MINUS           [ reduce using rule 113 (variable_declaration -> VAR IDENTIFIER ASSIGN expression .) ]


state 303

    (112) variable_declaration -> CONST IDENTIFIER type ASSIGN . expression
    (57) expression -> . slice_type LBRACE expression_list RBRACE
    (58) expression -> . slice_type LBRACE RBRACE
    (61) expression -> . LPAREN expression RPAREN
    (120) expression -> . binary_expression
    (121) expression -> . relational_expression
    (122) expression -> . logical_expression
    (123) expression -> . bitwise_expression
    (124) expression -> . PLUS expression
    (125) expression -> . MINUS expression
    (126) expression -> . LNOT expression
    (127) expression -> . INT
    (128) expression -> . FLOAT64
    (129) expression -> . TRUE
    (130) expression -> . FALSE
    (131) expression -> . IDENTIFIER
    (132) expression -> . STRING
    (133) expression -> . IDENTIFIER PLUSPLUS
    (134) expression -> . IDENTIFIER MINUSMINUS
    (145) expression -> . map_type LBRACE expression_map_list RBRACE
    (146) expression -> . map_type LBRACE RBRACE
    (169) expression -> . type_name LBRACE keyed_element_list RBRACE
    (170) expression -> . type_name LBRACE RBRACE
    (56) slice_type -> . LBRACKET RBRACKET primitive_type
    (175) binary_expression -> . expression PLUS expression
    (176) binary_expression -> . expression MINUS expression
    (177) binary_expression -> . expression TIMES expression
    (178) binary_expression -> . expression DIVIDE expression
    (179) binary_expression -> . expression MODULE expression
    (184) relational_expression -> . expression EQ expression
    (185) relational_expression -> . expression NEQ expression
    (186) relational_expression -> . expression LT expression
    (187) relational_expression -> . expression LE expression
    (188) relational_expression -> . expression GT expression
    (189) relational_expression -> . expression GE expression
    (190) logical_expression -> . expression LAND expression
    (191) logical_expression -> . expression LOR expression
    (192) bitwise_expression -> . expression AND expression
    (193) bitwise_expression -> . expression OR expression
    (194) bitwise_expression -> . expression XOR expression
    (195) bitwise_expression -> . expression AND_NOT expression
    (196) bitwise_expression -> . expression LSHIFT expression
    (197) bitwise_expression -> . expression RSHIFT expression
    (144) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (171) type_name -> . IDENTIFIER
    (172) type_name -> . slice_type
    (173) type_name -> . array_type
    (174) type_name -> . map_type
    (119) array_type -> . LBRACKET INT RBRACKET type

    LPAREN          shift and go to state 54
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    LNOT            shift and go to state 61
    INT             shift and go to state 62
    FLOAT64         shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 66
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    expression                     shift and go to state 320
    slice_type                     shift and go to state 53
    binary_expression              shift and go to state 55
    relational_expression          shift and go to state 56
    logical_expression             shift and go to state 57
    bitwise_expression             shift and go to state 58
    map_type                       shift and go to state 67
    type_name                      shift and go to state 68
    array_type                     shift and go to state 69

state 304

    (114) variable_declaration -> CONST IDENTIFIER ASSIGN expression .
    (175) binary_expression -> expression . PLUS expression
    (176) binary_expression -> expression . MINUS expression
    (177) binary_expression -> expression . TIMES expression
    (178) binary_expression -> expression . DIVIDE expression
    (179) binary_expression -> expression . MODULE expression
    (184) relational_expression -> expression . EQ expression
    (185) relational_expression -> expression . NEQ expression
    (186) relational_expression -> expression . LT expression
    (187) relational_expression -> expression . LE expression
    (188) relational_expression -> expression . GT expression
    (189) relational_expression -> expression . GE expression
    (190) logical_expression -> expression . LAND expression
    (191) logical_expression -> expression . LOR expression
    (192) bitwise_expression -> expression . AND expression
    (193) bitwise_expression -> expression . OR expression
    (194) bitwise_expression -> expression . XOR expression
    (195) bitwise_expression -> expression . AND_NOT expression
    (196) bitwise_expression -> expression . LSHIFT expression
    (197) bitwise_expression -> expression . RSHIFT expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    IDENTIFIER      reduce using rule 114 (variable_declaration -> CONST IDENTIFIER ASSIGN expression .)
    VAR             reduce using rule 114 (variable_declaration -> CONST IDENTIFIER ASSIGN expression .)
    CONST           reduce using rule 114 (variable_declaration -> CONST IDENTIFIER ASSIGN expression .)
    LPAREN          reduce using rule 114 (variable_declaration -> CONST IDENTIFIER ASSIGN expression .)
    LNOT            reduce using rule 114 (variable_declaration -> CONST IDENTIFIER ASSIGN expression .)
    INT             reduce using rule 114 (variable_declaration -> CONST IDENTIFIER ASSIGN expression .)
    FLOAT64         reduce using rule 114 (variable_declaration -> CONST IDENTIFIER ASSIGN expression .)
    TRUE            reduce using rule 114 (variable_declaration -> CONST IDENTIFIER ASSIGN expression .)
    FALSE           reduce using rule 114 (variable_declaration -> CONST IDENTIFIER ASSIGN expression .)
    STRING          reduce using rule 114 (variable_declaration -> CONST IDENTIFIER ASSIGN expression .)
    RETURN          reduce using rule 114 (variable_declaration -> CONST IDENTIFIER ASSIGN expression .)
    IF              reduce using rule 114 (variable_declaration -> CONST IDENTIFIER ASSIGN expression .)
    SWITCH          reduce using rule 114 (variable_declaration -> CONST IDENTIFIER ASSIGN expression .)
    BREAK           reduce using rule 114 (variable_declaration -> CONST IDENTIFIER ASSIGN expression .)
    CONTINUE        reduce using rule 114 (variable_declaration -> CONST IDENTIFIER ASSIGN expression .)
    LBRACKET        reduce using rule 114 (variable_declaration -> CONST IDENTIFIER ASSIGN expression .)
    MAP             reduce using rule 114 (variable_declaration -> CONST IDENTIFIER ASSIGN expression .)
    FOR             reduce using rule 114 (variable_declaration -> CONST IDENTIFIER ASSIGN expression .)
    RBRACE          reduce using rule 114 (variable_declaration -> CONST IDENTIFIER ASSIGN expression .)
    CASE            reduce using rule 114 (variable_declaration -> CONST IDENTIFIER ASSIGN expression .)
    DEFAULT         reduce using rule 114 (variable_declaration -> CONST IDENTIFIER ASSIGN expression .)
    PLUS            shift and go to state 86
    MINUS           shift and go to state 87
    TIMES           shift and go to state 88
    DIVIDE          shift and go to state 89
    MODULE          shift and go to state 90
    EQ              shift and go to state 91
    NEQ             shift and go to state 92
    LT              shift and go to state 93
    LE              shift and go to state 94
    GT              shift and go to state 95
    GE              shift and go to state 96
    LAND            shift and go to state 97
    LOR             shift and go to state 98
    AND             shift and go to state 99
    OR              shift and go to state 100
    XOR             shift and go to state 101
    AND_NOT         shift and go to state 102
    LSHIFT          shift and go to state 103
    RSHIFT          shift and go to state 104

  ! PLUS            [ reduce using rule 114 (variable_declaration -> CONST IDENTIFIER ASSIGN expression .) ]
  ! MINUS           [ reduce using rule 114 (variable_declaration -> CONST IDENTIFIER ASSIGN expression .) ]


state 305

    (95) return_list -> return_list COMMA expression .
    (175) binary_expression -> expression . PLUS expression
    (176) binary_expression -> expression . MINUS expression
    (177) binary_expression -> expression . TIMES expression
    (178) binary_expression -> expression . DIVIDE expression
    (179) binary_expression -> expression . MODULE expression
    (184) relational_expression -> expression . EQ expression
    (185) relational_expression -> expression . NEQ expression
    (186) relational_expression -> expression . LT expression
    (187) relational_expression -> expression . LE expression
    (188) relational_expression -> expression . GT expression
    (189) relational_expression -> expression . GE expression
    (190) logical_expression -> expression . LAND expression
    (191) logical_expression -> expression . LOR expression
    (192) bitwise_expression -> expression . AND expression
    (193) bitwise_expression -> expression . OR expression
    (194) bitwise_expression -> expression . XOR expression
    (195) bitwise_expression -> expression . AND_NOT expression
    (196) bitwise_expression -> expression . LSHIFT expression
    (197) bitwise_expression -> expression . RSHIFT expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    COMMA           reduce using rule 95 (return_list -> return_list COMMA expression .)
    IDENTIFIER      reduce using rule 95 (return_list -> return_list COMMA expression .)
    VAR             reduce using rule 95 (return_list -> return_list COMMA expression .)
    CONST           reduce using rule 95 (return_list -> return_list COMMA expression .)
    LPAREN          reduce using rule 95 (return_list -> return_list COMMA expression .)
    LNOT            reduce using rule 95 (return_list -> return_list COMMA expression .)
    INT             reduce using rule 95 (return_list -> return_list COMMA expression .)
    FLOAT64         reduce using rule 95 (return_list -> return_list COMMA expression .)
    TRUE            reduce using rule 95 (return_list -> return_list COMMA expression .)
    FALSE           reduce using rule 95 (return_list -> return_list COMMA expression .)
    STRING          reduce using rule 95 (return_list -> return_list COMMA expression .)
    RETURN          reduce using rule 95 (return_list -> return_list COMMA expression .)
    IF              reduce using rule 95 (return_list -> return_list COMMA expression .)
    SWITCH          reduce using rule 95 (return_list -> return_list COMMA expression .)
    BREAK           reduce using rule 95 (return_list -> return_list COMMA expression .)
    CONTINUE        reduce using rule 95 (return_list -> return_list COMMA expression .)
    LBRACKET        reduce using rule 95 (return_list -> return_list COMMA expression .)
    MAP             reduce using rule 95 (return_list -> return_list COMMA expression .)
    FOR             reduce using rule 95 (return_list -> return_list COMMA expression .)
    RBRACE          reduce using rule 95 (return_list -> return_list COMMA expression .)
    CASE            reduce using rule 95 (return_list -> return_list COMMA expression .)
    DEFAULT         reduce using rule 95 (return_list -> return_list COMMA expression .)
    PLUS            shift and go to state 86
    MINUS           shift and go to state 87
    TIMES           shift and go to state 88
    DIVIDE          shift and go to state 89
    MODULE          shift and go to state 90
    EQ              shift and go to state 91
    NEQ             shift and go to state 92
    LT              shift and go to state 93
    LE              shift and go to state 94
    GT              shift and go to state 95
    GE              shift and go to state 96
    LAND            shift and go to state 97
    LOR             shift and go to state 98
    AND             shift and go to state 99
    OR              shift and go to state 100
    XOR             shift and go to state 101
    AND_NOT         shift and go to state 102
    LSHIFT          shift and go to state 103
    RSHIFT          shift and go to state 104

  ! PLUS            [ reduce using rule 95 (return_list -> return_list COMMA expression .) ]
  ! MINUS           [ reduce using rule 95 (return_list -> return_list COMMA expression .) ]


state 306

    (136) if_statement -> IF expression block ELSE . block
    (137) if_statement -> IF expression block ELSE . if_statement
    (15) block -> . LBRACE enter_block exit_block RBRACE
    (16) block -> . LBRACE enter_block statement_list exit_block RBRACE
    (135) if_statement -> . IF expression block
    (136) if_statement -> . IF expression block ELSE block
    (137) if_statement -> . IF expression block ELSE if_statement
    (138) if_statement -> . IF if_assignment SEMICOLON expression block
    (139) if_statement -> . IF if_assignment SEMICOLON expression block ELSE block
    (140) if_statement -> . IF if_assignment SEMICOLON expression block ELSE if_statement

    LBRACE          shift and go to state 185
    IF              shift and go to state 219

    block                          shift and go to state 321
    if_statement                   shift and go to state 322

state 307

    (138) if_statement -> IF if_assignment SEMICOLON expression . block
    (139) if_statement -> IF if_assignment SEMICOLON expression . block ELSE block
    (140) if_statement -> IF if_assignment SEMICOLON expression . block ELSE if_statement
    (175) binary_expression -> expression . PLUS expression
    (176) binary_expression -> expression . MINUS expression
    (177) binary_expression -> expression . TIMES expression
    (178) binary_expression -> expression . DIVIDE expression
    (179) binary_expression -> expression . MODULE expression
    (184) relational_expression -> expression . EQ expression
    (185) relational_expression -> expression . NEQ expression
    (186) relational_expression -> expression . LT expression
    (187) relational_expression -> expression . LE expression
    (188) relational_expression -> expression . GT expression
    (189) relational_expression -> expression . GE expression
    (190) logical_expression -> expression . LAND expression
    (191) logical_expression -> expression . LOR expression
    (192) bitwise_expression -> expression . AND expression
    (193) bitwise_expression -> expression . OR expression
    (194) bitwise_expression -> expression . XOR expression
    (195) bitwise_expression -> expression . AND_NOT expression
    (196) bitwise_expression -> expression . LSHIFT expression
    (197) bitwise_expression -> expression . RSHIFT expression
    (15) block -> . LBRACE enter_block exit_block RBRACE
    (16) block -> . LBRACE enter_block statement_list exit_block RBRACE

    PLUS            shift and go to state 86
    MINUS           shift and go to state 87
    TIMES           shift and go to state 88
    DIVIDE          shift and go to state 89
    MODULE          shift and go to state 90
    EQ              shift and go to state 91
    NEQ             shift and go to state 92
    LT              shift and go to state 93
    LE              shift and go to state 94
    GT              shift and go to state 95
    GE              shift and go to state 96
    LAND            shift and go to state 97
    LOR             shift and go to state 98
    AND             shift and go to state 99
    OR              shift and go to state 100
    XOR             shift and go to state 101
    AND_NOT         shift and go to state 102
    LSHIFT          shift and go to state 103
    RSHIFT          shift and go to state 104
    LBRACE          shift and go to state 185

    block                          shift and go to state 323

state 308

    (51) simple_assignment -> IDENTIFIER ASSIGN expression .
    (175) binary_expression -> expression . PLUS expression
    (176) binary_expression -> expression . MINUS expression
    (177) binary_expression -> expression . TIMES expression
    (178) binary_expression -> expression . DIVIDE expression
    (179) binary_expression -> expression . MODULE expression
    (184) relational_expression -> expression . EQ expression
    (185) relational_expression -> expression . NEQ expression
    (186) relational_expression -> expression . LT expression
    (187) relational_expression -> expression . LE expression
    (188) relational_expression -> expression . GT expression
    (189) relational_expression -> expression . GE expression
    (190) logical_expression -> expression . LAND expression
    (191) logical_expression -> expression . LOR expression
    (192) bitwise_expression -> expression . AND expression
    (193) bitwise_expression -> expression . OR expression
    (194) bitwise_expression -> expression . XOR expression
    (195) bitwise_expression -> expression . AND_NOT expression
    (196) bitwise_expression -> expression . LSHIFT expression
    (197) bitwise_expression -> expression . RSHIFT expression

    SEMICOLON       reduce using rule 51 (simple_assignment -> IDENTIFIER ASSIGN expression .)
    LBRACE          reduce using rule 51 (simple_assignment -> IDENTIFIER ASSIGN expression .)
    PLUS            shift and go to state 86
    MINUS           shift and go to state 87
    TIMES           shift and go to state 88
    DIVIDE          shift and go to state 89
    MODULE          shift and go to state 90
    EQ              shift and go to state 91
    NEQ             shift and go to state 92
    LT              shift and go to state 93
    LE              shift and go to state 94
    GT              shift and go to state 95
    GE              shift and go to state 96
    LAND            shift and go to state 97
    LOR             shift and go to state 98
    AND             shift and go to state 99
    OR              shift and go to state 100
    XOR             shift and go to state 101
    AND_NOT         shift and go to state 102
    LSHIFT          shift and go to state 103
    RSHIFT          shift and go to state 104


state 309

    (62) short_assignment -> IDENTIFIER SHORT_ASSIGN expression .
    (175) binary_expression -> expression . PLUS expression
    (176) binary_expression -> expression . MINUS expression
    (177) binary_expression -> expression . TIMES expression
    (178) binary_expression -> expression . DIVIDE expression
    (179) binary_expression -> expression . MODULE expression
    (184) relational_expression -> expression . EQ expression
    (185) relational_expression -> expression . NEQ expression
    (186) relational_expression -> expression . LT expression
    (187) relational_expression -> expression . LE expression
    (188) relational_expression -> expression . GT expression
    (189) relational_expression -> expression . GE expression
    (190) logical_expression -> expression . LAND expression
    (191) logical_expression -> expression . LOR expression
    (192) bitwise_expression -> expression . AND expression
    (193) bitwise_expression -> expression . OR expression
    (194) bitwise_expression -> expression . XOR expression
    (195) bitwise_expression -> expression . AND_NOT expression
    (196) bitwise_expression -> expression . LSHIFT expression
    (197) bitwise_expression -> expression . RSHIFT expression

    SEMICOLON       reduce using rule 62 (short_assignment -> IDENTIFIER SHORT_ASSIGN expression .)
    PLUS            shift and go to state 86
    MINUS           shift and go to state 87
    TIMES           shift and go to state 88
    DIVIDE          shift and go to state 89
    MODULE          shift and go to state 90
    EQ              shift and go to state 91
    NEQ             shift and go to state 92
    LT              shift and go to state 93
    LE              shift and go to state 94
    GT              shift and go to state 95
    GE              shift and go to state 96
    LAND            shift and go to state 97
    LOR             shift and go to state 98
    AND             shift and go to state 99
    OR              shift and go to state 100
    XOR             shift and go to state 101
    AND_NOT         shift and go to state 102
    LSHIFT          shift and go to state 103
    RSHIFT          shift and go to state 104


state 310

    (35) local_var_dec -> VAR IDENTIFIER type .
    (36) local_var_dec -> VAR IDENTIFIER type . ASSIGN expression

    SEMICOLON       reduce using rule 35 (local_var_dec -> VAR IDENTIFIER type .)
    ASSIGN          shift and go to state 324


state 311

    (37) local_var_dec -> VAR IDENTIFIER ASSIGN . expression
    (57) expression -> . slice_type LBRACE expression_list RBRACE
    (58) expression -> . slice_type LBRACE RBRACE
    (61) expression -> . LPAREN expression RPAREN
    (120) expression -> . binary_expression
    (121) expression -> . relational_expression
    (122) expression -> . logical_expression
    (123) expression -> . bitwise_expression
    (124) expression -> . PLUS expression
    (125) expression -> . MINUS expression
    (126) expression -> . LNOT expression
    (127) expression -> . INT
    (128) expression -> . FLOAT64
    (129) expression -> . TRUE
    (130) expression -> . FALSE
    (131) expression -> . IDENTIFIER
    (132) expression -> . STRING
    (133) expression -> . IDENTIFIER PLUSPLUS
    (134) expression -> . IDENTIFIER MINUSMINUS
    (145) expression -> . map_type LBRACE expression_map_list RBRACE
    (146) expression -> . map_type LBRACE RBRACE
    (169) expression -> . type_name LBRACE keyed_element_list RBRACE
    (170) expression -> . type_name LBRACE RBRACE
    (56) slice_type -> . LBRACKET RBRACKET primitive_type
    (175) binary_expression -> . expression PLUS expression
    (176) binary_expression -> . expression MINUS expression
    (177) binary_expression -> . expression TIMES expression
    (178) binary_expression -> . expression DIVIDE expression
    (179) binary_expression -> . expression MODULE expression
    (184) relational_expression -> . expression EQ expression
    (185) relational_expression -> . expression NEQ expression
    (186) relational_expression -> . expression LT expression
    (187) relational_expression -> . expression LE expression
    (188) relational_expression -> . expression GT expression
    (189) relational_expression -> . expression GE expression
    (190) logical_expression -> . expression LAND expression
    (191) logical_expression -> . expression LOR expression
    (192) bitwise_expression -> . expression AND expression
    (193) bitwise_expression -> . expression OR expression
    (194) bitwise_expression -> . expression XOR expression
    (195) bitwise_expression -> . expression AND_NOT expression
    (196) bitwise_expression -> . expression LSHIFT expression
    (197) bitwise_expression -> . expression RSHIFT expression
    (144) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (171) type_name -> . IDENTIFIER
    (172) type_name -> . slice_type
    (173) type_name -> . array_type
    (174) type_name -> . map_type
    (119) array_type -> . LBRACKET INT RBRACKET type

    LPAREN          shift and go to state 54
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    LNOT            shift and go to state 61
    INT             shift and go to state 62
    FLOAT64         shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 66
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    expression                     shift and go to state 325
    slice_type                     shift and go to state 53
    binary_expression              shift and go to state 55
    relational_expression          shift and go to state 56
    logical_expression             shift and go to state 57
    bitwise_expression             shift and go to state 58
    map_type                       shift and go to state 67
    type_name                      shift and go to state 68
    array_type                     shift and go to state 69

state 312

    (228) switch_statement -> SWITCH enter_block switch_header LBRACE . case_clauses RBRACE exit_block
    (211) case_clauses -> . case_clause
    (212) case_clauses -> . case_clauses case_clause
    (213) case_clause -> . CASE case_expression_list COLON enter_block case_body exit_block
    (214) case_clause -> . DEFAULT COLON enter_block case_body exit_block

    CASE            shift and go to state 328
    DEFAULT         shift and go to state 329

    case_clauses                   shift and go to state 326
    case_clause                    shift and go to state 327

state 313

    (223) switch_init -> assignment SEMICOLON . switch_expression
    (224) switch_expression -> . switch_primary
    (225) switch_expression -> . empty
    (217) switch_primary -> . IDENTIFIER
    (218) switch_primary -> . INT
    (219) switch_primary -> . FLOAT64
    (220) switch_primary -> . STRING
    (221) switch_primary -> . TRUE
    (222) switch_primary -> . FALSE
    (7) empty -> .

    IDENTIFIER      shift and go to state 331
    INT             shift and go to state 292
    FLOAT64         shift and go to state 293
    STRING          shift and go to state 294
    TRUE            shift and go to state 295
    FALSE           shift and go to state 296
    LBRACE          reduce using rule 7 (empty -> .)

    switch_expression              shift and go to state 330
    switch_primary                 shift and go to state 288
    empty                          shift and go to state 289

state 314

    (81) for_classic -> FOR for_init SEMICOLON for_cond . SEMICOLON for_post block

    SEMICOLON       shift and go to state 332


state 315

    (88) for_cond -> expression .
    (175) binary_expression -> expression . PLUS expression
    (176) binary_expression -> expression . MINUS expression
    (177) binary_expression -> expression . TIMES expression
    (178) binary_expression -> expression . DIVIDE expression
    (179) binary_expression -> expression . MODULE expression
    (184) relational_expression -> expression . EQ expression
    (185) relational_expression -> expression . NEQ expression
    (186) relational_expression -> expression . LT expression
    (187) relational_expression -> expression . LE expression
    (188) relational_expression -> expression . GT expression
    (189) relational_expression -> expression . GE expression
    (190) logical_expression -> expression . LAND expression
    (191) logical_expression -> expression . LOR expression
    (192) bitwise_expression -> expression . AND expression
    (193) bitwise_expression -> expression . OR expression
    (194) bitwise_expression -> expression . XOR expression
    (195) bitwise_expression -> expression . AND_NOT expression
    (196) bitwise_expression -> expression . LSHIFT expression
    (197) bitwise_expression -> expression . RSHIFT expression

    SEMICOLON       reduce using rule 88 (for_cond -> expression .)
    PLUS            shift and go to state 86
    MINUS           shift and go to state 87
    TIMES           shift and go to state 88
    DIVIDE          shift and go to state 89
    MODULE          shift and go to state 90
    EQ              shift and go to state 91
    NEQ             shift and go to state 92
    LT              shift and go to state 93
    LE              shift and go to state 94
    GT              shift and go to state 95
    GE              shift and go to state 96
    LAND            shift and go to state 97
    LOR             shift and go to state 98
    AND             shift and go to state 99
    OR              shift and go to state 100
    XOR             shift and go to state 101
    AND_NOT         shift and go to state 102
    LSHIFT          shift and go to state 103
    RSHIFT          shift and go to state 104


state 316

    (89) for_cond -> empty .

    SEMICOLON       reduce using rule 89 (for_cond -> empty .)


state 317

    (229) print_expression -> IDENTIFIER DOT IDENTIFIER LPAREN argument_list . RPAREN

    RPAREN          shift and go to state 333


state 318

    (230) input_expression -> IDENTIFIER DOT IDENTIFIER LPAREN AND . IDENTIFIER COMMA argument_list RPAREN

    IDENTIFIER      shift and go to state 334


state 319

    (111) variable_declaration -> VAR IDENTIFIER type ASSIGN expression .
    (175) binary_expression -> expression . PLUS expression
    (176) binary_expression -> expression . MINUS expression
    (177) binary_expression -> expression . TIMES expression
    (178) binary_expression -> expression . DIVIDE expression
    (179) binary_expression -> expression . MODULE expression
    (184) relational_expression -> expression . EQ expression
    (185) relational_expression -> expression . NEQ expression
    (186) relational_expression -> expression . LT expression
    (187) relational_expression -> expression . LE expression
    (188) relational_expression -> expression . GT expression
    (189) relational_expression -> expression . GE expression
    (190) logical_expression -> expression . LAND expression
    (191) logical_expression -> expression . LOR expression
    (192) bitwise_expression -> expression . AND expression
    (193) bitwise_expression -> expression . OR expression
    (194) bitwise_expression -> expression . XOR expression
    (195) bitwise_expression -> expression . AND_NOT expression
    (196) bitwise_expression -> expression . LSHIFT expression
    (197) bitwise_expression -> expression . RSHIFT expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    IDENTIFIER      reduce using rule 111 (variable_declaration -> VAR IDENTIFIER type ASSIGN expression .)
    VAR             reduce using rule 111 (variable_declaration -> VAR IDENTIFIER type ASSIGN expression .)
    CONST           reduce using rule 111 (variable_declaration -> VAR IDENTIFIER type ASSIGN expression .)
    LPAREN          reduce using rule 111 (variable_declaration -> VAR IDENTIFIER type ASSIGN expression .)
    LNOT            reduce using rule 111 (variable_declaration -> VAR IDENTIFIER type ASSIGN expression .)
    INT             reduce using rule 111 (variable_declaration -> VAR IDENTIFIER type ASSIGN expression .)
    FLOAT64         reduce using rule 111 (variable_declaration -> VAR IDENTIFIER type ASSIGN expression .)
    TRUE            reduce using rule 111 (variable_declaration -> VAR IDENTIFIER type ASSIGN expression .)
    FALSE           reduce using rule 111 (variable_declaration -> VAR IDENTIFIER type ASSIGN expression .)
    STRING          reduce using rule 111 (variable_declaration -> VAR IDENTIFIER type ASSIGN expression .)
    RETURN          reduce using rule 111 (variable_declaration -> VAR IDENTIFIER type ASSIGN expression .)
    IF              reduce using rule 111 (variable_declaration -> VAR IDENTIFIER type ASSIGN expression .)
    SWITCH          reduce using rule 111 (variable_declaration -> VAR IDENTIFIER type ASSIGN expression .)
    BREAK           reduce using rule 111 (variable_declaration -> VAR IDENTIFIER type ASSIGN expression .)
    CONTINUE        reduce using rule 111 (variable_declaration -> VAR IDENTIFIER type ASSIGN expression .)
    LBRACKET        reduce using rule 111 (variable_declaration -> VAR IDENTIFIER type ASSIGN expression .)
    MAP             reduce using rule 111 (variable_declaration -> VAR IDENTIFIER type ASSIGN expression .)
    FOR             reduce using rule 111 (variable_declaration -> VAR IDENTIFIER type ASSIGN expression .)
    RBRACE          reduce using rule 111 (variable_declaration -> VAR IDENTIFIER type ASSIGN expression .)
    CASE            reduce using rule 111 (variable_declaration -> VAR IDENTIFIER type ASSIGN expression .)
    DEFAULT         reduce using rule 111 (variable_declaration -> VAR IDENTIFIER type ASSIGN expression .)
    PLUS            shift and go to state 86
    MINUS           shift and go to state 87
    TIMES           shift and go to state 88
    DIVIDE          shift and go to state 89
    MODULE          shift and go to state 90
    EQ              shift and go to state 91
    NEQ             shift and go to state 92
    LT              shift and go to state 93
    LE              shift and go to state 94
    GT              shift and go to state 95
    GE              shift and go to state 96
    LAND            shift and go to state 97
    LOR             shift and go to state 98
    AND             shift and go to state 99
    OR              shift and go to state 100
    XOR             shift and go to state 101
    AND_NOT         shift and go to state 102
    LSHIFT          shift and go to state 103
    RSHIFT          shift and go to state 104

  ! PLUS            [ reduce using rule 111 (variable_declaration -> VAR IDENTIFIER type ASSIGN expression .) ]
  ! MINUS           [ reduce using rule 111 (variable_declaration -> VAR IDENTIFIER type ASSIGN expression .) ]


state 320

    (112) variable_declaration -> CONST IDENTIFIER type ASSIGN expression .
    (175) binary_expression -> expression . PLUS expression
    (176) binary_expression -> expression . MINUS expression
    (177) binary_expression -> expression . TIMES expression
    (178) binary_expression -> expression . DIVIDE expression
    (179) binary_expression -> expression . MODULE expression
    (184) relational_expression -> expression . EQ expression
    (185) relational_expression -> expression . NEQ expression
    (186) relational_expression -> expression . LT expression
    (187) relational_expression -> expression . LE expression
    (188) relational_expression -> expression . GT expression
    (189) relational_expression -> expression . GE expression
    (190) logical_expression -> expression . LAND expression
    (191) logical_expression -> expression . LOR expression
    (192) bitwise_expression -> expression . AND expression
    (193) bitwise_expression -> expression . OR expression
    (194) bitwise_expression -> expression . XOR expression
    (195) bitwise_expression -> expression . AND_NOT expression
    (196) bitwise_expression -> expression . LSHIFT expression
    (197) bitwise_expression -> expression . RSHIFT expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    IDENTIFIER      reduce using rule 112 (variable_declaration -> CONST IDENTIFIER type ASSIGN expression .)
    VAR             reduce using rule 112 (variable_declaration -> CONST IDENTIFIER type ASSIGN expression .)
    CONST           reduce using rule 112 (variable_declaration -> CONST IDENTIFIER type ASSIGN expression .)
    LPAREN          reduce using rule 112 (variable_declaration -> CONST IDENTIFIER type ASSIGN expression .)
    LNOT            reduce using rule 112 (variable_declaration -> CONST IDENTIFIER type ASSIGN expression .)
    INT             reduce using rule 112 (variable_declaration -> CONST IDENTIFIER type ASSIGN expression .)
    FLOAT64         reduce using rule 112 (variable_declaration -> CONST IDENTIFIER type ASSIGN expression .)
    TRUE            reduce using rule 112 (variable_declaration -> CONST IDENTIFIER type ASSIGN expression .)
    FALSE           reduce using rule 112 (variable_declaration -> CONST IDENTIFIER type ASSIGN expression .)
    STRING          reduce using rule 112 (variable_declaration -> CONST IDENTIFIER type ASSIGN expression .)
    RETURN          reduce using rule 112 (variable_declaration -> CONST IDENTIFIER type ASSIGN expression .)
    IF              reduce using rule 112 (variable_declaration -> CONST IDENTIFIER type ASSIGN expression .)
    SWITCH          reduce using rule 112 (variable_declaration -> CONST IDENTIFIER type ASSIGN expression .)
    BREAK           reduce using rule 112 (variable_declaration -> CONST IDENTIFIER type ASSIGN expression .)
    CONTINUE        reduce using rule 112 (variable_declaration -> CONST IDENTIFIER type ASSIGN expression .)
    LBRACKET        reduce using rule 112 (variable_declaration -> CONST IDENTIFIER type ASSIGN expression .)
    MAP             reduce using rule 112 (variable_declaration -> CONST IDENTIFIER type ASSIGN expression .)
    FOR             reduce using rule 112 (variable_declaration -> CONST IDENTIFIER type ASSIGN expression .)
    RBRACE          reduce using rule 112 (variable_declaration -> CONST IDENTIFIER type ASSIGN expression .)
    CASE            reduce using rule 112 (variable_declaration -> CONST IDENTIFIER type ASSIGN expression .)
    DEFAULT         reduce using rule 112 (variable_declaration -> CONST IDENTIFIER type ASSIGN expression .)
    PLUS            shift and go to state 86
    MINUS           shift and go to state 87
    TIMES           shift and go to state 88
    DIVIDE          shift and go to state 89
    MODULE          shift and go to state 90
    EQ              shift and go to state 91
    NEQ             shift and go to state 92
    LT              shift and go to state 93
    LE              shift and go to state 94
    GT              shift and go to state 95
    GE              shift and go to state 96
    LAND            shift and go to state 97
    LOR             shift and go to state 98
    AND             shift and go to state 99
    OR              shift and go to state 100
    XOR             shift and go to state 101
    AND_NOT         shift and go to state 102
    LSHIFT          shift and go to state 103
    RSHIFT          shift and go to state 104

  ! PLUS            [ reduce using rule 112 (variable_declaration -> CONST IDENTIFIER type ASSIGN expression .) ]
  ! MINUS           [ reduce using rule 112 (variable_declaration -> CONST IDENTIFIER type ASSIGN expression .) ]


state 321

    (136) if_statement -> IF expression block ELSE block .

    IDENTIFIER      reduce using rule 136 (if_statement -> IF expression block ELSE block .)
    VAR             reduce using rule 136 (if_statement -> IF expression block ELSE block .)
    CONST           reduce using rule 136 (if_statement -> IF expression block ELSE block .)
    LPAREN          reduce using rule 136 (if_statement -> IF expression block ELSE block .)
    PLUS            reduce using rule 136 (if_statement -> IF expression block ELSE block .)
    MINUS           reduce using rule 136 (if_statement -> IF expression block ELSE block .)
    LNOT            reduce using rule 136 (if_statement -> IF expression block ELSE block .)
    INT             reduce using rule 136 (if_statement -> IF expression block ELSE block .)
    FLOAT64         reduce using rule 136 (if_statement -> IF expression block ELSE block .)
    TRUE            reduce using rule 136 (if_statement -> IF expression block ELSE block .)
    FALSE           reduce using rule 136 (if_statement -> IF expression block ELSE block .)
    STRING          reduce using rule 136 (if_statement -> IF expression block ELSE block .)
    RETURN          reduce using rule 136 (if_statement -> IF expression block ELSE block .)
    IF              reduce using rule 136 (if_statement -> IF expression block ELSE block .)
    SWITCH          reduce using rule 136 (if_statement -> IF expression block ELSE block .)
    BREAK           reduce using rule 136 (if_statement -> IF expression block ELSE block .)
    CONTINUE        reduce using rule 136 (if_statement -> IF expression block ELSE block .)
    LBRACKET        reduce using rule 136 (if_statement -> IF expression block ELSE block .)
    MAP             reduce using rule 136 (if_statement -> IF expression block ELSE block .)
    FOR             reduce using rule 136 (if_statement -> IF expression block ELSE block .)
    RBRACE          reduce using rule 136 (if_statement -> IF expression block ELSE block .)
    CASE            reduce using rule 136 (if_statement -> IF expression block ELSE block .)
    DEFAULT         reduce using rule 136 (if_statement -> IF expression block ELSE block .)


state 322

    (137) if_statement -> IF expression block ELSE if_statement .

    IDENTIFIER      reduce using rule 137 (if_statement -> IF expression block ELSE if_statement .)
    VAR             reduce using rule 137 (if_statement -> IF expression block ELSE if_statement .)
    CONST           reduce using rule 137 (if_statement -> IF expression block ELSE if_statement .)
    LPAREN          reduce using rule 137 (if_statement -> IF expression block ELSE if_statement .)
    PLUS            reduce using rule 137 (if_statement -> IF expression block ELSE if_statement .)
    MINUS           reduce using rule 137 (if_statement -> IF expression block ELSE if_statement .)
    LNOT            reduce using rule 137 (if_statement -> IF expression block ELSE if_statement .)
    INT             reduce using rule 137 (if_statement -> IF expression block ELSE if_statement .)
    FLOAT64         reduce using rule 137 (if_statement -> IF expression block ELSE if_statement .)
    TRUE            reduce using rule 137 (if_statement -> IF expression block ELSE if_statement .)
    FALSE           reduce using rule 137 (if_statement -> IF expression block ELSE if_statement .)
    STRING          reduce using rule 137 (if_statement -> IF expression block ELSE if_statement .)
    RETURN          reduce using rule 137 (if_statement -> IF expression block ELSE if_statement .)
    IF              reduce using rule 137 (if_statement -> IF expression block ELSE if_statement .)
    SWITCH          reduce using rule 137 (if_statement -> IF expression block ELSE if_statement .)
    BREAK           reduce using rule 137 (if_statement -> IF expression block ELSE if_statement .)
    CONTINUE        reduce using rule 137 (if_statement -> IF expression block ELSE if_statement .)
    LBRACKET        reduce using rule 137 (if_statement -> IF expression block ELSE if_statement .)
    MAP             reduce using rule 137 (if_statement -> IF expression block ELSE if_statement .)
    FOR             reduce using rule 137 (if_statement -> IF expression block ELSE if_statement .)
    RBRACE          reduce using rule 137 (if_statement -> IF expression block ELSE if_statement .)
    CASE            reduce using rule 137 (if_statement -> IF expression block ELSE if_statement .)
    DEFAULT         reduce using rule 137 (if_statement -> IF expression block ELSE if_statement .)


state 323

    (138) if_statement -> IF if_assignment SEMICOLON expression block .
    (139) if_statement -> IF if_assignment SEMICOLON expression block . ELSE block
    (140) if_statement -> IF if_assignment SEMICOLON expression block . ELSE if_statement

    IDENTIFIER      reduce using rule 138 (if_statement -> IF if_assignment SEMICOLON expression block .)
    VAR             reduce using rule 138 (if_statement -> IF if_assignment SEMICOLON expression block .)
    CONST           reduce using rule 138 (if_statement -> IF if_assignment SEMICOLON expression block .)
    LPAREN          reduce using rule 138 (if_statement -> IF if_assignment SEMICOLON expression block .)
    PLUS            reduce using rule 138 (if_statement -> IF if_assignment SEMICOLON expression block .)
    MINUS           reduce using rule 138 (if_statement -> IF if_assignment SEMICOLON expression block .)
    LNOT            reduce using rule 138 (if_statement -> IF if_assignment SEMICOLON expression block .)
    INT             reduce using rule 138 (if_statement -> IF if_assignment SEMICOLON expression block .)
    FLOAT64         reduce using rule 138 (if_statement -> IF if_assignment SEMICOLON expression block .)
    TRUE            reduce using rule 138 (if_statement -> IF if_assignment SEMICOLON expression block .)
    FALSE           reduce using rule 138 (if_statement -> IF if_assignment SEMICOLON expression block .)
    STRING          reduce using rule 138 (if_statement -> IF if_assignment SEMICOLON expression block .)
    RETURN          reduce using rule 138 (if_statement -> IF if_assignment SEMICOLON expression block .)
    IF              reduce using rule 138 (if_statement -> IF if_assignment SEMICOLON expression block .)
    SWITCH          reduce using rule 138 (if_statement -> IF if_assignment SEMICOLON expression block .)
    BREAK           reduce using rule 138 (if_statement -> IF if_assignment SEMICOLON expression block .)
    CONTINUE        reduce using rule 138 (if_statement -> IF if_assignment SEMICOLON expression block .)
    LBRACKET        reduce using rule 138 (if_statement -> IF if_assignment SEMICOLON expression block .)
    MAP             reduce using rule 138 (if_statement -> IF if_assignment SEMICOLON expression block .)
    FOR             reduce using rule 138 (if_statement -> IF if_assignment SEMICOLON expression block .)
    RBRACE          reduce using rule 138 (if_statement -> IF if_assignment SEMICOLON expression block .)
    CASE            reduce using rule 138 (if_statement -> IF if_assignment SEMICOLON expression block .)
    DEFAULT         reduce using rule 138 (if_statement -> IF if_assignment SEMICOLON expression block .)
    ELSE            shift and go to state 335


state 324

    (36) local_var_dec -> VAR IDENTIFIER type ASSIGN . expression
    (57) expression -> . slice_type LBRACE expression_list RBRACE
    (58) expression -> . slice_type LBRACE RBRACE
    (61) expression -> . LPAREN expression RPAREN
    (120) expression -> . binary_expression
    (121) expression -> . relational_expression
    (122) expression -> . logical_expression
    (123) expression -> . bitwise_expression
    (124) expression -> . PLUS expression
    (125) expression -> . MINUS expression
    (126) expression -> . LNOT expression
    (127) expression -> . INT
    (128) expression -> . FLOAT64
    (129) expression -> . TRUE
    (130) expression -> . FALSE
    (131) expression -> . IDENTIFIER
    (132) expression -> . STRING
    (133) expression -> . IDENTIFIER PLUSPLUS
    (134) expression -> . IDENTIFIER MINUSMINUS
    (145) expression -> . map_type LBRACE expression_map_list RBRACE
    (146) expression -> . map_type LBRACE RBRACE
    (169) expression -> . type_name LBRACE keyed_element_list RBRACE
    (170) expression -> . type_name LBRACE RBRACE
    (56) slice_type -> . LBRACKET RBRACKET primitive_type
    (175) binary_expression -> . expression PLUS expression
    (176) binary_expression -> . expression MINUS expression
    (177) binary_expression -> . expression TIMES expression
    (178) binary_expression -> . expression DIVIDE expression
    (179) binary_expression -> . expression MODULE expression
    (184) relational_expression -> . expression EQ expression
    (185) relational_expression -> . expression NEQ expression
    (186) relational_expression -> . expression LT expression
    (187) relational_expression -> . expression LE expression
    (188) relational_expression -> . expression GT expression
    (189) relational_expression -> . expression GE expression
    (190) logical_expression -> . expression LAND expression
    (191) logical_expression -> . expression LOR expression
    (192) bitwise_expression -> . expression AND expression
    (193) bitwise_expression -> . expression OR expression
    (194) bitwise_expression -> . expression XOR expression
    (195) bitwise_expression -> . expression AND_NOT expression
    (196) bitwise_expression -> . expression LSHIFT expression
    (197) bitwise_expression -> . expression RSHIFT expression
    (144) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (171) type_name -> . IDENTIFIER
    (172) type_name -> . slice_type
    (173) type_name -> . array_type
    (174) type_name -> . map_type
    (119) array_type -> . LBRACKET INT RBRACKET type

    LPAREN          shift and go to state 54
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    LNOT            shift and go to state 61
    INT             shift and go to state 62
    FLOAT64         shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 66
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    expression                     shift and go to state 336
    slice_type                     shift and go to state 53
    binary_expression              shift and go to state 55
    relational_expression          shift and go to state 56
    logical_expression             shift and go to state 57
    bitwise_expression             shift and go to state 58
    map_type                       shift and go to state 67
    type_name                      shift and go to state 68
    array_type                     shift and go to state 69

state 325

    (37) local_var_dec -> VAR IDENTIFIER ASSIGN expression .
    (175) binary_expression -> expression . PLUS expression
    (176) binary_expression -> expression . MINUS expression
    (177) binary_expression -> expression . TIMES expression
    (178) binary_expression -> expression . DIVIDE expression
    (179) binary_expression -> expression . MODULE expression
    (184) relational_expression -> expression . EQ expression
    (185) relational_expression -> expression . NEQ expression
    (186) relational_expression -> expression . LT expression
    (187) relational_expression -> expression . LE expression
    (188) relational_expression -> expression . GT expression
    (189) relational_expression -> expression . GE expression
    (190) logical_expression -> expression . LAND expression
    (191) logical_expression -> expression . LOR expression
    (192) bitwise_expression -> expression . AND expression
    (193) bitwise_expression -> expression . OR expression
    (194) bitwise_expression -> expression . XOR expression
    (195) bitwise_expression -> expression . AND_NOT expression
    (196) bitwise_expression -> expression . LSHIFT expression
    (197) bitwise_expression -> expression . RSHIFT expression

    SEMICOLON       reduce using rule 37 (local_var_dec -> VAR IDENTIFIER ASSIGN expression .)
    PLUS            shift and go to state 86
    MINUS           shift and go to state 87
    TIMES           shift and go to state 88
    DIVIDE          shift and go to state 89
    MODULE          shift and go to state 90
    EQ              shift and go to state 91
    NEQ             shift and go to state 92
    LT              shift and go to state 93
    LE              shift and go to state 94
    GT              shift and go to state 95
    GE              shift and go to state 96
    LAND            shift and go to state 97
    LOR             shift and go to state 98
    AND             shift and go to state 99
    OR              shift and go to state 100
    XOR             shift and go to state 101
    AND_NOT         shift and go to state 102
    LSHIFT          shift and go to state 103
    RSHIFT          shift and go to state 104


state 326

    (228) switch_statement -> SWITCH enter_block switch_header LBRACE case_clauses . RBRACE exit_block
    (212) case_clauses -> case_clauses . case_clause
    (213) case_clause -> . CASE case_expression_list COLON enter_block case_body exit_block
    (214) case_clause -> . DEFAULT COLON enter_block case_body exit_block

    RBRACE          shift and go to state 337
    CASE            shift and go to state 328
    DEFAULT         shift and go to state 329

    case_clause                    shift and go to state 338

state 327

    (211) case_clauses -> case_clause .

    RBRACE          reduce using rule 211 (case_clauses -> case_clause .)
    CASE            reduce using rule 211 (case_clauses -> case_clause .)
    DEFAULT         reduce using rule 211 (case_clauses -> case_clause .)


state 328

    (213) case_clause -> CASE . case_expression_list COLON enter_block case_body exit_block
    (209) case_expression_list -> . expression
    (210) case_expression_list -> . case_expression_list COMMA expression
    (57) expression -> . slice_type LBRACE expression_list RBRACE
    (58) expression -> . slice_type LBRACE RBRACE
    (61) expression -> . LPAREN expression RPAREN
    (120) expression -> . binary_expression
    (121) expression -> . relational_expression
    (122) expression -> . logical_expression
    (123) expression -> . bitwise_expression
    (124) expression -> . PLUS expression
    (125) expression -> . MINUS expression
    (126) expression -> . LNOT expression
    (127) expression -> . INT
    (128) expression -> . FLOAT64
    (129) expression -> . TRUE
    (130) expression -> . FALSE
    (131) expression -> . IDENTIFIER
    (132) expression -> . STRING
    (133) expression -> . IDENTIFIER PLUSPLUS
    (134) expression -> . IDENTIFIER MINUSMINUS
    (145) expression -> . map_type LBRACE expression_map_list RBRACE
    (146) expression -> . map_type LBRACE RBRACE
    (169) expression -> . type_name LBRACE keyed_element_list RBRACE
    (170) expression -> . type_name LBRACE RBRACE
    (56) slice_type -> . LBRACKET RBRACKET primitive_type
    (175) binary_expression -> . expression PLUS expression
    (176) binary_expression -> . expression MINUS expression
    (177) binary_expression -> . expression TIMES expression
    (178) binary_expression -> . expression DIVIDE expression
    (179) binary_expression -> . expression MODULE expression
    (184) relational_expression -> . expression EQ expression
    (185) relational_expression -> . expression NEQ expression
    (186) relational_expression -> . expression LT expression
    (187) relational_expression -> . expression LE expression
    (188) relational_expression -> . expression GT expression
    (189) relational_expression -> . expression GE expression
    (190) logical_expression -> . expression LAND expression
    (191) logical_expression -> . expression LOR expression
    (192) bitwise_expression -> . expression AND expression
    (193) bitwise_expression -> . expression OR expression
    (194) bitwise_expression -> . expression XOR expression
    (195) bitwise_expression -> . expression AND_NOT expression
    (196) bitwise_expression -> . expression LSHIFT expression
    (197) bitwise_expression -> . expression RSHIFT expression
    (144) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (171) type_name -> . IDENTIFIER
    (172) type_name -> . slice_type
    (173) type_name -> . array_type
    (174) type_name -> . map_type
    (119) array_type -> . LBRACKET INT RBRACKET type

    LPAREN          shift and go to state 54
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    LNOT            shift and go to state 61
    INT             shift and go to state 62
    FLOAT64         shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 66
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    case_expression_list           shift and go to state 339
    expression                     shift and go to state 340
    slice_type                     shift and go to state 53
    binary_expression              shift and go to state 55
    relational_expression          shift and go to state 56
    logical_expression             shift and go to state 57
    bitwise_expression             shift and go to state 58
    map_type                       shift and go to state 67
    type_name                      shift and go to state 68
    array_type                     shift and go to state 69

state 329

    (214) case_clause -> DEFAULT . COLON enter_block case_body exit_block

    COLON           shift and go to state 341


state 330

    (223) switch_init -> assignment SEMICOLON switch_expression .

    LBRACE          reduce using rule 223 (switch_init -> assignment SEMICOLON switch_expression .)


state 331

    (217) switch_primary -> IDENTIFIER .

    LBRACE          reduce using rule 217 (switch_primary -> IDENTIFIER .)


state 332

    (81) for_classic -> FOR for_init SEMICOLON for_cond SEMICOLON . for_post block
    (90) for_post -> . simple_assignment
    (91) for_post -> . assignment_compound
    (92) for_post -> . expression
    (93) for_post -> . empty
    (51) simple_assignment -> . IDENTIFIER ASSIGN expression
    (40) assignment_compound -> . IDENTIFIER operator_assign expression
    (57) expression -> . slice_type LBRACE expression_list RBRACE
    (58) expression -> . slice_type LBRACE RBRACE
    (61) expression -> . LPAREN expression RPAREN
    (120) expression -> . binary_expression
    (121) expression -> . relational_expression
    (122) expression -> . logical_expression
    (123) expression -> . bitwise_expression
    (124) expression -> . PLUS expression
    (125) expression -> . MINUS expression
    (126) expression -> . LNOT expression
    (127) expression -> . INT
    (128) expression -> . FLOAT64
    (129) expression -> . TRUE
    (130) expression -> . FALSE
    (131) expression -> . IDENTIFIER
    (132) expression -> . STRING
    (133) expression -> . IDENTIFIER PLUSPLUS
    (134) expression -> . IDENTIFIER MINUSMINUS
    (145) expression -> . map_type LBRACE expression_map_list RBRACE
    (146) expression -> . map_type LBRACE RBRACE
    (169) expression -> . type_name LBRACE keyed_element_list RBRACE
    (170) expression -> . type_name LBRACE RBRACE
    (7) empty -> .
    (56) slice_type -> . LBRACKET RBRACKET primitive_type
    (175) binary_expression -> . expression PLUS expression
    (176) binary_expression -> . expression MINUS expression
    (177) binary_expression -> . expression TIMES expression
    (178) binary_expression -> . expression DIVIDE expression
    (179) binary_expression -> . expression MODULE expression
    (184) relational_expression -> . expression EQ expression
    (185) relational_expression -> . expression NEQ expression
    (186) relational_expression -> . expression LT expression
    (187) relational_expression -> . expression LE expression
    (188) relational_expression -> . expression GT expression
    (189) relational_expression -> . expression GE expression
    (190) logical_expression -> . expression LAND expression
    (191) logical_expression -> . expression LOR expression
    (192) bitwise_expression -> . expression AND expression
    (193) bitwise_expression -> . expression OR expression
    (194) bitwise_expression -> . expression XOR expression
    (195) bitwise_expression -> . expression AND_NOT expression
    (196) bitwise_expression -> . expression LSHIFT expression
    (197) bitwise_expression -> . expression RSHIFT expression
    (144) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (171) type_name -> . IDENTIFIER
    (172) type_name -> . slice_type
    (173) type_name -> . array_type
    (174) type_name -> . map_type
    (119) array_type -> . LBRACKET INT RBRACKET type

    IDENTIFIER      shift and go to state 347
    LPAREN          shift and go to state 54
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    LNOT            shift and go to state 61
    INT             shift and go to state 62
    FLOAT64         shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    STRING          shift and go to state 66
    LBRACE          reduce using rule 7 (empty -> .)
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    for_post                       shift and go to state 342
    simple_assignment              shift and go to state 343
    assignment_compound            shift and go to state 344
    expression                     shift and go to state 345
    empty                          shift and go to state 346
    slice_type                     shift and go to state 53
    binary_expression              shift and go to state 55
    relational_expression          shift and go to state 56
    logical_expression             shift and go to state 57
    bitwise_expression             shift and go to state 58
    map_type                       shift and go to state 67
    type_name                      shift and go to state 68
    array_type                     shift and go to state 69

state 333

    (229) print_expression -> IDENTIFIER DOT IDENTIFIER LPAREN argument_list RPAREN .

    IDENTIFIER      reduce using rule 229 (print_expression -> IDENTIFIER DOT IDENTIFIER LPAREN argument_list RPAREN .)
    VAR             reduce using rule 229 (print_expression -> IDENTIFIER DOT IDENTIFIER LPAREN argument_list RPAREN .)
    CONST           reduce using rule 229 (print_expression -> IDENTIFIER DOT IDENTIFIER LPAREN argument_list RPAREN .)
    LPAREN          reduce using rule 229 (print_expression -> IDENTIFIER DOT IDENTIFIER LPAREN argument_list RPAREN .)
    PLUS            reduce using rule 229 (print_expression -> IDENTIFIER DOT IDENTIFIER LPAREN argument_list RPAREN .)
    MINUS           reduce using rule 229 (print_expression -> IDENTIFIER DOT IDENTIFIER LPAREN argument_list RPAREN .)
    LNOT            reduce using rule 229 (print_expression -> IDENTIFIER DOT IDENTIFIER LPAREN argument_list RPAREN .)
    INT             reduce using rule 229 (print_expression -> IDENTIFIER DOT IDENTIFIER LPAREN argument_list RPAREN .)
    FLOAT64         reduce using rule 229 (print_expression -> IDENTIFIER DOT IDENTIFIER LPAREN argument_list RPAREN .)
    TRUE            reduce using rule 229 (print_expression -> IDENTIFIER DOT IDENTIFIER LPAREN argument_list RPAREN .)
    FALSE           reduce using rule 229 (print_expression -> IDENTIFIER DOT IDENTIFIER LPAREN argument_list RPAREN .)
    STRING          reduce using rule 229 (print_expression -> IDENTIFIER DOT IDENTIFIER LPAREN argument_list RPAREN .)
    RETURN          reduce using rule 229 (print_expression -> IDENTIFIER DOT IDENTIFIER LPAREN argument_list RPAREN .)
    IF              reduce using rule 229 (print_expression -> IDENTIFIER DOT IDENTIFIER LPAREN argument_list RPAREN .)
    SWITCH          reduce using rule 229 (print_expression -> IDENTIFIER DOT IDENTIFIER LPAREN argument_list RPAREN .)
    BREAK           reduce using rule 229 (print_expression -> IDENTIFIER DOT IDENTIFIER LPAREN argument_list RPAREN .)
    CONTINUE        reduce using rule 229 (print_expression -> IDENTIFIER DOT IDENTIFIER LPAREN argument_list RPAREN .)
    LBRACKET        reduce using rule 229 (print_expression -> IDENTIFIER DOT IDENTIFIER LPAREN argument_list RPAREN .)
    MAP             reduce using rule 229 (print_expression -> IDENTIFIER DOT IDENTIFIER LPAREN argument_list RPAREN .)
    FOR             reduce using rule 229 (print_expression -> IDENTIFIER DOT IDENTIFIER LPAREN argument_list RPAREN .)
    RBRACE          reduce using rule 229 (print_expression -> IDENTIFIER DOT IDENTIFIER LPAREN argument_list RPAREN .)
    CASE            reduce using rule 229 (print_expression -> IDENTIFIER DOT IDENTIFIER LPAREN argument_list RPAREN .)
    DEFAULT         reduce using rule 229 (print_expression -> IDENTIFIER DOT IDENTIFIER LPAREN argument_list RPAREN .)


state 334

    (230) input_expression -> IDENTIFIER DOT IDENTIFIER LPAREN AND IDENTIFIER . COMMA argument_list RPAREN

    COMMA           shift and go to state 348


state 335

    (139) if_statement -> IF if_assignment SEMICOLON expression block ELSE . block
    (140) if_statement -> IF if_assignment SEMICOLON expression block ELSE . if_statement
    (15) block -> . LBRACE enter_block exit_block RBRACE
    (16) block -> . LBRACE enter_block statement_list exit_block RBRACE
    (135) if_statement -> . IF expression block
    (136) if_statement -> . IF expression block ELSE block
    (137) if_statement -> . IF expression block ELSE if_statement
    (138) if_statement -> . IF if_assignment SEMICOLON expression block
    (139) if_statement -> . IF if_assignment SEMICOLON expression block ELSE block
    (140) if_statement -> . IF if_assignment SEMICOLON expression block ELSE if_statement

    LBRACE          shift and go to state 185
    IF              shift and go to state 219

    block                          shift and go to state 349
    if_statement                   shift and go to state 350

state 336

    (36) local_var_dec -> VAR IDENTIFIER type ASSIGN expression .
    (175) binary_expression -> expression . PLUS expression
    (176) binary_expression -> expression . MINUS expression
    (177) binary_expression -> expression . TIMES expression
    (178) binary_expression -> expression . DIVIDE expression
    (179) binary_expression -> expression . MODULE expression
    (184) relational_expression -> expression . EQ expression
    (185) relational_expression -> expression . NEQ expression
    (186) relational_expression -> expression . LT expression
    (187) relational_expression -> expression . LE expression
    (188) relational_expression -> expression . GT expression
    (189) relational_expression -> expression . GE expression
    (190) logical_expression -> expression . LAND expression
    (191) logical_expression -> expression . LOR expression
    (192) bitwise_expression -> expression . AND expression
    (193) bitwise_expression -> expression . OR expression
    (194) bitwise_expression -> expression . XOR expression
    (195) bitwise_expression -> expression . AND_NOT expression
    (196) bitwise_expression -> expression . LSHIFT expression
    (197) bitwise_expression -> expression . RSHIFT expression

    SEMICOLON       reduce using rule 36 (local_var_dec -> VAR IDENTIFIER type ASSIGN expression .)
    PLUS            shift and go to state 86
    MINUS           shift and go to state 87
    TIMES           shift and go to state 88
    DIVIDE          shift and go to state 89
    MODULE          shift and go to state 90
    EQ              shift and go to state 91
    NEQ             shift and go to state 92
    LT              shift and go to state 93
    LE              shift and go to state 94
    GT              shift and go to state 95
    GE              shift and go to state 96
    LAND            shift and go to state 97
    LOR             shift and go to state 98
    AND             shift and go to state 99
    OR              shift and go to state 100
    XOR             shift and go to state 101
    AND_NOT         shift and go to state 102
    LSHIFT          shift and go to state 103
    RSHIFT          shift and go to state 104


state 337

    (228) switch_statement -> SWITCH enter_block switch_header LBRACE case_clauses RBRACE . exit_block
    (208) exit_block -> .

    IDENTIFIER      reduce using rule 208 (exit_block -> .)
    VAR             reduce using rule 208 (exit_block -> .)
    CONST           reduce using rule 208 (exit_block -> .)
    LPAREN          reduce using rule 208 (exit_block -> .)
    PLUS            reduce using rule 208 (exit_block -> .)
    MINUS           reduce using rule 208 (exit_block -> .)
    LNOT            reduce using rule 208 (exit_block -> .)
    INT             reduce using rule 208 (exit_block -> .)
    FLOAT64         reduce using rule 208 (exit_block -> .)
    TRUE            reduce using rule 208 (exit_block -> .)
    FALSE           reduce using rule 208 (exit_block -> .)
    STRING          reduce using rule 208 (exit_block -> .)
    RETURN          reduce using rule 208 (exit_block -> .)
    IF              reduce using rule 208 (exit_block -> .)
    SWITCH          reduce using rule 208 (exit_block -> .)
    BREAK           reduce using rule 208 (exit_block -> .)
    CONTINUE        reduce using rule 208 (exit_block -> .)
    LBRACKET        reduce using rule 208 (exit_block -> .)
    MAP             reduce using rule 208 (exit_block -> .)
    FOR             reduce using rule 208 (exit_block -> .)
    RBRACE          reduce using rule 208 (exit_block -> .)
    CASE            reduce using rule 208 (exit_block -> .)
    DEFAULT         reduce using rule 208 (exit_block -> .)

    exit_block                     shift and go to state 351

state 338

    (212) case_clauses -> case_clauses case_clause .

    RBRACE          reduce using rule 212 (case_clauses -> case_clauses case_clause .)
    CASE            reduce using rule 212 (case_clauses -> case_clauses case_clause .)
    DEFAULT         reduce using rule 212 (case_clauses -> case_clauses case_clause .)


state 339

    (213) case_clause -> CASE case_expression_list . COLON enter_block case_body exit_block
    (210) case_expression_list -> case_expression_list . COMMA expression

    COLON           shift and go to state 352
    COMMA           shift and go to state 353


state 340

    (209) case_expression_list -> expression .
    (175) binary_expression -> expression . PLUS expression
    (176) binary_expression -> expression . MINUS expression
    (177) binary_expression -> expression . TIMES expression
    (178) binary_expression -> expression . DIVIDE expression
    (179) binary_expression -> expression . MODULE expression
    (184) relational_expression -> expression . EQ expression
    (185) relational_expression -> expression . NEQ expression
    (186) relational_expression -> expression . LT expression
    (187) relational_expression -> expression . LE expression
    (188) relational_expression -> expression . GT expression
    (189) relational_expression -> expression . GE expression
    (190) logical_expression -> expression . LAND expression
    (191) logical_expression -> expression . LOR expression
    (192) bitwise_expression -> expression . AND expression
    (193) bitwise_expression -> expression . OR expression
    (194) bitwise_expression -> expression . XOR expression
    (195) bitwise_expression -> expression . AND_NOT expression
    (196) bitwise_expression -> expression . LSHIFT expression
    (197) bitwise_expression -> expression . RSHIFT expression

    COLON           reduce using rule 209 (case_expression_list -> expression .)
    COMMA           reduce using rule 209 (case_expression_list -> expression .)
    PLUS            shift and go to state 86
    MINUS           shift and go to state 87
    TIMES           shift and go to state 88
    DIVIDE          shift and go to state 89
    MODULE          shift and go to state 90
    EQ              shift and go to state 91
    NEQ             shift and go to state 92
    LT              shift and go to state 93
    LE              shift and go to state 94
    GT              shift and go to state 95
    GE              shift and go to state 96
    LAND            shift and go to state 97
    LOR             shift and go to state 98
    AND             shift and go to state 99
    OR              shift and go to state 100
    XOR             shift and go to state 101
    AND_NOT         shift and go to state 102
    LSHIFT          shift and go to state 103
    RSHIFT          shift and go to state 104


state 341

    (214) case_clause -> DEFAULT COLON . enter_block case_body exit_block
    (207) enter_block -> .

    IDENTIFIER      reduce using rule 207 (enter_block -> .)
    VAR             reduce using rule 207 (enter_block -> .)
    CONST           reduce using rule 207 (enter_block -> .)
    LPAREN          reduce using rule 207 (enter_block -> .)
    PLUS            reduce using rule 207 (enter_block -> .)
    MINUS           reduce using rule 207 (enter_block -> .)
    LNOT            reduce using rule 207 (enter_block -> .)
    INT             reduce using rule 207 (enter_block -> .)
    FLOAT64         reduce using rule 207 (enter_block -> .)
    TRUE            reduce using rule 207 (enter_block -> .)
    FALSE           reduce using rule 207 (enter_block -> .)
    STRING          reduce using rule 207 (enter_block -> .)
    RETURN          reduce using rule 207 (enter_block -> .)
    IF              reduce using rule 207 (enter_block -> .)
    SWITCH          reduce using rule 207 (enter_block -> .)
    BREAK           reduce using rule 207 (enter_block -> .)
    CONTINUE        reduce using rule 207 (enter_block -> .)
    LBRACKET        reduce using rule 207 (enter_block -> .)
    MAP             reduce using rule 207 (enter_block -> .)
    FOR             reduce using rule 207 (enter_block -> .)
    RBRACE          reduce using rule 207 (enter_block -> .)
    CASE            reduce using rule 207 (enter_block -> .)
    DEFAULT         reduce using rule 207 (enter_block -> .)

    enter_block                    shift and go to state 354

state 342

    (81) for_classic -> FOR for_init SEMICOLON for_cond SEMICOLON for_post . block
    (15) block -> . LBRACE enter_block exit_block RBRACE
    (16) block -> . LBRACE enter_block statement_list exit_block RBRACE

    LBRACE          shift and go to state 185

    block                          shift and go to state 355

state 343

    (90) for_post -> simple_assignment .

    LBRACE          reduce using rule 90 (for_post -> simple_assignment .)


state 344

    (91) for_post -> assignment_compound .

    LBRACE          reduce using rule 91 (for_post -> assignment_compound .)


state 345

    (92) for_post -> expression .
    (175) binary_expression -> expression . PLUS expression
    (176) binary_expression -> expression . MINUS expression
    (177) binary_expression -> expression . TIMES expression
    (178) binary_expression -> expression . DIVIDE expression
    (179) binary_expression -> expression . MODULE expression
    (184) relational_expression -> expression . EQ expression
    (185) relational_expression -> expression . NEQ expression
    (186) relational_expression -> expression . LT expression
    (187) relational_expression -> expression . LE expression
    (188) relational_expression -> expression . GT expression
    (189) relational_expression -> expression . GE expression
    (190) logical_expression -> expression . LAND expression
    (191) logical_expression -> expression . LOR expression
    (192) bitwise_expression -> expression . AND expression
    (193) bitwise_expression -> expression . OR expression
    (194) bitwise_expression -> expression . XOR expression
    (195) bitwise_expression -> expression . AND_NOT expression
    (196) bitwise_expression -> expression . LSHIFT expression
    (197) bitwise_expression -> expression . RSHIFT expression

    LBRACE          reduce using rule 92 (for_post -> expression .)
    PLUS            shift and go to state 86
    MINUS           shift and go to state 87
    TIMES           shift and go to state 88
    DIVIDE          shift and go to state 89
    MODULE          shift and go to state 90
    EQ              shift and go to state 91
    NEQ             shift and go to state 92
    LT              shift and go to state 93
    LE              shift and go to state 94
    GT              shift and go to state 95
    GE              shift and go to state 96
    LAND            shift and go to state 97
    LOR             shift and go to state 98
    AND             shift and go to state 99
    OR              shift and go to state 100
    XOR             shift and go to state 101
    AND_NOT         shift and go to state 102
    LSHIFT          shift and go to state 103
    RSHIFT          shift and go to state 104


state 346

    (93) for_post -> empty .

    LBRACE          reduce using rule 93 (for_post -> empty .)


state 347

    (51) simple_assignment -> IDENTIFIER . ASSIGN expression
    (40) assignment_compound -> IDENTIFIER . operator_assign expression
    (131) expression -> IDENTIFIER .
    (133) expression -> IDENTIFIER . PLUSPLUS
    (134) expression -> IDENTIFIER . MINUSMINUS
    (171) type_name -> IDENTIFIER .
    (41) operator_assign -> . PLUS_ASSIGN
    (42) operator_assign -> . MINUS_ASSIGN
    (43) operator_assign -> . MULT_ASSIGN
    (44) operator_assign -> . DIV_ASSIGN
    (45) operator_assign -> . MOD_ASSIGN
    (46) operator_assign -> . AND_ASSIGN
    (47) operator_assign -> . OR_ASSIGN
    (48) operator_assign -> . XOR_ASSIGN
    (49) operator_assign -> . LSHIFT_ASSIGN
    (50) operator_assign -> . RSHIFT_ASSIGN

  ! reduce/reduce conflict for LBRACE resolved using rule 131 (expression -> IDENTIFIER .)
    ASSIGN          shift and go to state 282
    PLUS            reduce using rule 131 (expression -> IDENTIFIER .)
    MINUS           reduce using rule 131 (expression -> IDENTIFIER .)
    TIMES           reduce using rule 131 (expression -> IDENTIFIER .)
    DIVIDE          reduce using rule 131 (expression -> IDENTIFIER .)
    MODULE          reduce using rule 131 (expression -> IDENTIFIER .)
    EQ              reduce using rule 131 (expression -> IDENTIFIER .)
    NEQ             reduce using rule 131 (expression -> IDENTIFIER .)
    LT              reduce using rule 131 (expression -> IDENTIFIER .)
    LE              reduce using rule 131 (expression -> IDENTIFIER .)
    GT              reduce using rule 131 (expression -> IDENTIFIER .)
    GE              reduce using rule 131 (expression -> IDENTIFIER .)
    LAND            reduce using rule 131 (expression -> IDENTIFIER .)
    LOR             reduce using rule 131 (expression -> IDENTIFIER .)
    AND             reduce using rule 131 (expression -> IDENTIFIER .)
    OR              reduce using rule 131 (expression -> IDENTIFIER .)
    XOR             reduce using rule 131 (expression -> IDENTIFIER .)
    AND_NOT         reduce using rule 131 (expression -> IDENTIFIER .)
    LSHIFT          reduce using rule 131 (expression -> IDENTIFIER .)
    RSHIFT          reduce using rule 131 (expression -> IDENTIFIER .)
    LBRACE          reduce using rule 131 (expression -> IDENTIFIER .)
    PLUSPLUS        shift and go to state 84
    MINUSMINUS      shift and go to state 85
    PLUS_ASSIGN     shift and go to state 236
    MINUS_ASSIGN    shift and go to state 237
    MULT_ASSIGN     shift and go to state 238
    DIV_ASSIGN      shift and go to state 239
    MOD_ASSIGN      shift and go to state 240
    AND_ASSIGN      shift and go to state 241
    OR_ASSIGN       shift and go to state 242
    XOR_ASSIGN      shift and go to state 243
    LSHIFT_ASSIGN   shift and go to state 244
    RSHIFT_ASSIGN   shift and go to state 245

  ! LBRACE          [ reduce using rule 171 (type_name -> IDENTIFIER .) ]

    operator_assign                shift and go to state 233

state 348

    (230) input_expression -> IDENTIFIER DOT IDENTIFIER LPAREN AND IDENTIFIER COMMA . argument_list RPAREN
    (231) argument_list -> . expression_list
    (232) argument_list -> . empty
    (59) expression_list -> . expression
    (60) expression_list -> . expression_list COMMA expression
    (7) empty -> .
    (57) expression -> . slice_type LBRACE expression_list RBRACE
    (58) expression -> . slice_type LBRACE RBRACE
    (61) expression -> . LPAREN expression RPAREN
    (120) expression -> . binary_expression
    (121) expression -> . relational_expression
    (122) expression -> . logical_expression
    (123) expression -> . bitwise_expression
    (124) expression -> . PLUS expression
    (125) expression -> . MINUS expression
    (126) expression -> . LNOT expression
    (127) expression -> . INT
    (128) expression -> . FLOAT64
    (129) expression -> . TRUE
    (130) expression -> . FALSE
    (131) expression -> . IDENTIFIER
    (132) expression -> . STRING
    (133) expression -> . IDENTIFIER PLUSPLUS
    (134) expression -> . IDENTIFIER MINUSMINUS
    (145) expression -> . map_type LBRACE expression_map_list RBRACE
    (146) expression -> . map_type LBRACE RBRACE
    (169) expression -> . type_name LBRACE keyed_element_list RBRACE
    (170) expression -> . type_name LBRACE RBRACE
    (56) slice_type -> . LBRACKET RBRACKET primitive_type
    (175) binary_expression -> . expression PLUS expression
    (176) binary_expression -> . expression MINUS expression
    (177) binary_expression -> . expression TIMES expression
    (178) binary_expression -> . expression DIVIDE expression
    (179) binary_expression -> . expression MODULE expression
    (184) relational_expression -> . expression EQ expression
    (185) relational_expression -> . expression NEQ expression
    (186) relational_expression -> . expression LT expression
    (187) relational_expression -> . expression LE expression
    (188) relational_expression -> . expression GT expression
    (189) relational_expression -> . expression GE expression
    (190) logical_expression -> . expression LAND expression
    (191) logical_expression -> . expression LOR expression
    (192) bitwise_expression -> . expression AND expression
    (193) bitwise_expression -> . expression OR expression
    (194) bitwise_expression -> . expression XOR expression
    (195) bitwise_expression -> . expression AND_NOT expression
    (196) bitwise_expression -> . expression LSHIFT expression
    (197) bitwise_expression -> . expression RSHIFT expression
    (144) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (171) type_name -> . IDENTIFIER
    (172) type_name -> . slice_type
    (173) type_name -> . array_type
    (174) type_name -> . map_type
    (119) array_type -> . LBRACKET INT RBRACKET type

    RPAREN          reduce using rule 7 (empty -> .)
    LPAREN          shift and go to state 54
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    LNOT            shift and go to state 61
    INT             shift and go to state 62
    FLOAT64         shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 66
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    argument_list                  shift and go to state 356
    expression_list                shift and go to state 273
    empty                          shift and go to state 274
    expression                     shift and go to state 148
    slice_type                     shift and go to state 53
    binary_expression              shift and go to state 55
    relational_expression          shift and go to state 56
    logical_expression             shift and go to state 57
    bitwise_expression             shift and go to state 58
    map_type                       shift and go to state 67
    type_name                      shift and go to state 68
    array_type                     shift and go to state 69

state 349

    (139) if_statement -> IF if_assignment SEMICOLON expression block ELSE block .

    IDENTIFIER      reduce using rule 139 (if_statement -> IF if_assignment SEMICOLON expression block ELSE block .)
    VAR             reduce using rule 139 (if_statement -> IF if_assignment SEMICOLON expression block ELSE block .)
    CONST           reduce using rule 139 (if_statement -> IF if_assignment SEMICOLON expression block ELSE block .)
    LPAREN          reduce using rule 139 (if_statement -> IF if_assignment SEMICOLON expression block ELSE block .)
    PLUS            reduce using rule 139 (if_statement -> IF if_assignment SEMICOLON expression block ELSE block .)
    MINUS           reduce using rule 139 (if_statement -> IF if_assignment SEMICOLON expression block ELSE block .)
    LNOT            reduce using rule 139 (if_statement -> IF if_assignment SEMICOLON expression block ELSE block .)
    INT             reduce using rule 139 (if_statement -> IF if_assignment SEMICOLON expression block ELSE block .)
    FLOAT64         reduce using rule 139 (if_statement -> IF if_assignment SEMICOLON expression block ELSE block .)
    TRUE            reduce using rule 139 (if_statement -> IF if_assignment SEMICOLON expression block ELSE block .)
    FALSE           reduce using rule 139 (if_statement -> IF if_assignment SEMICOLON expression block ELSE block .)
    STRING          reduce using rule 139 (if_statement -> IF if_assignment SEMICOLON expression block ELSE block .)
    RETURN          reduce using rule 139 (if_statement -> IF if_assignment SEMICOLON expression block ELSE block .)
    IF              reduce using rule 139 (if_statement -> IF if_assignment SEMICOLON expression block ELSE block .)
    SWITCH          reduce using rule 139 (if_statement -> IF if_assignment SEMICOLON expression block ELSE block .)
    BREAK           reduce using rule 139 (if_statement -> IF if_assignment SEMICOLON expression block ELSE block .)
    CONTINUE        reduce using rule 139 (if_statement -> IF if_assignment SEMICOLON expression block ELSE block .)
    LBRACKET        reduce using rule 139 (if_statement -> IF if_assignment SEMICOLON expression block ELSE block .)
    MAP             reduce using rule 139 (if_statement -> IF if_assignment SEMICOLON expression block ELSE block .)
    FOR             reduce using rule 139 (if_statement -> IF if_assignment SEMICOLON expression block ELSE block .)
    RBRACE          reduce using rule 139 (if_statement -> IF if_assignment SEMICOLON expression block ELSE block .)
    CASE            reduce using rule 139 (if_statement -> IF if_assignment SEMICOLON expression block ELSE block .)
    DEFAULT         reduce using rule 139 (if_statement -> IF if_assignment SEMICOLON expression block ELSE block .)


state 350

    (140) if_statement -> IF if_assignment SEMICOLON expression block ELSE if_statement .

    IDENTIFIER      reduce using rule 140 (if_statement -> IF if_assignment SEMICOLON expression block ELSE if_statement .)
    VAR             reduce using rule 140 (if_statement -> IF if_assignment SEMICOLON expression block ELSE if_statement .)
    CONST           reduce using rule 140 (if_statement -> IF if_assignment SEMICOLON expression block ELSE if_statement .)
    LPAREN          reduce using rule 140 (if_statement -> IF if_assignment SEMICOLON expression block ELSE if_statement .)
    PLUS            reduce using rule 140 (if_statement -> IF if_assignment SEMICOLON expression block ELSE if_statement .)
    MINUS           reduce using rule 140 (if_statement -> IF if_assignment SEMICOLON expression block ELSE if_statement .)
    LNOT            reduce using rule 140 (if_statement -> IF if_assignment SEMICOLON expression block ELSE if_statement .)
    INT             reduce using rule 140 (if_statement -> IF if_assignment SEMICOLON expression block ELSE if_statement .)
    FLOAT64         reduce using rule 140 (if_statement -> IF if_assignment SEMICOLON expression block ELSE if_statement .)
    TRUE            reduce using rule 140 (if_statement -> IF if_assignment SEMICOLON expression block ELSE if_statement .)
    FALSE           reduce using rule 140 (if_statement -> IF if_assignment SEMICOLON expression block ELSE if_statement .)
    STRING          reduce using rule 140 (if_statement -> IF if_assignment SEMICOLON expression block ELSE if_statement .)
    RETURN          reduce using rule 140 (if_statement -> IF if_assignment SEMICOLON expression block ELSE if_statement .)
    IF              reduce using rule 140 (if_statement -> IF if_assignment SEMICOLON expression block ELSE if_statement .)
    SWITCH          reduce using rule 140 (if_statement -> IF if_assignment SEMICOLON expression block ELSE if_statement .)
    BREAK           reduce using rule 140 (if_statement -> IF if_assignment SEMICOLON expression block ELSE if_statement .)
    CONTINUE        reduce using rule 140 (if_statement -> IF if_assignment SEMICOLON expression block ELSE if_statement .)
    LBRACKET        reduce using rule 140 (if_statement -> IF if_assignment SEMICOLON expression block ELSE if_statement .)
    MAP             reduce using rule 140 (if_statement -> IF if_assignment SEMICOLON expression block ELSE if_statement .)
    FOR             reduce using rule 140 (if_statement -> IF if_assignment SEMICOLON expression block ELSE if_statement .)
    RBRACE          reduce using rule 140 (if_statement -> IF if_assignment SEMICOLON expression block ELSE if_statement .)
    CASE            reduce using rule 140 (if_statement -> IF if_assignment SEMICOLON expression block ELSE if_statement .)
    DEFAULT         reduce using rule 140 (if_statement -> IF if_assignment SEMICOLON expression block ELSE if_statement .)


state 351

    (228) switch_statement -> SWITCH enter_block switch_header LBRACE case_clauses RBRACE exit_block .

    IDENTIFIER      reduce using rule 228 (switch_statement -> SWITCH enter_block switch_header LBRACE case_clauses RBRACE exit_block .)
    VAR             reduce using rule 228 (switch_statement -> SWITCH enter_block switch_header LBRACE case_clauses RBRACE exit_block .)
    CONST           reduce using rule 228 (switch_statement -> SWITCH enter_block switch_header LBRACE case_clauses RBRACE exit_block .)
    LPAREN          reduce using rule 228 (switch_statement -> SWITCH enter_block switch_header LBRACE case_clauses RBRACE exit_block .)
    PLUS            reduce using rule 228 (switch_statement -> SWITCH enter_block switch_header LBRACE case_clauses RBRACE exit_block .)
    MINUS           reduce using rule 228 (switch_statement -> SWITCH enter_block switch_header LBRACE case_clauses RBRACE exit_block .)
    LNOT            reduce using rule 228 (switch_statement -> SWITCH enter_block switch_header LBRACE case_clauses RBRACE exit_block .)
    INT             reduce using rule 228 (switch_statement -> SWITCH enter_block switch_header LBRACE case_clauses RBRACE exit_block .)
    FLOAT64         reduce using rule 228 (switch_statement -> SWITCH enter_block switch_header LBRACE case_clauses RBRACE exit_block .)
    TRUE            reduce using rule 228 (switch_statement -> SWITCH enter_block switch_header LBRACE case_clauses RBRACE exit_block .)
    FALSE           reduce using rule 228 (switch_statement -> SWITCH enter_block switch_header LBRACE case_clauses RBRACE exit_block .)
    STRING          reduce using rule 228 (switch_statement -> SWITCH enter_block switch_header LBRACE case_clauses RBRACE exit_block .)
    RETURN          reduce using rule 228 (switch_statement -> SWITCH enter_block switch_header LBRACE case_clauses RBRACE exit_block .)
    IF              reduce using rule 228 (switch_statement -> SWITCH enter_block switch_header LBRACE case_clauses RBRACE exit_block .)
    SWITCH          reduce using rule 228 (switch_statement -> SWITCH enter_block switch_header LBRACE case_clauses RBRACE exit_block .)
    BREAK           reduce using rule 228 (switch_statement -> SWITCH enter_block switch_header LBRACE case_clauses RBRACE exit_block .)
    CONTINUE        reduce using rule 228 (switch_statement -> SWITCH enter_block switch_header LBRACE case_clauses RBRACE exit_block .)
    LBRACKET        reduce using rule 228 (switch_statement -> SWITCH enter_block switch_header LBRACE case_clauses RBRACE exit_block .)
    MAP             reduce using rule 228 (switch_statement -> SWITCH enter_block switch_header LBRACE case_clauses RBRACE exit_block .)
    FOR             reduce using rule 228 (switch_statement -> SWITCH enter_block switch_header LBRACE case_clauses RBRACE exit_block .)
    RBRACE          reduce using rule 228 (switch_statement -> SWITCH enter_block switch_header LBRACE case_clauses RBRACE exit_block .)
    CASE            reduce using rule 228 (switch_statement -> SWITCH enter_block switch_header LBRACE case_clauses RBRACE exit_block .)
    DEFAULT         reduce using rule 228 (switch_statement -> SWITCH enter_block switch_header LBRACE case_clauses RBRACE exit_block .)


state 352

    (213) case_clause -> CASE case_expression_list COLON . enter_block case_body exit_block
    (207) enter_block -> .

    IDENTIFIER      reduce using rule 207 (enter_block -> .)
    VAR             reduce using rule 207 (enter_block -> .)
    CONST           reduce using rule 207 (enter_block -> .)
    LPAREN          reduce using rule 207 (enter_block -> .)
    PLUS            reduce using rule 207 (enter_block -> .)
    MINUS           reduce using rule 207 (enter_block -> .)
    LNOT            reduce using rule 207 (enter_block -> .)
    INT             reduce using rule 207 (enter_block -> .)
    FLOAT64         reduce using rule 207 (enter_block -> .)
    TRUE            reduce using rule 207 (enter_block -> .)
    FALSE           reduce using rule 207 (enter_block -> .)
    STRING          reduce using rule 207 (enter_block -> .)
    RETURN          reduce using rule 207 (enter_block -> .)
    IF              reduce using rule 207 (enter_block -> .)
    SWITCH          reduce using rule 207 (enter_block -> .)
    BREAK           reduce using rule 207 (enter_block -> .)
    CONTINUE        reduce using rule 207 (enter_block -> .)
    LBRACKET        reduce using rule 207 (enter_block -> .)
    MAP             reduce using rule 207 (enter_block -> .)
    FOR             reduce using rule 207 (enter_block -> .)
    RBRACE          reduce using rule 207 (enter_block -> .)
    CASE            reduce using rule 207 (enter_block -> .)
    DEFAULT         reduce using rule 207 (enter_block -> .)

    enter_block                    shift and go to state 357

state 353

    (210) case_expression_list -> case_expression_list COMMA . expression
    (57) expression -> . slice_type LBRACE expression_list RBRACE
    (58) expression -> . slice_type LBRACE RBRACE
    (61) expression -> . LPAREN expression RPAREN
    (120) expression -> . binary_expression
    (121) expression -> . relational_expression
    (122) expression -> . logical_expression
    (123) expression -> . bitwise_expression
    (124) expression -> . PLUS expression
    (125) expression -> . MINUS expression
    (126) expression -> . LNOT expression
    (127) expression -> . INT
    (128) expression -> . FLOAT64
    (129) expression -> . TRUE
    (130) expression -> . FALSE
    (131) expression -> . IDENTIFIER
    (132) expression -> . STRING
    (133) expression -> . IDENTIFIER PLUSPLUS
    (134) expression -> . IDENTIFIER MINUSMINUS
    (145) expression -> . map_type LBRACE expression_map_list RBRACE
    (146) expression -> . map_type LBRACE RBRACE
    (169) expression -> . type_name LBRACE keyed_element_list RBRACE
    (170) expression -> . type_name LBRACE RBRACE
    (56) slice_type -> . LBRACKET RBRACKET primitive_type
    (175) binary_expression -> . expression PLUS expression
    (176) binary_expression -> . expression MINUS expression
    (177) binary_expression -> . expression TIMES expression
    (178) binary_expression -> . expression DIVIDE expression
    (179) binary_expression -> . expression MODULE expression
    (184) relational_expression -> . expression EQ expression
    (185) relational_expression -> . expression NEQ expression
    (186) relational_expression -> . expression LT expression
    (187) relational_expression -> . expression LE expression
    (188) relational_expression -> . expression GT expression
    (189) relational_expression -> . expression GE expression
    (190) logical_expression -> . expression LAND expression
    (191) logical_expression -> . expression LOR expression
    (192) bitwise_expression -> . expression AND expression
    (193) bitwise_expression -> . expression OR expression
    (194) bitwise_expression -> . expression XOR expression
    (195) bitwise_expression -> . expression AND_NOT expression
    (196) bitwise_expression -> . expression LSHIFT expression
    (197) bitwise_expression -> . expression RSHIFT expression
    (144) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (171) type_name -> . IDENTIFIER
    (172) type_name -> . slice_type
    (173) type_name -> . array_type
    (174) type_name -> . map_type
    (119) array_type -> . LBRACKET INT RBRACKET type

    LPAREN          shift and go to state 54
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    LNOT            shift and go to state 61
    INT             shift and go to state 62
    FLOAT64         shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    IDENTIFIER      shift and go to state 51
    STRING          shift and go to state 66
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39

    expression                     shift and go to state 358
    slice_type                     shift and go to state 53
    binary_expression              shift and go to state 55
    relational_expression          shift and go to state 56
    logical_expression             shift and go to state 57
    bitwise_expression             shift and go to state 58
    map_type                       shift and go to state 67
    type_name                      shift and go to state 68
    array_type                     shift and go to state 69

state 354

    (214) case_clause -> DEFAULT COLON enter_block . case_body exit_block
    (215) case_body -> . statement_list
    (216) case_body -> . empty
    (17) statement_list -> . statement
    (18) statement_list -> . statement_list statement
    (7) empty -> .
    (19) statement -> . assignment
    (20) statement -> . assignment_compound
    (21) statement -> . variable_declaration
    (22) statement -> . expression
    (23) statement -> . return_statement
    (24) statement -> . for_statement
    (25) statement -> . if_statement
    (26) statement -> . switch_statement
    (27) statement -> . break_statement
    (28) statement -> . continue_statement
    (29) statement -> . call_expression
    (109) assignment -> . IDENTIFIER ASSIGN expression
    (110) assignment -> . IDENTIFIER SHORT_ASSIGN expression
    (40) assignment_compound -> . IDENTIFIER operator_assign expression
    (111) variable_declaration -> . VAR IDENTIFIER type ASSIGN expression
    (112) variable_declaration -> . CONST IDENTIFIER type ASSIGN expression
    (113) variable_declaration -> . VAR IDENTIFIER ASSIGN expression
    (114) variable_declaration -> . CONST IDENTIFIER ASSIGN expression
    (57) expression -> . slice_type LBRACE expression_list RBRACE
    (58) expression -> . slice_type LBRACE RBRACE
    (61) expression -> . LPAREN expression RPAREN
    (120) expression -> . binary_expression
    (121) expression -> . relational_expression
    (122) expression -> . logical_expression
    (123) expression -> . bitwise_expression
    (124) expression -> . PLUS expression
    (125) expression -> . MINUS expression
    (126) expression -> . LNOT expression
    (127) expression -> . INT
    (128) expression -> . FLOAT64
    (129) expression -> . TRUE
    (130) expression -> . FALSE
    (131) expression -> . IDENTIFIER
    (132) expression -> . STRING
    (133) expression -> . IDENTIFIER PLUSPLUS
    (134) expression -> . IDENTIFIER MINUSMINUS
    (145) expression -> . map_type LBRACE expression_map_list RBRACE
    (146) expression -> . map_type LBRACE RBRACE
    (169) expression -> . type_name LBRACE keyed_element_list RBRACE
    (170) expression -> . type_name LBRACE RBRACE
    (105) return_statement -> . RETURN
    (106) return_statement -> . RETURN return_list
    (78) for_statement -> . for_classic
    (79) for_statement -> . for_condition
    (80) for_statement -> . for_infinite
    (135) if_statement -> . IF expression block
    (136) if_statement -> . IF expression block ELSE block
    (137) if_statement -> . IF expression block ELSE if_statement
    (138) if_statement -> . IF if_assignment SEMICOLON expression block
    (139) if_statement -> . IF if_assignment SEMICOLON expression block ELSE block
    (140) if_statement -> . IF if_assignment SEMICOLON expression block ELSE if_statement
    (228) switch_statement -> . SWITCH enter_block switch_header LBRACE case_clauses RBRACE exit_block
    (74) break_statement -> . BREAK
    (75) continue_statement -> . CONTINUE
    (202) call_expression -> . print_expression
    (203) call_expression -> . input_expression
    (204) call_expression -> . func_call_expression
    (56) slice_type -> . LBRACKET RBRACKET primitive_type
    (175) binary_expression -> . expression PLUS expression
    (176) binary_expression -> . expression MINUS expression
    (177) binary_expression -> . expression TIMES expression
    (178) binary_expression -> . expression DIVIDE expression
    (179) binary_expression -> . expression MODULE expression
    (184) relational_expression -> . expression EQ expression
    (185) relational_expression -> . expression NEQ expression
    (186) relational_expression -> . expression LT expression
    (187) relational_expression -> . expression LE expression
    (188) relational_expression -> . expression GT expression
    (189) relational_expression -> . expression GE expression
    (190) logical_expression -> . expression LAND expression
    (191) logical_expression -> . expression LOR expression
    (192) bitwise_expression -> . expression AND expression
    (193) bitwise_expression -> . expression OR expression
    (194) bitwise_expression -> . expression XOR expression
    (195) bitwise_expression -> . expression AND_NOT expression
    (196) bitwise_expression -> . expression LSHIFT expression
    (197) bitwise_expression -> . expression RSHIFT expression
    (144) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (171) type_name -> . IDENTIFIER
    (172) type_name -> . slice_type
    (173) type_name -> . array_type
    (174) type_name -> . map_type
    (81) for_classic -> . FOR for_init SEMICOLON for_cond SEMICOLON for_post block
    (82) for_condition -> . FOR expression block
    (83) for_infinite -> . FOR block
    (229) print_expression -> . IDENTIFIER DOT IDENTIFIER LPAREN argument_list RPAREN
    (230) input_expression -> . IDENTIFIER DOT IDENTIFIER LPAREN AND IDENTIFIER COMMA argument_list RPAREN
    (201) func_call_expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (119) array_type -> . LBRACKET INT RBRACKET type

    RBRACE          reduce using rule 7 (empty -> .)
    CASE            reduce using rule 7 (empty -> .)
    DEFAULT         reduce using rule 7 (empty -> .)
    IDENTIFIER      shift and go to state 212
    VAR             shift and go to state 213
    CONST           shift and go to state 214
    LPAREN          shift and go to state 54
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    LNOT            shift and go to state 61
    INT             shift and go to state 62
    FLOAT64         shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    STRING          shift and go to state 66
    RETURN          shift and go to state 215
    IF              shift and go to state 219
    SWITCH          shift and go to state 220
    BREAK           shift and go to state 221
    CONTINUE        shift and go to state 222
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39
    FOR             shift and go to state 226

    case_body                      shift and go to state 359
    statement_list                 shift and go to state 360
    empty                          shift and go to state 361
    statement                      shift and go to state 200
    assignment                     shift and go to state 201
    assignment_compound            shift and go to state 202
    variable_declaration           shift and go to state 203
    expression                     shift and go to state 204
    return_statement               shift and go to state 205
    for_statement                  shift and go to state 206
    if_statement                   shift and go to state 207
    switch_statement               shift and go to state 208
    break_statement                shift and go to state 209
    continue_statement             shift and go to state 210
    call_expression                shift and go to state 211
    slice_type                     shift and go to state 53
    binary_expression              shift and go to state 55
    relational_expression          shift and go to state 56
    logical_expression             shift and go to state 57
    bitwise_expression             shift and go to state 58
    map_type                       shift and go to state 67
    type_name                      shift and go to state 68
    for_classic                    shift and go to state 216
    for_condition                  shift and go to state 217
    for_infinite                   shift and go to state 218
    print_expression               shift and go to state 223
    input_expression               shift and go to state 224
    func_call_expression           shift and go to state 225
    array_type                     shift and go to state 69

state 355

    (81) for_classic -> FOR for_init SEMICOLON for_cond SEMICOLON for_post block .

    IDENTIFIER      reduce using rule 81 (for_classic -> FOR for_init SEMICOLON for_cond SEMICOLON for_post block .)
    VAR             reduce using rule 81 (for_classic -> FOR for_init SEMICOLON for_cond SEMICOLON for_post block .)
    CONST           reduce using rule 81 (for_classic -> FOR for_init SEMICOLON for_cond SEMICOLON for_post block .)
    LPAREN          reduce using rule 81 (for_classic -> FOR for_init SEMICOLON for_cond SEMICOLON for_post block .)
    PLUS            reduce using rule 81 (for_classic -> FOR for_init SEMICOLON for_cond SEMICOLON for_post block .)
    MINUS           reduce using rule 81 (for_classic -> FOR for_init SEMICOLON for_cond SEMICOLON for_post block .)
    LNOT            reduce using rule 81 (for_classic -> FOR for_init SEMICOLON for_cond SEMICOLON for_post block .)
    INT             reduce using rule 81 (for_classic -> FOR for_init SEMICOLON for_cond SEMICOLON for_post block .)
    FLOAT64         reduce using rule 81 (for_classic -> FOR for_init SEMICOLON for_cond SEMICOLON for_post block .)
    TRUE            reduce using rule 81 (for_classic -> FOR for_init SEMICOLON for_cond SEMICOLON for_post block .)
    FALSE           reduce using rule 81 (for_classic -> FOR for_init SEMICOLON for_cond SEMICOLON for_post block .)
    STRING          reduce using rule 81 (for_classic -> FOR for_init SEMICOLON for_cond SEMICOLON for_post block .)
    RETURN          reduce using rule 81 (for_classic -> FOR for_init SEMICOLON for_cond SEMICOLON for_post block .)
    IF              reduce using rule 81 (for_classic -> FOR for_init SEMICOLON for_cond SEMICOLON for_post block .)
    SWITCH          reduce using rule 81 (for_classic -> FOR for_init SEMICOLON for_cond SEMICOLON for_post block .)
    BREAK           reduce using rule 81 (for_classic -> FOR for_init SEMICOLON for_cond SEMICOLON for_post block .)
    CONTINUE        reduce using rule 81 (for_classic -> FOR for_init SEMICOLON for_cond SEMICOLON for_post block .)
    LBRACKET        reduce using rule 81 (for_classic -> FOR for_init SEMICOLON for_cond SEMICOLON for_post block .)
    MAP             reduce using rule 81 (for_classic -> FOR for_init SEMICOLON for_cond SEMICOLON for_post block .)
    FOR             reduce using rule 81 (for_classic -> FOR for_init SEMICOLON for_cond SEMICOLON for_post block .)
    RBRACE          reduce using rule 81 (for_classic -> FOR for_init SEMICOLON for_cond SEMICOLON for_post block .)
    CASE            reduce using rule 81 (for_classic -> FOR for_init SEMICOLON for_cond SEMICOLON for_post block .)
    DEFAULT         reduce using rule 81 (for_classic -> FOR for_init SEMICOLON for_cond SEMICOLON for_post block .)


state 356

    (230) input_expression -> IDENTIFIER DOT IDENTIFIER LPAREN AND IDENTIFIER COMMA argument_list . RPAREN

    RPAREN          shift and go to state 362


state 357

    (213) case_clause -> CASE case_expression_list COLON enter_block . case_body exit_block
    (215) case_body -> . statement_list
    (216) case_body -> . empty
    (17) statement_list -> . statement
    (18) statement_list -> . statement_list statement
    (7) empty -> .
    (19) statement -> . assignment
    (20) statement -> . assignment_compound
    (21) statement -> . variable_declaration
    (22) statement -> . expression
    (23) statement -> . return_statement
    (24) statement -> . for_statement
    (25) statement -> . if_statement
    (26) statement -> . switch_statement
    (27) statement -> . break_statement
    (28) statement -> . continue_statement
    (29) statement -> . call_expression
    (109) assignment -> . IDENTIFIER ASSIGN expression
    (110) assignment -> . IDENTIFIER SHORT_ASSIGN expression
    (40) assignment_compound -> . IDENTIFIER operator_assign expression
    (111) variable_declaration -> . VAR IDENTIFIER type ASSIGN expression
    (112) variable_declaration -> . CONST IDENTIFIER type ASSIGN expression
    (113) variable_declaration -> . VAR IDENTIFIER ASSIGN expression
    (114) variable_declaration -> . CONST IDENTIFIER ASSIGN expression
    (57) expression -> . slice_type LBRACE expression_list RBRACE
    (58) expression -> . slice_type LBRACE RBRACE
    (61) expression -> . LPAREN expression RPAREN
    (120) expression -> . binary_expression
    (121) expression -> . relational_expression
    (122) expression -> . logical_expression
    (123) expression -> . bitwise_expression
    (124) expression -> . PLUS expression
    (125) expression -> . MINUS expression
    (126) expression -> . LNOT expression
    (127) expression -> . INT
    (128) expression -> . FLOAT64
    (129) expression -> . TRUE
    (130) expression -> . FALSE
    (131) expression -> . IDENTIFIER
    (132) expression -> . STRING
    (133) expression -> . IDENTIFIER PLUSPLUS
    (134) expression -> . IDENTIFIER MINUSMINUS
    (145) expression -> . map_type LBRACE expression_map_list RBRACE
    (146) expression -> . map_type LBRACE RBRACE
    (169) expression -> . type_name LBRACE keyed_element_list RBRACE
    (170) expression -> . type_name LBRACE RBRACE
    (105) return_statement -> . RETURN
    (106) return_statement -> . RETURN return_list
    (78) for_statement -> . for_classic
    (79) for_statement -> . for_condition
    (80) for_statement -> . for_infinite
    (135) if_statement -> . IF expression block
    (136) if_statement -> . IF expression block ELSE block
    (137) if_statement -> . IF expression block ELSE if_statement
    (138) if_statement -> . IF if_assignment SEMICOLON expression block
    (139) if_statement -> . IF if_assignment SEMICOLON expression block ELSE block
    (140) if_statement -> . IF if_assignment SEMICOLON expression block ELSE if_statement
    (228) switch_statement -> . SWITCH enter_block switch_header LBRACE case_clauses RBRACE exit_block
    (74) break_statement -> . BREAK
    (75) continue_statement -> . CONTINUE
    (202) call_expression -> . print_expression
    (203) call_expression -> . input_expression
    (204) call_expression -> . func_call_expression
    (56) slice_type -> . LBRACKET RBRACKET primitive_type
    (175) binary_expression -> . expression PLUS expression
    (176) binary_expression -> . expression MINUS expression
    (177) binary_expression -> . expression TIMES expression
    (178) binary_expression -> . expression DIVIDE expression
    (179) binary_expression -> . expression MODULE expression
    (184) relational_expression -> . expression EQ expression
    (185) relational_expression -> . expression NEQ expression
    (186) relational_expression -> . expression LT expression
    (187) relational_expression -> . expression LE expression
    (188) relational_expression -> . expression GT expression
    (189) relational_expression -> . expression GE expression
    (190) logical_expression -> . expression LAND expression
    (191) logical_expression -> . expression LOR expression
    (192) bitwise_expression -> . expression AND expression
    (193) bitwise_expression -> . expression OR expression
    (194) bitwise_expression -> . expression XOR expression
    (195) bitwise_expression -> . expression AND_NOT expression
    (196) bitwise_expression -> . expression LSHIFT expression
    (197) bitwise_expression -> . expression RSHIFT expression
    (144) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (171) type_name -> . IDENTIFIER
    (172) type_name -> . slice_type
    (173) type_name -> . array_type
    (174) type_name -> . map_type
    (81) for_classic -> . FOR for_init SEMICOLON for_cond SEMICOLON for_post block
    (82) for_condition -> . FOR expression block
    (83) for_infinite -> . FOR block
    (229) print_expression -> . IDENTIFIER DOT IDENTIFIER LPAREN argument_list RPAREN
    (230) input_expression -> . IDENTIFIER DOT IDENTIFIER LPAREN AND IDENTIFIER COMMA argument_list RPAREN
    (201) func_call_expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (119) array_type -> . LBRACKET INT RBRACKET type

    RBRACE          reduce using rule 7 (empty -> .)
    CASE            reduce using rule 7 (empty -> .)
    DEFAULT         reduce using rule 7 (empty -> .)
    IDENTIFIER      shift and go to state 212
    VAR             shift and go to state 213
    CONST           shift and go to state 214
    LPAREN          shift and go to state 54
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    LNOT            shift and go to state 61
    INT             shift and go to state 62
    FLOAT64         shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    STRING          shift and go to state 66
    RETURN          shift and go to state 215
    IF              shift and go to state 219
    SWITCH          shift and go to state 220
    BREAK           shift and go to state 221
    CONTINUE        shift and go to state 222
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39
    FOR             shift and go to state 226

    case_body                      shift and go to state 363
    statement_list                 shift and go to state 360
    empty                          shift and go to state 361
    statement                      shift and go to state 200
    assignment                     shift and go to state 201
    assignment_compound            shift and go to state 202
    variable_declaration           shift and go to state 203
    expression                     shift and go to state 204
    return_statement               shift and go to state 205
    for_statement                  shift and go to state 206
    if_statement                   shift and go to state 207
    switch_statement               shift and go to state 208
    break_statement                shift and go to state 209
    continue_statement             shift and go to state 210
    call_expression                shift and go to state 211
    slice_type                     shift and go to state 53
    binary_expression              shift and go to state 55
    relational_expression          shift and go to state 56
    logical_expression             shift and go to state 57
    bitwise_expression             shift and go to state 58
    map_type                       shift and go to state 67
    type_name                      shift and go to state 68
    for_classic                    shift and go to state 216
    for_condition                  shift and go to state 217
    for_infinite                   shift and go to state 218
    print_expression               shift and go to state 223
    input_expression               shift and go to state 224
    func_call_expression           shift and go to state 225
    array_type                     shift and go to state 69

state 358

    (210) case_expression_list -> case_expression_list COMMA expression .
    (175) binary_expression -> expression . PLUS expression
    (176) binary_expression -> expression . MINUS expression
    (177) binary_expression -> expression . TIMES expression
    (178) binary_expression -> expression . DIVIDE expression
    (179) binary_expression -> expression . MODULE expression
    (184) relational_expression -> expression . EQ expression
    (185) relational_expression -> expression . NEQ expression
    (186) relational_expression -> expression . LT expression
    (187) relational_expression -> expression . LE expression
    (188) relational_expression -> expression . GT expression
    (189) relational_expression -> expression . GE expression
    (190) logical_expression -> expression . LAND expression
    (191) logical_expression -> expression . LOR expression
    (192) bitwise_expression -> expression . AND expression
    (193) bitwise_expression -> expression . OR expression
    (194) bitwise_expression -> expression . XOR expression
    (195) bitwise_expression -> expression . AND_NOT expression
    (196) bitwise_expression -> expression . LSHIFT expression
    (197) bitwise_expression -> expression . RSHIFT expression

    COLON           reduce using rule 210 (case_expression_list -> case_expression_list COMMA expression .)
    COMMA           reduce using rule 210 (case_expression_list -> case_expression_list COMMA expression .)
    PLUS            shift and go to state 86
    MINUS           shift and go to state 87
    TIMES           shift and go to state 88
    DIVIDE          shift and go to state 89
    MODULE          shift and go to state 90
    EQ              shift and go to state 91
    NEQ             shift and go to state 92
    LT              shift and go to state 93
    LE              shift and go to state 94
    GT              shift and go to state 95
    GE              shift and go to state 96
    LAND            shift and go to state 97
    LOR             shift and go to state 98
    AND             shift and go to state 99
    OR              shift and go to state 100
    XOR             shift and go to state 101
    AND_NOT         shift and go to state 102
    LSHIFT          shift and go to state 103
    RSHIFT          shift and go to state 104


state 359

    (214) case_clause -> DEFAULT COLON enter_block case_body . exit_block
    (208) exit_block -> .

    RBRACE          reduce using rule 208 (exit_block -> .)
    CASE            reduce using rule 208 (exit_block -> .)
    DEFAULT         reduce using rule 208 (exit_block -> .)

    exit_block                     shift and go to state 364

state 360

    (215) case_body -> statement_list .
    (18) statement_list -> statement_list . statement
    (19) statement -> . assignment
    (20) statement -> . assignment_compound
    (21) statement -> . variable_declaration
    (22) statement -> . expression
    (23) statement -> . return_statement
    (24) statement -> . for_statement
    (25) statement -> . if_statement
    (26) statement -> . switch_statement
    (27) statement -> . break_statement
    (28) statement -> . continue_statement
    (29) statement -> . call_expression
    (109) assignment -> . IDENTIFIER ASSIGN expression
    (110) assignment -> . IDENTIFIER SHORT_ASSIGN expression
    (40) assignment_compound -> . IDENTIFIER operator_assign expression
    (111) variable_declaration -> . VAR IDENTIFIER type ASSIGN expression
    (112) variable_declaration -> . CONST IDENTIFIER type ASSIGN expression
    (113) variable_declaration -> . VAR IDENTIFIER ASSIGN expression
    (114) variable_declaration -> . CONST IDENTIFIER ASSIGN expression
    (57) expression -> . slice_type LBRACE expression_list RBRACE
    (58) expression -> . slice_type LBRACE RBRACE
    (61) expression -> . LPAREN expression RPAREN
    (120) expression -> . binary_expression
    (121) expression -> . relational_expression
    (122) expression -> . logical_expression
    (123) expression -> . bitwise_expression
    (124) expression -> . PLUS expression
    (125) expression -> . MINUS expression
    (126) expression -> . LNOT expression
    (127) expression -> . INT
    (128) expression -> . FLOAT64
    (129) expression -> . TRUE
    (130) expression -> . FALSE
    (131) expression -> . IDENTIFIER
    (132) expression -> . STRING
    (133) expression -> . IDENTIFIER PLUSPLUS
    (134) expression -> . IDENTIFIER MINUSMINUS
    (145) expression -> . map_type LBRACE expression_map_list RBRACE
    (146) expression -> . map_type LBRACE RBRACE
    (169) expression -> . type_name LBRACE keyed_element_list RBRACE
    (170) expression -> . type_name LBRACE RBRACE
    (105) return_statement -> . RETURN
    (106) return_statement -> . RETURN return_list
    (78) for_statement -> . for_classic
    (79) for_statement -> . for_condition
    (80) for_statement -> . for_infinite
    (135) if_statement -> . IF expression block
    (136) if_statement -> . IF expression block ELSE block
    (137) if_statement -> . IF expression block ELSE if_statement
    (138) if_statement -> . IF if_assignment SEMICOLON expression block
    (139) if_statement -> . IF if_assignment SEMICOLON expression block ELSE block
    (140) if_statement -> . IF if_assignment SEMICOLON expression block ELSE if_statement
    (228) switch_statement -> . SWITCH enter_block switch_header LBRACE case_clauses RBRACE exit_block
    (74) break_statement -> . BREAK
    (75) continue_statement -> . CONTINUE
    (202) call_expression -> . print_expression
    (203) call_expression -> . input_expression
    (204) call_expression -> . func_call_expression
    (56) slice_type -> . LBRACKET RBRACKET primitive_type
    (175) binary_expression -> . expression PLUS expression
    (176) binary_expression -> . expression MINUS expression
    (177) binary_expression -> . expression TIMES expression
    (178) binary_expression -> . expression DIVIDE expression
    (179) binary_expression -> . expression MODULE expression
    (184) relational_expression -> . expression EQ expression
    (185) relational_expression -> . expression NEQ expression
    (186) relational_expression -> . expression LT expression
    (187) relational_expression -> . expression LE expression
    (188) relational_expression -> . expression GT expression
    (189) relational_expression -> . expression GE expression
    (190) logical_expression -> . expression LAND expression
    (191) logical_expression -> . expression LOR expression
    (192) bitwise_expression -> . expression AND expression
    (193) bitwise_expression -> . expression OR expression
    (194) bitwise_expression -> . expression XOR expression
    (195) bitwise_expression -> . expression AND_NOT expression
    (196) bitwise_expression -> . expression LSHIFT expression
    (197) bitwise_expression -> . expression RSHIFT expression
    (144) map_type -> . MAP LBRACKET primitive_type RBRACKET primitive_type
    (171) type_name -> . IDENTIFIER
    (172) type_name -> . slice_type
    (173) type_name -> . array_type
    (174) type_name -> . map_type
    (81) for_classic -> . FOR for_init SEMICOLON for_cond SEMICOLON for_post block
    (82) for_condition -> . FOR expression block
    (83) for_infinite -> . FOR block
    (229) print_expression -> . IDENTIFIER DOT IDENTIFIER LPAREN argument_list RPAREN
    (230) input_expression -> . IDENTIFIER DOT IDENTIFIER LPAREN AND IDENTIFIER COMMA argument_list RPAREN
    (201) func_call_expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (119) array_type -> . LBRACKET INT RBRACKET type

    RBRACE          reduce using rule 215 (case_body -> statement_list .)
    CASE            reduce using rule 215 (case_body -> statement_list .)
    DEFAULT         reduce using rule 215 (case_body -> statement_list .)
    IDENTIFIER      shift and go to state 212
    VAR             shift and go to state 213
    CONST           shift and go to state 214
    LPAREN          shift and go to state 54
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    LNOT            shift and go to state 61
    INT             shift and go to state 62
    FLOAT64         shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    STRING          shift and go to state 66
    RETURN          shift and go to state 215
    IF              shift and go to state 219
    SWITCH          shift and go to state 220
    BREAK           shift and go to state 221
    CONTINUE        shift and go to state 222
    LBRACKET        shift and go to state 38
    MAP             shift and go to state 39
    FOR             shift and go to state 226

    statement                      shift and go to state 230
    assignment                     shift and go to state 201
    assignment_compound            shift and go to state 202
    variable_declaration           shift and go to state 203
    expression                     shift and go to state 204
    return_statement               shift and go to state 205
    for_statement                  shift and go to state 206
    if_statement                   shift and go to state 207
    switch_statement               shift and go to state 208
    break_statement                shift and go to state 209
    continue_statement             shift and go to state 210
    call_expression                shift and go to state 211
    slice_type                     shift and go to state 53
    binary_expression              shift and go to state 55
    relational_expression          shift and go to state 56
    logical_expression             shift and go to state 57
    bitwise_expression             shift and go to state 58
    map_type                       shift and go to state 67
    type_name                      shift and go to state 68
    for_classic                    shift and go to state 216
    for_condition                  shift and go to state 217
    for_infinite                   shift and go to state 218
    print_expression               shift and go to state 223
    input_expression               shift and go to state 224
    func_call_expression           shift and go to state 225
    array_type                     shift and go to state 69

state 361

    (216) case_body -> empty .

    RBRACE          reduce using rule 216 (case_body -> empty .)
    CASE            reduce using rule 216 (case_body -> empty .)
    DEFAULT         reduce using rule 216 (case_body -> empty .)


state 362

    (230) input_expression -> IDENTIFIER DOT IDENTIFIER LPAREN AND IDENTIFIER COMMA argument_list RPAREN .

    IDENTIFIER      reduce using rule 230 (input_expression -> IDENTIFIER DOT IDENTIFIER LPAREN AND IDENTIFIER COMMA argument_list RPAREN .)
    VAR             reduce using rule 230 (input_expression -> IDENTIFIER DOT IDENTIFIER LPAREN AND IDENTIFIER COMMA argument_list RPAREN .)
    CONST           reduce using rule 230 (input_expression -> IDENTIFIER DOT IDENTIFIER LPAREN AND IDENTIFIER COMMA argument_list RPAREN .)
    LPAREN          reduce using rule 230 (input_expression -> IDENTIFIER DOT IDENTIFIER LPAREN AND IDENTIFIER COMMA argument_list RPAREN .)
    PLUS            reduce using rule 230 (input_expression -> IDENTIFIER DOT IDENTIFIER LPAREN AND IDENTIFIER COMMA argument_list RPAREN .)
    MINUS           reduce using rule 230 (input_expression -> IDENTIFIER DOT IDENTIFIER LPAREN AND IDENTIFIER COMMA argument_list RPAREN .)
    LNOT            reduce using rule 230 (input_expression -> IDENTIFIER DOT IDENTIFIER LPAREN AND IDENTIFIER COMMA argument_list RPAREN .)
    INT             reduce using rule 230 (input_expression -> IDENTIFIER DOT IDENTIFIER LPAREN AND IDENTIFIER COMMA argument_list RPAREN .)
    FLOAT64         reduce using rule 230 (input_expression -> IDENTIFIER DOT IDENTIFIER LPAREN AND IDENTIFIER COMMA argument_list RPAREN .)
    TRUE            reduce using rule 230 (input_expression -> IDENTIFIER DOT IDENTIFIER LPAREN AND IDENTIFIER COMMA argument_list RPAREN .)
    FALSE           reduce using rule 230 (input_expression -> IDENTIFIER DOT IDENTIFIER LPAREN AND IDENTIFIER COMMA argument_list RPAREN .)
    STRING          reduce using rule 230 (input_expression -> IDENTIFIER DOT IDENTIFIER LPAREN AND IDENTIFIER COMMA argument_list RPAREN .)
    RETURN          reduce using rule 230 (input_expression -> IDENTIFIER DOT IDENTIFIER LPAREN AND IDENTIFIER COMMA argument_list RPAREN .)
    IF              reduce using rule 230 (input_expression -> IDENTIFIER DOT IDENTIFIER LPAREN AND IDENTIFIER COMMA argument_list RPAREN .)
    SWITCH          reduce using rule 230 (input_expression -> IDENTIFIER DOT IDENTIFIER LPAREN AND IDENTIFIER COMMA argument_list RPAREN .)
    BREAK           reduce using rule 230 (input_expression -> IDENTIFIER DOT IDENTIFIER LPAREN AND IDENTIFIER COMMA argument_list RPAREN .)
    CONTINUE        reduce using rule 230 (input_expression -> IDENTIFIER DOT IDENTIFIER LPAREN AND IDENTIFIER COMMA argument_list RPAREN .)
    LBRACKET        reduce using rule 230 (input_expression -> IDENTIFIER DOT IDENTIFIER LPAREN AND IDENTIFIER COMMA argument_list RPAREN .)
    MAP             reduce using rule 230 (input_expression -> IDENTIFIER DOT IDENTIFIER LPAREN AND IDENTIFIER COMMA argument_list RPAREN .)
    FOR             reduce using rule 230 (input_expression -> IDENTIFIER DOT IDENTIFIER LPAREN AND IDENTIFIER COMMA argument_list RPAREN .)
    RBRACE          reduce using rule 230 (input_expression -> IDENTIFIER DOT IDENTIFIER LPAREN AND IDENTIFIER COMMA argument_list RPAREN .)
    CASE            reduce using rule 230 (input_expression -> IDENTIFIER DOT IDENTIFIER LPAREN AND IDENTIFIER COMMA argument_list RPAREN .)
    DEFAULT         reduce using rule 230 (input_expression -> IDENTIFIER DOT IDENTIFIER LPAREN AND IDENTIFIER COMMA argument_list RPAREN .)


state 363

    (213) case_clause -> CASE case_expression_list COLON enter_block case_body . exit_block
    (208) exit_block -> .

    RBRACE          reduce using rule 208 (exit_block -> .)
    CASE            reduce using rule 208 (exit_block -> .)
    DEFAULT         reduce using rule 208 (exit_block -> .)

    exit_block                     shift and go to state 365

state 364

    (214) case_clause -> DEFAULT COLON enter_block case_body exit_block .

    RBRACE          reduce using rule 214 (case_clause -> DEFAULT COLON enter_block case_body exit_block .)
    CASE            reduce using rule 214 (case_clause -> DEFAULT COLON enter_block case_body exit_block .)
    DEFAULT         reduce using rule 214 (case_clause -> DEFAULT COLON enter_block case_body exit_block .)


state 365

    (213) case_clause -> CASE case_expression_list COLON enter_block case_body exit_block .

    RBRACE          reduce using rule 213 (case_clause -> CASE case_expression_list COLON enter_block case_body exit_block .)
    CASE            reduce using rule 213 (case_clause -> CASE case_expression_list COLON enter_block case_body exit_block .)
    DEFAULT         reduce using rule 213 (case_clause -> CASE case_expression_list COLON enter_block case_body exit_block .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for IMPORT in state 2 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 53 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 67 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 143 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 143 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 143 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 143 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 143 resolved as shift
WARNING: shift/reduce conflict for EQ in state 143 resolved as shift
WARNING: shift/reduce conflict for NEQ in state 143 resolved as shift
WARNING: shift/reduce conflict for LT in state 143 resolved as shift
WARNING: shift/reduce conflict for LE in state 143 resolved as shift
WARNING: shift/reduce conflict for GT in state 143 resolved as shift
WARNING: shift/reduce conflict for GE in state 143 resolved as shift
WARNING: shift/reduce conflict for LAND in state 143 resolved as shift
WARNING: shift/reduce conflict for LOR in state 143 resolved as shift
WARNING: shift/reduce conflict for AND in state 143 resolved as shift
WARNING: shift/reduce conflict for OR in state 143 resolved as shift
WARNING: shift/reduce conflict for XOR in state 143 resolved as shift
WARNING: shift/reduce conflict for AND_NOT in state 143 resolved as shift
WARNING: shift/reduce conflict for LSHIFT in state 143 resolved as shift
WARNING: shift/reduce conflict for RSHIFT in state 143 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 204 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 204 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 212 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 215 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 215 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 215 resolved as shift
WARNING: shift/reduce conflict for LNOT in state 215 resolved as shift
WARNING: shift/reduce conflict for INT in state 215 resolved as shift
WARNING: shift/reduce conflict for FLOAT64 in state 215 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 215 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 215 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 215 resolved as shift
WARNING: shift/reduce conflict for STRING in state 215 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 215 resolved as shift
WARNING: shift/reduce conflict for MAP in state 215 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 249 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 249 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 268 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 268 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 269 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 269 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 270 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 270 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 302 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 302 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 304 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 304 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 305 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 305 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 319 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 319 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 320 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 320 resolved as shift
WARNING: reduce/reduce conflict in state 51 resolved using rule (expression -> IDENTIFIER)
WARNING: rejected rule (type_name -> IDENTIFIER) in state 51
WARNING: reduce/reduce conflict in state 252 resolved using rule (expression -> IDENTIFIER)
WARNING: rejected rule (type_name -> IDENTIFIER) in state 252
WARNING: reduce/reduce conflict in state 265 resolved using rule (expression -> IDENTIFIER)
WARNING: rejected rule (type_name -> IDENTIFIER) in state 265
WARNING: reduce/reduce conflict in state 347 resolved using rule (expression -> IDENTIFIER)
WARNING: rejected rule (type_name -> IDENTIFIER) in state 347
